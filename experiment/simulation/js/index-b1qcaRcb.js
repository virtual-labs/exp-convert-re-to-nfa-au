function AL(t, e) {
  for (var n = 0; n < e.length; n++) {
    const r = e[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in t)) {
          const o = Object.getOwnPropertyDescriptor(r, i);
          o &&
            Object.defineProperty(
              t,
              i,
              o.get ? o : { enumerable: !0, get: () => r[i] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const o of i)
      if (o.type === "childList")
        for (const a of o.addedNodes)
          a.tagName === "LINK" && a.rel === "modulepreload" && r(a);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(i) {
    const o = {};
    return (
      i.integrity && (o.integrity = i.integrity),
      i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (o.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (o.credentials = "omit")
        : (o.credentials = "same-origin"),
      o
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const o = n(i);
    fetch(i.href, o);
  }
})();
function Ny(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
var RL = { exports: {} },
  Fy = {},
  PL = { exports: {} },
  sn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var om = Symbol.for("react.element"),
  y5 = Symbol.for("react.portal"),
  x5 = Symbol.for("react.fragment"),
  S5 = Symbol.for("react.strict_mode"),
  _5 = Symbol.for("react.profiler"),
  b5 = Symbol.for("react.provider"),
  w5 = Symbol.for("react.context"),
  E5 = Symbol.for("react.forward_ref"),
  M5 = Symbol.for("react.suspense"),
  C5 = Symbol.for("react.memo"),
  T5 = Symbol.for("react.lazy"),
  oA = Symbol.iterator;
function A5(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (oA && t[oA]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var IL = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  LL = Object.assign,
  OL = {};
function wf(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = OL),
    (this.updater = n || IL);
}
wf.prototype.isReactComponent = {};
wf.prototype.setState = function (t, e) {
  if (typeof t != "object" && typeof t != "function" && t != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, t, e, "setState");
};
wf.prototype.forceUpdate = function (t) {
  this.updater.enqueueForceUpdate(this, t, "forceUpdate");
};
function NL() {}
NL.prototype = wf.prototype;
function YE(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = OL),
    (this.updater = n || IL);
}
var ZE = (YE.prototype = new NL());
ZE.constructor = YE;
LL(ZE, wf.prototype);
ZE.isPureReactComponent = !0;
var aA = Array.isArray,
  FL = Object.prototype.hasOwnProperty,
  QE = { current: null },
  DL = { key: !0, ref: !0, __self: !0, __source: !0 };
function zL(t, e, n) {
  var r,
    i = {},
    o = null,
    a = null;
  if (e != null)
    for (r in (e.ref !== void 0 && (a = e.ref),
    e.key !== void 0 && (o = "" + e.key),
    e))
      FL.call(e, r) && !DL.hasOwnProperty(r) && (i[r] = e[r]);
  var s = arguments.length - 2;
  if (s === 1) i.children = n;
  else if (1 < s) {
    for (var l = Array(s), c = 0; c < s; c++) l[c] = arguments[c + 2];
    i.children = l;
  }
  if (t && t.defaultProps)
    for (r in ((s = t.defaultProps), s)) i[r] === void 0 && (i[r] = s[r]);
  return {
    $$typeof: om,
    type: t,
    key: o,
    ref: a,
    props: i,
    _owner: QE.current,
  };
}
function R5(t, e) {
  return {
    $$typeof: om,
    type: t.type,
    key: e,
    ref: t.ref,
    props: t.props,
    _owner: t._owner,
  };
}
function JE(t) {
  return typeof t == "object" && t !== null && t.$$typeof === om;
}
function P5(t) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    t.replace(/[=:]/g, function (n) {
      return e[n];
    })
  );
}
var sA = /\/+/g;
function Jx(t, e) {
  return typeof t == "object" && t !== null && t.key != null
    ? P5("" + t.key)
    : e.toString(36);
}
function i0(t, e, n, r, i) {
  var o = typeof t;
  (o === "undefined" || o === "boolean") && (t = null);
  var a = !1;
  if (t === null) a = !0;
  else
    switch (o) {
      case "string":
      case "number":
        a = !0;
        break;
      case "object":
        switch (t.$$typeof) {
          case om:
          case y5:
            a = !0;
        }
    }
  if (a)
    return (
      (a = t),
      (i = i(a)),
      (t = r === "" ? "." + Jx(a, 0) : r),
      aA(i)
        ? ((n = ""),
          t != null && (n = t.replace(sA, "$&/") + "/"),
          i0(i, e, n, "", function (c) {
            return c;
          }))
        : i != null &&
          (JE(i) &&
            (i = R5(
              i,
              n +
                (!i.key || (a && a.key === i.key)
                  ? ""
                  : ("" + i.key).replace(sA, "$&/") + "/") +
                t
            )),
          e.push(i)),
      1
    );
  if (((a = 0), (r = r === "" ? "." : r + ":"), aA(t)))
    for (var s = 0; s < t.length; s++) {
      o = t[s];
      var l = r + Jx(o, s);
      a += i0(o, e, n, l, i);
    }
  else if (((l = A5(t)), typeof l == "function"))
    for (t = l.call(t), s = 0; !(o = t.next()).done; )
      (o = o.value), (l = r + Jx(o, s++)), (a += i0(o, e, n, l, i));
  else if (o === "object")
    throw (
      ((e = String(t)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(t).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return a;
}
function wg(t, e, n) {
  if (t == null) return t;
  var r = [],
    i = 0;
  return (
    i0(t, r, "", "", function (o) {
      return e.call(n, o, i++);
    }),
    r
  );
}
function I5(t) {
  if (t._status === -1) {
    var e = t._result;
    (e = e()),
      e.then(
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 1), (t._result = n));
        },
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 2), (t._result = n));
        }
      ),
      t._status === -1 && ((t._status = 0), (t._result = e));
  }
  if (t._status === 1) return t._result.default;
  throw t._result;
}
var Fi = { current: null },
  o0 = { transition: null },
  L5 = {
    ReactCurrentDispatcher: Fi,
    ReactCurrentBatchConfig: o0,
    ReactCurrentOwner: QE,
  };
sn.Children = {
  map: wg,
  forEach: function (t, e, n) {
    wg(
      t,
      function () {
        e.apply(this, arguments);
      },
      n
    );
  },
  count: function (t) {
    var e = 0;
    return (
      wg(t, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (t) {
    return (
      wg(t, function (e) {
        return e;
      }) || []
    );
  },
  only: function (t) {
    if (!JE(t))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return t;
  },
};
sn.Component = wf;
sn.Fragment = x5;
sn.Profiler = _5;
sn.PureComponent = YE;
sn.StrictMode = S5;
sn.Suspense = M5;
sn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = L5;
sn.cloneElement = function (t, e, n) {
  if (t == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        t +
        "."
    );
  var r = LL({}, t.props),
    i = t.key,
    o = t.ref,
    a = t._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((o = e.ref), (a = QE.current)),
      e.key !== void 0 && (i = "" + e.key),
      t.type && t.type.defaultProps)
    )
      var s = t.type.defaultProps;
    for (l in e)
      FL.call(e, l) &&
        !DL.hasOwnProperty(l) &&
        (r[l] = e[l] === void 0 && s !== void 0 ? s[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) r.children = n;
  else if (1 < l) {
    s = Array(l);
    for (var c = 0; c < l; c++) s[c] = arguments[c + 2];
    r.children = s;
  }
  return { $$typeof: om, type: t.type, key: i, ref: o, props: r, _owner: a };
};
sn.createContext = function (t) {
  return (
    (t = {
      $$typeof: w5,
      _currentValue: t,
      _currentValue2: t,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (t.Provider = { $$typeof: b5, _context: t }),
    (t.Consumer = t)
  );
};
sn.createElement = zL;
sn.createFactory = function (t) {
  var e = zL.bind(null, t);
  return (e.type = t), e;
};
sn.createRef = function () {
  return { current: null };
};
sn.forwardRef = function (t) {
  return { $$typeof: E5, render: t };
};
sn.isValidElement = JE;
sn.lazy = function (t) {
  return { $$typeof: T5, _payload: { _status: -1, _result: t }, _init: I5 };
};
sn.memo = function (t, e) {
  return { $$typeof: C5, type: t, compare: e === void 0 ? null : e };
};
sn.startTransition = function (t) {
  var e = o0.transition;
  o0.transition = {};
  try {
    t();
  } finally {
    o0.transition = e;
  }
};
sn.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
sn.useCallback = function (t, e) {
  return Fi.current.useCallback(t, e);
};
sn.useContext = function (t) {
  return Fi.current.useContext(t);
};
sn.useDebugValue = function () {};
sn.useDeferredValue = function (t) {
  return Fi.current.useDeferredValue(t);
};
sn.useEffect = function (t, e) {
  return Fi.current.useEffect(t, e);
};
sn.useId = function () {
  return Fi.current.useId();
};
sn.useImperativeHandle = function (t, e, n) {
  return Fi.current.useImperativeHandle(t, e, n);
};
sn.useInsertionEffect = function (t, e) {
  return Fi.current.useInsertionEffect(t, e);
};
sn.useLayoutEffect = function (t, e) {
  return Fi.current.useLayoutEffect(t, e);
};
sn.useMemo = function (t, e) {
  return Fi.current.useMemo(t, e);
};
sn.useReducer = function (t, e, n) {
  return Fi.current.useReducer(t, e, n);
};
sn.useRef = function (t) {
  return Fi.current.useRef(t);
};
sn.useState = function (t) {
  return Fi.current.useState(t);
};
sn.useSyncExternalStore = function (t, e, n) {
  return Fi.current.useSyncExternalStore(t, e, n);
};
sn.useTransition = function () {
  return Fi.current.useTransition();
};
sn.version = "18.2.0";
PL.exports = sn;
var E = PL.exports;
const at = Ny(E),
  ru = AL({ __proto__: null, default: at }, [E]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var O5 = E,
  N5 = Symbol.for("react.element"),
  F5 = Symbol.for("react.fragment"),
  D5 = Object.prototype.hasOwnProperty,
  z5 = O5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  U5 = { key: !0, ref: !0, __self: !0, __source: !0 };
function UL(t, e, n) {
  var r,
    i = {},
    o = null,
    a = null;
  n !== void 0 && (o = "" + n),
    e.key !== void 0 && (o = "" + e.key),
    e.ref !== void 0 && (a = e.ref);
  for (r in e) D5.call(e, r) && !U5.hasOwnProperty(r) && (i[r] = e[r]);
  if (t && t.defaultProps)
    for (r in ((e = t.defaultProps), e)) i[r] === void 0 && (i[r] = e[r]);
  return {
    $$typeof: N5,
    type: t,
    key: o,
    ref: a,
    props: i,
    _owner: z5.current,
  };
}
Fy.Fragment = F5;
Fy.jsx = UL;
Fy.jsxs = UL;
RL.exports = Fy;
var L = RL.exports,
  ib = {},
  kL = { exports: {} },
  Lo = {},
  BL = { exports: {} },
  HL = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (t) {
  function e(B, $) {
    var G = B.length;
    B.push($);
    e: for (; 0 < G; ) {
      var k = (G - 1) >>> 1,
        q = B[k];
      if (0 < i(q, $)) (B[k] = $), (B[G] = q), (G = k);
      else break e;
    }
  }
  function n(B) {
    return B.length === 0 ? null : B[0];
  }
  function r(B) {
    if (B.length === 0) return null;
    var $ = B[0],
      G = B.pop();
    if (G !== $) {
      B[0] = G;
      e: for (var k = 0, q = B.length, X = q >>> 1; k < X; ) {
        var ee = 2 * (k + 1) - 1,
          J = B[ee],
          oe = ee + 1,
          ae = B[oe];
        if (0 > i(J, G))
          oe < q && 0 > i(ae, J)
            ? ((B[k] = ae), (B[oe] = G), (k = oe))
            : ((B[k] = J), (B[ee] = G), (k = ee));
        else if (oe < q && 0 > i(ae, G)) (B[k] = ae), (B[oe] = G), (k = oe);
        else break e;
      }
    }
    return $;
  }
  function i(B, $) {
    var G = B.sortIndex - $.sortIndex;
    return G !== 0 ? G : B.id - $.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var o = performance;
    t.unstable_now = function () {
      return o.now();
    };
  } else {
    var a = Date,
      s = a.now();
    t.unstable_now = function () {
      return a.now() - s;
    };
  }
  var l = [],
    c = [],
    u = 1,
    d = null,
    p = 3,
    m = !1,
    v = !1,
    S = !1,
    x = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    _ = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function y(B) {
    for (var $ = n(c); $ !== null; ) {
      if ($.callback === null) r(c);
      else if ($.startTime <= B)
        r(c), ($.sortIndex = $.expirationTime), e(l, $);
      else break;
      $ = n(c);
    }
  }
  function w(B) {
    if (((S = !1), y(B), !v))
      if (n(l) !== null) (v = !0), W(A);
      else {
        var $ = n(c);
        $ !== null && Q(w, $.startTime - B);
      }
  }
  function A(B, $) {
    (v = !1), S && ((S = !1), g(I), (I = -1)), (m = !0);
    var G = p;
    try {
      for (
        y($), d = n(l);
        d !== null && (!(d.expirationTime > $) || (B && !F()));

      ) {
        var k = d.callback;
        if (typeof k == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var q = k(d.expirationTime <= $);
          ($ = t.unstable_now()),
            typeof q == "function" ? (d.callback = q) : d === n(l) && r(l),
            y($);
        } else r(l);
        d = n(l);
      }
      if (d !== null) var X = !0;
      else {
        var ee = n(c);
        ee !== null && Q(w, ee.startTime - $), (X = !1);
      }
      return X;
    } finally {
      (d = null), (p = G), (m = !1);
    }
  }
  var M = !1,
    T = null,
    I = -1,
    R = 5,
    P = -1;
  function F() {
    return !(t.unstable_now() - P < R);
  }
  function D() {
    if (T !== null) {
      var B = t.unstable_now();
      P = B;
      var $ = !0;
      try {
        $ = T(!0, B);
      } finally {
        $ ? j() : ((M = !1), (T = null));
      }
    } else M = !1;
  }
  var j;
  if (typeof _ == "function")
    j = function () {
      _(D);
    };
  else if (typeof MessageChannel < "u") {
    var N = new MessageChannel(),
      V = N.port2;
    (N.port1.onmessage = D),
      (j = function () {
        V.postMessage(null);
      });
  } else
    j = function () {
      x(D, 0);
    };
  function W(B) {
    (T = B), M || ((M = !0), j());
  }
  function Q(B, $) {
    I = x(function () {
      B(t.unstable_now());
    }, $);
  }
  (t.unstable_IdlePriority = 5),
    (t.unstable_ImmediatePriority = 1),
    (t.unstable_LowPriority = 4),
    (t.unstable_NormalPriority = 3),
    (t.unstable_Profiling = null),
    (t.unstable_UserBlockingPriority = 2),
    (t.unstable_cancelCallback = function (B) {
      B.callback = null;
    }),
    (t.unstable_continueExecution = function () {
      v || m || ((v = !0), W(A));
    }),
    (t.unstable_forceFrameRate = function (B) {
      0 > B || 125 < B
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (R = 0 < B ? Math.floor(1e3 / B) : 5);
    }),
    (t.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (t.unstable_getFirstCallbackNode = function () {
      return n(l);
    }),
    (t.unstable_next = function (B) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var $ = 3;
          break;
        default:
          $ = p;
      }
      var G = p;
      p = $;
      try {
        return B();
      } finally {
        p = G;
      }
    }),
    (t.unstable_pauseExecution = function () {}),
    (t.unstable_requestPaint = function () {}),
    (t.unstable_runWithPriority = function (B, $) {
      switch (B) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          B = 3;
      }
      var G = p;
      p = B;
      try {
        return $();
      } finally {
        p = G;
      }
    }),
    (t.unstable_scheduleCallback = function (B, $, G) {
      var k = t.unstable_now();
      switch (
        (typeof G == "object" && G !== null
          ? ((G = G.delay), (G = typeof G == "number" && 0 < G ? k + G : k))
          : (G = k),
        B)
      ) {
        case 1:
          var q = -1;
          break;
        case 2:
          q = 250;
          break;
        case 5:
          q = 1073741823;
          break;
        case 4:
          q = 1e4;
          break;
        default:
          q = 5e3;
      }
      return (
        (q = G + q),
        (B = {
          id: u++,
          callback: $,
          priorityLevel: B,
          startTime: G,
          expirationTime: q,
          sortIndex: -1,
        }),
        G > k
          ? ((B.sortIndex = G),
            e(c, B),
            n(l) === null &&
              B === n(c) &&
              (S ? (g(I), (I = -1)) : (S = !0), Q(w, G - k)))
          : ((B.sortIndex = q), e(l, B), v || m || ((v = !0), W(A))),
        B
      );
    }),
    (t.unstable_shouldYield = F),
    (t.unstable_wrapCallback = function (B) {
      var $ = p;
      return function () {
        var G = p;
        p = $;
        try {
          return B.apply(this, arguments);
        } finally {
          p = G;
        }
      };
    });
})(HL);
BL.exports = HL;
var k5 = BL.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var jL = E,
  Ro = k5;
function rt(t) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1;
    n < arguments.length;
    n++
  )
    e += "&args[]=" + encodeURIComponent(arguments[n]);
  return (
    "Minified React error #" +
    t +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var VL = new Set(),
  lp = {};
function gu(t, e) {
  rf(t, e), rf(t + "Capture", e);
}
function rf(t, e) {
  for (lp[t] = e, t = 0; t < e.length; t++) VL.add(e[t]);
}
var Us = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  ob = Object.prototype.hasOwnProperty,
  B5 =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  lA = {},
  cA = {};
function H5(t) {
  return ob.call(cA, t)
    ? !0
    : ob.call(lA, t)
    ? !1
    : B5.test(t)
    ? (cA[t] = !0)
    : ((lA[t] = !0), !1);
}
function j5(t, e, n, r) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return r
        ? !1
        : n !== null
        ? !n.acceptsBooleans
        : ((t = t.toLowerCase().slice(0, 5)), t !== "data-" && t !== "aria-");
    default:
      return !1;
  }
}
function V5(t, e, n, r) {
  if (e === null || typeof e > "u" || j5(t, e, n, r)) return !0;
  if (r) return !1;
  if (n !== null)
    switch (n.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function Di(t, e, n, r, i, o, a) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = n),
    (this.propertyName = t),
    (this.type = e),
    (this.sanitizeURL = o),
    (this.removeEmptyString = a);
}
var Jr = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (t) {
    Jr[t] = new Di(t, 0, !1, t, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (t) {
  var e = t[0];
  Jr[e] = new Di(e, 1, !1, t[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
  Jr[t] = new Di(t, 2, !1, t.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (t) {
  Jr[t] = new Di(t, 2, !1, t, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (t) {
    Jr[t] = new Di(t, 3, !1, t.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (t) {
  Jr[t] = new Di(t, 3, !0, t, null, !1, !1);
});
["capture", "download"].forEach(function (t) {
  Jr[t] = new Di(t, 4, !1, t, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (t) {
  Jr[t] = new Di(t, 6, !1, t, null, !1, !1);
});
["rowSpan", "start"].forEach(function (t) {
  Jr[t] = new Di(t, 5, !1, t.toLowerCase(), null, !1, !1);
});
var eM = /[\-:]([a-z])/g;
function tM(t) {
  return t[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(eM, tM);
    Jr[e] = new Di(e, 1, !1, t, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(eM, tM);
    Jr[e] = new Di(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (t) {
  var e = t.replace(eM, tM);
  Jr[e] = new Di(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (t) {
  Jr[t] = new Di(t, 1, !1, t.toLowerCase(), null, !1, !1);
});
Jr.xlinkHref = new Di(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (t) {
  Jr[t] = new Di(t, 1, !1, t.toLowerCase(), null, !0, !0);
});
function nM(t, e, n, r) {
  var i = Jr.hasOwnProperty(e) ? Jr[e] : null;
  (i !== null
    ? i.type !== 0
    : r ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (V5(e, n, i, r) && (n = null),
    r || i === null
      ? H5(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n))
      : i.mustUseProperty
      ? (t[i.propertyName] = n === null ? (i.type === 3 ? !1 : "") : n)
      : ((e = i.attributeName),
        (r = i.attributeNamespace),
        n === null
          ? t.removeAttribute(e)
          : ((i = i.type),
            (n = i === 3 || (i === 4 && n === !0) ? "" : "" + n),
            r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))));
}
var Xs = jL.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  Eg = Symbol.for("react.element"),
  Cd = Symbol.for("react.portal"),
  Td = Symbol.for("react.fragment"),
  rM = Symbol.for("react.strict_mode"),
  ab = Symbol.for("react.profiler"),
  $L = Symbol.for("react.provider"),
  GL = Symbol.for("react.context"),
  iM = Symbol.for("react.forward_ref"),
  sb = Symbol.for("react.suspense"),
  lb = Symbol.for("react.suspense_list"),
  oM = Symbol.for("react.memo"),
  ml = Symbol.for("react.lazy"),
  WL = Symbol.for("react.offscreen"),
  uA = Symbol.iterator;
function th(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (uA && t[uA]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var tr = Object.assign,
  eS;
function Lh(t) {
  if (eS === void 0)
    try {
      throw Error();
    } catch (n) {
      var e = n.stack.trim().match(/\n( *(at )?)/);
      eS = (e && e[1]) || "";
    }
  return (
    `
` +
    eS +
    t
  );
}
var tS = !1;
function nS(t, e) {
  if (!t || tS) return "";
  tS = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (c) {
          var r = c;
        }
        Reflect.construct(t, [], e);
      } else {
        try {
          e.call();
        } catch (c) {
          r = c;
        }
        t.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (c) {
        r = c;
      }
      t();
    }
  } catch (c) {
    if (c && r && typeof c.stack == "string") {
      for (
        var i = c.stack.split(`
`),
          o = r.stack.split(`
`),
          a = i.length - 1,
          s = o.length - 1;
        1 <= a && 0 <= s && i[a] !== o[s];

      )
        s--;
      for (; 1 <= a && 0 <= s; a--, s--)
        if (i[a] !== o[s]) {
          if (a !== 1 || s !== 1)
            do
              if ((a--, s--, 0 > s || i[a] !== o[s])) {
                var l =
                  `
` + i[a].replace(" at new ", " at ");
                return (
                  t.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", t.displayName)),
                  l
                );
              }
            while (1 <= a && 0 <= s);
          break;
        }
    }
  } finally {
    (tS = !1), (Error.prepareStackTrace = n);
  }
  return (t = t ? t.displayName || t.name : "") ? Lh(t) : "";
}
function $5(t) {
  switch (t.tag) {
    case 5:
      return Lh(t.type);
    case 16:
      return Lh("Lazy");
    case 13:
      return Lh("Suspense");
    case 19:
      return Lh("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (t = nS(t.type, !1)), t;
    case 11:
      return (t = nS(t.type.render, !1)), t;
    case 1:
      return (t = nS(t.type, !0)), t;
    default:
      return "";
  }
}
function cb(t) {
  if (t == null) return null;
  if (typeof t == "function") return t.displayName || t.name || null;
  if (typeof t == "string") return t;
  switch (t) {
    case Td:
      return "Fragment";
    case Cd:
      return "Portal";
    case ab:
      return "Profiler";
    case rM:
      return "StrictMode";
    case sb:
      return "Suspense";
    case lb:
      return "SuspenseList";
  }
  if (typeof t == "object")
    switch (t.$$typeof) {
      case GL:
        return (t.displayName || "Context") + ".Consumer";
      case $L:
        return (t._context.displayName || "Context") + ".Provider";
      case iM:
        var e = t.render;
        return (
          (t = t.displayName),
          t ||
            ((t = e.displayName || e.name || ""),
            (t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")),
          t
        );
      case oM:
        return (
          (e = t.displayName || null), e !== null ? e : cb(t.type) || "Memo"
        );
      case ml:
        (e = t._payload), (t = t._init);
        try {
          return cb(t(e));
        } catch {}
    }
  return null;
}
function G5(t) {
  var e = t.type;
  switch (t.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (t = e.render),
        (t = t.displayName || t.name || ""),
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return cb(e);
    case 8:
      return e === rM ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Ul(t) {
  switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return t;
    case "object":
      return t;
    default:
      return "";
  }
}
function XL(t) {
  var e = t.type;
  return (
    (t = t.nodeName) &&
    t.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function W5(t) {
  var e = XL(t) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
    r = "" + t[e];
  if (
    !t.hasOwnProperty(e) &&
    typeof n < "u" &&
    typeof n.get == "function" &&
    typeof n.set == "function"
  ) {
    var i = n.get,
      o = n.set;
    return (
      Object.defineProperty(t, e, {
        configurable: !0,
        get: function () {
          return i.call(this);
        },
        set: function (a) {
          (r = "" + a), o.call(this, a);
        },
      }),
      Object.defineProperty(t, e, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return r;
        },
        setValue: function (a) {
          r = "" + a;
        },
        stopTracking: function () {
          (t._valueTracker = null), delete t[e];
        },
      }
    );
  }
}
function Mg(t) {
  t._valueTracker || (t._valueTracker = W5(t));
}
function qL(t) {
  if (!t) return !1;
  var e = t._valueTracker;
  if (!e) return !0;
  var n = e.getValue(),
    r = "";
  return (
    t && (r = XL(t) ? (t.checked ? "true" : "false") : t.value),
    (t = r),
    t !== n ? (e.setValue(t), !0) : !1
  );
}
function z0(t) {
  if (((t = t || (typeof document < "u" ? document : void 0)), typeof t > "u"))
    return null;
  try {
    return t.activeElement || t.body;
  } catch {
    return t.body;
  }
}
function ub(t, e) {
  var n = e.checked;
  return tr({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? t._wrapperState.initialChecked,
  });
}
function dA(t, e) {
  var n = e.defaultValue == null ? "" : e.defaultValue,
    r = e.checked != null ? e.checked : e.defaultChecked;
  (n = Ul(e.value != null ? e.value : n)),
    (t._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function KL(t, e) {
  (e = e.checked), e != null && nM(t, "checked", e, !1);
}
function db(t, e) {
  KL(t, e);
  var n = Ul(e.value),
    r = e.type;
  if (n != null)
    r === "number"
      ? ((n === 0 && t.value === "") || t.value != n) && (t.value = "" + n)
      : t.value !== "" + n && (t.value = "" + n);
  else if (r === "submit" || r === "reset") {
    t.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? fb(t, e.type, n)
    : e.hasOwnProperty("defaultValue") && fb(t, e.type, Ul(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (t.defaultChecked = !!e.defaultChecked);
}
function fA(t, e, n) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var r = e.type;
    if (
      !(
        (r !== "submit" && r !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + t._wrapperState.initialValue),
      n || e === t.value || (t.value = e),
      (t.defaultValue = e);
  }
  (n = t.name),
    n !== "" && (t.name = ""),
    (t.defaultChecked = !!t._wrapperState.initialChecked),
    n !== "" && (t.name = n);
}
function fb(t, e, n) {
  (e !== "number" || z0(t.ownerDocument) !== t) &&
    (n == null
      ? (t.defaultValue = "" + t._wrapperState.initialValue)
      : t.defaultValue !== "" + n && (t.defaultValue = "" + n));
}
var Oh = Array.isArray;
function Xd(t, e, n, r) {
  if (((t = t.options), e)) {
    e = {};
    for (var i = 0; i < n.length; i++) e["$" + n[i]] = !0;
    for (n = 0; n < t.length; n++)
      (i = e.hasOwnProperty("$" + t[n].value)),
        t[n].selected !== i && (t[n].selected = i),
        i && r && (t[n].defaultSelected = !0);
  } else {
    for (n = "" + Ul(n), e = null, i = 0; i < t.length; i++) {
      if (t[i].value === n) {
        (t[i].selected = !0), r && (t[i].defaultSelected = !0);
        return;
      }
      e !== null || t[i].disabled || (e = t[i]);
    }
    e !== null && (e.selected = !0);
  }
}
function hb(t, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(rt(91));
  return tr({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + t._wrapperState.initialValue,
  });
}
function hA(t, e) {
  var n = e.value;
  if (n == null) {
    if (((n = e.children), (e = e.defaultValue), n != null)) {
      if (e != null) throw Error(rt(92));
      if (Oh(n)) {
        if (1 < n.length) throw Error(rt(93));
        n = n[0];
      }
      e = n;
    }
    e == null && (e = ""), (n = e);
  }
  t._wrapperState = { initialValue: Ul(n) };
}
function YL(t, e) {
  var n = Ul(e.value),
    r = Ul(e.defaultValue);
  n != null &&
    ((n = "" + n),
    n !== t.value && (t.value = n),
    e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)),
    r != null && (t.defaultValue = "" + r);
}
function pA(t) {
  var e = t.textContent;
  e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
}
function ZL(t) {
  switch (t) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function pb(t, e) {
  return t == null || t === "http://www.w3.org/1999/xhtml"
    ? ZL(e)
    : t === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : t;
}
var Cg,
  QL = (function (t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, n, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return t(e, n, r, i);
          });
        }
      : t;
  })(function (t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t)
      t.innerHTML = e;
    else {
      for (
        Cg = Cg || document.createElement("div"),
          Cg.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = Cg.firstChild;
        t.firstChild;

      )
        t.removeChild(t.firstChild);
      for (; e.firstChild; ) t.appendChild(e.firstChild);
    }
  });
function cp(t, e) {
  if (e) {
    var n = t.firstChild;
    if (n && n === t.lastChild && n.nodeType === 3) {
      n.nodeValue = e;
      return;
    }
  }
  t.textContent = e;
}
var Bh = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  X5 = ["Webkit", "ms", "Moz", "O"];
Object.keys(Bh).forEach(function (t) {
  X5.forEach(function (e) {
    (e = e + t.charAt(0).toUpperCase() + t.substring(1)), (Bh[e] = Bh[t]);
  });
});
function JL(t, e, n) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : n || typeof e != "number" || e === 0 || (Bh.hasOwnProperty(t) && Bh[t])
    ? ("" + e).trim()
    : e + "px";
}
function eO(t, e) {
  t = t.style;
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      var r = n.indexOf("--") === 0,
        i = JL(n, e[n], r);
      n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : (t[n] = i);
    }
}
var q5 = tr(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function mb(t, e) {
  if (e) {
    if (q5[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(rt(137, t));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(rt(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(rt(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(rt(62));
  }
}
function gb(t, e) {
  if (t.indexOf("-") === -1) return typeof e.is == "string";
  switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var vb = null;
function aM(t) {
  return (
    (t = t.target || t.srcElement || window),
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
  );
}
var yb = null,
  qd = null,
  Kd = null;
function mA(t) {
  if ((t = lm(t))) {
    if (typeof yb != "function") throw Error(rt(280));
    var e = t.stateNode;
    e && ((e = By(e)), yb(t.stateNode, t.type, e));
  }
}
function tO(t) {
  qd ? (Kd ? Kd.push(t) : (Kd = [t])) : (qd = t);
}
function nO() {
  if (qd) {
    var t = qd,
      e = Kd;
    if (((Kd = qd = null), mA(t), e)) for (t = 0; t < e.length; t++) mA(e[t]);
  }
}
function rO(t, e) {
  return t(e);
}
function iO() {}
var rS = !1;
function oO(t, e, n) {
  if (rS) return t(e, n);
  rS = !0;
  try {
    return rO(t, e, n);
  } finally {
    (rS = !1), (qd !== null || Kd !== null) && (iO(), nO());
  }
}
function up(t, e) {
  var n = t.stateNode;
  if (n === null) return null;
  var r = By(n);
  if (r === null) return null;
  n = r[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) ||
        ((t = t.type),
        (r = !(
          t === "button" ||
          t === "input" ||
          t === "select" ||
          t === "textarea"
        ))),
        (t = !r);
      break e;
    default:
      t = !1;
  }
  if (t) return null;
  if (n && typeof n != "function") throw Error(rt(231, e, typeof n));
  return n;
}
var xb = !1;
if (Us)
  try {
    var nh = {};
    Object.defineProperty(nh, "passive", {
      get: function () {
        xb = !0;
      },
    }),
      window.addEventListener("test", nh, nh),
      window.removeEventListener("test", nh, nh);
  } catch {
    xb = !1;
  }
function K5(t, e, n, r, i, o, a, s, l) {
  var c = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(n, c);
  } catch (u) {
    this.onError(u);
  }
}
var Hh = !1,
  U0 = null,
  k0 = !1,
  Sb = null,
  Y5 = {
    onError: function (t) {
      (Hh = !0), (U0 = t);
    },
  };
function Z5(t, e, n, r, i, o, a, s, l) {
  (Hh = !1), (U0 = null), K5.apply(Y5, arguments);
}
function Q5(t, e, n, r, i, o, a, s, l) {
  if ((Z5.apply(this, arguments), Hh)) {
    if (Hh) {
      var c = U0;
      (Hh = !1), (U0 = null);
    } else throw Error(rt(198));
    k0 || ((k0 = !0), (Sb = c));
  }
}
function vu(t) {
  var e = t,
    n = t;
  if (t.alternate) for (; e.return; ) e = e.return;
  else {
    t = e;
    do (e = t), e.flags & 4098 && (n = e.return), (t = e.return);
    while (t);
  }
  return e.tag === 3 ? n : null;
}
function aO(t) {
  if (t.tag === 13) {
    var e = t.memoizedState;
    if (
      (e === null && ((t = t.alternate), t !== null && (e = t.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function gA(t) {
  if (vu(t) !== t) throw Error(rt(188));
}
function J5(t) {
  var e = t.alternate;
  if (!e) {
    if (((e = vu(t)), e === null)) throw Error(rt(188));
    return e !== t ? null : t;
  }
  for (var n = t, r = e; ; ) {
    var i = n.return;
    if (i === null) break;
    var o = i.alternate;
    if (o === null) {
      if (((r = i.return), r !== null)) {
        n = r;
        continue;
      }
      break;
    }
    if (i.child === o.child) {
      for (o = i.child; o; ) {
        if (o === n) return gA(i), t;
        if (o === r) return gA(i), e;
        o = o.sibling;
      }
      throw Error(rt(188));
    }
    if (n.return !== r.return) (n = i), (r = o);
    else {
      for (var a = !1, s = i.child; s; ) {
        if (s === n) {
          (a = !0), (n = i), (r = o);
          break;
        }
        if (s === r) {
          (a = !0), (r = i), (n = o);
          break;
        }
        s = s.sibling;
      }
      if (!a) {
        for (s = o.child; s; ) {
          if (s === n) {
            (a = !0), (n = o), (r = i);
            break;
          }
          if (s === r) {
            (a = !0), (r = o), (n = i);
            break;
          }
          s = s.sibling;
        }
        if (!a) throw Error(rt(189));
      }
    }
    if (n.alternate !== r) throw Error(rt(190));
  }
  if (n.tag !== 3) throw Error(rt(188));
  return n.stateNode.current === n ? t : e;
}
function sO(t) {
  return (t = J5(t)), t !== null ? lO(t) : null;
}
function lO(t) {
  if (t.tag === 5 || t.tag === 6) return t;
  for (t = t.child; t !== null; ) {
    var e = lO(t);
    if (e !== null) return e;
    t = t.sibling;
  }
  return null;
}
var cO = Ro.unstable_scheduleCallback,
  vA = Ro.unstable_cancelCallback,
  eB = Ro.unstable_shouldYield,
  tB = Ro.unstable_requestPaint,
  mr = Ro.unstable_now,
  nB = Ro.unstable_getCurrentPriorityLevel,
  sM = Ro.unstable_ImmediatePriority,
  uO = Ro.unstable_UserBlockingPriority,
  B0 = Ro.unstable_NormalPriority,
  rB = Ro.unstable_LowPriority,
  dO = Ro.unstable_IdlePriority,
  Dy = null,
  Za = null;
function iB(t) {
  if (Za && typeof Za.onCommitFiberRoot == "function")
    try {
      Za.onCommitFiberRoot(Dy, t, void 0, (t.current.flags & 128) === 128);
    } catch {}
}
var Ma = Math.clz32 ? Math.clz32 : sB,
  oB = Math.log,
  aB = Math.LN2;
function sB(t) {
  return (t >>>= 0), t === 0 ? 32 : (31 - ((oB(t) / aB) | 0)) | 0;
}
var Tg = 64,
  Ag = 4194304;
function Nh(t) {
  switch (t & -t) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return t & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return t;
  }
}
function H0(t, e) {
  var n = t.pendingLanes;
  if (n === 0) return 0;
  var r = 0,
    i = t.suspendedLanes,
    o = t.pingedLanes,
    a = n & 268435455;
  if (a !== 0) {
    var s = a & ~i;
    s !== 0 ? (r = Nh(s)) : ((o &= a), o !== 0 && (r = Nh(o)));
  } else (a = n & ~i), a !== 0 ? (r = Nh(a)) : o !== 0 && (r = Nh(o));
  if (r === 0) return 0;
  if (
    e !== 0 &&
    e !== r &&
    !(e & i) &&
    ((i = r & -r), (o = e & -e), i >= o || (i === 16 && (o & 4194240) !== 0))
  )
    return e;
  if ((r & 4 && (r |= n & 16), (e = t.entangledLanes), e !== 0))
    for (t = t.entanglements, e &= r; 0 < e; )
      (n = 31 - Ma(e)), (i = 1 << n), (r |= t[n]), (e &= ~i);
  return r;
}
function lB(t, e) {
  switch (t) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function cB(t, e) {
  for (
    var n = t.suspendedLanes,
      r = t.pingedLanes,
      i = t.expirationTimes,
      o = t.pendingLanes;
    0 < o;

  ) {
    var a = 31 - Ma(o),
      s = 1 << a,
      l = i[a];
    l === -1
      ? (!(s & n) || s & r) && (i[a] = lB(s, e))
      : l <= e && (t.expiredLanes |= s),
      (o &= ~s);
  }
}
function _b(t) {
  return (
    (t = t.pendingLanes & -1073741825),
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
  );
}
function fO() {
  var t = Tg;
  return (Tg <<= 1), !(Tg & 4194240) && (Tg = 64), t;
}
function iS(t) {
  for (var e = [], n = 0; 31 > n; n++) e.push(t);
  return e;
}
function am(t, e, n) {
  (t.pendingLanes |= e),
    e !== 536870912 && ((t.suspendedLanes = 0), (t.pingedLanes = 0)),
    (t = t.eventTimes),
    (e = 31 - Ma(e)),
    (t[e] = n);
}
function uB(t, e) {
  var n = t.pendingLanes & ~e;
  (t.pendingLanes = e),
    (t.suspendedLanes = 0),
    (t.pingedLanes = 0),
    (t.expiredLanes &= e),
    (t.mutableReadLanes &= e),
    (t.entangledLanes &= e),
    (e = t.entanglements);
  var r = t.eventTimes;
  for (t = t.expirationTimes; 0 < n; ) {
    var i = 31 - Ma(n),
      o = 1 << i;
    (e[i] = 0), (r[i] = -1), (t[i] = -1), (n &= ~o);
  }
}
function lM(t, e) {
  var n = (t.entangledLanes |= e);
  for (t = t.entanglements; n; ) {
    var r = 31 - Ma(n),
      i = 1 << r;
    (i & e) | (t[r] & e) && (t[r] |= e), (n &= ~i);
  }
}
var Cn = 0;
function hO(t) {
  return (t &= -t), 1 < t ? (4 < t ? (t & 268435455 ? 16 : 536870912) : 4) : 1;
}
var pO,
  cM,
  mO,
  gO,
  vO,
  bb = !1,
  Rg = [],
  Cl = null,
  Tl = null,
  Al = null,
  dp = new Map(),
  fp = new Map(),
  vl = [],
  dB =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function yA(t, e) {
  switch (t) {
    case "focusin":
    case "focusout":
      Cl = null;
      break;
    case "dragenter":
    case "dragleave":
      Tl = null;
      break;
    case "mouseover":
    case "mouseout":
      Al = null;
      break;
    case "pointerover":
    case "pointerout":
      dp.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      fp.delete(e.pointerId);
  }
}
function rh(t, e, n, r, i, o) {
  return t === null || t.nativeEvent !== o
    ? ((t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: o,
        targetContainers: [i],
      }),
      e !== null && ((e = lm(e)), e !== null && cM(e)),
      t)
    : ((t.eventSystemFlags |= r),
      (e = t.targetContainers),
      i !== null && e.indexOf(i) === -1 && e.push(i),
      t);
}
function fB(t, e, n, r, i) {
  switch (e) {
    case "focusin":
      return (Cl = rh(Cl, t, e, n, r, i)), !0;
    case "dragenter":
      return (Tl = rh(Tl, t, e, n, r, i)), !0;
    case "mouseover":
      return (Al = rh(Al, t, e, n, r, i)), !0;
    case "pointerover":
      var o = i.pointerId;
      return dp.set(o, rh(dp.get(o) || null, t, e, n, r, i)), !0;
    case "gotpointercapture":
      return (
        (o = i.pointerId), fp.set(o, rh(fp.get(o) || null, t, e, n, r, i)), !0
      );
  }
  return !1;
}
function yO(t) {
  var e = Dc(t.target);
  if (e !== null) {
    var n = vu(e);
    if (n !== null) {
      if (((e = n.tag), e === 13)) {
        if (((e = aO(n)), e !== null)) {
          (t.blockedOn = e),
            vO(t.priority, function () {
              mO(n);
            });
          return;
        }
      } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return;
      }
    }
  }
  t.blockedOn = null;
}
function a0(t) {
  if (t.blockedOn !== null) return !1;
  for (var e = t.targetContainers; 0 < e.length; ) {
    var n = wb(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
    if (n === null) {
      n = t.nativeEvent;
      var r = new n.constructor(n.type, n);
      (vb = r), n.target.dispatchEvent(r), (vb = null);
    } else return (e = lm(n)), e !== null && cM(e), (t.blockedOn = n), !1;
    e.shift();
  }
  return !0;
}
function xA(t, e, n) {
  a0(t) && n.delete(e);
}
function hB() {
  (bb = !1),
    Cl !== null && a0(Cl) && (Cl = null),
    Tl !== null && a0(Tl) && (Tl = null),
    Al !== null && a0(Al) && (Al = null),
    dp.forEach(xA),
    fp.forEach(xA);
}
function ih(t, e) {
  t.blockedOn === e &&
    ((t.blockedOn = null),
    bb ||
      ((bb = !0),
      Ro.unstable_scheduleCallback(Ro.unstable_NormalPriority, hB)));
}
function hp(t) {
  function e(i) {
    return ih(i, t);
  }
  if (0 < Rg.length) {
    ih(Rg[0], t);
    for (var n = 1; n < Rg.length; n++) {
      var r = Rg[n];
      r.blockedOn === t && (r.blockedOn = null);
    }
  }
  for (
    Cl !== null && ih(Cl, t),
      Tl !== null && ih(Tl, t),
      Al !== null && ih(Al, t),
      dp.forEach(e),
      fp.forEach(e),
      n = 0;
    n < vl.length;
    n++
  )
    (r = vl[n]), r.blockedOn === t && (r.blockedOn = null);
  for (; 0 < vl.length && ((n = vl[0]), n.blockedOn === null); )
    yO(n), n.blockedOn === null && vl.shift();
}
var Yd = Xs.ReactCurrentBatchConfig,
  j0 = !0;
function pB(t, e, n, r) {
  var i = Cn,
    o = Yd.transition;
  Yd.transition = null;
  try {
    (Cn = 1), uM(t, e, n, r);
  } finally {
    (Cn = i), (Yd.transition = o);
  }
}
function mB(t, e, n, r) {
  var i = Cn,
    o = Yd.transition;
  Yd.transition = null;
  try {
    (Cn = 4), uM(t, e, n, r);
  } finally {
    (Cn = i), (Yd.transition = o);
  }
}
function uM(t, e, n, r) {
  if (j0) {
    var i = wb(t, e, n, r);
    if (i === null) pS(t, e, r, V0, n), yA(t, r);
    else if (fB(i, t, e, n, r)) r.stopPropagation();
    else if ((yA(t, r), e & 4 && -1 < dB.indexOf(t))) {
      for (; i !== null; ) {
        var o = lm(i);
        if (
          (o !== null && pO(o),
          (o = wb(t, e, n, r)),
          o === null && pS(t, e, r, V0, n),
          o === i)
        )
          break;
        i = o;
      }
      i !== null && r.stopPropagation();
    } else pS(t, e, r, null, n);
  }
}
var V0 = null;
function wb(t, e, n, r) {
  if (((V0 = null), (t = aM(r)), (t = Dc(t)), t !== null))
    if (((e = vu(t)), e === null)) t = null;
    else if (((n = e.tag), n === 13)) {
      if (((t = aO(e)), t !== null)) return t;
      t = null;
    } else if (n === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      t = null;
    } else e !== t && (t = null);
  return (V0 = t), null;
}
function xO(t) {
  switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (nB()) {
        case sM:
          return 1;
        case uO:
          return 4;
        case B0:
        case rB:
          return 16;
        case dO:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Sl = null,
  dM = null,
  s0 = null;
function SO() {
  if (s0) return s0;
  var t,
    e = dM,
    n = e.length,
    r,
    i = "value" in Sl ? Sl.value : Sl.textContent,
    o = i.length;
  for (t = 0; t < n && e[t] === i[t]; t++);
  var a = n - t;
  for (r = 1; r <= a && e[n - r] === i[o - r]; r++);
  return (s0 = i.slice(t, 1 < r ? 1 - r : void 0));
}
function l0(t) {
  var e = t.keyCode;
  return (
    "charCode" in t
      ? ((t = t.charCode), t === 0 && e === 13 && (t = 13))
      : (t = e),
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
  );
}
function Pg() {
  return !0;
}
function SA() {
  return !1;
}
function Oo(t) {
  function e(n, r, i, o, a) {
    (this._reactName = n),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = o),
      (this.target = a),
      (this.currentTarget = null);
    for (var s in t)
      t.hasOwnProperty(s) && ((n = t[s]), (this[s] = n ? n(o) : o[s]));
    return (
      (this.isDefaultPrevented = (
        o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1
      )
        ? Pg
        : SA),
      (this.isPropagationStopped = SA),
      this
    );
  }
  return (
    tr(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var n = this.nativeEvent;
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          (this.isDefaultPrevented = Pg));
      },
      stopPropagation: function () {
        var n = this.nativeEvent;
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          (this.isPropagationStopped = Pg));
      },
      persist: function () {},
      isPersistent: Pg,
    }),
    e
  );
}
var Ef = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (t) {
      return t.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  fM = Oo(Ef),
  sm = tr({}, Ef, { view: 0, detail: 0 }),
  gB = Oo(sm),
  oS,
  aS,
  oh,
  zy = tr({}, sm, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: hM,
    button: 0,
    buttons: 0,
    relatedTarget: function (t) {
      return t.relatedTarget === void 0
        ? t.fromElement === t.srcElement
          ? t.toElement
          : t.fromElement
        : t.relatedTarget;
    },
    movementX: function (t) {
      return "movementX" in t
        ? t.movementX
        : (t !== oh &&
            (oh && t.type === "mousemove"
              ? ((oS = t.screenX - oh.screenX), (aS = t.screenY - oh.screenY))
              : (aS = oS = 0),
            (oh = t)),
          oS);
    },
    movementY: function (t) {
      return "movementY" in t ? t.movementY : aS;
    },
  }),
  _A = Oo(zy),
  vB = tr({}, zy, { dataTransfer: 0 }),
  yB = Oo(vB),
  xB = tr({}, sm, { relatedTarget: 0 }),
  sS = Oo(xB),
  SB = tr({}, Ef, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  _B = Oo(SB),
  bB = tr({}, Ef, {
    clipboardData: function (t) {
      return "clipboardData" in t ? t.clipboardData : window.clipboardData;
    },
  }),
  wB = Oo(bB),
  EB = tr({}, Ef, { data: 0 }),
  bA = Oo(EB),
  MB = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  CB = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  TB = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function AB(t) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(t) : (t = TB[t]) ? !!e[t] : !1;
}
function hM() {
  return AB;
}
var RB = tr({}, sm, {
    key: function (t) {
      if (t.key) {
        var e = MB[t.key] || t.key;
        if (e !== "Unidentified") return e;
      }
      return t.type === "keypress"
        ? ((t = l0(t)), t === 13 ? "Enter" : String.fromCharCode(t))
        : t.type === "keydown" || t.type === "keyup"
        ? CB[t.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: hM,
    charCode: function (t) {
      return t.type === "keypress" ? l0(t) : 0;
    },
    keyCode: function (t) {
      return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
    },
    which: function (t) {
      return t.type === "keypress"
        ? l0(t)
        : t.type === "keydown" || t.type === "keyup"
        ? t.keyCode
        : 0;
    },
  }),
  PB = Oo(RB),
  IB = tr({}, zy, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  wA = Oo(IB),
  LB = tr({}, sm, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: hM,
  }),
  OB = Oo(LB),
  NB = tr({}, Ef, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  FB = Oo(NB),
  DB = tr({}, zy, {
    deltaX: function (t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
    },
    deltaY: function (t) {
      return "deltaY" in t
        ? t.deltaY
        : "wheelDeltaY" in t
        ? -t.wheelDeltaY
        : "wheelDelta" in t
        ? -t.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  zB = Oo(DB),
  UB = [9, 13, 27, 32],
  pM = Us && "CompositionEvent" in window,
  jh = null;
Us && "documentMode" in document && (jh = document.documentMode);
var kB = Us && "TextEvent" in window && !jh,
  _O = Us && (!pM || (jh && 8 < jh && 11 >= jh)),
  EA = " ",
  MA = !1;
function bO(t, e) {
  switch (t) {
    case "keyup":
      return UB.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function wO(t) {
  return (t = t.detail), typeof t == "object" && "data" in t ? t.data : null;
}
var Ad = !1;
function BB(t, e) {
  switch (t) {
    case "compositionend":
      return wO(e);
    case "keypress":
      return e.which !== 32 ? null : ((MA = !0), EA);
    case "textInput":
      return (t = e.data), t === EA && MA ? null : t;
    default:
      return null;
  }
}
function HB(t, e) {
  if (Ad)
    return t === "compositionend" || (!pM && bO(t, e))
      ? ((t = SO()), (s0 = dM = Sl = null), (Ad = !1), t)
      : null;
  switch (t) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return _O && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var jB = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function CA(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e === "input" ? !!jB[t.type] : e === "textarea";
}
function EO(t, e, n, r) {
  tO(r),
    (e = $0(e, "onChange")),
    0 < e.length &&
      ((n = new fM("onChange", "change", null, n, r)),
      t.push({ event: n, listeners: e }));
}
var Vh = null,
  pp = null;
function VB(t) {
  FO(t, 0);
}
function Uy(t) {
  var e = Id(t);
  if (qL(e)) return t;
}
function $B(t, e) {
  if (t === "change") return e;
}
var MO = !1;
if (Us) {
  var lS;
  if (Us) {
    var cS = "oninput" in document;
    if (!cS) {
      var TA = document.createElement("div");
      TA.setAttribute("oninput", "return;"),
        (cS = typeof TA.oninput == "function");
    }
    lS = cS;
  } else lS = !1;
  MO = lS && (!document.documentMode || 9 < document.documentMode);
}
function AA() {
  Vh && (Vh.detachEvent("onpropertychange", CO), (pp = Vh = null));
}
function CO(t) {
  if (t.propertyName === "value" && Uy(pp)) {
    var e = [];
    EO(e, pp, t, aM(t)), oO(VB, e);
  }
}
function GB(t, e, n) {
  t === "focusin"
    ? (AA(), (Vh = e), (pp = n), Vh.attachEvent("onpropertychange", CO))
    : t === "focusout" && AA();
}
function WB(t) {
  if (t === "selectionchange" || t === "keyup" || t === "keydown")
    return Uy(pp);
}
function XB(t, e) {
  if (t === "click") return Uy(e);
}
function qB(t, e) {
  if (t === "input" || t === "change") return Uy(e);
}
function KB(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var Ra = typeof Object.is == "function" ? Object.is : KB;
function mp(t, e) {
  if (Ra(t, e)) return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null)
    return !1;
  var n = Object.keys(t),
    r = Object.keys(e);
  if (n.length !== r.length) return !1;
  for (r = 0; r < n.length; r++) {
    var i = n[r];
    if (!ob.call(e, i) || !Ra(t[i], e[i])) return !1;
  }
  return !0;
}
function RA(t) {
  for (; t && t.firstChild; ) t = t.firstChild;
  return t;
}
function PA(t, e) {
  var n = RA(t);
  t = 0;
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (((r = t + n.textContent.length), t <= e && r >= e))
        return { node: n, offset: e - t };
      t = r;
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e;
        }
        n = n.parentNode;
      }
      n = void 0;
    }
    n = RA(n);
  }
}
function TO(t, e) {
  return t && e
    ? t === e
      ? !0
      : t && t.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? TO(t, e.parentNode)
      : "contains" in t
      ? t.contains(e)
      : t.compareDocumentPosition
      ? !!(t.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function AO() {
  for (var t = window, e = z0(); e instanceof t.HTMLIFrameElement; ) {
    try {
      var n = typeof e.contentWindow.location.href == "string";
    } catch {
      n = !1;
    }
    if (n) t = e.contentWindow;
    else break;
    e = z0(t.document);
  }
  return e;
}
function mM(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (t.type === "text" ||
        t.type === "search" ||
        t.type === "tel" ||
        t.type === "url" ||
        t.type === "password")) ||
      e === "textarea" ||
      t.contentEditable === "true")
  );
}
function YB(t) {
  var e = AO(),
    n = t.focusedElem,
    r = t.selectionRange;
  if (
    e !== n &&
    n &&
    n.ownerDocument &&
    TO(n.ownerDocument.documentElement, n)
  ) {
    if (r !== null && mM(n)) {
      if (
        ((e = r.start),
        (t = r.end),
        t === void 0 && (t = e),
        "selectionStart" in n)
      )
        (n.selectionStart = e), (n.selectionEnd = Math.min(t, n.value.length));
      else if (
        ((t = ((e = n.ownerDocument || document) && e.defaultView) || window),
        t.getSelection)
      ) {
        t = t.getSelection();
        var i = n.textContent.length,
          o = Math.min(r.start, i);
        (r = r.end === void 0 ? o : Math.min(r.end, i)),
          !t.extend && o > r && ((i = r), (r = o), (o = i)),
          (i = PA(n, o));
        var a = PA(n, r);
        i &&
          a &&
          (t.rangeCount !== 1 ||
            t.anchorNode !== i.node ||
            t.anchorOffset !== i.offset ||
            t.focusNode !== a.node ||
            t.focusOffset !== a.offset) &&
          ((e = e.createRange()),
          e.setStart(i.node, i.offset),
          t.removeAllRanges(),
          o > r
            ? (t.addRange(e), t.extend(a.node, a.offset))
            : (e.setEnd(a.node, a.offset), t.addRange(e)));
      }
    }
    for (e = [], t = n; (t = t.parentNode); )
      t.nodeType === 1 &&
        e.push({ element: t, left: t.scrollLeft, top: t.scrollTop });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)
      (t = e[n]),
        (t.element.scrollLeft = t.left),
        (t.element.scrollTop = t.top);
  }
}
var ZB = Us && "documentMode" in document && 11 >= document.documentMode,
  Rd = null,
  Eb = null,
  $h = null,
  Mb = !1;
function IA(t, e, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  Mb ||
    Rd == null ||
    Rd !== z0(r) ||
    ((r = Rd),
    "selectionStart" in r && mM(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = (
          (r.ownerDocument && r.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    ($h && mp($h, r)) ||
      (($h = r),
      (r = $0(Eb, "onSelect")),
      0 < r.length &&
        ((e = new fM("onSelect", "select", null, e, n)),
        t.push({ event: e, listeners: r }),
        (e.target = Rd))));
}
function Ig(t, e) {
  var n = {};
  return (
    (n[t.toLowerCase()] = e.toLowerCase()),
    (n["Webkit" + t] = "webkit" + e),
    (n["Moz" + t] = "moz" + e),
    n
  );
}
var Pd = {
    animationend: Ig("Animation", "AnimationEnd"),
    animationiteration: Ig("Animation", "AnimationIteration"),
    animationstart: Ig("Animation", "AnimationStart"),
    transitionend: Ig("Transition", "TransitionEnd"),
  },
  uS = {},
  RO = {};
Us &&
  ((RO = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete Pd.animationend.animation,
    delete Pd.animationiteration.animation,
    delete Pd.animationstart.animation),
  "TransitionEvent" in window || delete Pd.transitionend.transition);
function ky(t) {
  if (uS[t]) return uS[t];
  if (!Pd[t]) return t;
  var e = Pd[t],
    n;
  for (n in e) if (e.hasOwnProperty(n) && n in RO) return (uS[t] = e[n]);
  return t;
}
var PO = ky("animationend"),
  IO = ky("animationiteration"),
  LO = ky("animationstart"),
  OO = ky("transitionend"),
  NO = new Map(),
  LA =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function Xl(t, e) {
  NO.set(t, e), gu(e, [t]);
}
for (var dS = 0; dS < LA.length; dS++) {
  var fS = LA[dS],
    QB = fS.toLowerCase(),
    JB = fS[0].toUpperCase() + fS.slice(1);
  Xl(QB, "on" + JB);
}
Xl(PO, "onAnimationEnd");
Xl(IO, "onAnimationIteration");
Xl(LO, "onAnimationStart");
Xl("dblclick", "onDoubleClick");
Xl("focusin", "onFocus");
Xl("focusout", "onBlur");
Xl(OO, "onTransitionEnd");
rf("onMouseEnter", ["mouseout", "mouseover"]);
rf("onMouseLeave", ["mouseout", "mouseover"]);
rf("onPointerEnter", ["pointerout", "pointerover"]);
rf("onPointerLeave", ["pointerout", "pointerover"]);
gu(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
gu(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
gu("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
gu(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
gu(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
gu(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var Fh =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  e6 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Fh));
function OA(t, e, n) {
  var r = t.type || "unknown-event";
  (t.currentTarget = n), Q5(r, e, void 0, t), (t.currentTarget = null);
}
function FO(t, e) {
  e = (e & 4) !== 0;
  for (var n = 0; n < t.length; n++) {
    var r = t[n],
      i = r.event;
    r = r.listeners;
    e: {
      var o = void 0;
      if (e)
        for (var a = r.length - 1; 0 <= a; a--) {
          var s = r[a],
            l = s.instance,
            c = s.currentTarget;
          if (((s = s.listener), l !== o && i.isPropagationStopped())) break e;
          OA(i, s, c), (o = l);
        }
      else
        for (a = 0; a < r.length; a++) {
          if (
            ((s = r[a]),
            (l = s.instance),
            (c = s.currentTarget),
            (s = s.listener),
            l !== o && i.isPropagationStopped())
          )
            break e;
          OA(i, s, c), (o = l);
        }
    }
  }
  if (k0) throw ((t = Sb), (k0 = !1), (Sb = null), t);
}
function Hn(t, e) {
  var n = e[Pb];
  n === void 0 && (n = e[Pb] = new Set());
  var r = t + "__bubble";
  n.has(r) || (DO(e, t, 2, !1), n.add(r));
}
function hS(t, e, n) {
  var r = 0;
  e && (r |= 4), DO(n, t, r, e);
}
var Lg = "_reactListening" + Math.random().toString(36).slice(2);
function gp(t) {
  if (!t[Lg]) {
    (t[Lg] = !0),
      VL.forEach(function (n) {
        n !== "selectionchange" && (e6.has(n) || hS(n, !1, t), hS(n, !0, t));
      });
    var e = t.nodeType === 9 ? t : t.ownerDocument;
    e === null || e[Lg] || ((e[Lg] = !0), hS("selectionchange", !1, e));
  }
}
function DO(t, e, n, r) {
  switch (xO(e)) {
    case 1:
      var i = pB;
      break;
    case 4:
      i = mB;
      break;
    default:
      i = uM;
  }
  (n = i.bind(null, e, n, t)),
    (i = void 0),
    !xb ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (i = !0),
    r
      ? i !== void 0
        ? t.addEventListener(e, n, { capture: !0, passive: i })
        : t.addEventListener(e, n, !0)
      : i !== void 0
      ? t.addEventListener(e, n, { passive: i })
      : t.addEventListener(e, n, !1);
}
function pS(t, e, n, r, i) {
  var o = r;
  if (!(e & 1) && !(e & 2) && r !== null)
    e: for (;;) {
      if (r === null) return;
      var a = r.tag;
      if (a === 3 || a === 4) {
        var s = r.stateNode.containerInfo;
        if (s === i || (s.nodeType === 8 && s.parentNode === i)) break;
        if (a === 4)
          for (a = r.return; a !== null; ) {
            var l = a.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = a.stateNode.containerInfo),
              l === i || (l.nodeType === 8 && l.parentNode === i))
            )
              return;
            a = a.return;
          }
        for (; s !== null; ) {
          if (((a = Dc(s)), a === null)) return;
          if (((l = a.tag), l === 5 || l === 6)) {
            r = o = a;
            continue e;
          }
          s = s.parentNode;
        }
      }
      r = r.return;
    }
  oO(function () {
    var c = o,
      u = aM(n),
      d = [];
    e: {
      var p = NO.get(t);
      if (p !== void 0) {
        var m = fM,
          v = t;
        switch (t) {
          case "keypress":
            if (l0(n) === 0) break e;
          case "keydown":
          case "keyup":
            m = PB;
            break;
          case "focusin":
            (v = "focus"), (m = sS);
            break;
          case "focusout":
            (v = "blur"), (m = sS);
            break;
          case "beforeblur":
          case "afterblur":
            m = sS;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            m = _A;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            m = yB;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            m = OB;
            break;
          case PO:
          case IO:
          case LO:
            m = _B;
            break;
          case OO:
            m = FB;
            break;
          case "scroll":
            m = gB;
            break;
          case "wheel":
            m = zB;
            break;
          case "copy":
          case "cut":
          case "paste":
            m = wB;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            m = wA;
        }
        var S = (e & 4) !== 0,
          x = !S && t === "scroll",
          g = S ? (p !== null ? p + "Capture" : null) : p;
        S = [];
        for (var _ = c, y; _ !== null; ) {
          y = _;
          var w = y.stateNode;
          if (
            (y.tag === 5 &&
              w !== null &&
              ((y = w),
              g !== null && ((w = up(_, g)), w != null && S.push(vp(_, w, y)))),
            x)
          )
            break;
          _ = _.return;
        }
        0 < S.length &&
          ((p = new m(p, v, null, n, u)), d.push({ event: p, listeners: S }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((p = t === "mouseover" || t === "pointerover"),
          (m = t === "mouseout" || t === "pointerout"),
          p &&
            n !== vb &&
            (v = n.relatedTarget || n.fromElement) &&
            (Dc(v) || v[ks]))
        )
          break e;
        if (
          (m || p) &&
          ((p =
            u.window === u
              ? u
              : (p = u.ownerDocument)
              ? p.defaultView || p.parentWindow
              : window),
          m
            ? ((v = n.relatedTarget || n.toElement),
              (m = c),
              (v = v ? Dc(v) : null),
              v !== null &&
                ((x = vu(v)), v !== x || (v.tag !== 5 && v.tag !== 6)) &&
                (v = null))
            : ((m = null), (v = c)),
          m !== v)
        ) {
          if (
            ((S = _A),
            (w = "onMouseLeave"),
            (g = "onMouseEnter"),
            (_ = "mouse"),
            (t === "pointerout" || t === "pointerover") &&
              ((S = wA),
              (w = "onPointerLeave"),
              (g = "onPointerEnter"),
              (_ = "pointer")),
            (x = m == null ? p : Id(m)),
            (y = v == null ? p : Id(v)),
            (p = new S(w, _ + "leave", m, n, u)),
            (p.target = x),
            (p.relatedTarget = y),
            (w = null),
            Dc(u) === c &&
              ((S = new S(g, _ + "enter", v, n, u)),
              (S.target = y),
              (S.relatedTarget = x),
              (w = S)),
            (x = w),
            m && v)
          )
            t: {
              for (S = m, g = v, _ = 0, y = S; y; y = Bu(y)) _++;
              for (y = 0, w = g; w; w = Bu(w)) y++;
              for (; 0 < _ - y; ) (S = Bu(S)), _--;
              for (; 0 < y - _; ) (g = Bu(g)), y--;
              for (; _--; ) {
                if (S === g || (g !== null && S === g.alternate)) break t;
                (S = Bu(S)), (g = Bu(g));
              }
              S = null;
            }
          else S = null;
          m !== null && NA(d, p, m, S, !1),
            v !== null && x !== null && NA(d, x, v, S, !0);
        }
      }
      e: {
        if (
          ((p = c ? Id(c) : window),
          (m = p.nodeName && p.nodeName.toLowerCase()),
          m === "select" || (m === "input" && p.type === "file"))
        )
          var A = $B;
        else if (CA(p))
          if (MO) A = qB;
          else {
            A = WB;
            var M = GB;
          }
        else
          (m = p.nodeName) &&
            m.toLowerCase() === "input" &&
            (p.type === "checkbox" || p.type === "radio") &&
            (A = XB);
        if (A && (A = A(t, c))) {
          EO(d, A, n, u);
          break e;
        }
        M && M(t, p, c),
          t === "focusout" &&
            (M = p._wrapperState) &&
            M.controlled &&
            p.type === "number" &&
            fb(p, "number", p.value);
      }
      switch (((M = c ? Id(c) : window), t)) {
        case "focusin":
          (CA(M) || M.contentEditable === "true") &&
            ((Rd = M), (Eb = c), ($h = null));
          break;
        case "focusout":
          $h = Eb = Rd = null;
          break;
        case "mousedown":
          Mb = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (Mb = !1), IA(d, n, u);
          break;
        case "selectionchange":
          if (ZB) break;
        case "keydown":
        case "keyup":
          IA(d, n, u);
      }
      var T;
      if (pM)
        e: {
          switch (t) {
            case "compositionstart":
              var I = "onCompositionStart";
              break e;
            case "compositionend":
              I = "onCompositionEnd";
              break e;
            case "compositionupdate":
              I = "onCompositionUpdate";
              break e;
          }
          I = void 0;
        }
      else
        Ad
          ? bO(t, n) && (I = "onCompositionEnd")
          : t === "keydown" && n.keyCode === 229 && (I = "onCompositionStart");
      I &&
        (_O &&
          n.locale !== "ko" &&
          (Ad || I !== "onCompositionStart"
            ? I === "onCompositionEnd" && Ad && (T = SO())
            : ((Sl = u),
              (dM = "value" in Sl ? Sl.value : Sl.textContent),
              (Ad = !0))),
        (M = $0(c, I)),
        0 < M.length &&
          ((I = new bA(I, t, null, n, u)),
          d.push({ event: I, listeners: M }),
          T ? (I.data = T) : ((T = wO(n)), T !== null && (I.data = T)))),
        (T = kB ? BB(t, n) : HB(t, n)) &&
          ((c = $0(c, "onBeforeInput")),
          0 < c.length &&
            ((u = new bA("onBeforeInput", "beforeinput", null, n, u)),
            d.push({ event: u, listeners: c }),
            (u.data = T)));
    }
    FO(d, e);
  });
}
function vp(t, e, n) {
  return { instance: t, listener: e, currentTarget: n };
}
function $0(t, e) {
  for (var n = e + "Capture", r = []; t !== null; ) {
    var i = t,
      o = i.stateNode;
    i.tag === 5 &&
      o !== null &&
      ((i = o),
      (o = up(t, n)),
      o != null && r.unshift(vp(t, o, i)),
      (o = up(t, e)),
      o != null && r.push(vp(t, o, i))),
      (t = t.return);
  }
  return r;
}
function Bu(t) {
  if (t === null) return null;
  do t = t.return;
  while (t && t.tag !== 5);
  return t || null;
}
function NA(t, e, n, r, i) {
  for (var o = e._reactName, a = []; n !== null && n !== r; ) {
    var s = n,
      l = s.alternate,
      c = s.stateNode;
    if (l !== null && l === r) break;
    s.tag === 5 &&
      c !== null &&
      ((s = c),
      i
        ? ((l = up(n, o)), l != null && a.unshift(vp(n, l, s)))
        : i || ((l = up(n, o)), l != null && a.push(vp(n, l, s)))),
      (n = n.return);
  }
  a.length !== 0 && t.push({ event: e, listeners: a });
}
var t6 = /\r\n?/g,
  n6 = /\u0000|\uFFFD/g;
function FA(t) {
  return (typeof t == "string" ? t : "" + t)
    .replace(
      t6,
      `
`
    )
    .replace(n6, "");
}
function Og(t, e, n) {
  if (((e = FA(e)), FA(t) !== e && n)) throw Error(rt(425));
}
function G0() {}
var Cb = null,
  Tb = null;
function Ab(t, e) {
  return (
    t === "textarea" ||
    t === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var Rb = typeof setTimeout == "function" ? setTimeout : void 0,
  r6 = typeof clearTimeout == "function" ? clearTimeout : void 0,
  DA = typeof Promise == "function" ? Promise : void 0,
  i6 =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof DA < "u"
      ? function (t) {
          return DA.resolve(null).then(t).catch(o6);
        }
      : Rb;
function o6(t) {
  setTimeout(function () {
    throw t;
  });
}
function mS(t, e) {
  var n = e,
    r = 0;
  do {
    var i = n.nextSibling;
    if ((t.removeChild(n), i && i.nodeType === 8))
      if (((n = i.data), n === "/$")) {
        if (r === 0) {
          t.removeChild(i), hp(e);
          return;
        }
        r--;
      } else (n !== "$" && n !== "$?" && n !== "$!") || r++;
    n = i;
  } while (n);
  hp(e);
}
function Rl(t) {
  for (; t != null; t = t.nextSibling) {
    var e = t.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = t.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return t;
}
function zA(t) {
  t = t.previousSibling;
  for (var e = 0; t; ) {
    if (t.nodeType === 8) {
      var n = t.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (e === 0) return t;
        e--;
      } else n === "/$" && e++;
    }
    t = t.previousSibling;
  }
  return null;
}
var Mf = Math.random().toString(36).slice(2),
  qa = "__reactFiber$" + Mf,
  yp = "__reactProps$" + Mf,
  ks = "__reactContainer$" + Mf,
  Pb = "__reactEvents$" + Mf,
  a6 = "__reactListeners$" + Mf,
  s6 = "__reactHandles$" + Mf;
function Dc(t) {
  var e = t[qa];
  if (e) return e;
  for (var n = t.parentNode; n; ) {
    if ((e = n[ks] || n[qa])) {
      if (
        ((n = e.alternate),
        e.child !== null || (n !== null && n.child !== null))
      )
        for (t = zA(t); t !== null; ) {
          if ((n = t[qa])) return n;
          t = zA(t);
        }
      return e;
    }
    (t = n), (n = t.parentNode);
  }
  return null;
}
function lm(t) {
  return (
    (t = t[qa] || t[ks]),
    !t || (t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3) ? null : t
  );
}
function Id(t) {
  if (t.tag === 5 || t.tag === 6) return t.stateNode;
  throw Error(rt(33));
}
function By(t) {
  return t[yp] || null;
}
var Ib = [],
  Ld = -1;
function ql(t) {
  return { current: t };
}
function Vn(t) {
  0 > Ld || ((t.current = Ib[Ld]), (Ib[Ld] = null), Ld--);
}
function kn(t, e) {
  Ld++, (Ib[Ld] = t.current), (t.current = e);
}
var kl = {},
  gi = ql(kl),
  Zi = ql(!1),
  iu = kl;
function of(t, e) {
  var n = t.type.contextTypes;
  if (!n) return kl;
  var r = t.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
    return r.__reactInternalMemoizedMaskedChildContext;
  var i = {},
    o;
  for (o in n) i[o] = e[o];
  return (
    r &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = e),
      (t.__reactInternalMemoizedMaskedChildContext = i)),
    i
  );
}
function Qi(t) {
  return (t = t.childContextTypes), t != null;
}
function W0() {
  Vn(Zi), Vn(gi);
}
function UA(t, e, n) {
  if (gi.current !== kl) throw Error(rt(168));
  kn(gi, e), kn(Zi, n);
}
function zO(t, e, n) {
  var r = t.stateNode;
  if (((e = e.childContextTypes), typeof r.getChildContext != "function"))
    return n;
  r = r.getChildContext();
  for (var i in r) if (!(i in e)) throw Error(rt(108, G5(t) || "Unknown", i));
  return tr({}, n, r);
}
function X0(t) {
  return (
    (t =
      ((t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext) || kl),
    (iu = gi.current),
    kn(gi, t),
    kn(Zi, Zi.current),
    !0
  );
}
function kA(t, e, n) {
  var r = t.stateNode;
  if (!r) throw Error(rt(169));
  n
    ? ((t = zO(t, e, iu)),
      (r.__reactInternalMemoizedMergedChildContext = t),
      Vn(Zi),
      Vn(gi),
      kn(gi, t))
    : Vn(Zi),
    kn(Zi, n);
}
var Cs = null,
  Hy = !1,
  gS = !1;
function UO(t) {
  Cs === null ? (Cs = [t]) : Cs.push(t);
}
function l6(t) {
  (Hy = !0), UO(t);
}
function Kl() {
  if (!gS && Cs !== null) {
    gS = !0;
    var t = 0,
      e = Cn;
    try {
      var n = Cs;
      for (Cn = 1; t < n.length; t++) {
        var r = n[t];
        do r = r(!0);
        while (r !== null);
      }
      (Cs = null), (Hy = !1);
    } catch (i) {
      throw (Cs !== null && (Cs = Cs.slice(t + 1)), cO(sM, Kl), i);
    } finally {
      (Cn = e), (gS = !1);
    }
  }
  return null;
}
var Od = [],
  Nd = 0,
  q0 = null,
  K0 = 0,
  qo = [],
  Ko = 0,
  ou = null,
  Ps = 1,
  Is = "";
function Mc(t, e) {
  (Od[Nd++] = K0), (Od[Nd++] = q0), (q0 = t), (K0 = e);
}
function kO(t, e, n) {
  (qo[Ko++] = Ps), (qo[Ko++] = Is), (qo[Ko++] = ou), (ou = t);
  var r = Ps;
  t = Is;
  var i = 32 - Ma(r) - 1;
  (r &= ~(1 << i)), (n += 1);
  var o = 32 - Ma(e) + i;
  if (30 < o) {
    var a = i - (i % 5);
    (o = (r & ((1 << a) - 1)).toString(32)),
      (r >>= a),
      (i -= a),
      (Ps = (1 << (32 - Ma(e) + i)) | (n << i) | r),
      (Is = o + t);
  } else (Ps = (1 << o) | (n << i) | r), (Is = t);
}
function gM(t) {
  t.return !== null && (Mc(t, 1), kO(t, 1, 0));
}
function vM(t) {
  for (; t === q0; )
    (q0 = Od[--Nd]), (Od[Nd] = null), (K0 = Od[--Nd]), (Od[Nd] = null);
  for (; t === ou; )
    (ou = qo[--Ko]),
      (qo[Ko] = null),
      (Is = qo[--Ko]),
      (qo[Ko] = null),
      (Ps = qo[--Ko]),
      (qo[Ko] = null);
}
var To = null,
  bo = null,
  Wn = !1,
  Sa = null;
function BO(t, e) {
  var n = Qo(5, null, null, 0);
  (n.elementType = "DELETED"),
    (n.stateNode = e),
    (n.return = t),
    (e = t.deletions),
    e === null ? ((t.deletions = [n]), (t.flags |= 16)) : e.push(n);
}
function BA(t, e) {
  switch (t.tag) {
    case 5:
      var n = t.type;
      return (
        (e =
          e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((t.stateNode = e), (To = t), (bo = Rl(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = t.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((t.stateNode = e), (To = t), (bo = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((n = ou !== null ? { id: Ps, overflow: Is } : null),
            (t.memoizedState = {
              dehydrated: e,
              treeContext: n,
              retryLane: 1073741824,
            }),
            (n = Qo(18, null, null, 0)),
            (n.stateNode = e),
            (n.return = t),
            (t.child = n),
            (To = t),
            (bo = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function Lb(t) {
  return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
}
function Ob(t) {
  if (Wn) {
    var e = bo;
    if (e) {
      var n = e;
      if (!BA(t, e)) {
        if (Lb(t)) throw Error(rt(418));
        e = Rl(n.nextSibling);
        var r = To;
        e && BA(t, e)
          ? BO(r, n)
          : ((t.flags = (t.flags & -4097) | 2), (Wn = !1), (To = t));
      }
    } else {
      if (Lb(t)) throw Error(rt(418));
      (t.flags = (t.flags & -4097) | 2), (Wn = !1), (To = t);
    }
  }
}
function HA(t) {
  for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
    t = t.return;
  To = t;
}
function Ng(t) {
  if (t !== To) return !1;
  if (!Wn) return HA(t), (Wn = !0), !1;
  var e;
  if (
    ((e = t.tag !== 3) &&
      !(e = t.tag !== 5) &&
      ((e = t.type),
      (e = e !== "head" && e !== "body" && !Ab(t.type, t.memoizedProps))),
    e && (e = bo))
  ) {
    if (Lb(t)) throw (HO(), Error(rt(418)));
    for (; e; ) BO(t, e), (e = Rl(e.nextSibling));
  }
  if ((HA(t), t.tag === 13)) {
    if (((t = t.memoizedState), (t = t !== null ? t.dehydrated : null), !t))
      throw Error(rt(317));
    e: {
      for (t = t.nextSibling, e = 0; t; ) {
        if (t.nodeType === 8) {
          var n = t.data;
          if (n === "/$") {
            if (e === 0) {
              bo = Rl(t.nextSibling);
              break e;
            }
            e--;
          } else (n !== "$" && n !== "$!" && n !== "$?") || e++;
        }
        t = t.nextSibling;
      }
      bo = null;
    }
  } else bo = To ? Rl(t.stateNode.nextSibling) : null;
  return !0;
}
function HO() {
  for (var t = bo; t; ) t = Rl(t.nextSibling);
}
function af() {
  (bo = To = null), (Wn = !1);
}
function yM(t) {
  Sa === null ? (Sa = [t]) : Sa.push(t);
}
var c6 = Xs.ReactCurrentBatchConfig;
function pa(t, e) {
  if (t && t.defaultProps) {
    (e = tr({}, e)), (t = t.defaultProps);
    for (var n in t) e[n] === void 0 && (e[n] = t[n]);
    return e;
  }
  return e;
}
var Y0 = ql(null),
  Z0 = null,
  Fd = null,
  xM = null;
function SM() {
  xM = Fd = Z0 = null;
}
function _M(t) {
  var e = Y0.current;
  Vn(Y0), (t._currentValue = e);
}
function Nb(t, e, n) {
  for (; t !== null; ) {
    var r = t.alternate;
    if (
      ((t.childLanes & e) !== e
        ? ((t.childLanes |= e), r !== null && (r.childLanes |= e))
        : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
      t === n)
    )
      break;
    t = t.return;
  }
}
function Zd(t, e) {
  (Z0 = t),
    (xM = Fd = null),
    (t = t.dependencies),
    t !== null &&
      t.firstContext !== null &&
      (t.lanes & e && (Yi = !0), (t.firstContext = null));
}
function na(t) {
  var e = t._currentValue;
  if (xM !== t)
    if (((t = { context: t, memoizedValue: e, next: null }), Fd === null)) {
      if (Z0 === null) throw Error(rt(308));
      (Fd = t), (Z0.dependencies = { lanes: 0, firstContext: t });
    } else Fd = Fd.next = t;
  return e;
}
var zc = null;
function bM(t) {
  zc === null ? (zc = [t]) : zc.push(t);
}
function jO(t, e, n, r) {
  var i = e.interleaved;
  return (
    i === null ? ((n.next = n), bM(e)) : ((n.next = i.next), (i.next = n)),
    (e.interleaved = n),
    Bs(t, r)
  );
}
function Bs(t, e) {
  t.lanes |= e;
  var n = t.alternate;
  for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null; )
    (t.childLanes |= e),
      (n = t.alternate),
      n !== null && (n.childLanes |= e),
      (n = t),
      (t = t.return);
  return n.tag === 3 ? n.stateNode : null;
}
var gl = !1;
function wM(t) {
  t.updateQueue = {
    baseState: t.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function VO(t, e) {
  (t = t.updateQueue),
    e.updateQueue === t &&
      (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects,
      });
}
function Ns(t, e) {
  return {
    eventTime: t,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function Pl(t, e, n) {
  var r = t.updateQueue;
  if (r === null) return null;
  if (((r = r.shared), mn & 2)) {
    var i = r.pending;
    return (
      i === null ? (e.next = e) : ((e.next = i.next), (i.next = e)),
      (r.pending = e),
      Bs(t, n)
    );
  }
  return (
    (i = r.interleaved),
    i === null ? ((e.next = e), bM(r)) : ((e.next = i.next), (i.next = e)),
    (r.interleaved = e),
    Bs(t, n)
  );
}
function c0(t, e, n) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (n & 4194240) !== 0))
  ) {
    var r = e.lanes;
    (r &= t.pendingLanes), (n |= r), (e.lanes = n), lM(t, n);
  }
}
function jA(t, e) {
  var n = t.updateQueue,
    r = t.alternate;
  if (r !== null && ((r = r.updateQueue), n === r)) {
    var i = null,
      o = null;
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var a = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        };
        o === null ? (i = o = a) : (o = o.next = a), (n = n.next);
      } while (n !== null);
      o === null ? (i = o = e) : (o = o.next = e);
    } else i = o = e;
    (n = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: o,
      shared: r.shared,
      effects: r.effects,
    }),
      (t.updateQueue = n);
    return;
  }
  (t = n.lastBaseUpdate),
    t === null ? (n.firstBaseUpdate = e) : (t.next = e),
    (n.lastBaseUpdate = e);
}
function Q0(t, e, n, r) {
  var i = t.updateQueue;
  gl = !1;
  var o = i.firstBaseUpdate,
    a = i.lastBaseUpdate,
    s = i.shared.pending;
  if (s !== null) {
    i.shared.pending = null;
    var l = s,
      c = l.next;
    (l.next = null), a === null ? (o = c) : (a.next = c), (a = l);
    var u = t.alternate;
    u !== null &&
      ((u = u.updateQueue),
      (s = u.lastBaseUpdate),
      s !== a &&
        (s === null ? (u.firstBaseUpdate = c) : (s.next = c),
        (u.lastBaseUpdate = l)));
  }
  if (o !== null) {
    var d = i.baseState;
    (a = 0), (u = c = l = null), (s = o);
    do {
      var p = s.lane,
        m = s.eventTime;
      if ((r & p) === p) {
        u !== null &&
          (u = u.next =
            {
              eventTime: m,
              lane: 0,
              tag: s.tag,
              payload: s.payload,
              callback: s.callback,
              next: null,
            });
        e: {
          var v = t,
            S = s;
          switch (((p = e), (m = n), S.tag)) {
            case 1:
              if (((v = S.payload), typeof v == "function")) {
                d = v.call(m, d, p);
                break e;
              }
              d = v;
              break e;
            case 3:
              v.flags = (v.flags & -65537) | 128;
            case 0:
              if (
                ((v = S.payload),
                (p = typeof v == "function" ? v.call(m, d, p) : v),
                p == null)
              )
                break e;
              d = tr({}, d, p);
              break e;
            case 2:
              gl = !0;
          }
        }
        s.callback !== null &&
          s.lane !== 0 &&
          ((t.flags |= 64),
          (p = i.effects),
          p === null ? (i.effects = [s]) : p.push(s));
      } else
        (m = {
          eventTime: m,
          lane: p,
          tag: s.tag,
          payload: s.payload,
          callback: s.callback,
          next: null,
        }),
          u === null ? ((c = u = m), (l = d)) : (u = u.next = m),
          (a |= p);
      if (((s = s.next), s === null)) {
        if (((s = i.shared.pending), s === null)) break;
        (p = s),
          (s = p.next),
          (p.next = null),
          (i.lastBaseUpdate = p),
          (i.shared.pending = null);
      }
    } while (!0);
    if (
      (u === null && (l = d),
      (i.baseState = l),
      (i.firstBaseUpdate = c),
      (i.lastBaseUpdate = u),
      (e = i.shared.interleaved),
      e !== null)
    ) {
      i = e;
      do (a |= i.lane), (i = i.next);
      while (i !== e);
    } else o === null && (i.shared.lanes = 0);
    (su |= a), (t.lanes = a), (t.memoizedState = d);
  }
}
function VA(t, e, n) {
  if (((t = e.effects), (e.effects = null), t !== null))
    for (e = 0; e < t.length; e++) {
      var r = t[e],
        i = r.callback;
      if (i !== null) {
        if (((r.callback = null), (r = n), typeof i != "function"))
          throw Error(rt(191, i));
        i.call(r);
      }
    }
}
var $O = new jL.Component().refs;
function Fb(t, e, n, r) {
  (e = t.memoizedState),
    (n = n(r, e)),
    (n = n == null ? e : tr({}, e, n)),
    (t.memoizedState = n),
    t.lanes === 0 && (t.updateQueue.baseState = n);
}
var jy = {
  isMounted: function (t) {
    return (t = t._reactInternals) ? vu(t) === t : !1;
  },
  enqueueSetState: function (t, e, n) {
    t = t._reactInternals;
    var r = Li(),
      i = Ll(t),
      o = Ns(r, i);
    (o.payload = e),
      n != null && (o.callback = n),
      (e = Pl(t, o, i)),
      e !== null && (Ca(e, t, i, r), c0(e, t, i));
  },
  enqueueReplaceState: function (t, e, n) {
    t = t._reactInternals;
    var r = Li(),
      i = Ll(t),
      o = Ns(r, i);
    (o.tag = 1),
      (o.payload = e),
      n != null && (o.callback = n),
      (e = Pl(t, o, i)),
      e !== null && (Ca(e, t, i, r), c0(e, t, i));
  },
  enqueueForceUpdate: function (t, e) {
    t = t._reactInternals;
    var n = Li(),
      r = Ll(t),
      i = Ns(n, r);
    (i.tag = 2),
      e != null && (i.callback = e),
      (e = Pl(t, i, r)),
      e !== null && (Ca(e, t, r, n), c0(e, t, r));
  },
};
function $A(t, e, n, r, i, o, a) {
  return (
    (t = t.stateNode),
    typeof t.shouldComponentUpdate == "function"
      ? t.shouldComponentUpdate(r, o, a)
      : e.prototype && e.prototype.isPureReactComponent
      ? !mp(n, r) || !mp(i, o)
      : !0
  );
}
function GO(t, e, n) {
  var r = !1,
    i = kl,
    o = e.contextType;
  return (
    typeof o == "object" && o !== null
      ? (o = na(o))
      : ((i = Qi(e) ? iu : gi.current),
        (r = e.contextTypes),
        (o = (r = r != null) ? of(t, i) : kl)),
    (e = new e(n, o)),
    (t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = jy),
    (t.stateNode = e),
    (e._reactInternals = t),
    r &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = i),
      (t.__reactInternalMemoizedMaskedChildContext = o)),
    e
  );
}
function GA(t, e, n, r) {
  (t = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(n, r),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(n, r),
    e.state !== t && jy.enqueueReplaceState(e, e.state, null);
}
function Db(t, e, n, r) {
  var i = t.stateNode;
  (i.props = n), (i.state = t.memoizedState), (i.refs = $O), wM(t);
  var o = e.contextType;
  typeof o == "object" && o !== null
    ? (i.context = na(o))
    : ((o = Qi(e) ? iu : gi.current), (i.context = of(t, o))),
    (i.state = t.memoizedState),
    (o = e.getDerivedStateFromProps),
    typeof o == "function" && (Fb(t, e, o, n), (i.state = t.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof i.getSnapshotBeforeUpdate == "function" ||
      (typeof i.UNSAFE_componentWillMount != "function" &&
        typeof i.componentWillMount != "function") ||
      ((e = i.state),
      typeof i.componentWillMount == "function" && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == "function" &&
        i.UNSAFE_componentWillMount(),
      e !== i.state && jy.enqueueReplaceState(i, i.state, null),
      Q0(t, n, i, r),
      (i.state = t.memoizedState)),
    typeof i.componentDidMount == "function" && (t.flags |= 4194308);
}
function ah(t, e, n) {
  if (
    ((t = n.ref), t !== null && typeof t != "function" && typeof t != "object")
  ) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(rt(309));
        var r = n.stateNode;
      }
      if (!r) throw Error(rt(147, t));
      var i = r,
        o = "" + t;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === o
        ? e.ref
        : ((e = function (a) {
            var s = i.refs;
            s === $O && (s = i.refs = {}),
              a === null ? delete s[o] : (s[o] = a);
          }),
          (e._stringRef = o),
          e);
    }
    if (typeof t != "string") throw Error(rt(284));
    if (!n._owner) throw Error(rt(290, t));
  }
  return t;
}
function Fg(t, e) {
  throw (
    ((t = Object.prototype.toString.call(e)),
    Error(
      rt(
        31,
        t === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : t
      )
    ))
  );
}
function WA(t) {
  var e = t._init;
  return e(t._payload);
}
function WO(t) {
  function e(g, _) {
    if (t) {
      var y = g.deletions;
      y === null ? ((g.deletions = [_]), (g.flags |= 16)) : y.push(_);
    }
  }
  function n(g, _) {
    if (!t) return null;
    for (; _ !== null; ) e(g, _), (_ = _.sibling);
    return null;
  }
  function r(g, _) {
    for (g = new Map(); _ !== null; )
      _.key !== null ? g.set(_.key, _) : g.set(_.index, _), (_ = _.sibling);
    return g;
  }
  function i(g, _) {
    return (g = Ol(g, _)), (g.index = 0), (g.sibling = null), g;
  }
  function o(g, _, y) {
    return (
      (g.index = y),
      t
        ? ((y = g.alternate),
          y !== null
            ? ((y = y.index), y < _ ? ((g.flags |= 2), _) : y)
            : ((g.flags |= 2), _))
        : ((g.flags |= 1048576), _)
    );
  }
  function a(g) {
    return t && g.alternate === null && (g.flags |= 2), g;
  }
  function s(g, _, y, w) {
    return _ === null || _.tag !== 6
      ? ((_ = wS(y, g.mode, w)), (_.return = g), _)
      : ((_ = i(_, y)), (_.return = g), _);
  }
  function l(g, _, y, w) {
    var A = y.type;
    return A === Td
      ? u(g, _, y.props.children, w, y.key)
      : _ !== null &&
        (_.elementType === A ||
          (typeof A == "object" &&
            A !== null &&
            A.$$typeof === ml &&
            WA(A) === _.type))
      ? ((w = i(_, y.props)), (w.ref = ah(g, _, y)), (w.return = g), w)
      : ((w = m0(y.type, y.key, y.props, null, g.mode, w)),
        (w.ref = ah(g, _, y)),
        (w.return = g),
        w);
  }
  function c(g, _, y, w) {
    return _ === null ||
      _.tag !== 4 ||
      _.stateNode.containerInfo !== y.containerInfo ||
      _.stateNode.implementation !== y.implementation
      ? ((_ = ES(y, g.mode, w)), (_.return = g), _)
      : ((_ = i(_, y.children || [])), (_.return = g), _);
  }
  function u(g, _, y, w, A) {
    return _ === null || _.tag !== 7
      ? ((_ = Xc(y, g.mode, w, A)), (_.return = g), _)
      : ((_ = i(_, y)), (_.return = g), _);
  }
  function d(g, _, y) {
    if ((typeof _ == "string" && _ !== "") || typeof _ == "number")
      return (_ = wS("" + _, g.mode, y)), (_.return = g), _;
    if (typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case Eg:
          return (
            (y = m0(_.type, _.key, _.props, null, g.mode, y)),
            (y.ref = ah(g, null, _)),
            (y.return = g),
            y
          );
        case Cd:
          return (_ = ES(_, g.mode, y)), (_.return = g), _;
        case ml:
          var w = _._init;
          return d(g, w(_._payload), y);
      }
      if (Oh(_) || th(_))
        return (_ = Xc(_, g.mode, y, null)), (_.return = g), _;
      Fg(g, _);
    }
    return null;
  }
  function p(g, _, y, w) {
    var A = _ !== null ? _.key : null;
    if ((typeof y == "string" && y !== "") || typeof y == "number")
      return A !== null ? null : s(g, _, "" + y, w);
    if (typeof y == "object" && y !== null) {
      switch (y.$$typeof) {
        case Eg:
          return y.key === A ? l(g, _, y, w) : null;
        case Cd:
          return y.key === A ? c(g, _, y, w) : null;
        case ml:
          return (A = y._init), p(g, _, A(y._payload), w);
      }
      if (Oh(y) || th(y)) return A !== null ? null : u(g, _, y, w, null);
      Fg(g, y);
    }
    return null;
  }
  function m(g, _, y, w, A) {
    if ((typeof w == "string" && w !== "") || typeof w == "number")
      return (g = g.get(y) || null), s(_, g, "" + w, A);
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case Eg:
          return (g = g.get(w.key === null ? y : w.key) || null), l(_, g, w, A);
        case Cd:
          return (g = g.get(w.key === null ? y : w.key) || null), c(_, g, w, A);
        case ml:
          var M = w._init;
          return m(g, _, y, M(w._payload), A);
      }
      if (Oh(w) || th(w)) return (g = g.get(y) || null), u(_, g, w, A, null);
      Fg(_, w);
    }
    return null;
  }
  function v(g, _, y, w) {
    for (
      var A = null, M = null, T = _, I = (_ = 0), R = null;
      T !== null && I < y.length;
      I++
    ) {
      T.index > I ? ((R = T), (T = null)) : (R = T.sibling);
      var P = p(g, T, y[I], w);
      if (P === null) {
        T === null && (T = R);
        break;
      }
      t && T && P.alternate === null && e(g, T),
        (_ = o(P, _, I)),
        M === null ? (A = P) : (M.sibling = P),
        (M = P),
        (T = R);
    }
    if (I === y.length) return n(g, T), Wn && Mc(g, I), A;
    if (T === null) {
      for (; I < y.length; I++)
        (T = d(g, y[I], w)),
          T !== null &&
            ((_ = o(T, _, I)), M === null ? (A = T) : (M.sibling = T), (M = T));
      return Wn && Mc(g, I), A;
    }
    for (T = r(g, T); I < y.length; I++)
      (R = m(T, g, I, y[I], w)),
        R !== null &&
          (t && R.alternate !== null && T.delete(R.key === null ? I : R.key),
          (_ = o(R, _, I)),
          M === null ? (A = R) : (M.sibling = R),
          (M = R));
    return (
      t &&
        T.forEach(function (F) {
          return e(g, F);
        }),
      Wn && Mc(g, I),
      A
    );
  }
  function S(g, _, y, w) {
    var A = th(y);
    if (typeof A != "function") throw Error(rt(150));
    if (((y = A.call(y)), y == null)) throw Error(rt(151));
    for (
      var M = (A = null), T = _, I = (_ = 0), R = null, P = y.next();
      T !== null && !P.done;
      I++, P = y.next()
    ) {
      T.index > I ? ((R = T), (T = null)) : (R = T.sibling);
      var F = p(g, T, P.value, w);
      if (F === null) {
        T === null && (T = R);
        break;
      }
      t && T && F.alternate === null && e(g, T),
        (_ = o(F, _, I)),
        M === null ? (A = F) : (M.sibling = F),
        (M = F),
        (T = R);
    }
    if (P.done) return n(g, T), Wn && Mc(g, I), A;
    if (T === null) {
      for (; !P.done; I++, P = y.next())
        (P = d(g, P.value, w)),
          P !== null &&
            ((_ = o(P, _, I)), M === null ? (A = P) : (M.sibling = P), (M = P));
      return Wn && Mc(g, I), A;
    }
    for (T = r(g, T); !P.done; I++, P = y.next())
      (P = m(T, g, I, P.value, w)),
        P !== null &&
          (t && P.alternate !== null && T.delete(P.key === null ? I : P.key),
          (_ = o(P, _, I)),
          M === null ? (A = P) : (M.sibling = P),
          (M = P));
    return (
      t &&
        T.forEach(function (D) {
          return e(g, D);
        }),
      Wn && Mc(g, I),
      A
    );
  }
  function x(g, _, y, w) {
    if (
      (typeof y == "object" &&
        y !== null &&
        y.type === Td &&
        y.key === null &&
        (y = y.props.children),
      typeof y == "object" && y !== null)
    ) {
      switch (y.$$typeof) {
        case Eg:
          e: {
            for (var A = y.key, M = _; M !== null; ) {
              if (M.key === A) {
                if (((A = y.type), A === Td)) {
                  if (M.tag === 7) {
                    n(g, M.sibling),
                      (_ = i(M, y.props.children)),
                      (_.return = g),
                      (g = _);
                    break e;
                  }
                } else if (
                  M.elementType === A ||
                  (typeof A == "object" &&
                    A !== null &&
                    A.$$typeof === ml &&
                    WA(A) === M.type)
                ) {
                  n(g, M.sibling),
                    (_ = i(M, y.props)),
                    (_.ref = ah(g, M, y)),
                    (_.return = g),
                    (g = _);
                  break e;
                }
                n(g, M);
                break;
              } else e(g, M);
              M = M.sibling;
            }
            y.type === Td
              ? ((_ = Xc(y.props.children, g.mode, w, y.key)),
                (_.return = g),
                (g = _))
              : ((w = m0(y.type, y.key, y.props, null, g.mode, w)),
                (w.ref = ah(g, _, y)),
                (w.return = g),
                (g = w));
          }
          return a(g);
        case Cd:
          e: {
            for (M = y.key; _ !== null; ) {
              if (_.key === M)
                if (
                  _.tag === 4 &&
                  _.stateNode.containerInfo === y.containerInfo &&
                  _.stateNode.implementation === y.implementation
                ) {
                  n(g, _.sibling),
                    (_ = i(_, y.children || [])),
                    (_.return = g),
                    (g = _);
                  break e;
                } else {
                  n(g, _);
                  break;
                }
              else e(g, _);
              _ = _.sibling;
            }
            (_ = ES(y, g.mode, w)), (_.return = g), (g = _);
          }
          return a(g);
        case ml:
          return (M = y._init), x(g, _, M(y._payload), w);
      }
      if (Oh(y)) return v(g, _, y, w);
      if (th(y)) return S(g, _, y, w);
      Fg(g, y);
    }
    return (typeof y == "string" && y !== "") || typeof y == "number"
      ? ((y = "" + y),
        _ !== null && _.tag === 6
          ? (n(g, _.sibling), (_ = i(_, y)), (_.return = g), (g = _))
          : (n(g, _), (_ = wS(y, g.mode, w)), (_.return = g), (g = _)),
        a(g))
      : n(g, _);
  }
  return x;
}
var sf = WO(!0),
  XO = WO(!1),
  cm = {},
  Qa = ql(cm),
  xp = ql(cm),
  Sp = ql(cm);
function Uc(t) {
  if (t === cm) throw Error(rt(174));
  return t;
}
function EM(t, e) {
  switch ((kn(Sp, e), kn(xp, t), kn(Qa, cm), (t = e.nodeType), t)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : pb(null, "");
      break;
    default:
      (t = t === 8 ? e.parentNode : e),
        (e = t.namespaceURI || null),
        (t = t.tagName),
        (e = pb(e, t));
  }
  Vn(Qa), kn(Qa, e);
}
function lf() {
  Vn(Qa), Vn(xp), Vn(Sp);
}
function qO(t) {
  Uc(Sp.current);
  var e = Uc(Qa.current),
    n = pb(e, t.type);
  e !== n && (kn(xp, t), kn(Qa, n));
}
function MM(t) {
  xp.current === t && (Vn(Qa), Vn(xp));
}
var Kn = ql(0);
function J0(t) {
  for (var e = t; e !== null; ) {
    if (e.tag === 13) {
      var n = e.memoizedState;
      if (
        n !== null &&
        ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === t) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === t) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var vS = [];
function CM() {
  for (var t = 0; t < vS.length; t++)
    vS[t]._workInProgressVersionPrimary = null;
  vS.length = 0;
}
var u0 = Xs.ReactCurrentDispatcher,
  yS = Xs.ReactCurrentBatchConfig,
  au = 0,
  er = null,
  Cr = null,
  Br = null,
  ey = !1,
  Gh = !1,
  _p = 0,
  u6 = 0;
function ai() {
  throw Error(rt(321));
}
function TM(t, e) {
  if (e === null) return !1;
  for (var n = 0; n < e.length && n < t.length; n++)
    if (!Ra(t[n], e[n])) return !1;
  return !0;
}
function AM(t, e, n, r, i, o) {
  if (
    ((au = o),
    (er = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (u0.current = t === null || t.memoizedState === null ? p6 : m6),
    (t = n(r, i)),
    Gh)
  ) {
    o = 0;
    do {
      if (((Gh = !1), (_p = 0), 25 <= o)) throw Error(rt(301));
      (o += 1),
        (Br = Cr = null),
        (e.updateQueue = null),
        (u0.current = g6),
        (t = n(r, i));
    } while (Gh);
  }
  if (
    ((u0.current = ty),
    (e = Cr !== null && Cr.next !== null),
    (au = 0),
    (Br = Cr = er = null),
    (ey = !1),
    e)
  )
    throw Error(rt(300));
  return t;
}
function RM() {
  var t = _p !== 0;
  return (_p = 0), t;
}
function Xa() {
  var t = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return Br === null ? (er.memoizedState = Br = t) : (Br = Br.next = t), Br;
}
function ra() {
  if (Cr === null) {
    var t = er.alternate;
    t = t !== null ? t.memoizedState : null;
  } else t = Cr.next;
  var e = Br === null ? er.memoizedState : Br.next;
  if (e !== null) (Br = e), (Cr = t);
  else {
    if (t === null) throw Error(rt(310));
    (Cr = t),
      (t = {
        memoizedState: Cr.memoizedState,
        baseState: Cr.baseState,
        baseQueue: Cr.baseQueue,
        queue: Cr.queue,
        next: null,
      }),
      Br === null ? (er.memoizedState = Br = t) : (Br = Br.next = t);
  }
  return Br;
}
function bp(t, e) {
  return typeof e == "function" ? e(t) : e;
}
function xS(t) {
  var e = ra(),
    n = e.queue;
  if (n === null) throw Error(rt(311));
  n.lastRenderedReducer = t;
  var r = Cr,
    i = r.baseQueue,
    o = n.pending;
  if (o !== null) {
    if (i !== null) {
      var a = i.next;
      (i.next = o.next), (o.next = a);
    }
    (r.baseQueue = i = o), (n.pending = null);
  }
  if (i !== null) {
    (o = i.next), (r = r.baseState);
    var s = (a = null),
      l = null,
      c = o;
    do {
      var u = c.lane;
      if ((au & u) === u)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null,
            }),
          (r = c.hasEagerState ? c.eagerState : t(r, c.action));
      else {
        var d = {
          lane: u,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null,
        };
        l === null ? ((s = l = d), (a = r)) : (l = l.next = d),
          (er.lanes |= u),
          (su |= u);
      }
      c = c.next;
    } while (c !== null && c !== o);
    l === null ? (a = r) : (l.next = s),
      Ra(r, e.memoizedState) || (Yi = !0),
      (e.memoizedState = r),
      (e.baseState = a),
      (e.baseQueue = l),
      (n.lastRenderedState = r);
  }
  if (((t = n.interleaved), t !== null)) {
    i = t;
    do (o = i.lane), (er.lanes |= o), (su |= o), (i = i.next);
    while (i !== t);
  } else i === null && (n.lanes = 0);
  return [e.memoizedState, n.dispatch];
}
function SS(t) {
  var e = ra(),
    n = e.queue;
  if (n === null) throw Error(rt(311));
  n.lastRenderedReducer = t;
  var r = n.dispatch,
    i = n.pending,
    o = e.memoizedState;
  if (i !== null) {
    n.pending = null;
    var a = (i = i.next);
    do (o = t(o, a.action)), (a = a.next);
    while (a !== i);
    Ra(o, e.memoizedState) || (Yi = !0),
      (e.memoizedState = o),
      e.baseQueue === null && (e.baseState = o),
      (n.lastRenderedState = o);
  }
  return [o, r];
}
function KO() {}
function YO(t, e) {
  var n = er,
    r = ra(),
    i = e(),
    o = !Ra(r.memoizedState, i);
  if (
    (o && ((r.memoizedState = i), (Yi = !0)),
    (r = r.queue),
    PM(JO.bind(null, n, r, t), [t]),
    r.getSnapshot !== e || o || (Br !== null && Br.memoizedState.tag & 1))
  ) {
    if (
      ((n.flags |= 2048),
      wp(9, QO.bind(null, n, r, i, e), void 0, null),
      jr === null)
    )
      throw Error(rt(349));
    au & 30 || ZO(n, e, i);
  }
  return i;
}
function ZO(t, e, n) {
  (t.flags |= 16384),
    (t = { getSnapshot: e, value: n }),
    (e = er.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (er.updateQueue = e),
        (e.stores = [t]))
      : ((n = e.stores), n === null ? (e.stores = [t]) : n.push(t));
}
function QO(t, e, n, r) {
  (e.value = n), (e.getSnapshot = r), eN(e) && tN(t);
}
function JO(t, e, n) {
  return n(function () {
    eN(e) && tN(t);
  });
}
function eN(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var n = e();
    return !Ra(t, n);
  } catch {
    return !0;
  }
}
function tN(t) {
  var e = Bs(t, 1);
  e !== null && Ca(e, t, 1, -1);
}
function XA(t) {
  var e = Xa();
  return (
    typeof t == "function" && (t = t()),
    (e.memoizedState = e.baseState = t),
    (t = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: bp,
      lastRenderedState: t,
    }),
    (e.queue = t),
    (t = t.dispatch = h6.bind(null, er, t)),
    [e.memoizedState, t]
  );
}
function wp(t, e, n, r) {
  return (
    (t = { tag: t, create: e, destroy: n, deps: r, next: null }),
    (e = er.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (er.updateQueue = e),
        (e.lastEffect = t.next = t))
      : ((n = e.lastEffect),
        n === null
          ? (e.lastEffect = t.next = t)
          : ((r = n.next), (n.next = t), (t.next = r), (e.lastEffect = t))),
    t
  );
}
function nN() {
  return ra().memoizedState;
}
function d0(t, e, n, r) {
  var i = Xa();
  (er.flags |= t),
    (i.memoizedState = wp(1 | e, n, void 0, r === void 0 ? null : r));
}
function Vy(t, e, n, r) {
  var i = ra();
  r = r === void 0 ? null : r;
  var o = void 0;
  if (Cr !== null) {
    var a = Cr.memoizedState;
    if (((o = a.destroy), r !== null && TM(r, a.deps))) {
      i.memoizedState = wp(e, n, o, r);
      return;
    }
  }
  (er.flags |= t), (i.memoizedState = wp(1 | e, n, o, r));
}
function qA(t, e) {
  return d0(8390656, 8, t, e);
}
function PM(t, e) {
  return Vy(2048, 8, t, e);
}
function rN(t, e) {
  return Vy(4, 2, t, e);
}
function iN(t, e) {
  return Vy(4, 4, t, e);
}
function oN(t, e) {
  if (typeof e == "function")
    return (
      (t = t()),
      e(t),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (t = t()),
      (e.current = t),
      function () {
        e.current = null;
      }
    );
}
function aN(t, e, n) {
  return (
    (n = n != null ? n.concat([t]) : null), Vy(4, 4, oN.bind(null, e, t), n)
  );
}
function IM() {}
function sN(t, e) {
  var n = ra();
  e = e === void 0 ? null : e;
  var r = n.memoizedState;
  return r !== null && e !== null && TM(e, r[1])
    ? r[0]
    : ((n.memoizedState = [t, e]), t);
}
function lN(t, e) {
  var n = ra();
  e = e === void 0 ? null : e;
  var r = n.memoizedState;
  return r !== null && e !== null && TM(e, r[1])
    ? r[0]
    : ((t = t()), (n.memoizedState = [t, e]), t);
}
function cN(t, e, n) {
  return au & 21
    ? (Ra(n, e) || ((n = fO()), (er.lanes |= n), (su |= n), (t.baseState = !0)),
      e)
    : (t.baseState && ((t.baseState = !1), (Yi = !0)), (t.memoizedState = n));
}
function d6(t, e) {
  var n = Cn;
  (Cn = n !== 0 && 4 > n ? n : 4), t(!0);
  var r = yS.transition;
  yS.transition = {};
  try {
    t(!1), e();
  } finally {
    (Cn = n), (yS.transition = r);
  }
}
function uN() {
  return ra().memoizedState;
}
function f6(t, e, n) {
  var r = Ll(t);
  if (
    ((n = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    dN(t))
  )
    fN(e, n);
  else if (((n = jO(t, e, n, r)), n !== null)) {
    var i = Li();
    Ca(n, t, r, i), hN(n, e, r);
  }
}
function h6(t, e, n) {
  var r = Ll(t),
    i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null };
  if (dN(t)) fN(e, i);
  else {
    var o = t.alternate;
    if (
      t.lanes === 0 &&
      (o === null || o.lanes === 0) &&
      ((o = e.lastRenderedReducer), o !== null)
    )
      try {
        var a = e.lastRenderedState,
          s = o(a, n);
        if (((i.hasEagerState = !0), (i.eagerState = s), Ra(s, a))) {
          var l = e.interleaved;
          l === null
            ? ((i.next = i), bM(e))
            : ((i.next = l.next), (l.next = i)),
            (e.interleaved = i);
          return;
        }
      } catch {
      } finally {
      }
    (n = jO(t, e, i, r)),
      n !== null && ((i = Li()), Ca(n, t, r, i), hN(n, e, r));
  }
}
function dN(t) {
  var e = t.alternate;
  return t === er || (e !== null && e === er);
}
function fN(t, e) {
  Gh = ey = !0;
  var n = t.pending;
  n === null ? (e.next = e) : ((e.next = n.next), (n.next = e)),
    (t.pending = e);
}
function hN(t, e, n) {
  if (n & 4194240) {
    var r = e.lanes;
    (r &= t.pendingLanes), (n |= r), (e.lanes = n), lM(t, n);
  }
}
var ty = {
    readContext: na,
    useCallback: ai,
    useContext: ai,
    useEffect: ai,
    useImperativeHandle: ai,
    useInsertionEffect: ai,
    useLayoutEffect: ai,
    useMemo: ai,
    useReducer: ai,
    useRef: ai,
    useState: ai,
    useDebugValue: ai,
    useDeferredValue: ai,
    useTransition: ai,
    useMutableSource: ai,
    useSyncExternalStore: ai,
    useId: ai,
    unstable_isNewReconciler: !1,
  },
  p6 = {
    readContext: na,
    useCallback: function (t, e) {
      return (Xa().memoizedState = [t, e === void 0 ? null : e]), t;
    },
    useContext: na,
    useEffect: qA,
    useImperativeHandle: function (t, e, n) {
      return (
        (n = n != null ? n.concat([t]) : null),
        d0(4194308, 4, oN.bind(null, e, t), n)
      );
    },
    useLayoutEffect: function (t, e) {
      return d0(4194308, 4, t, e);
    },
    useInsertionEffect: function (t, e) {
      return d0(4, 2, t, e);
    },
    useMemo: function (t, e) {
      var n = Xa();
      return (
        (e = e === void 0 ? null : e), (t = t()), (n.memoizedState = [t, e]), t
      );
    },
    useReducer: function (t, e, n) {
      var r = Xa();
      return (
        (e = n !== void 0 ? n(e) : e),
        (r.memoizedState = r.baseState = e),
        (t = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: t,
          lastRenderedState: e,
        }),
        (r.queue = t),
        (t = t.dispatch = f6.bind(null, er, t)),
        [r.memoizedState, t]
      );
    },
    useRef: function (t) {
      var e = Xa();
      return (t = { current: t }), (e.memoizedState = t);
    },
    useState: XA,
    useDebugValue: IM,
    useDeferredValue: function (t) {
      return (Xa().memoizedState = t);
    },
    useTransition: function () {
      var t = XA(!1),
        e = t[0];
      return (t = d6.bind(null, t[1])), (Xa().memoizedState = t), [e, t];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (t, e, n) {
      var r = er,
        i = Xa();
      if (Wn) {
        if (n === void 0) throw Error(rt(407));
        n = n();
      } else {
        if (((n = e()), jr === null)) throw Error(rt(349));
        au & 30 || ZO(r, e, n);
      }
      i.memoizedState = n;
      var o = { value: n, getSnapshot: e };
      return (
        (i.queue = o),
        qA(JO.bind(null, r, o, t), [t]),
        (r.flags |= 2048),
        wp(9, QO.bind(null, r, o, n, e), void 0, null),
        n
      );
    },
    useId: function () {
      var t = Xa(),
        e = jr.identifierPrefix;
      if (Wn) {
        var n = Is,
          r = Ps;
        (n = (r & ~(1 << (32 - Ma(r) - 1))).toString(32) + n),
          (e = ":" + e + "R" + n),
          (n = _p++),
          0 < n && (e += "H" + n.toString(32)),
          (e += ":");
      } else (n = u6++), (e = ":" + e + "r" + n.toString(32) + ":");
      return (t.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  m6 = {
    readContext: na,
    useCallback: sN,
    useContext: na,
    useEffect: PM,
    useImperativeHandle: aN,
    useInsertionEffect: rN,
    useLayoutEffect: iN,
    useMemo: lN,
    useReducer: xS,
    useRef: nN,
    useState: function () {
      return xS(bp);
    },
    useDebugValue: IM,
    useDeferredValue: function (t) {
      var e = ra();
      return cN(e, Cr.memoizedState, t);
    },
    useTransition: function () {
      var t = xS(bp)[0],
        e = ra().memoizedState;
      return [t, e];
    },
    useMutableSource: KO,
    useSyncExternalStore: YO,
    useId: uN,
    unstable_isNewReconciler: !1,
  },
  g6 = {
    readContext: na,
    useCallback: sN,
    useContext: na,
    useEffect: PM,
    useImperativeHandle: aN,
    useInsertionEffect: rN,
    useLayoutEffect: iN,
    useMemo: lN,
    useReducer: SS,
    useRef: nN,
    useState: function () {
      return SS(bp);
    },
    useDebugValue: IM,
    useDeferredValue: function (t) {
      var e = ra();
      return Cr === null ? (e.memoizedState = t) : cN(e, Cr.memoizedState, t);
    },
    useTransition: function () {
      var t = SS(bp)[0],
        e = ra().memoizedState;
      return [t, e];
    },
    useMutableSource: KO,
    useSyncExternalStore: YO,
    useId: uN,
    unstable_isNewReconciler: !1,
  };
function cf(t, e) {
  try {
    var n = "",
      r = e;
    do (n += $5(r)), (r = r.return);
    while (r);
    var i = n;
  } catch (o) {
    i =
      `
Error generating stack: ` +
      o.message +
      `
` +
      o.stack;
  }
  return { value: t, source: e, stack: i, digest: null };
}
function _S(t, e, n) {
  return { value: t, source: null, stack: n ?? null, digest: e ?? null };
}
function zb(t, e) {
  try {
    console.error(e.value);
  } catch (n) {
    setTimeout(function () {
      throw n;
    });
  }
}
var v6 = typeof WeakMap == "function" ? WeakMap : Map;
function pN(t, e, n) {
  (n = Ns(-1, n)), (n.tag = 3), (n.payload = { element: null });
  var r = e.value;
  return (
    (n.callback = function () {
      ry || ((ry = !0), (Xb = r)), zb(t, e);
    }),
    n
  );
}
function mN(t, e, n) {
  (n = Ns(-1, n)), (n.tag = 3);
  var r = t.type.getDerivedStateFromError;
  if (typeof r == "function") {
    var i = e.value;
    (n.payload = function () {
      return r(i);
    }),
      (n.callback = function () {
        zb(t, e);
      });
  }
  var o = t.stateNode;
  return (
    o !== null &&
      typeof o.componentDidCatch == "function" &&
      (n.callback = function () {
        zb(t, e),
          typeof r != "function" &&
            (Il === null ? (Il = new Set([this])) : Il.add(this));
        var a = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: a !== null ? a : "",
        });
      }),
    n
  );
}
function KA(t, e, n) {
  var r = t.pingCache;
  if (r === null) {
    r = t.pingCache = new v6();
    var i = new Set();
    r.set(e, i);
  } else (i = r.get(e)), i === void 0 && ((i = new Set()), r.set(e, i));
  i.has(n) || (i.add(n), (t = I6.bind(null, t, e, n)), e.then(t, t));
}
function YA(t) {
  do {
    var e;
    if (
      ((e = t.tag === 13) &&
        ((e = t.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return t;
    t = t.return;
  } while (t !== null);
  return null;
}
function ZA(t, e, n, r, i) {
  return t.mode & 1
    ? ((t.flags |= 65536), (t.lanes = i), t)
    : (t === e
        ? (t.flags |= 65536)
        : ((t.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null
              ? (n.tag = 17)
              : ((e = Ns(-1, 1)), (e.tag = 2), Pl(n, e, 1))),
          (n.lanes |= 1)),
      t);
}
var y6 = Xs.ReactCurrentOwner,
  Yi = !1;
function Ri(t, e, n, r) {
  e.child = t === null ? XO(e, null, n, r) : sf(e, t.child, n, r);
}
function QA(t, e, n, r, i) {
  n = n.render;
  var o = e.ref;
  return (
    Zd(e, i),
    (r = AM(t, e, n, r, o, i)),
    (n = RM()),
    t !== null && !Yi
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~i),
        Hs(t, e, i))
      : (Wn && n && gM(e), (e.flags |= 1), Ri(t, e, r, i), e.child)
  );
}
function JA(t, e, n, r, i) {
  if (t === null) {
    var o = n.type;
    return typeof o == "function" &&
      !kM(o) &&
      o.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((e.tag = 15), (e.type = o), gN(t, e, o, r, i))
      : ((t = m0(n.type, null, r, e, e.mode, i)),
        (t.ref = e.ref),
        (t.return = e),
        (e.child = t));
  }
  if (((o = t.child), !(t.lanes & i))) {
    var a = o.memoizedProps;
    if (
      ((n = n.compare), (n = n !== null ? n : mp), n(a, r) && t.ref === e.ref)
    )
      return Hs(t, e, i);
  }
  return (
    (e.flags |= 1),
    (t = Ol(o, r)),
    (t.ref = e.ref),
    (t.return = e),
    (e.child = t)
  );
}
function gN(t, e, n, r, i) {
  if (t !== null) {
    var o = t.memoizedProps;
    if (mp(o, r) && t.ref === e.ref)
      if (((Yi = !1), (e.pendingProps = r = o), (t.lanes & i) !== 0))
        t.flags & 131072 && (Yi = !0);
      else return (e.lanes = t.lanes), Hs(t, e, i);
  }
  return Ub(t, e, n, r, i);
}
function vN(t, e, n) {
  var r = e.pendingProps,
    i = r.children,
    o = t !== null ? t.memoizedState : null;
  if (r.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        kn(zd, So),
        (So |= n);
    else {
      if (!(n & 1073741824))
        return (
          (t = o !== null ? o.baseLanes | n : n),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: t,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          kn(zd, So),
          (So |= t),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = o !== null ? o.baseLanes : n),
        kn(zd, So),
        (So |= r);
    }
  else
    o !== null ? ((r = o.baseLanes | n), (e.memoizedState = null)) : (r = n),
      kn(zd, So),
      (So |= r);
  return Ri(t, e, i, n), e.child;
}
function yN(t, e) {
  var n = e.ref;
  ((t === null && n !== null) || (t !== null && t.ref !== n)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function Ub(t, e, n, r, i) {
  var o = Qi(n) ? iu : gi.current;
  return (
    (o = of(e, o)),
    Zd(e, i),
    (n = AM(t, e, n, r, o, i)),
    (r = RM()),
    t !== null && !Yi
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~i),
        Hs(t, e, i))
      : (Wn && r && gM(e), (e.flags |= 1), Ri(t, e, n, i), e.child)
  );
}
function eR(t, e, n, r, i) {
  if (Qi(n)) {
    var o = !0;
    X0(e);
  } else o = !1;
  if ((Zd(e, i), e.stateNode === null))
    f0(t, e), GO(e, n, r), Db(e, n, r, i), (r = !0);
  else if (t === null) {
    var a = e.stateNode,
      s = e.memoizedProps;
    a.props = s;
    var l = a.context,
      c = n.contextType;
    typeof c == "object" && c !== null
      ? (c = na(c))
      : ((c = Qi(n) ? iu : gi.current), (c = of(e, c)));
    var u = n.getDerivedStateFromProps,
      d =
        typeof u == "function" ||
        typeof a.getSnapshotBeforeUpdate == "function";
    d ||
      (typeof a.UNSAFE_componentWillReceiveProps != "function" &&
        typeof a.componentWillReceiveProps != "function") ||
      ((s !== r || l !== c) && GA(e, a, r, c)),
      (gl = !1);
    var p = e.memoizedState;
    (a.state = p),
      Q0(e, r, a, i),
      (l = e.memoizedState),
      s !== r || p !== l || Zi.current || gl
        ? (typeof u == "function" && (Fb(e, n, u, r), (l = e.memoizedState)),
          (s = gl || $A(e, n, s, r, p, l, c))
            ? (d ||
                (typeof a.UNSAFE_componentWillMount != "function" &&
                  typeof a.componentWillMount != "function") ||
                (typeof a.componentWillMount == "function" &&
                  a.componentWillMount(),
                typeof a.UNSAFE_componentWillMount == "function" &&
                  a.UNSAFE_componentWillMount()),
              typeof a.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof a.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = r),
              (e.memoizedState = l)),
          (a.props = r),
          (a.state = l),
          (a.context = c),
          (r = s))
        : (typeof a.componentDidMount == "function" && (e.flags |= 4194308),
          (r = !1));
  } else {
    (a = e.stateNode),
      VO(t, e),
      (s = e.memoizedProps),
      (c = e.type === e.elementType ? s : pa(e.type, s)),
      (a.props = c),
      (d = e.pendingProps),
      (p = a.context),
      (l = n.contextType),
      typeof l == "object" && l !== null
        ? (l = na(l))
        : ((l = Qi(n) ? iu : gi.current), (l = of(e, l)));
    var m = n.getDerivedStateFromProps;
    (u =
      typeof m == "function" ||
      typeof a.getSnapshotBeforeUpdate == "function") ||
      (typeof a.UNSAFE_componentWillReceiveProps != "function" &&
        typeof a.componentWillReceiveProps != "function") ||
      ((s !== d || p !== l) && GA(e, a, r, l)),
      (gl = !1),
      (p = e.memoizedState),
      (a.state = p),
      Q0(e, r, a, i);
    var v = e.memoizedState;
    s !== d || p !== v || Zi.current || gl
      ? (typeof m == "function" && (Fb(e, n, m, r), (v = e.memoizedState)),
        (c = gl || $A(e, n, c, r, p, v, l) || !1)
          ? (u ||
              (typeof a.UNSAFE_componentWillUpdate != "function" &&
                typeof a.componentWillUpdate != "function") ||
              (typeof a.componentWillUpdate == "function" &&
                a.componentWillUpdate(r, v, l),
              typeof a.UNSAFE_componentWillUpdate == "function" &&
                a.UNSAFE_componentWillUpdate(r, v, l)),
            typeof a.componentDidUpdate == "function" && (e.flags |= 4),
            typeof a.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof a.componentDidUpdate != "function" ||
              (s === t.memoizedProps && p === t.memoizedState) ||
              (e.flags |= 4),
            typeof a.getSnapshotBeforeUpdate != "function" ||
              (s === t.memoizedProps && p === t.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = r),
            (e.memoizedState = v)),
        (a.props = r),
        (a.state = v),
        (a.context = l),
        (r = c))
      : (typeof a.componentDidUpdate != "function" ||
          (s === t.memoizedProps && p === t.memoizedState) ||
          (e.flags |= 4),
        typeof a.getSnapshotBeforeUpdate != "function" ||
          (s === t.memoizedProps && p === t.memoizedState) ||
          (e.flags |= 1024),
        (r = !1));
  }
  return kb(t, e, n, r, o, i);
}
function kb(t, e, n, r, i, o) {
  yN(t, e);
  var a = (e.flags & 128) !== 0;
  if (!r && !a) return i && kA(e, n, !1), Hs(t, e, o);
  (r = e.stateNode), (y6.current = e);
  var s =
    a && typeof n.getDerivedStateFromError != "function" ? null : r.render();
  return (
    (e.flags |= 1),
    t !== null && a
      ? ((e.child = sf(e, t.child, null, o)), (e.child = sf(e, null, s, o)))
      : Ri(t, e, s, o),
    (e.memoizedState = r.state),
    i && kA(e, n, !0),
    e.child
  );
}
function xN(t) {
  var e = t.stateNode;
  e.pendingContext
    ? UA(t, e.pendingContext, e.pendingContext !== e.context)
    : e.context && UA(t, e.context, !1),
    EM(t, e.containerInfo);
}
function tR(t, e, n, r, i) {
  return af(), yM(i), (e.flags |= 256), Ri(t, e, n, r), e.child;
}
var Bb = { dehydrated: null, treeContext: null, retryLane: 0 };
function Hb(t) {
  return { baseLanes: t, cachePool: null, transitions: null };
}
function SN(t, e, n) {
  var r = e.pendingProps,
    i = Kn.current,
    o = !1,
    a = (e.flags & 128) !== 0,
    s;
  if (
    ((s = a) ||
      (s = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0),
    s
      ? ((o = !0), (e.flags &= -129))
      : (t === null || t.memoizedState !== null) && (i |= 1),
    kn(Kn, i & 1),
    t === null)
  )
    return (
      Ob(e),
      (t = e.memoizedState),
      t !== null && ((t = t.dehydrated), t !== null)
        ? (e.mode & 1
            ? t.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((a = r.children),
          (t = r.fallback),
          o
            ? ((r = e.mode),
              (o = e.child),
              (a = { mode: "hidden", children: a }),
              !(r & 1) && o !== null
                ? ((o.childLanes = 0), (o.pendingProps = a))
                : (o = Wy(a, r, 0, null)),
              (t = Xc(t, r, n, null)),
              (o.return = e),
              (t.return = e),
              (o.sibling = t),
              (e.child = o),
              (e.child.memoizedState = Hb(n)),
              (e.memoizedState = Bb),
              t)
            : LM(e, a))
    );
  if (((i = t.memoizedState), i !== null && ((s = i.dehydrated), s !== null)))
    return x6(t, e, a, r, s, i, n);
  if (o) {
    (o = r.fallback), (a = e.mode), (i = t.child), (s = i.sibling);
    var l = { mode: "hidden", children: r.children };
    return (
      !(a & 1) && e.child !== i
        ? ((r = e.child),
          (r.childLanes = 0),
          (r.pendingProps = l),
          (e.deletions = null))
        : ((r = Ol(i, l)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      s !== null ? (o = Ol(s, o)) : ((o = Xc(o, a, n, null)), (o.flags |= 2)),
      (o.return = e),
      (r.return = e),
      (r.sibling = o),
      (e.child = r),
      (r = o),
      (o = e.child),
      (a = t.child.memoizedState),
      (a =
        a === null
          ? Hb(n)
          : {
              baseLanes: a.baseLanes | n,
              cachePool: null,
              transitions: a.transitions,
            }),
      (o.memoizedState = a),
      (o.childLanes = t.childLanes & ~n),
      (e.memoizedState = Bb),
      r
    );
  }
  return (
    (o = t.child),
    (t = o.sibling),
    (r = Ol(o, { mode: "visible", children: r.children })),
    !(e.mode & 1) && (r.lanes = n),
    (r.return = e),
    (r.sibling = null),
    t !== null &&
      ((n = e.deletions),
      n === null ? ((e.deletions = [t]), (e.flags |= 16)) : n.push(t)),
    (e.child = r),
    (e.memoizedState = null),
    r
  );
}
function LM(t, e) {
  return (
    (e = Wy({ mode: "visible", children: e }, t.mode, 0, null)),
    (e.return = t),
    (t.child = e)
  );
}
function Dg(t, e, n, r) {
  return (
    r !== null && yM(r),
    sf(e, t.child, null, n),
    (t = LM(e, e.pendingProps.children)),
    (t.flags |= 2),
    (e.memoizedState = null),
    t
  );
}
function x6(t, e, n, r, i, o, a) {
  if (n)
    return e.flags & 256
      ? ((e.flags &= -257), (r = _S(Error(rt(422)))), Dg(t, e, a, r))
      : e.memoizedState !== null
      ? ((e.child = t.child), (e.flags |= 128), null)
      : ((o = r.fallback),
        (i = e.mode),
        (r = Wy({ mode: "visible", children: r.children }, i, 0, null)),
        (o = Xc(o, i, a, null)),
        (o.flags |= 2),
        (r.return = e),
        (o.return = e),
        (r.sibling = o),
        (e.child = r),
        e.mode & 1 && sf(e, t.child, null, a),
        (e.child.memoizedState = Hb(a)),
        (e.memoizedState = Bb),
        o);
  if (!(e.mode & 1)) return Dg(t, e, a, null);
  if (i.data === "$!") {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var s = r.dgst;
    return (
      (r = s), (o = Error(rt(419))), (r = _S(o, r, void 0)), Dg(t, e, a, r)
    );
  }
  if (((s = (a & t.childLanes) !== 0), Yi || s)) {
    if (((r = jr), r !== null)) {
      switch (a & -a) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      (i = i & (r.suspendedLanes | a) ? 0 : i),
        i !== 0 &&
          i !== o.retryLane &&
          ((o.retryLane = i), Bs(t, i), Ca(r, t, i, -1));
    }
    return UM(), (r = _S(Error(rt(421)))), Dg(t, e, a, r);
  }
  return i.data === "$?"
    ? ((e.flags |= 128),
      (e.child = t.child),
      (e = L6.bind(null, t)),
      (i._reactRetry = e),
      null)
    : ((t = o.treeContext),
      (bo = Rl(i.nextSibling)),
      (To = e),
      (Wn = !0),
      (Sa = null),
      t !== null &&
        ((qo[Ko++] = Ps),
        (qo[Ko++] = Is),
        (qo[Ko++] = ou),
        (Ps = t.id),
        (Is = t.overflow),
        (ou = e)),
      (e = LM(e, r.children)),
      (e.flags |= 4096),
      e);
}
function nR(t, e, n) {
  t.lanes |= e;
  var r = t.alternate;
  r !== null && (r.lanes |= e), Nb(t.return, e, n);
}
function bS(t, e, n, r, i) {
  var o = t.memoizedState;
  o === null
    ? (t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i,
      })
    : ((o.isBackwards = e),
      (o.rendering = null),
      (o.renderingStartTime = 0),
      (o.last = r),
      (o.tail = n),
      (o.tailMode = i));
}
function _N(t, e, n) {
  var r = e.pendingProps,
    i = r.revealOrder,
    o = r.tail;
  if ((Ri(t, e, r.children, n), (r = Kn.current), r & 2))
    (r = (r & 1) | 2), (e.flags |= 128);
  else {
    if (t !== null && t.flags & 128)
      e: for (t = e.child; t !== null; ) {
        if (t.tag === 13) t.memoizedState !== null && nR(t, n, e);
        else if (t.tag === 19) nR(t, n, e);
        else if (t.child !== null) {
          (t.child.return = t), (t = t.child);
          continue;
        }
        if (t === e) break e;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e) break e;
          t = t.return;
        }
        (t.sibling.return = t.return), (t = t.sibling);
      }
    r &= 1;
  }
  if ((kn(Kn, r), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (i) {
      case "forwards":
        for (n = e.child, i = null; n !== null; )
          (t = n.alternate),
            t !== null && J0(t) === null && (i = n),
            (n = n.sibling);
        (n = i),
          n === null
            ? ((i = e.child), (e.child = null))
            : ((i = n.sibling), (n.sibling = null)),
          bS(e, !1, i, n, o);
        break;
      case "backwards":
        for (n = null, i = e.child, e.child = null; i !== null; ) {
          if (((t = i.alternate), t !== null && J0(t) === null)) {
            e.child = i;
            break;
          }
          (t = i.sibling), (i.sibling = n), (n = i), (i = t);
        }
        bS(e, !0, n, null, o);
        break;
      case "together":
        bS(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function f0(t, e) {
  !(e.mode & 1) &&
    t !== null &&
    ((t.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Hs(t, e, n) {
  if (
    (t !== null && (e.dependencies = t.dependencies),
    (su |= e.lanes),
    !(n & e.childLanes))
  )
    return null;
  if (t !== null && e.child !== t.child) throw Error(rt(153));
  if (e.child !== null) {
    for (
      t = e.child, n = Ol(t, t.pendingProps), e.child = n, n.return = e;
      t.sibling !== null;

    )
      (t = t.sibling), (n = n.sibling = Ol(t, t.pendingProps)), (n.return = e);
    n.sibling = null;
  }
  return e.child;
}
function S6(t, e, n) {
  switch (e.tag) {
    case 3:
      xN(e), af();
      break;
    case 5:
      qO(e);
      break;
    case 1:
      Qi(e.type) && X0(e);
      break;
    case 4:
      EM(e, e.stateNode.containerInfo);
      break;
    case 10:
      var r = e.type._context,
        i = e.memoizedProps.value;
      kn(Y0, r._currentValue), (r._currentValue = i);
      break;
    case 13:
      if (((r = e.memoizedState), r !== null))
        return r.dehydrated !== null
          ? (kn(Kn, Kn.current & 1), (e.flags |= 128), null)
          : n & e.child.childLanes
          ? SN(t, e, n)
          : (kn(Kn, Kn.current & 1),
            (t = Hs(t, e, n)),
            t !== null ? t.sibling : null);
      kn(Kn, Kn.current & 1);
      break;
    case 19:
      if (((r = (n & e.childLanes) !== 0), t.flags & 128)) {
        if (r) return _N(t, e, n);
        e.flags |= 128;
      }
      if (
        ((i = e.memoizedState),
        i !== null &&
          ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        kn(Kn, Kn.current),
        r)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), vN(t, e, n);
  }
  return Hs(t, e, n);
}
var bN, jb, wN, EN;
bN = function (t, e) {
  for (var n = e.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      (n.child.return = n), (n = n.child);
      continue;
    }
    if (n === e) break;
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === e) return;
      n = n.return;
    }
    (n.sibling.return = n.return), (n = n.sibling);
  }
};
jb = function () {};
wN = function (t, e, n, r) {
  var i = t.memoizedProps;
  if (i !== r) {
    (t = e.stateNode), Uc(Qa.current);
    var o = null;
    switch (n) {
      case "input":
        (i = ub(t, i)), (r = ub(t, r)), (o = []);
        break;
      case "select":
        (i = tr({}, i, { value: void 0 })),
          (r = tr({}, r, { value: void 0 })),
          (o = []);
        break;
      case "textarea":
        (i = hb(t, i)), (r = hb(t, r)), (o = []);
        break;
      default:
        typeof i.onClick != "function" &&
          typeof r.onClick == "function" &&
          (t.onclick = G0);
    }
    mb(n, r);
    var a;
    n = null;
    for (c in i)
      if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
        if (c === "style") {
          var s = i[c];
          for (a in s) s.hasOwnProperty(a) && (n || (n = {}), (n[a] = ""));
        } else
          c !== "dangerouslySetInnerHTML" &&
            c !== "children" &&
            c !== "suppressContentEditableWarning" &&
            c !== "suppressHydrationWarning" &&
            c !== "autoFocus" &&
            (lp.hasOwnProperty(c)
              ? o || (o = [])
              : (o = o || []).push(c, null));
    for (c in r) {
      var l = r[c];
      if (
        ((s = i != null ? i[c] : void 0),
        r.hasOwnProperty(c) && l !== s && (l != null || s != null))
      )
        if (c === "style")
          if (s) {
            for (a in s)
              !s.hasOwnProperty(a) ||
                (l && l.hasOwnProperty(a)) ||
                (n || (n = {}), (n[a] = ""));
            for (a in l)
              l.hasOwnProperty(a) &&
                s[a] !== l[a] &&
                (n || (n = {}), (n[a] = l[a]));
          } else n || (o || (o = []), o.push(c, n)), (n = l);
        else
          c === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (s = s ? s.__html : void 0),
              l != null && s !== l && (o = o || []).push(c, l))
            : c === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (o = o || []).push(c, "" + l)
            : c !== "suppressContentEditableWarning" &&
              c !== "suppressHydrationWarning" &&
              (lp.hasOwnProperty(c)
                ? (l != null && c === "onScroll" && Hn("scroll", t),
                  o || s === l || (o = []))
                : (o = o || []).push(c, l));
    }
    n && (o = o || []).push("style", n);
    var c = o;
    (e.updateQueue = c) && (e.flags |= 4);
  }
};
EN = function (t, e, n, r) {
  n !== r && (e.flags |= 4);
};
function sh(t, e) {
  if (!Wn)
    switch (t.tailMode) {
      case "hidden":
        e = t.tail;
        for (var n = null; e !== null; )
          e.alternate !== null && (n = e), (e = e.sibling);
        n === null ? (t.tail = null) : (n.sibling = null);
        break;
      case "collapsed":
        n = t.tail;
        for (var r = null; n !== null; )
          n.alternate !== null && (r = n), (n = n.sibling);
        r === null
          ? e || t.tail === null
            ? (t.tail = null)
            : (t.tail.sibling = null)
          : (r.sibling = null);
    }
}
function si(t) {
  var e = t.alternate !== null && t.alternate.child === t.child,
    n = 0,
    r = 0;
  if (e)
    for (var i = t.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = t),
        (i = i.sibling);
  else
    for (i = t.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = t),
        (i = i.sibling);
  return (t.subtreeFlags |= r), (t.childLanes = n), e;
}
function _6(t, e, n) {
  var r = e.pendingProps;
  switch ((vM(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return si(e), null;
    case 1:
      return Qi(e.type) && W0(), si(e), null;
    case 3:
      return (
        (r = e.stateNode),
        lf(),
        Vn(Zi),
        Vn(gi),
        CM(),
        r.pendingContext &&
          ((r.context = r.pendingContext), (r.pendingContext = null)),
        (t === null || t.child === null) &&
          (Ng(e)
            ? (e.flags |= 4)
            : t === null ||
              (t.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), Sa !== null && (Yb(Sa), (Sa = null)))),
        jb(t, e),
        si(e),
        null
      );
    case 5:
      MM(e);
      var i = Uc(Sp.current);
      if (((n = e.type), t !== null && e.stateNode != null))
        wN(t, e, n, r, i),
          t.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!r) {
          if (e.stateNode === null) throw Error(rt(166));
          return si(e), null;
        }
        if (((t = Uc(Qa.current)), Ng(e))) {
          (r = e.stateNode), (n = e.type);
          var o = e.memoizedProps;
          switch (((r[qa] = e), (r[yp] = o), (t = (e.mode & 1) !== 0), n)) {
            case "dialog":
              Hn("cancel", r), Hn("close", r);
              break;
            case "iframe":
            case "object":
            case "embed":
              Hn("load", r);
              break;
            case "video":
            case "audio":
              for (i = 0; i < Fh.length; i++) Hn(Fh[i], r);
              break;
            case "source":
              Hn("error", r);
              break;
            case "img":
            case "image":
            case "link":
              Hn("error", r), Hn("load", r);
              break;
            case "details":
              Hn("toggle", r);
              break;
            case "input":
              dA(r, o), Hn("invalid", r);
              break;
            case "select":
              (r._wrapperState = { wasMultiple: !!o.multiple }),
                Hn("invalid", r);
              break;
            case "textarea":
              hA(r, o), Hn("invalid", r);
          }
          mb(n, o), (i = null);
          for (var a in o)
            if (o.hasOwnProperty(a)) {
              var s = o[a];
              a === "children"
                ? typeof s == "string"
                  ? r.textContent !== s &&
                    (o.suppressHydrationWarning !== !0 &&
                      Og(r.textContent, s, t),
                    (i = ["children", s]))
                  : typeof s == "number" &&
                    r.textContent !== "" + s &&
                    (o.suppressHydrationWarning !== !0 &&
                      Og(r.textContent, s, t),
                    (i = ["children", "" + s]))
                : lp.hasOwnProperty(a) &&
                  s != null &&
                  a === "onScroll" &&
                  Hn("scroll", r);
            }
          switch (n) {
            case "input":
              Mg(r), fA(r, o, !0);
              break;
            case "textarea":
              Mg(r), pA(r);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof o.onClick == "function" && (r.onclick = G0);
          }
          (r = i), (e.updateQueue = r), r !== null && (e.flags |= 4);
        } else {
          (a = i.nodeType === 9 ? i : i.ownerDocument),
            t === "http://www.w3.org/1999/xhtml" && (t = ZL(n)),
            t === "http://www.w3.org/1999/xhtml"
              ? n === "script"
                ? ((t = a.createElement("div")),
                  (t.innerHTML = "<script></script>"),
                  (t = t.removeChild(t.firstChild)))
                : typeof r.is == "string"
                ? (t = a.createElement(n, { is: r.is }))
                : ((t = a.createElement(n)),
                  n === "select" &&
                    ((a = t),
                    r.multiple
                      ? (a.multiple = !0)
                      : r.size && (a.size = r.size)))
              : (t = a.createElementNS(t, n)),
            (t[qa] = e),
            (t[yp] = r),
            bN(t, e, !1, !1),
            (e.stateNode = t);
          e: {
            switch (((a = gb(n, r)), n)) {
              case "dialog":
                Hn("cancel", t), Hn("close", t), (i = r);
                break;
              case "iframe":
              case "object":
              case "embed":
                Hn("load", t), (i = r);
                break;
              case "video":
              case "audio":
                for (i = 0; i < Fh.length; i++) Hn(Fh[i], t);
                i = r;
                break;
              case "source":
                Hn("error", t), (i = r);
                break;
              case "img":
              case "image":
              case "link":
                Hn("error", t), Hn("load", t), (i = r);
                break;
              case "details":
                Hn("toggle", t), (i = r);
                break;
              case "input":
                dA(t, r), (i = ub(t, r)), Hn("invalid", t);
                break;
              case "option":
                i = r;
                break;
              case "select":
                (t._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = tr({}, r, { value: void 0 })),
                  Hn("invalid", t);
                break;
              case "textarea":
                hA(t, r), (i = hb(t, r)), Hn("invalid", t);
                break;
              default:
                i = r;
            }
            mb(n, i), (s = i);
            for (o in s)
              if (s.hasOwnProperty(o)) {
                var l = s[o];
                o === "style"
                  ? eO(t, l)
                  : o === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && QL(t, l))
                  : o === "children"
                  ? typeof l == "string"
                    ? (n !== "textarea" || l !== "") && cp(t, l)
                    : typeof l == "number" && cp(t, "" + l)
                  : o !== "suppressContentEditableWarning" &&
                    o !== "suppressHydrationWarning" &&
                    o !== "autoFocus" &&
                    (lp.hasOwnProperty(o)
                      ? l != null && o === "onScroll" && Hn("scroll", t)
                      : l != null && nM(t, o, l, a));
              }
            switch (n) {
              case "input":
                Mg(t), fA(t, r, !1);
                break;
              case "textarea":
                Mg(t), pA(t);
                break;
              case "option":
                r.value != null && t.setAttribute("value", "" + Ul(r.value));
                break;
              case "select":
                (t.multiple = !!r.multiple),
                  (o = r.value),
                  o != null
                    ? Xd(t, !!r.multiple, o, !1)
                    : r.defaultValue != null &&
                      Xd(t, !!r.multiple, r.defaultValue, !0);
                break;
              default:
                typeof i.onClick == "function" && (t.onclick = G0);
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1;
            }
          }
          r && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return si(e), null;
    case 6:
      if (t && e.stateNode != null) EN(t, e, t.memoizedProps, r);
      else {
        if (typeof r != "string" && e.stateNode === null) throw Error(rt(166));
        if (((n = Uc(Sp.current)), Uc(Qa.current), Ng(e))) {
          if (
            ((r = e.stateNode),
            (n = e.memoizedProps),
            (r[qa] = e),
            (o = r.nodeValue !== n) && ((t = To), t !== null))
          )
            switch (t.tag) {
              case 3:
                Og(r.nodeValue, n, (t.mode & 1) !== 0);
                break;
              case 5:
                t.memoizedProps.suppressHydrationWarning !== !0 &&
                  Og(r.nodeValue, n, (t.mode & 1) !== 0);
            }
          o && (e.flags |= 4);
        } else
          (r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r)),
            (r[qa] = e),
            (e.stateNode = r);
      }
      return si(e), null;
    case 13:
      if (
        (Vn(Kn),
        (r = e.memoizedState),
        t === null ||
          (t.memoizedState !== null && t.memoizedState.dehydrated !== null))
      ) {
        if (Wn && bo !== null && e.mode & 1 && !(e.flags & 128))
          HO(), af(), (e.flags |= 98560), (o = !1);
        else if (((o = Ng(e)), r !== null && r.dehydrated !== null)) {
          if (t === null) {
            if (!o) throw Error(rt(318));
            if (
              ((o = e.memoizedState),
              (o = o !== null ? o.dehydrated : null),
              !o)
            )
              throw Error(rt(317));
            o[qa] = e;
          } else
            af(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          si(e), (o = !1);
        } else Sa !== null && (Yb(Sa), (Sa = null)), (o = !0);
        if (!o) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = n), e)
        : ((r = r !== null),
          r !== (t !== null && t.memoizedState !== null) &&
            r &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (t === null || Kn.current & 1 ? Ar === 0 && (Ar = 3) : UM())),
          e.updateQueue !== null && (e.flags |= 4),
          si(e),
          null);
    case 4:
      return (
        lf(), jb(t, e), t === null && gp(e.stateNode.containerInfo), si(e), null
      );
    case 10:
      return _M(e.type._context), si(e), null;
    case 17:
      return Qi(e.type) && W0(), si(e), null;
    case 19:
      if ((Vn(Kn), (o = e.memoizedState), o === null)) return si(e), null;
      if (((r = (e.flags & 128) !== 0), (a = o.rendering), a === null))
        if (r) sh(o, !1);
        else {
          if (Ar !== 0 || (t !== null && t.flags & 128))
            for (t = e.child; t !== null; ) {
              if (((a = J0(t)), a !== null)) {
                for (
                  e.flags |= 128,
                    sh(o, !1),
                    r = a.updateQueue,
                    r !== null && ((e.updateQueue = r), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    r = n,
                    n = e.child;
                  n !== null;

                )
                  (o = n),
                    (t = r),
                    (o.flags &= 14680066),
                    (a = o.alternate),
                    a === null
                      ? ((o.childLanes = 0),
                        (o.lanes = t),
                        (o.child = null),
                        (o.subtreeFlags = 0),
                        (o.memoizedProps = null),
                        (o.memoizedState = null),
                        (o.updateQueue = null),
                        (o.dependencies = null),
                        (o.stateNode = null))
                      : ((o.childLanes = a.childLanes),
                        (o.lanes = a.lanes),
                        (o.child = a.child),
                        (o.subtreeFlags = 0),
                        (o.deletions = null),
                        (o.memoizedProps = a.memoizedProps),
                        (o.memoizedState = a.memoizedState),
                        (o.updateQueue = a.updateQueue),
                        (o.type = a.type),
                        (t = a.dependencies),
                        (o.dependencies =
                          t === null
                            ? null
                            : {
                                lanes: t.lanes,
                                firstContext: t.firstContext,
                              })),
                    (n = n.sibling);
                return kn(Kn, (Kn.current & 1) | 2), e.child;
              }
              t = t.sibling;
            }
          o.tail !== null &&
            mr() > uf &&
            ((e.flags |= 128), (r = !0), sh(o, !1), (e.lanes = 4194304));
        }
      else {
        if (!r)
          if (((t = J0(a)), t !== null)) {
            if (
              ((e.flags |= 128),
              (r = !0),
              (n = t.updateQueue),
              n !== null && ((e.updateQueue = n), (e.flags |= 4)),
              sh(o, !0),
              o.tail === null && o.tailMode === "hidden" && !a.alternate && !Wn)
            )
              return si(e), null;
          } else
            2 * mr() - o.renderingStartTime > uf &&
              n !== 1073741824 &&
              ((e.flags |= 128), (r = !0), sh(o, !1), (e.lanes = 4194304));
        o.isBackwards
          ? ((a.sibling = e.child), (e.child = a))
          : ((n = o.last),
            n !== null ? (n.sibling = a) : (e.child = a),
            (o.last = a));
      }
      return o.tail !== null
        ? ((e = o.tail),
          (o.rendering = e),
          (o.tail = e.sibling),
          (o.renderingStartTime = mr()),
          (e.sibling = null),
          (n = Kn.current),
          kn(Kn, r ? (n & 1) | 2 : n & 1),
          e)
        : (si(e), null);
    case 22:
    case 23:
      return (
        zM(),
        (r = e.memoizedState !== null),
        t !== null && (t.memoizedState !== null) !== r && (e.flags |= 8192),
        r && e.mode & 1
          ? So & 1073741824 && (si(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : si(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(rt(156, e.tag));
}
function b6(t, e) {
  switch ((vM(e), e.tag)) {
    case 1:
      return (
        Qi(e.type) && W0(),
        (t = e.flags),
        t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 3:
      return (
        lf(),
        Vn(Zi),
        Vn(gi),
        CM(),
        (t = e.flags),
        t & 65536 && !(t & 128) ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 5:
      return MM(e), null;
    case 13:
      if (
        (Vn(Kn), (t = e.memoizedState), t !== null && t.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(rt(340));
        af();
      }
      return (
        (t = e.flags), t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 19:
      return Vn(Kn), null;
    case 4:
      return lf(), null;
    case 10:
      return _M(e.type._context), null;
    case 22:
    case 23:
      return zM(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var zg = !1,
  hi = !1,
  w6 = typeof WeakSet == "function" ? WeakSet : Set,
  yt = null;
function Dd(t, e) {
  var n = t.ref;
  if (n !== null)
    if (typeof n == "function")
      try {
        n(null);
      } catch (r) {
        or(t, e, r);
      }
    else n.current = null;
}
function Vb(t, e, n) {
  try {
    n();
  } catch (r) {
    or(t, e, r);
  }
}
var rR = !1;
function E6(t, e) {
  if (((Cb = j0), (t = AO()), mM(t))) {
    if ("selectionStart" in t)
      var n = { start: t.selectionStart, end: t.selectionEnd };
    else
      e: {
        n = ((n = t.ownerDocument) && n.defaultView) || window;
        var r = n.getSelection && n.getSelection();
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode;
          var i = r.anchorOffset,
            o = r.focusNode;
          r = r.focusOffset;
          try {
            n.nodeType, o.nodeType;
          } catch {
            n = null;
            break e;
          }
          var a = 0,
            s = -1,
            l = -1,
            c = 0,
            u = 0,
            d = t,
            p = null;
          t: for (;;) {
            for (
              var m;
              d !== n || (i !== 0 && d.nodeType !== 3) || (s = a + i),
                d !== o || (r !== 0 && d.nodeType !== 3) || (l = a + r),
                d.nodeType === 3 && (a += d.nodeValue.length),
                (m = d.firstChild) !== null;

            )
              (p = d), (d = m);
            for (;;) {
              if (d === t) break t;
              if (
                (p === n && ++c === i && (s = a),
                p === o && ++u === r && (l = a),
                (m = d.nextSibling) !== null)
              )
                break;
              (d = p), (p = d.parentNode);
            }
            d = m;
          }
          n = s === -1 || l === -1 ? null : { start: s, end: l };
        } else n = null;
      }
    n = n || { start: 0, end: 0 };
  } else n = null;
  for (
    Tb = { focusedElem: t, selectionRange: n }, j0 = !1, yt = e;
    yt !== null;

  )
    if (((e = yt), (t = e.child), (e.subtreeFlags & 1028) !== 0 && t !== null))
      (t.return = e), (yt = t);
    else
      for (; yt !== null; ) {
        e = yt;
        try {
          var v = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (v !== null) {
                  var S = v.memoizedProps,
                    x = v.memoizedState,
                    g = e.stateNode,
                    _ = g.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? S : pa(e.type, S),
                      x
                    );
                  g.__reactInternalSnapshotBeforeUpdate = _;
                }
                break;
              case 3:
                var y = e.stateNode.containerInfo;
                y.nodeType === 1
                  ? (y.textContent = "")
                  : y.nodeType === 9 &&
                    y.documentElement &&
                    y.removeChild(y.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(rt(163));
            }
        } catch (w) {
          or(e, e.return, w);
        }
        if (((t = e.sibling), t !== null)) {
          (t.return = e.return), (yt = t);
          break;
        }
        yt = e.return;
      }
  return (v = rR), (rR = !1), v;
}
function Wh(t, e, n) {
  var r = e.updateQueue;
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next);
    do {
      if ((i.tag & t) === t) {
        var o = i.destroy;
        (i.destroy = void 0), o !== void 0 && Vb(e, n, o);
      }
      i = i.next;
    } while (i !== r);
  }
}
function $y(t, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var n = (e = e.next);
    do {
      if ((n.tag & t) === t) {
        var r = n.create;
        n.destroy = r();
      }
      n = n.next;
    } while (n !== e);
  }
}
function $b(t) {
  var e = t.ref;
  if (e !== null) {
    var n = t.stateNode;
    switch (t.tag) {
      case 5:
        t = n;
        break;
      default:
        t = n;
    }
    typeof e == "function" ? e(t) : (e.current = t);
  }
}
function MN(t) {
  var e = t.alternate;
  e !== null && ((t.alternate = null), MN(e)),
    (t.child = null),
    (t.deletions = null),
    (t.sibling = null),
    t.tag === 5 &&
      ((e = t.stateNode),
      e !== null &&
        (delete e[qa], delete e[yp], delete e[Pb], delete e[a6], delete e[s6])),
    (t.stateNode = null),
    (t.return = null),
    (t.dependencies = null),
    (t.memoizedProps = null),
    (t.memoizedState = null),
    (t.pendingProps = null),
    (t.stateNode = null),
    (t.updateQueue = null);
}
function CN(t) {
  return t.tag === 5 || t.tag === 3 || t.tag === 4;
}
function iR(t) {
  e: for (;;) {
    for (; t.sibling === null; ) {
      if (t.return === null || CN(t.return)) return null;
      t = t.return;
    }
    for (
      t.sibling.return = t.return, t = t.sibling;
      t.tag !== 5 && t.tag !== 6 && t.tag !== 18;

    ) {
      if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
      (t.child.return = t), (t = t.child);
    }
    if (!(t.flags & 2)) return t.stateNode;
  }
}
function Gb(t, e, n) {
  var r = t.tag;
  if (r === 5 || r === 6)
    (t = t.stateNode),
      e
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(t, e)
          : n.insertBefore(t, e)
        : (n.nodeType === 8
            ? ((e = n.parentNode), e.insertBefore(t, n))
            : ((e = n), e.appendChild(t)),
          (n = n._reactRootContainer),
          n != null || e.onclick !== null || (e.onclick = G0));
  else if (r !== 4 && ((t = t.child), t !== null))
    for (Gb(t, e, n), t = t.sibling; t !== null; ) Gb(t, e, n), (t = t.sibling);
}
function Wb(t, e, n) {
  var r = t.tag;
  if (r === 5 || r === 6)
    (t = t.stateNode), e ? n.insertBefore(t, e) : n.appendChild(t);
  else if (r !== 4 && ((t = t.child), t !== null))
    for (Wb(t, e, n), t = t.sibling; t !== null; ) Wb(t, e, n), (t = t.sibling);
}
var Kr = null,
  va = !1;
function al(t, e, n) {
  for (n = n.child; n !== null; ) TN(t, e, n), (n = n.sibling);
}
function TN(t, e, n) {
  if (Za && typeof Za.onCommitFiberUnmount == "function")
    try {
      Za.onCommitFiberUnmount(Dy, n);
    } catch {}
  switch (n.tag) {
    case 5:
      hi || Dd(n, e);
    case 6:
      var r = Kr,
        i = va;
      (Kr = null),
        al(t, e, n),
        (Kr = r),
        (va = i),
        Kr !== null &&
          (va
            ? ((t = Kr),
              (n = n.stateNode),
              t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n))
            : Kr.removeChild(n.stateNode));
      break;
    case 18:
      Kr !== null &&
        (va
          ? ((t = Kr),
            (n = n.stateNode),
            t.nodeType === 8
              ? mS(t.parentNode, n)
              : t.nodeType === 1 && mS(t, n),
            hp(t))
          : mS(Kr, n.stateNode));
      break;
    case 4:
      (r = Kr),
        (i = va),
        (Kr = n.stateNode.containerInfo),
        (va = !0),
        al(t, e, n),
        (Kr = r),
        (va = i);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !hi &&
        ((r = n.updateQueue), r !== null && ((r = r.lastEffect), r !== null))
      ) {
        i = r = r.next;
        do {
          var o = i,
            a = o.destroy;
          (o = o.tag),
            a !== void 0 && (o & 2 || o & 4) && Vb(n, e, a),
            (i = i.next);
        } while (i !== r);
      }
      al(t, e, n);
      break;
    case 1:
      if (
        !hi &&
        (Dd(n, e),
        (r = n.stateNode),
        typeof r.componentWillUnmount == "function")
      )
        try {
          (r.props = n.memoizedProps),
            (r.state = n.memoizedState),
            r.componentWillUnmount();
        } catch (s) {
          or(n, e, s);
        }
      al(t, e, n);
      break;
    case 21:
      al(t, e, n);
      break;
    case 22:
      n.mode & 1
        ? ((hi = (r = hi) || n.memoizedState !== null), al(t, e, n), (hi = r))
        : al(t, e, n);
      break;
    default:
      al(t, e, n);
  }
}
function oR(t) {
  var e = t.updateQueue;
  if (e !== null) {
    t.updateQueue = null;
    var n = t.stateNode;
    n === null && (n = t.stateNode = new w6()),
      e.forEach(function (r) {
        var i = O6.bind(null, t, r);
        n.has(r) || (n.add(r), r.then(i, i));
      });
  }
}
function ca(t, e) {
  var n = e.deletions;
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      try {
        var o = t,
          a = e,
          s = a;
        e: for (; s !== null; ) {
          switch (s.tag) {
            case 5:
              (Kr = s.stateNode), (va = !1);
              break e;
            case 3:
              (Kr = s.stateNode.containerInfo), (va = !0);
              break e;
            case 4:
              (Kr = s.stateNode.containerInfo), (va = !0);
              break e;
          }
          s = s.return;
        }
        if (Kr === null) throw Error(rt(160));
        TN(o, a, i), (Kr = null), (va = !1);
        var l = i.alternate;
        l !== null && (l.return = null), (i.return = null);
      } catch (c) {
        or(i, e, c);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) AN(e, t), (e = e.sibling);
}
function AN(t, e) {
  var n = t.alternate,
    r = t.flags;
  switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((ca(e, t), Va(t), r & 4)) {
        try {
          Wh(3, t, t.return), $y(3, t);
        } catch (S) {
          or(t, t.return, S);
        }
        try {
          Wh(5, t, t.return);
        } catch (S) {
          or(t, t.return, S);
        }
      }
      break;
    case 1:
      ca(e, t), Va(t), r & 512 && n !== null && Dd(n, n.return);
      break;
    case 5:
      if (
        (ca(e, t),
        Va(t),
        r & 512 && n !== null && Dd(n, n.return),
        t.flags & 32)
      ) {
        var i = t.stateNode;
        try {
          cp(i, "");
        } catch (S) {
          or(t, t.return, S);
        }
      }
      if (r & 4 && ((i = t.stateNode), i != null)) {
        var o = t.memoizedProps,
          a = n !== null ? n.memoizedProps : o,
          s = t.type,
          l = t.updateQueue;
        if (((t.updateQueue = null), l !== null))
          try {
            s === "input" && o.type === "radio" && o.name != null && KL(i, o),
              gb(s, a);
            var c = gb(s, o);
            for (a = 0; a < l.length; a += 2) {
              var u = l[a],
                d = l[a + 1];
              u === "style"
                ? eO(i, d)
                : u === "dangerouslySetInnerHTML"
                ? QL(i, d)
                : u === "children"
                ? cp(i, d)
                : nM(i, u, d, c);
            }
            switch (s) {
              case "input":
                db(i, o);
                break;
              case "textarea":
                YL(i, o);
                break;
              case "select":
                var p = i._wrapperState.wasMultiple;
                i._wrapperState.wasMultiple = !!o.multiple;
                var m = o.value;
                m != null
                  ? Xd(i, !!o.multiple, m, !1)
                  : p !== !!o.multiple &&
                    (o.defaultValue != null
                      ? Xd(i, !!o.multiple, o.defaultValue, !0)
                      : Xd(i, !!o.multiple, o.multiple ? [] : "", !1));
            }
            i[yp] = o;
          } catch (S) {
            or(t, t.return, S);
          }
      }
      break;
    case 6:
      if ((ca(e, t), Va(t), r & 4)) {
        if (t.stateNode === null) throw Error(rt(162));
        (i = t.stateNode), (o = t.memoizedProps);
        try {
          i.nodeValue = o;
        } catch (S) {
          or(t, t.return, S);
        }
      }
      break;
    case 3:
      if (
        (ca(e, t), Va(t), r & 4 && n !== null && n.memoizedState.isDehydrated)
      )
        try {
          hp(e.containerInfo);
        } catch (S) {
          or(t, t.return, S);
        }
      break;
    case 4:
      ca(e, t), Va(t);
      break;
    case 13:
      ca(e, t),
        Va(t),
        (i = t.child),
        i.flags & 8192 &&
          ((o = i.memoizedState !== null),
          (i.stateNode.isHidden = o),
          !o ||
            (i.alternate !== null && i.alternate.memoizedState !== null) ||
            (FM = mr())),
        r & 4 && oR(t);
      break;
    case 22:
      if (
        ((u = n !== null && n.memoizedState !== null),
        t.mode & 1 ? ((hi = (c = hi) || u), ca(e, t), (hi = c)) : ca(e, t),
        Va(t),
        r & 8192)
      ) {
        if (
          ((c = t.memoizedState !== null),
          (t.stateNode.isHidden = c) && !u && t.mode & 1)
        )
          for (yt = t, u = t.child; u !== null; ) {
            for (d = yt = u; yt !== null; ) {
              switch (((p = yt), (m = p.child), p.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Wh(4, p, p.return);
                  break;
                case 1:
                  Dd(p, p.return);
                  var v = p.stateNode;
                  if (typeof v.componentWillUnmount == "function") {
                    (r = p), (n = p.return);
                    try {
                      (e = r),
                        (v.props = e.memoizedProps),
                        (v.state = e.memoizedState),
                        v.componentWillUnmount();
                    } catch (S) {
                      or(r, n, S);
                    }
                  }
                  break;
                case 5:
                  Dd(p, p.return);
                  break;
                case 22:
                  if (p.memoizedState !== null) {
                    sR(d);
                    continue;
                  }
              }
              m !== null ? ((m.return = p), (yt = m)) : sR(d);
            }
            u = u.sibling;
          }
        e: for (u = null, d = t; ; ) {
          if (d.tag === 5) {
            if (u === null) {
              u = d;
              try {
                (i = d.stateNode),
                  c
                    ? ((o = i.style),
                      typeof o.setProperty == "function"
                        ? o.setProperty("display", "none", "important")
                        : (o.display = "none"))
                    : ((s = d.stateNode),
                      (l = d.memoizedProps.style),
                      (a =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (s.style.display = JL("display", a)));
              } catch (S) {
                or(t, t.return, S);
              }
            }
          } else if (d.tag === 6) {
            if (u === null)
              try {
                d.stateNode.nodeValue = c ? "" : d.memoizedProps;
              } catch (S) {
                or(t, t.return, S);
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === t) &&
            d.child !== null
          ) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === t) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === t) break e;
            u === d && (u = null), (d = d.return);
          }
          u === d && (u = null), (d.sibling.return = d.return), (d = d.sibling);
        }
      }
      break;
    case 19:
      ca(e, t), Va(t), r & 4 && oR(t);
      break;
    case 21:
      break;
    default:
      ca(e, t), Va(t);
  }
}
function Va(t) {
  var e = t.flags;
  if (e & 2) {
    try {
      e: {
        for (var n = t.return; n !== null; ) {
          if (CN(n)) {
            var r = n;
            break e;
          }
          n = n.return;
        }
        throw Error(rt(160));
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode;
          r.flags & 32 && (cp(i, ""), (r.flags &= -33));
          var o = iR(t);
          Wb(t, o, i);
          break;
        case 3:
        case 4:
          var a = r.stateNode.containerInfo,
            s = iR(t);
          Gb(t, s, a);
          break;
        default:
          throw Error(rt(161));
      }
    } catch (l) {
      or(t, t.return, l);
    }
    t.flags &= -3;
  }
  e & 4096 && (t.flags &= -4097);
}
function M6(t, e, n) {
  (yt = t), RN(t);
}
function RN(t, e, n) {
  for (var r = (t.mode & 1) !== 0; yt !== null; ) {
    var i = yt,
      o = i.child;
    if (i.tag === 22 && r) {
      var a = i.memoizedState !== null || zg;
      if (!a) {
        var s = i.alternate,
          l = (s !== null && s.memoizedState !== null) || hi;
        s = zg;
        var c = hi;
        if (((zg = a), (hi = l) && !c))
          for (yt = i; yt !== null; )
            (a = yt),
              (l = a.child),
              a.tag === 22 && a.memoizedState !== null
                ? lR(i)
                : l !== null
                ? ((l.return = a), (yt = l))
                : lR(i);
        for (; o !== null; ) (yt = o), RN(o), (o = o.sibling);
        (yt = i), (zg = s), (hi = c);
      }
      aR(t);
    } else
      i.subtreeFlags & 8772 && o !== null ? ((o.return = i), (yt = o)) : aR(t);
  }
}
function aR(t) {
  for (; yt !== null; ) {
    var e = yt;
    if (e.flags & 8772) {
      var n = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              hi || $y(5, e);
              break;
            case 1:
              var r = e.stateNode;
              if (e.flags & 4 && !hi)
                if (n === null) r.componentDidMount();
                else {
                  var i =
                    e.elementType === e.type
                      ? n.memoizedProps
                      : pa(e.type, n.memoizedProps);
                  r.componentDidUpdate(
                    i,
                    n.memoizedState,
                    r.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var o = e.updateQueue;
              o !== null && VA(e, o, r);
              break;
            case 3:
              var a = e.updateQueue;
              if (a !== null) {
                if (((n = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      n = e.child.stateNode;
                      break;
                    case 1:
                      n = e.child.stateNode;
                  }
                VA(e, a, n);
              }
              break;
            case 5:
              var s = e.stateNode;
              if (n === null && e.flags & 4) {
                n = s;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && n.focus();
                    break;
                  case "img":
                    l.src && (n.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var c = e.alternate;
                if (c !== null) {
                  var u = c.memoizedState;
                  if (u !== null) {
                    var d = u.dehydrated;
                    d !== null && hp(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(rt(163));
          }
        hi || (e.flags & 512 && $b(e));
      } catch (p) {
        or(e, e.return, p);
      }
    }
    if (e === t) {
      yt = null;
      break;
    }
    if (((n = e.sibling), n !== null)) {
      (n.return = e.return), (yt = n);
      break;
    }
    yt = e.return;
  }
}
function sR(t) {
  for (; yt !== null; ) {
    var e = yt;
    if (e === t) {
      yt = null;
      break;
    }
    var n = e.sibling;
    if (n !== null) {
      (n.return = e.return), (yt = n);
      break;
    }
    yt = e.return;
  }
}
function lR(t) {
  for (; yt !== null; ) {
    var e = yt;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var n = e.return;
          try {
            $y(4, e);
          } catch (l) {
            or(e, n, l);
          }
          break;
        case 1:
          var r = e.stateNode;
          if (typeof r.componentDidMount == "function") {
            var i = e.return;
            try {
              r.componentDidMount();
            } catch (l) {
              or(e, i, l);
            }
          }
          var o = e.return;
          try {
            $b(e);
          } catch (l) {
            or(e, o, l);
          }
          break;
        case 5:
          var a = e.return;
          try {
            $b(e);
          } catch (l) {
            or(e, a, l);
          }
      }
    } catch (l) {
      or(e, e.return, l);
    }
    if (e === t) {
      yt = null;
      break;
    }
    var s = e.sibling;
    if (s !== null) {
      (s.return = e.return), (yt = s);
      break;
    }
    yt = e.return;
  }
}
var C6 = Math.ceil,
  ny = Xs.ReactCurrentDispatcher,
  OM = Xs.ReactCurrentOwner,
  ea = Xs.ReactCurrentBatchConfig,
  mn = 0,
  jr = null,
  br = null,
  Zr = 0,
  So = 0,
  zd = ql(0),
  Ar = 0,
  Ep = null,
  su = 0,
  Gy = 0,
  NM = 0,
  Xh = null,
  Xi = null,
  FM = 0,
  uf = 1 / 0,
  Ms = null,
  ry = !1,
  Xb = null,
  Il = null,
  Ug = !1,
  _l = null,
  iy = 0,
  qh = 0,
  qb = null,
  h0 = -1,
  p0 = 0;
function Li() {
  return mn & 6 ? mr() : h0 !== -1 ? h0 : (h0 = mr());
}
function Ll(t) {
  return t.mode & 1
    ? mn & 2 && Zr !== 0
      ? Zr & -Zr
      : c6.transition !== null
      ? (p0 === 0 && (p0 = fO()), p0)
      : ((t = Cn),
        t !== 0 || ((t = window.event), (t = t === void 0 ? 16 : xO(t.type))),
        t)
    : 1;
}
function Ca(t, e, n, r) {
  if (50 < qh) throw ((qh = 0), (qb = null), Error(rt(185)));
  am(t, n, r),
    (!(mn & 2) || t !== jr) &&
      (t === jr && (!(mn & 2) && (Gy |= n), Ar === 4 && yl(t, Zr)),
      Ji(t, r),
      n === 1 && mn === 0 && !(e.mode & 1) && ((uf = mr() + 500), Hy && Kl()));
}
function Ji(t, e) {
  var n = t.callbackNode;
  cB(t, e);
  var r = H0(t, t === jr ? Zr : 0);
  if (r === 0)
    n !== null && vA(n), (t.callbackNode = null), (t.callbackPriority = 0);
  else if (((e = r & -r), t.callbackPriority !== e)) {
    if ((n != null && vA(n), e === 1))
      t.tag === 0 ? l6(cR.bind(null, t)) : UO(cR.bind(null, t)),
        i6(function () {
          !(mn & 6) && Kl();
        }),
        (n = null);
    else {
      switch (hO(r)) {
        case 1:
          n = sM;
          break;
        case 4:
          n = uO;
          break;
        case 16:
          n = B0;
          break;
        case 536870912:
          n = dO;
          break;
        default:
          n = B0;
      }
      n = zN(n, PN.bind(null, t));
    }
    (t.callbackPriority = e), (t.callbackNode = n);
  }
}
function PN(t, e) {
  if (((h0 = -1), (p0 = 0), mn & 6)) throw Error(rt(327));
  var n = t.callbackNode;
  if (Qd() && t.callbackNode !== n) return null;
  var r = H0(t, t === jr ? Zr : 0);
  if (r === 0) return null;
  if (r & 30 || r & t.expiredLanes || e) e = oy(t, r);
  else {
    e = r;
    var i = mn;
    mn |= 2;
    var o = LN();
    (jr !== t || Zr !== e) && ((Ms = null), (uf = mr() + 500), Wc(t, e));
    do
      try {
        R6();
        break;
      } catch (s) {
        IN(t, s);
      }
    while (!0);
    SM(),
      (ny.current = o),
      (mn = i),
      br !== null ? (e = 0) : ((jr = null), (Zr = 0), (e = Ar));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((i = _b(t)), i !== 0 && ((r = i), (e = Kb(t, i)))), e === 1)
    )
      throw ((n = Ep), Wc(t, 0), yl(t, r), Ji(t, mr()), n);
    if (e === 6) yl(t, r);
    else {
      if (
        ((i = t.current.alternate),
        !(r & 30) &&
          !T6(i) &&
          ((e = oy(t, r)),
          e === 2 && ((o = _b(t)), o !== 0 && ((r = o), (e = Kb(t, o)))),
          e === 1))
      )
        throw ((n = Ep), Wc(t, 0), yl(t, r), Ji(t, mr()), n);
      switch (((t.finishedWork = i), (t.finishedLanes = r), e)) {
        case 0:
        case 1:
          throw Error(rt(345));
        case 2:
          Cc(t, Xi, Ms);
          break;
        case 3:
          if (
            (yl(t, r), (r & 130023424) === r && ((e = FM + 500 - mr()), 10 < e))
          ) {
            if (H0(t, 0) !== 0) break;
            if (((i = t.suspendedLanes), (i & r) !== r)) {
              Li(), (t.pingedLanes |= t.suspendedLanes & i);
              break;
            }
            t.timeoutHandle = Rb(Cc.bind(null, t, Xi, Ms), e);
            break;
          }
          Cc(t, Xi, Ms);
          break;
        case 4:
          if ((yl(t, r), (r & 4194240) === r)) break;
          for (e = t.eventTimes, i = -1; 0 < r; ) {
            var a = 31 - Ma(r);
            (o = 1 << a), (a = e[a]), a > i && (i = a), (r &= ~o);
          }
          if (
            ((r = i),
            (r = mr() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                ? 480
                : 1080 > r
                ? 1080
                : 1920 > r
                ? 1920
                : 3e3 > r
                ? 3e3
                : 4320 > r
                ? 4320
                : 1960 * C6(r / 1960)) - r),
            10 < r)
          ) {
            t.timeoutHandle = Rb(Cc.bind(null, t, Xi, Ms), r);
            break;
          }
          Cc(t, Xi, Ms);
          break;
        case 5:
          Cc(t, Xi, Ms);
          break;
        default:
          throw Error(rt(329));
      }
    }
  }
  return Ji(t, mr()), t.callbackNode === n ? PN.bind(null, t) : null;
}
function Kb(t, e) {
  var n = Xh;
  return (
    t.current.memoizedState.isDehydrated && (Wc(t, e).flags |= 256),
    (t = oy(t, e)),
    t !== 2 && ((e = Xi), (Xi = n), e !== null && Yb(e)),
    t
  );
}
function Yb(t) {
  Xi === null ? (Xi = t) : Xi.push.apply(Xi, t);
}
function T6(t) {
  for (var e = t; ; ) {
    if (e.flags & 16384) {
      var n = e.updateQueue;
      if (n !== null && ((n = n.stores), n !== null))
        for (var r = 0; r < n.length; r++) {
          var i = n[r],
            o = i.getSnapshot;
          i = i.value;
          try {
            if (!Ra(o(), i)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((n = e.child), e.subtreeFlags & 16384 && n !== null))
      (n.return = e), (e = n);
    else {
      if (e === t) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function yl(t, e) {
  for (
    e &= ~NM,
      e &= ~Gy,
      t.suspendedLanes |= e,
      t.pingedLanes &= ~e,
      t = t.expirationTimes;
    0 < e;

  ) {
    var n = 31 - Ma(e),
      r = 1 << n;
    (t[n] = -1), (e &= ~r);
  }
}
function cR(t) {
  if (mn & 6) throw Error(rt(327));
  Qd();
  var e = H0(t, 0);
  if (!(e & 1)) return Ji(t, mr()), null;
  var n = oy(t, e);
  if (t.tag !== 0 && n === 2) {
    var r = _b(t);
    r !== 0 && ((e = r), (n = Kb(t, r)));
  }
  if (n === 1) throw ((n = Ep), Wc(t, 0), yl(t, e), Ji(t, mr()), n);
  if (n === 6) throw Error(rt(345));
  return (
    (t.finishedWork = t.current.alternate),
    (t.finishedLanes = e),
    Cc(t, Xi, Ms),
    Ji(t, mr()),
    null
  );
}
function DM(t, e) {
  var n = mn;
  mn |= 1;
  try {
    return t(e);
  } finally {
    (mn = n), mn === 0 && ((uf = mr() + 500), Hy && Kl());
  }
}
function lu(t) {
  _l !== null && _l.tag === 0 && !(mn & 6) && Qd();
  var e = mn;
  mn |= 1;
  var n = ea.transition,
    r = Cn;
  try {
    if (((ea.transition = null), (Cn = 1), t)) return t();
  } finally {
    (Cn = r), (ea.transition = n), (mn = e), !(mn & 6) && Kl();
  }
}
function zM() {
  (So = zd.current), Vn(zd);
}
function Wc(t, e) {
  (t.finishedWork = null), (t.finishedLanes = 0);
  var n = t.timeoutHandle;
  if ((n !== -1 && ((t.timeoutHandle = -1), r6(n)), br !== null))
    for (n = br.return; n !== null; ) {
      var r = n;
      switch ((vM(r), r.tag)) {
        case 1:
          (r = r.type.childContextTypes), r != null && W0();
          break;
        case 3:
          lf(), Vn(Zi), Vn(gi), CM();
          break;
        case 5:
          MM(r);
          break;
        case 4:
          lf();
          break;
        case 13:
          Vn(Kn);
          break;
        case 19:
          Vn(Kn);
          break;
        case 10:
          _M(r.type._context);
          break;
        case 22:
        case 23:
          zM();
      }
      n = n.return;
    }
  if (
    ((jr = t),
    (br = t = Ol(t.current, null)),
    (Zr = So = e),
    (Ar = 0),
    (Ep = null),
    (NM = Gy = su = 0),
    (Xi = Xh = null),
    zc !== null)
  ) {
    for (e = 0; e < zc.length; e++)
      if (((n = zc[e]), (r = n.interleaved), r !== null)) {
        n.interleaved = null;
        var i = r.next,
          o = n.pending;
        if (o !== null) {
          var a = o.next;
          (o.next = i), (r.next = a);
        }
        n.pending = r;
      }
    zc = null;
  }
  return t;
}
function IN(t, e) {
  do {
    var n = br;
    try {
      if ((SM(), (u0.current = ty), ey)) {
        for (var r = er.memoizedState; r !== null; ) {
          var i = r.queue;
          i !== null && (i.pending = null), (r = r.next);
        }
        ey = !1;
      }
      if (
        ((au = 0),
        (Br = Cr = er = null),
        (Gh = !1),
        (_p = 0),
        (OM.current = null),
        n === null || n.return === null)
      ) {
        (Ar = 1), (Ep = e), (br = null);
        break;
      }
      e: {
        var o = t,
          a = n.return,
          s = n,
          l = e;
        if (
          ((e = Zr),
          (s.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var c = l,
            u = s,
            d = u.tag;
          if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var p = u.alternate;
            p
              ? ((u.updateQueue = p.updateQueue),
                (u.memoizedState = p.memoizedState),
                (u.lanes = p.lanes))
              : ((u.updateQueue = null), (u.memoizedState = null));
          }
          var m = YA(a);
          if (m !== null) {
            (m.flags &= -257),
              ZA(m, a, s, o, e),
              m.mode & 1 && KA(o, c, e),
              (e = m),
              (l = c);
            var v = e.updateQueue;
            if (v === null) {
              var S = new Set();
              S.add(l), (e.updateQueue = S);
            } else v.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              KA(o, c, e), UM();
              break e;
            }
            l = Error(rt(426));
          }
        } else if (Wn && s.mode & 1) {
          var x = YA(a);
          if (x !== null) {
            !(x.flags & 65536) && (x.flags |= 256),
              ZA(x, a, s, o, e),
              yM(cf(l, s));
            break e;
          }
        }
        (o = l = cf(l, s)),
          Ar !== 4 && (Ar = 2),
          Xh === null ? (Xh = [o]) : Xh.push(o),
          (o = a);
        do {
          switch (o.tag) {
            case 3:
              (o.flags |= 65536), (e &= -e), (o.lanes |= e);
              var g = pN(o, l, e);
              jA(o, g);
              break e;
            case 1:
              s = l;
              var _ = o.type,
                y = o.stateNode;
              if (
                !(o.flags & 128) &&
                (typeof _.getDerivedStateFromError == "function" ||
                  (y !== null &&
                    typeof y.componentDidCatch == "function" &&
                    (Il === null || !Il.has(y))))
              ) {
                (o.flags |= 65536), (e &= -e), (o.lanes |= e);
                var w = mN(o, s, e);
                jA(o, w);
                break e;
              }
          }
          o = o.return;
        } while (o !== null);
      }
      NN(n);
    } catch (A) {
      (e = A), br === n && n !== null && (br = n = n.return);
      continue;
    }
    break;
  } while (!0);
}
function LN() {
  var t = ny.current;
  return (ny.current = ty), t === null ? ty : t;
}
function UM() {
  (Ar === 0 || Ar === 3 || Ar === 2) && (Ar = 4),
    jr === null || (!(su & 268435455) && !(Gy & 268435455)) || yl(jr, Zr);
}
function oy(t, e) {
  var n = mn;
  mn |= 2;
  var r = LN();
  (jr !== t || Zr !== e) && ((Ms = null), Wc(t, e));
  do
    try {
      A6();
      break;
    } catch (i) {
      IN(t, i);
    }
  while (!0);
  if ((SM(), (mn = n), (ny.current = r), br !== null)) throw Error(rt(261));
  return (jr = null), (Zr = 0), Ar;
}
function A6() {
  for (; br !== null; ) ON(br);
}
function R6() {
  for (; br !== null && !eB(); ) ON(br);
}
function ON(t) {
  var e = DN(t.alternate, t, So);
  (t.memoizedProps = t.pendingProps),
    e === null ? NN(t) : (br = e),
    (OM.current = null);
}
function NN(t) {
  var e = t;
  do {
    var n = e.alternate;
    if (((t = e.return), e.flags & 32768)) {
      if (((n = b6(n, e)), n !== null)) {
        (n.flags &= 32767), (br = n);
        return;
      }
      if (t !== null)
        (t.flags |= 32768), (t.subtreeFlags = 0), (t.deletions = null);
      else {
        (Ar = 6), (br = null);
        return;
      }
    } else if (((n = _6(n, e, So)), n !== null)) {
      br = n;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      br = e;
      return;
    }
    br = e = t;
  } while (e !== null);
  Ar === 0 && (Ar = 5);
}
function Cc(t, e, n) {
  var r = Cn,
    i = ea.transition;
  try {
    (ea.transition = null), (Cn = 1), P6(t, e, n, r);
  } finally {
    (ea.transition = i), (Cn = r);
  }
  return null;
}
function P6(t, e, n, r) {
  do Qd();
  while (_l !== null);
  if (mn & 6) throw Error(rt(327));
  n = t.finishedWork;
  var i = t.finishedLanes;
  if (n === null) return null;
  if (((t.finishedWork = null), (t.finishedLanes = 0), n === t.current))
    throw Error(rt(177));
  (t.callbackNode = null), (t.callbackPriority = 0);
  var o = n.lanes | n.childLanes;
  if (
    (uB(t, o),
    t === jr && ((br = jr = null), (Zr = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      Ug ||
      ((Ug = !0),
      zN(B0, function () {
        return Qd(), null;
      })),
    (o = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || o)
  ) {
    (o = ea.transition), (ea.transition = null);
    var a = Cn;
    Cn = 1;
    var s = mn;
    (mn |= 4),
      (OM.current = null),
      E6(t, n),
      AN(n, t),
      YB(Tb),
      (j0 = !!Cb),
      (Tb = Cb = null),
      (t.current = n),
      M6(n),
      tB(),
      (mn = s),
      (Cn = a),
      (ea.transition = o);
  } else t.current = n;
  if (
    (Ug && ((Ug = !1), (_l = t), (iy = i)),
    (o = t.pendingLanes),
    o === 0 && (Il = null),
    iB(n.stateNode),
    Ji(t, mr()),
    e !== null)
  )
    for (r = t.onRecoverableError, n = 0; n < e.length; n++)
      (i = e[n]), r(i.value, { componentStack: i.stack, digest: i.digest });
  if (ry) throw ((ry = !1), (t = Xb), (Xb = null), t);
  return (
    iy & 1 && t.tag !== 0 && Qd(),
    (o = t.pendingLanes),
    o & 1 ? (t === qb ? qh++ : ((qh = 0), (qb = t))) : (qh = 0),
    Kl(),
    null
  );
}
function Qd() {
  if (_l !== null) {
    var t = hO(iy),
      e = ea.transition,
      n = Cn;
    try {
      if (((ea.transition = null), (Cn = 16 > t ? 16 : t), _l === null))
        var r = !1;
      else {
        if (((t = _l), (_l = null), (iy = 0), mn & 6)) throw Error(rt(331));
        var i = mn;
        for (mn |= 4, yt = t.current; yt !== null; ) {
          var o = yt,
            a = o.child;
          if (yt.flags & 16) {
            var s = o.deletions;
            if (s !== null) {
              for (var l = 0; l < s.length; l++) {
                var c = s[l];
                for (yt = c; yt !== null; ) {
                  var u = yt;
                  switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Wh(8, u, o);
                  }
                  var d = u.child;
                  if (d !== null) (d.return = u), (yt = d);
                  else
                    for (; yt !== null; ) {
                      u = yt;
                      var p = u.sibling,
                        m = u.return;
                      if ((MN(u), u === c)) {
                        yt = null;
                        break;
                      }
                      if (p !== null) {
                        (p.return = m), (yt = p);
                        break;
                      }
                      yt = m;
                    }
                }
              }
              var v = o.alternate;
              if (v !== null) {
                var S = v.child;
                if (S !== null) {
                  v.child = null;
                  do {
                    var x = S.sibling;
                    (S.sibling = null), (S = x);
                  } while (S !== null);
                }
              }
              yt = o;
            }
          }
          if (o.subtreeFlags & 2064 && a !== null) (a.return = o), (yt = a);
          else
            e: for (; yt !== null; ) {
              if (((o = yt), o.flags & 2048))
                switch (o.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Wh(9, o, o.return);
                }
              var g = o.sibling;
              if (g !== null) {
                (g.return = o.return), (yt = g);
                break e;
              }
              yt = o.return;
            }
        }
        var _ = t.current;
        for (yt = _; yt !== null; ) {
          a = yt;
          var y = a.child;
          if (a.subtreeFlags & 2064 && y !== null) (y.return = a), (yt = y);
          else
            e: for (a = _; yt !== null; ) {
              if (((s = yt), s.flags & 2048))
                try {
                  switch (s.tag) {
                    case 0:
                    case 11:
                    case 15:
                      $y(9, s);
                  }
                } catch (A) {
                  or(s, s.return, A);
                }
              if (s === a) {
                yt = null;
                break e;
              }
              var w = s.sibling;
              if (w !== null) {
                (w.return = s.return), (yt = w);
                break e;
              }
              yt = s.return;
            }
        }
        if (
          ((mn = i), Kl(), Za && typeof Za.onPostCommitFiberRoot == "function")
        )
          try {
            Za.onPostCommitFiberRoot(Dy, t);
          } catch {}
        r = !0;
      }
      return r;
    } finally {
      (Cn = n), (ea.transition = e);
    }
  }
  return !1;
}
function uR(t, e, n) {
  (e = cf(n, e)),
    (e = pN(t, e, 1)),
    (t = Pl(t, e, 1)),
    (e = Li()),
    t !== null && (am(t, 1, e), Ji(t, e));
}
function or(t, e, n) {
  if (t.tag === 3) uR(t, t, n);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        uR(e, t, n);
        break;
      } else if (e.tag === 1) {
        var r = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof r.componentDidCatch == "function" &&
            (Il === null || !Il.has(r)))
        ) {
          (t = cf(n, t)),
            (t = mN(e, t, 1)),
            (e = Pl(e, t, 1)),
            (t = Li()),
            e !== null && (am(e, 1, t), Ji(e, t));
          break;
        }
      }
      e = e.return;
    }
}
function I6(t, e, n) {
  var r = t.pingCache;
  r !== null && r.delete(e),
    (e = Li()),
    (t.pingedLanes |= t.suspendedLanes & n),
    jr === t &&
      (Zr & n) === n &&
      (Ar === 4 || (Ar === 3 && (Zr & 130023424) === Zr && 500 > mr() - FM)
        ? Wc(t, 0)
        : (NM |= n)),
    Ji(t, e);
}
function FN(t, e) {
  e === 0 &&
    (t.mode & 1
      ? ((e = Ag), (Ag <<= 1), !(Ag & 130023424) && (Ag = 4194304))
      : (e = 1));
  var n = Li();
  (t = Bs(t, e)), t !== null && (am(t, e, n), Ji(t, n));
}
function L6(t) {
  var e = t.memoizedState,
    n = 0;
  e !== null && (n = e.retryLane), FN(t, n);
}
function O6(t, e) {
  var n = 0;
  switch (t.tag) {
    case 13:
      var r = t.stateNode,
        i = t.memoizedState;
      i !== null && (n = i.retryLane);
      break;
    case 19:
      r = t.stateNode;
      break;
    default:
      throw Error(rt(314));
  }
  r !== null && r.delete(e), FN(t, n);
}
var DN;
DN = function (t, e, n) {
  if (t !== null)
    if (t.memoizedProps !== e.pendingProps || Zi.current) Yi = !0;
    else {
      if (!(t.lanes & n) && !(e.flags & 128)) return (Yi = !1), S6(t, e, n);
      Yi = !!(t.flags & 131072);
    }
  else (Yi = !1), Wn && e.flags & 1048576 && kO(e, K0, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var r = e.type;
      f0(t, e), (t = e.pendingProps);
      var i = of(e, gi.current);
      Zd(e, n), (i = AM(null, e, r, t, i, n));
      var o = RM();
      return (
        (e.flags |= 1),
        typeof i == "object" &&
        i !== null &&
        typeof i.render == "function" &&
        i.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            Qi(r) ? ((o = !0), X0(e)) : (o = !1),
            (e.memoizedState =
              i.state !== null && i.state !== void 0 ? i.state : null),
            wM(e),
            (i.updater = jy),
            (e.stateNode = i),
            (i._reactInternals = e),
            Db(e, r, t, n),
            (e = kb(null, e, r, !0, o, n)))
          : ((e.tag = 0), Wn && o && gM(e), Ri(null, e, i, n), (e = e.child)),
        e
      );
    case 16:
      r = e.elementType;
      e: {
        switch (
          (f0(t, e),
          (t = e.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (e.type = r),
          (i = e.tag = F6(r)),
          (t = pa(r, t)),
          i)
        ) {
          case 0:
            e = Ub(null, e, r, t, n);
            break e;
          case 1:
            e = eR(null, e, r, t, n);
            break e;
          case 11:
            e = QA(null, e, r, t, n);
            break e;
          case 14:
            e = JA(null, e, r, pa(r.type, t), n);
            break e;
        }
        throw Error(rt(306, r, ""));
      }
      return e;
    case 0:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : pa(r, i)),
        Ub(t, e, r, i, n)
      );
    case 1:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : pa(r, i)),
        eR(t, e, r, i, n)
      );
    case 3:
      e: {
        if ((xN(e), t === null)) throw Error(rt(387));
        (r = e.pendingProps),
          (o = e.memoizedState),
          (i = o.element),
          VO(t, e),
          Q0(e, r, null, n);
        var a = e.memoizedState;
        if (((r = a.element), o.isDehydrated))
          if (
            ((o = {
              element: r,
              isDehydrated: !1,
              cache: a.cache,
              pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
              transitions: a.transitions,
            }),
            (e.updateQueue.baseState = o),
            (e.memoizedState = o),
            e.flags & 256)
          ) {
            (i = cf(Error(rt(423)), e)), (e = tR(t, e, r, n, i));
            break e;
          } else if (r !== i) {
            (i = cf(Error(rt(424)), e)), (e = tR(t, e, r, n, i));
            break e;
          } else
            for (
              bo = Rl(e.stateNode.containerInfo.firstChild),
                To = e,
                Wn = !0,
                Sa = null,
                n = XO(e, null, r, n),
                e.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling);
        else {
          if ((af(), r === i)) {
            e = Hs(t, e, n);
            break e;
          }
          Ri(t, e, r, n);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        qO(e),
        t === null && Ob(e),
        (r = e.type),
        (i = e.pendingProps),
        (o = t !== null ? t.memoizedProps : null),
        (a = i.children),
        Ab(r, i) ? (a = null) : o !== null && Ab(r, o) && (e.flags |= 32),
        yN(t, e),
        Ri(t, e, a, n),
        e.child
      );
    case 6:
      return t === null && Ob(e), null;
    case 13:
      return SN(t, e, n);
    case 4:
      return (
        EM(e, e.stateNode.containerInfo),
        (r = e.pendingProps),
        t === null ? (e.child = sf(e, null, r, n)) : Ri(t, e, r, n),
        e.child
      );
    case 11:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : pa(r, i)),
        QA(t, e, r, i, n)
      );
    case 7:
      return Ri(t, e, e.pendingProps, n), e.child;
    case 8:
      return Ri(t, e, e.pendingProps.children, n), e.child;
    case 12:
      return Ri(t, e, e.pendingProps.children, n), e.child;
    case 10:
      e: {
        if (
          ((r = e.type._context),
          (i = e.pendingProps),
          (o = e.memoizedProps),
          (a = i.value),
          kn(Y0, r._currentValue),
          (r._currentValue = a),
          o !== null)
        )
          if (Ra(o.value, a)) {
            if (o.children === i.children && !Zi.current) {
              e = Hs(t, e, n);
              break e;
            }
          } else
            for (o = e.child, o !== null && (o.return = e); o !== null; ) {
              var s = o.dependencies;
              if (s !== null) {
                a = o.child;
                for (var l = s.firstContext; l !== null; ) {
                  if (l.context === r) {
                    if (o.tag === 1) {
                      (l = Ns(-1, n & -n)), (l.tag = 2);
                      var c = o.updateQueue;
                      if (c !== null) {
                        c = c.shared;
                        var u = c.pending;
                        u === null
                          ? (l.next = l)
                          : ((l.next = u.next), (u.next = l)),
                          (c.pending = l);
                      }
                    }
                    (o.lanes |= n),
                      (l = o.alternate),
                      l !== null && (l.lanes |= n),
                      Nb(o.return, n, e),
                      (s.lanes |= n);
                    break;
                  }
                  l = l.next;
                }
              } else if (o.tag === 10) a = o.type === e.type ? null : o.child;
              else if (o.tag === 18) {
                if (((a = o.return), a === null)) throw Error(rt(341));
                (a.lanes |= n),
                  (s = a.alternate),
                  s !== null && (s.lanes |= n),
                  Nb(a, n, e),
                  (a = o.sibling);
              } else a = o.child;
              if (a !== null) a.return = o;
              else
                for (a = o; a !== null; ) {
                  if (a === e) {
                    a = null;
                    break;
                  }
                  if (((o = a.sibling), o !== null)) {
                    (o.return = a.return), (a = o);
                    break;
                  }
                  a = a.return;
                }
              o = a;
            }
        Ri(t, e, i.children, n), (e = e.child);
      }
      return e;
    case 9:
      return (
        (i = e.type),
        (r = e.pendingProps.children),
        Zd(e, n),
        (i = na(i)),
        (r = r(i)),
        (e.flags |= 1),
        Ri(t, e, r, n),
        e.child
      );
    case 14:
      return (
        (r = e.type),
        (i = pa(r, e.pendingProps)),
        (i = pa(r.type, i)),
        JA(t, e, r, i, n)
      );
    case 15:
      return gN(t, e, e.type, e.pendingProps, n);
    case 17:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : pa(r, i)),
        f0(t, e),
        (e.tag = 1),
        Qi(r) ? ((t = !0), X0(e)) : (t = !1),
        Zd(e, n),
        GO(e, r, i),
        Db(e, r, i, n),
        kb(null, e, r, !0, t, n)
      );
    case 19:
      return _N(t, e, n);
    case 22:
      return vN(t, e, n);
  }
  throw Error(rt(156, e.tag));
};
function zN(t, e) {
  return cO(t, e);
}
function N6(t, e, n, r) {
  (this.tag = t),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Qo(t, e, n, r) {
  return new N6(t, e, n, r);
}
function kM(t) {
  return (t = t.prototype), !(!t || !t.isReactComponent);
}
function F6(t) {
  if (typeof t == "function") return kM(t) ? 1 : 0;
  if (t != null) {
    if (((t = t.$$typeof), t === iM)) return 11;
    if (t === oM) return 14;
  }
  return 2;
}
function Ol(t, e) {
  var n = t.alternate;
  return (
    n === null
      ? ((n = Qo(t.tag, e, t.key, t.mode)),
        (n.elementType = t.elementType),
        (n.type = t.type),
        (n.stateNode = t.stateNode),
        (n.alternate = t),
        (t.alternate = n))
      : ((n.pendingProps = e),
        (n.type = t.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = t.flags & 14680064),
    (n.childLanes = t.childLanes),
    (n.lanes = t.lanes),
    (n.child = t.child),
    (n.memoizedProps = t.memoizedProps),
    (n.memoizedState = t.memoizedState),
    (n.updateQueue = t.updateQueue),
    (e = t.dependencies),
    (n.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (n.sibling = t.sibling),
    (n.index = t.index),
    (n.ref = t.ref),
    n
  );
}
function m0(t, e, n, r, i, o) {
  var a = 2;
  if (((r = t), typeof t == "function")) kM(t) && (a = 1);
  else if (typeof t == "string") a = 5;
  else
    e: switch (t) {
      case Td:
        return Xc(n.children, i, o, e);
      case rM:
        (a = 8), (i |= 8);
        break;
      case ab:
        return (
          (t = Qo(12, n, e, i | 2)), (t.elementType = ab), (t.lanes = o), t
        );
      case sb:
        return (t = Qo(13, n, e, i)), (t.elementType = sb), (t.lanes = o), t;
      case lb:
        return (t = Qo(19, n, e, i)), (t.elementType = lb), (t.lanes = o), t;
      case WL:
        return Wy(n, i, o, e);
      default:
        if (typeof t == "object" && t !== null)
          switch (t.$$typeof) {
            case $L:
              a = 10;
              break e;
            case GL:
              a = 9;
              break e;
            case iM:
              a = 11;
              break e;
            case oM:
              a = 14;
              break e;
            case ml:
              (a = 16), (r = null);
              break e;
          }
        throw Error(rt(130, t == null ? t : typeof t, ""));
    }
  return (
    (e = Qo(a, n, e, i)), (e.elementType = t), (e.type = r), (e.lanes = o), e
  );
}
function Xc(t, e, n, r) {
  return (t = Qo(7, t, r, e)), (t.lanes = n), t;
}
function Wy(t, e, n, r) {
  return (
    (t = Qo(22, t, r, e)),
    (t.elementType = WL),
    (t.lanes = n),
    (t.stateNode = { isHidden: !1 }),
    t
  );
}
function wS(t, e, n) {
  return (t = Qo(6, t, null, e)), (t.lanes = n), t;
}
function ES(t, e, n) {
  return (
    (e = Qo(4, t.children !== null ? t.children : [], t.key, e)),
    (e.lanes = n),
    (e.stateNode = {
      containerInfo: t.containerInfo,
      pendingChildren: null,
      implementation: t.implementation,
    }),
    e
  );
}
function D6(t, e, n, r, i) {
  (this.tag = e),
    (this.containerInfo = t),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = iS(0)),
    (this.expirationTimes = iS(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = iS(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null);
}
function BM(t, e, n, r, i, o, a, s, l) {
  return (
    (t = new D6(t, e, n, s, l)),
    e === 1 ? ((e = 1), o === !0 && (e |= 8)) : (e = 0),
    (o = Qo(3, null, null, e)),
    (t.current = o),
    (o.stateNode = t),
    (o.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    wM(o),
    t
  );
}
function z6(t, e, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Cd,
    key: r == null ? null : "" + r,
    children: t,
    containerInfo: e,
    implementation: n,
  };
}
function UN(t) {
  if (!t) return kl;
  t = t._reactInternals;
  e: {
    if (vu(t) !== t || t.tag !== 1) throw Error(rt(170));
    var e = t;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (Qi(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(rt(171));
  }
  if (t.tag === 1) {
    var n = t.type;
    if (Qi(n)) return zO(t, n, e);
  }
  return e;
}
function kN(t, e, n, r, i, o, a, s, l) {
  return (
    (t = BM(n, r, !0, t, i, o, a, s, l)),
    (t.context = UN(null)),
    (n = t.current),
    (r = Li()),
    (i = Ll(n)),
    (o = Ns(r, i)),
    (o.callback = e ?? null),
    Pl(n, o, i),
    (t.current.lanes = i),
    am(t, i, r),
    Ji(t, r),
    t
  );
}
function Xy(t, e, n, r) {
  var i = e.current,
    o = Li(),
    a = Ll(i);
  return (
    (n = UN(n)),
    e.context === null ? (e.context = n) : (e.pendingContext = n),
    (e = Ns(o, a)),
    (e.payload = { element: t }),
    (r = r === void 0 ? null : r),
    r !== null && (e.callback = r),
    (t = Pl(i, e, a)),
    t !== null && (Ca(t, i, a, o), c0(t, i, a)),
    a
  );
}
function ay(t) {
  if (((t = t.current), !t.child)) return null;
  switch (t.child.tag) {
    case 5:
      return t.child.stateNode;
    default:
      return t.child.stateNode;
  }
}
function dR(t, e) {
  if (((t = t.memoizedState), t !== null && t.dehydrated !== null)) {
    var n = t.retryLane;
    t.retryLane = n !== 0 && n < e ? n : e;
  }
}
function HM(t, e) {
  dR(t, e), (t = t.alternate) && dR(t, e);
}
function U6() {
  return null;
}
var BN =
  typeof reportError == "function"
    ? reportError
    : function (t) {
        console.error(t);
      };
function jM(t) {
  this._internalRoot = t;
}
qy.prototype.render = jM.prototype.render = function (t) {
  var e = this._internalRoot;
  if (e === null) throw Error(rt(409));
  Xy(t, e, null, null);
};
qy.prototype.unmount = jM.prototype.unmount = function () {
  var t = this._internalRoot;
  if (t !== null) {
    this._internalRoot = null;
    var e = t.containerInfo;
    lu(function () {
      Xy(null, t, null, null);
    }),
      (e[ks] = null);
  }
};
function qy(t) {
  this._internalRoot = t;
}
qy.prototype.unstable_scheduleHydration = function (t) {
  if (t) {
    var e = gO();
    t = { blockedOn: null, target: t, priority: e };
    for (var n = 0; n < vl.length && e !== 0 && e < vl[n].priority; n++);
    vl.splice(n, 0, t), n === 0 && yO(t);
  }
};
function VM(t) {
  return !(!t || (t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11));
}
function Ky(t) {
  return !(
    !t ||
    (t.nodeType !== 1 &&
      t.nodeType !== 9 &&
      t.nodeType !== 11 &&
      (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
  );
}
function fR() {}
function k6(t, e, n, r, i) {
  if (i) {
    if (typeof r == "function") {
      var o = r;
      r = function () {
        var c = ay(a);
        o.call(c);
      };
    }
    var a = kN(e, r, t, 0, null, !1, !1, "", fR);
    return (
      (t._reactRootContainer = a),
      (t[ks] = a.current),
      gp(t.nodeType === 8 ? t.parentNode : t),
      lu(),
      a
    );
  }
  for (; (i = t.lastChild); ) t.removeChild(i);
  if (typeof r == "function") {
    var s = r;
    r = function () {
      var c = ay(l);
      s.call(c);
    };
  }
  var l = BM(t, 0, !1, null, null, !1, !1, "", fR);
  return (
    (t._reactRootContainer = l),
    (t[ks] = l.current),
    gp(t.nodeType === 8 ? t.parentNode : t),
    lu(function () {
      Xy(e, l, n, r);
    }),
    l
  );
}
function Yy(t, e, n, r, i) {
  var o = n._reactRootContainer;
  if (o) {
    var a = o;
    if (typeof i == "function") {
      var s = i;
      i = function () {
        var l = ay(a);
        s.call(l);
      };
    }
    Xy(e, a, t, i);
  } else a = k6(n, e, t, i, r);
  return ay(a);
}
pO = function (t) {
  switch (t.tag) {
    case 3:
      var e = t.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var n = Nh(e.pendingLanes);
        n !== 0 &&
          (lM(e, n | 1), Ji(e, mr()), !(mn & 6) && ((uf = mr() + 500), Kl()));
      }
      break;
    case 13:
      lu(function () {
        var r = Bs(t, 1);
        if (r !== null) {
          var i = Li();
          Ca(r, t, 1, i);
        }
      }),
        HM(t, 1);
  }
};
cM = function (t) {
  if (t.tag === 13) {
    var e = Bs(t, 134217728);
    if (e !== null) {
      var n = Li();
      Ca(e, t, 134217728, n);
    }
    HM(t, 134217728);
  }
};
mO = function (t) {
  if (t.tag === 13) {
    var e = Ll(t),
      n = Bs(t, e);
    if (n !== null) {
      var r = Li();
      Ca(n, t, e, r);
    }
    HM(t, e);
  }
};
gO = function () {
  return Cn;
};
vO = function (t, e) {
  var n = Cn;
  try {
    return (Cn = t), e();
  } finally {
    Cn = n;
  }
};
yb = function (t, e, n) {
  switch (e) {
    case "input":
      if ((db(t, n), (e = n.name), n.type === "radio" && e != null)) {
        for (n = t; n.parentNode; ) n = n.parentNode;
        for (
          n = n.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < n.length;
          e++
        ) {
          var r = n[e];
          if (r !== t && r.form === t.form) {
            var i = By(r);
            if (!i) throw Error(rt(90));
            qL(r), db(r, i);
          }
        }
      }
      break;
    case "textarea":
      YL(t, n);
      break;
    case "select":
      (e = n.value), e != null && Xd(t, !!n.multiple, e, !1);
  }
};
rO = DM;
iO = lu;
var B6 = { usingClientEntryPoint: !1, Events: [lm, Id, By, tO, nO, DM] },
  lh = {
    findFiberByHostInstance: Dc,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  H6 = {
    bundleType: lh.bundleType,
    version: lh.version,
    rendererPackageName: lh.rendererPackageName,
    rendererConfig: lh.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Xs.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (t) {
      return (t = sO(t)), t === null ? null : t.stateNode;
    },
    findFiberByHostInstance: lh.findFiberByHostInstance || U6,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var kg = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!kg.isDisabled && kg.supportsFiber)
    try {
      (Dy = kg.inject(H6)), (Za = kg);
    } catch {}
}
Lo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = B6;
Lo.createPortal = function (t, e) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!VM(e)) throw Error(rt(200));
  return z6(t, e, null, n);
};
Lo.createRoot = function (t, e) {
  if (!VM(t)) throw Error(rt(299));
  var n = !1,
    r = "",
    i = BN;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (n = !0),
      e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
    (e = BM(t, 1, !1, null, null, n, !1, r, i)),
    (t[ks] = e.current),
    gp(t.nodeType === 8 ? t.parentNode : t),
    new jM(e)
  );
};
Lo.findDOMNode = function (t) {
  if (t == null) return null;
  if (t.nodeType === 1) return t;
  var e = t._reactInternals;
  if (e === void 0)
    throw typeof t.render == "function"
      ? Error(rt(188))
      : ((t = Object.keys(t).join(",")), Error(rt(268, t)));
  return (t = sO(e)), (t = t === null ? null : t.stateNode), t;
};
Lo.flushSync = function (t) {
  return lu(t);
};
Lo.hydrate = function (t, e, n) {
  if (!Ky(e)) throw Error(rt(200));
  return Yy(null, t, e, !0, n);
};
Lo.hydrateRoot = function (t, e, n) {
  if (!VM(t)) throw Error(rt(405));
  var r = (n != null && n.hydratedSources) || null,
    i = !1,
    o = "",
    a = BN;
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (i = !0),
      n.identifierPrefix !== void 0 && (o = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (a = n.onRecoverableError)),
    (e = kN(e, null, t, 1, n ?? null, i, !1, o, a)),
    (t[ks] = e.current),
    gp(t),
    r)
  )
    for (t = 0; t < r.length; t++)
      (n = r[t]),
        (i = n._getVersion),
        (i = i(n._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [n, i])
          : e.mutableSourceEagerHydrationData.push(n, i);
  return new qy(e);
};
Lo.render = function (t, e, n) {
  if (!Ky(e)) throw Error(rt(200));
  return Yy(null, t, e, !1, n);
};
Lo.unmountComponentAtNode = function (t) {
  if (!Ky(t)) throw Error(rt(40));
  return t._reactRootContainer
    ? (lu(function () {
        Yy(null, null, t, !1, function () {
          (t._reactRootContainer = null), (t[ks] = null);
        });
      }),
      !0)
    : !1;
};
Lo.unstable_batchedUpdates = DM;
Lo.unstable_renderSubtreeIntoContainer = function (t, e, n, r) {
  if (!Ky(n)) throw Error(rt(200));
  if (t == null || t._reactInternals === void 0) throw Error(rt(38));
  return Yy(t, e, n, !1, r);
};
Lo.version = "18.2.0-next-9e3b772b8-20220608";
function HN() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(HN);
    } catch (t) {
      console.error(t);
    }
}
HN(), (kL.exports = Lo);
var Cf = kL.exports;
const jN = Ny(Cf),
  j6 = AL({ __proto__: null, default: jN }, [Cf]);
var VN,
  hR = Cf;
(VN = ib.createRoot = hR.createRoot), (ib.hydrateRoot = hR.hydrateRoot);
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const um = "160",
  Tc = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  Ac = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  $N = 0,
  Zb = 1,
  GN = 2,
  V6 = 3,
  WN = 0,
  Zy = 1,
  Kh = 2,
  ma = 3,
  js = 0,
  Oi = 1,
  Zo = 2,
  $6 = 2,
  Fs = 0,
  qc = 1,
  Qb = 2,
  Jb = 3,
  ew = 4,
  XN = 5,
  xl = 100,
  qN = 101,
  KN = 102,
  tw = 103,
  nw = 104,
  YN = 200,
  ZN = 201,
  QN = 202,
  JN = 203,
  sy = 204,
  ly = 205,
  eF = 206,
  tF = 207,
  nF = 208,
  rF = 209,
  iF = 210,
  oF = 211,
  aF = 212,
  sF = 213,
  lF = 214,
  cF = 0,
  uF = 1,
  dF = 2,
  Mp = 3,
  fF = 4,
  hF = 5,
  pF = 6,
  mF = 7,
  dm = 0,
  gF = 1,
  vF = 2,
  Ja = 0,
  yF = 1,
  xF = 2,
  SF = 3,
  $M = 4,
  _F = 5,
  bF = 6,
  rw = "attached",
  wF = "detached",
  Qy = 300,
  Vs = 301,
  Bl = 302,
  Cp = 303,
  Tp = 304,
  Tf = 306,
  Ap = 1e3,
  pi = 1001,
  Rp = 1002,
  pr = 1003,
  cy = 1004,
  G6 = 1004,
  Yh = 1005,
  W6 = 1005,
  Yn = 1006,
  GM = 1007,
  X6 = 1007,
  Hl = 1008,
  q6 = 1008,
  es = 1009,
  EF = 1010,
  MF = 1011,
  Jy = 1012,
  WM = 1013,
  Ls = 1014,
  wa = 1015,
  df = 1016,
  XM = 1017,
  qM = 1018,
  Nl = 1020,
  CF = 1021,
  Ii = 1023,
  TF = 1024,
  AF = 1025,
  Fl = 1026,
  cu = 1027,
  RF = 1028,
  KM = 1029,
  PF = 1030,
  YM = 1031,
  ZM = 1033,
  g0 = 33776,
  v0 = 33777,
  y0 = 33778,
  x0 = 33779,
  iw = 35840,
  ow = 35841,
  aw = 35842,
  sw = 35843,
  QM = 36196,
  lw = 37492,
  cw = 37496,
  uw = 37808,
  dw = 37809,
  fw = 37810,
  hw = 37811,
  pw = 37812,
  mw = 37813,
  gw = 37814,
  vw = 37815,
  yw = 37816,
  xw = 37817,
  Sw = 37818,
  _w = 37819,
  bw = 37820,
  ww = 37821,
  S0 = 36492,
  Ew = 36494,
  Mw = 36495,
  IF = 36283,
  Cw = 36284,
  Tw = 36285,
  Aw = 36286,
  LF = 2200,
  OF = 2201,
  NF = 2202,
  Pp = 2300,
  Ip = 2301,
  _0 = 2302,
  kc = 2400,
  Bc = 2401,
  Lp = 2402,
  e1 = 2500,
  JM = 2501,
  K6 = 0,
  Y6 = 1,
  Z6 = 2,
  eC = 3e3,
  Dl = 3001,
  FF = 3200,
  tC = 3201,
  Yl = 0,
  DF = 1,
  _o = "",
  Tr = "srgb",
  rs = "srgb-linear",
  t1 = "display-p3",
  fm = "display-p3-linear",
  Op = "linear",
  Un = "srgb",
  Np = "rec709",
  Fp = "p3",
  Q6 = 0,
  Rc = 7680,
  J6 = 7681,
  eH = 7682,
  tH = 7683,
  nH = 34055,
  rH = 34056,
  iH = 5386,
  oH = 512,
  aH = 513,
  sH = 514,
  lH = 515,
  cH = 516,
  uH = 517,
  dH = 518,
  Rw = 519,
  zF = 512,
  UF = 513,
  kF = 514,
  nC = 515,
  BF = 516,
  HF = 517,
  jF = 518,
  VF = 519,
  Dp = 35044,
  fH = 35048,
  hH = 35040,
  pH = 35045,
  mH = 35049,
  gH = 35041,
  vH = 35046,
  yH = 35050,
  xH = 35042,
  SH = "100",
  Pw = "300 es",
  uy = 1035,
  Ea = 2e3,
  ff = 2001;
let qs = class {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(n);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, a = i.length; o < a; o++) i[o].call(this, e);
      e.target = null;
    }
  }
};
const li = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let pR = 1234567;
const Kc = Math.PI / 180,
  hf = 180 / Math.PI;
function Ao() {
  const t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    li[t & 255] +
    li[(t >> 8) & 255] +
    li[(t >> 16) & 255] +
    li[(t >> 24) & 255] +
    "-" +
    li[e & 255] +
    li[(e >> 8) & 255] +
    "-" +
    li[((e >> 16) & 15) | 64] +
    li[(e >> 24) & 255] +
    "-" +
    li[(n & 63) | 128] +
    li[(n >> 8) & 255] +
    "-" +
    li[(n >> 16) & 255] +
    li[(n >> 24) & 255] +
    li[r & 255] +
    li[(r >> 8) & 255] +
    li[(r >> 16) & 255] +
    li[(r >> 24) & 255]
  ).toLowerCase();
}
function ar(t, e, n) {
  return Math.max(e, Math.min(n, t));
}
function rC(t, e) {
  return ((t % e) + e) % e;
}
function _H(t, e, n, r, i) {
  return r + ((t - e) * (i - r)) / (n - e);
}
function bH(t, e, n) {
  return t !== e ? (n - t) / (e - t) : 0;
}
function Zh(t, e, n) {
  return (1 - n) * t + n * e;
}
function wH(t, e, n, r) {
  return Zh(t, e, 1 - Math.exp(-n * r));
}
function EH(t, e = 1) {
  return e - Math.abs(rC(t, e * 2) - e);
}
function MH(t, e, n) {
  return t <= e
    ? 0
    : t >= n
    ? 1
    : ((t = (t - e) / (n - e)), t * t * (3 - 2 * t));
}
function CH(t, e, n) {
  return t <= e
    ? 0
    : t >= n
    ? 1
    : ((t = (t - e) / (n - e)), t * t * t * (t * (t * 6 - 15) + 10));
}
function TH(t, e) {
  return t + Math.floor(Math.random() * (e - t + 1));
}
function AH(t, e) {
  return t + Math.random() * (e - t);
}
function RH(t) {
  return t * (0.5 - Math.random());
}
function PH(t) {
  t !== void 0 && (pR = t);
  let e = (pR += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function IH(t) {
  return t * Kc;
}
function LH(t) {
  return t * hf;
}
function Iw(t) {
  return (t & (t - 1)) === 0 && t !== 0;
}
function OH(t) {
  return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
}
function dy(t) {
  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
}
function NH(t, e, n, r, i) {
  const o = Math.cos,
    a = Math.sin,
    s = o(n / 2),
    l = a(n / 2),
    c = o((e + r) / 2),
    u = a((e + r) / 2),
    d = o((e - r) / 2),
    p = a((e - r) / 2),
    m = o((r - e) / 2),
    v = a((r - e) / 2);
  switch (i) {
    case "XYX":
      t.set(s * u, l * d, l * p, s * c);
      break;
    case "YZY":
      t.set(l * p, s * u, l * d, s * c);
      break;
    case "ZXZ":
      t.set(l * d, l * p, s * u, s * c);
      break;
    case "XZX":
      t.set(s * u, l * v, l * m, s * c);
      break;
    case "YXY":
      t.set(l * m, s * u, l * v, s * c);
      break;
    case "ZYZ":
      t.set(l * v, l * m, s * u, s * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function Ki(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return t / 4294967295;
    case Uint16Array:
      return t / 65535;
    case Uint8Array:
      return t / 255;
    case Int32Array:
      return Math.max(t / 2147483647, -1);
    case Int16Array:
      return Math.max(t / 32767, -1);
    case Int8Array:
      return Math.max(t / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Zt(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return Math.round(t * 4294967295);
    case Uint16Array:
      return Math.round(t * 65535);
    case Uint8Array:
      return Math.round(t * 255);
    case Int32Array:
      return Math.round(t * 2147483647);
    case Int16Array:
      return Math.round(t * 32767);
    case Int8Array:
      return Math.round(t * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const $F = {
  DEG2RAD: Kc,
  RAD2DEG: hf,
  generateUUID: Ao,
  clamp: ar,
  euclideanModulo: rC,
  mapLinear: _H,
  inverseLerp: bH,
  lerp: Zh,
  damp: wH,
  pingpong: EH,
  smoothstep: MH,
  smootherstep: CH,
  randInt: TH,
  randFloat: AH,
  randFloatSpread: RH,
  seededRandom: PH,
  degToRad: IH,
  radToDeg: LH,
  isPowerOfTwo: Iw,
  ceilPowerOfTwo: OH,
  floorPowerOfTwo: dy,
  setQuaternionFromProperEuler: NH,
  normalize: Zt,
  denormalize: Ki,
};
class Ge {
  constructor(e = 0, n = 0) {
    (Ge.prototype.isVector2 = !0), (this.x = e), (this.y = n);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return (this.x = e), (this.y = n), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, n) {
    return (this.x = e.x + n.x), (this.y = e.y + n.y), this;
  }
  addScaledVector(e, n) {
    return (this.x += e.x * n), (this.y += e.y * n), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, n) {
    return (this.x = e.x - n.x), (this.y = e.y - n.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x,
      r = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * n + i[3] * r + i[6]),
      (this.y = i[1] * n + i[4] * r + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      this
    );
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(n, r))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const r = this.dot(e) / n;
    return Math.acos(ar(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x,
      r = this.y - e.y;
    return n * n + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (this.x += (e.x - this.x) * n), (this.y += (e.y - this.y) * n), this;
  }
  lerpVectors(e, n, r) {
    return (
      (this.x = e.x + (n.x - e.x) * r), (this.y = e.y + (n.y - e.y) * r), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return (this.x = e[n]), (this.y = e[n + 1]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.x), (e[n + 1] = this.y), e;
  }
  fromBufferAttribute(e, n) {
    return (this.x = e.getX(n)), (this.y = e.getY(n)), this;
  }
  rotateAround(e, n) {
    const r = Math.cos(n),
      i = Math.sin(n),
      o = this.x - e.x,
      a = this.y - e.y;
    return (this.x = o * r - a * i + e.x), (this.y = o * i + a * r + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Yt {
  constructor(e, n, r, i, o, a, s, l, c) {
    (Yt.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, n, r, i, o, a, s, l, c);
  }
  set(e, n, r, i, o, a, s, l, c) {
    const u = this.elements;
    return (
      (u[0] = e),
      (u[1] = i),
      (u[2] = s),
      (u[3] = n),
      (u[4] = o),
      (u[5] = l),
      (u[6] = r),
      (u[7] = a),
      (u[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const n = this.elements,
      r = e.elements;
    return (
      (n[0] = r[0]),
      (n[1] = r[1]),
      (n[2] = r[2]),
      (n[3] = r[3]),
      (n[4] = r[4]),
      (n[5] = r[5]),
      (n[6] = r[6]),
      (n[7] = r[7]),
      (n[8] = r[8]),
      this
    );
  }
  extractBasis(e, n, r) {
    return (
      e.setFromMatrix3Column(this, 0),
      n.setFromMatrix3Column(this, 1),
      r.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return (
      this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const r = e.elements,
      i = n.elements,
      o = this.elements,
      a = r[0],
      s = r[3],
      l = r[6],
      c = r[1],
      u = r[4],
      d = r[7],
      p = r[2],
      m = r[5],
      v = r[8],
      S = i[0],
      x = i[3],
      g = i[6],
      _ = i[1],
      y = i[4],
      w = i[7],
      A = i[2],
      M = i[5],
      T = i[8];
    return (
      (o[0] = a * S + s * _ + l * A),
      (o[3] = a * x + s * y + l * M),
      (o[6] = a * g + s * w + l * T),
      (o[1] = c * S + u * _ + d * A),
      (o[4] = c * x + u * y + d * M),
      (o[7] = c * g + u * w + d * T),
      (o[2] = p * S + m * _ + v * A),
      (o[5] = p * x + m * y + v * M),
      (o[8] = p * g + m * w + v * T),
      this
    );
  }
  multiplyScalar(e) {
    const n = this.elements;
    return (
      (n[0] *= e),
      (n[3] *= e),
      (n[6] *= e),
      (n[1] *= e),
      (n[4] *= e),
      (n[7] *= e),
      (n[2] *= e),
      (n[5] *= e),
      (n[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      n = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      a = e[4],
      s = e[5],
      l = e[6],
      c = e[7],
      u = e[8];
    return (
      n * a * u - n * s * c - r * o * u + r * s * l + i * o * c - i * a * l
    );
  }
  invert() {
    const e = this.elements,
      n = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      a = e[4],
      s = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      d = u * a - s * c,
      p = s * l - u * o,
      m = c * o - a * l,
      v = n * d + r * p + i * m;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const S = 1 / v;
    return (
      (e[0] = d * S),
      (e[1] = (i * c - u * r) * S),
      (e[2] = (s * r - i * a) * S),
      (e[3] = p * S),
      (e[4] = (u * n - i * l) * S),
      (e[5] = (i * o - s * n) * S),
      (e[6] = m * S),
      (e[7] = (r * l - c * n) * S),
      (e[8] = (a * n - r * o) * S),
      this
    );
  }
  transpose() {
    let e;
    const n = this.elements;
    return (
      (e = n[1]),
      (n[1] = n[3]),
      (n[3] = e),
      (e = n[2]),
      (n[2] = n[6]),
      (n[6] = e),
      (e = n[5]),
      (n[5] = n[7]),
      (n[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[3]),
      (e[2] = n[6]),
      (e[3] = n[1]),
      (e[4] = n[4]),
      (e[5] = n[7]),
      (e[6] = n[2]),
      (e[7] = n[5]),
      (e[8] = n[8]),
      this
    );
  }
  setUvTransform(e, n, r, i, o, a, s) {
    const l = Math.cos(o),
      c = Math.sin(o);
    return (
      this.set(
        r * l,
        r * c,
        -r * (l * a + c * s) + a + e,
        -i * c,
        i * l,
        -i * (-c * a + l * s) + s + n,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, n) {
    return this.premultiply(MS.makeScale(e, n)), this;
  }
  rotate(e) {
    return this.premultiply(MS.makeRotation(-e)), this;
  }
  translate(e, n) {
    return this.premultiply(MS.makeTranslation(e, n)), this;
  }
  makeTranslation(e, n) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, n, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const n = Math.cos(e),
      r = Math.sin(e);
    return this.set(n, -r, 0, r, n, 0, 0, 0, 1), this;
  }
  makeScale(e, n) {
    return this.set(e, 0, 0, 0, n, 0, 0, 0, 1), this;
  }
  equals(e) {
    const n = this.elements,
      r = e.elements;
    for (let i = 0; i < 9; i++) if (n[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let r = 0; r < 9; r++) this.elements[r] = e[r + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.elements;
    return (
      (e[n] = r[0]),
      (e[n + 1] = r[1]),
      (e[n + 2] = r[2]),
      (e[n + 3] = r[3]),
      (e[n + 4] = r[4]),
      (e[n + 5] = r[5]),
      (e[n + 6] = r[6]),
      (e[n + 7] = r[7]),
      (e[n + 8] = r[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const MS = new Yt();
function GF(t) {
  for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
  return !1;
}
const FH = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Ud(t, e) {
  return new FH[t](e);
}
function zp(t) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", t);
}
function WF() {
  const t = zp("canvas");
  return (t.style.display = "block"), t;
}
const mR = {};
function Qh(t) {
  t in mR || ((mR[t] = !0), console.warn(t));
}
const gR = new Yt().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  vR = new Yt().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  Bg = {
    [rs]: {
      transfer: Op,
      primaries: Np,
      toReference: (t) => t,
      fromReference: (t) => t,
    },
    [Tr]: {
      transfer: Un,
      primaries: Np,
      toReference: (t) => t.convertSRGBToLinear(),
      fromReference: (t) => t.convertLinearToSRGB(),
    },
    [fm]: {
      transfer: Op,
      primaries: Fp,
      toReference: (t) => t.applyMatrix3(vR),
      fromReference: (t) => t.applyMatrix3(gR),
    },
    [t1]: {
      transfer: Un,
      primaries: Fp,
      toReference: (t) => t.convertSRGBToLinear().applyMatrix3(vR),
      fromReference: (t) => t.applyMatrix3(gR).convertLinearToSRGB(),
    },
  },
  DH = new Set([rs, fm]),
  Mn = {
    enabled: !0,
    _workingColorSpace: rs,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(t) {
      if (!DH.has(t))
        throw new Error(`Unsupported working color space, "${t}".`);
      this._workingColorSpace = t;
    },
    convert: function (t, e, n) {
      if (this.enabled === !1 || e === n || !e || !n) return t;
      const r = Bg[e].toReference,
        i = Bg[n].fromReference;
      return i(r(t));
    },
    fromWorkingColorSpace: function (t, e) {
      return this.convert(t, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function (t, e) {
      return this.convert(t, e, this._workingColorSpace);
    },
    getPrimaries: function (t) {
      return Bg[t].primaries;
    },
    getTransfer: function (t) {
      return t === _o ? Op : Bg[t].transfer;
    },
  };
function Jd(t) {
  return t < 0.04045
    ? t * 0.0773993808
    : Math.pow(t * 0.9478672986 + 0.0521327014, 2.4);
}
function CS(t) {
  return t < 0.0031308 ? t * 12.92 : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
let Hu;
class iC {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let n;
    if (e instanceof HTMLCanvasElement) n = e;
    else {
      Hu === void 0 && (Hu = zp("canvas")),
        (Hu.width = e.width),
        (Hu.height = e.height);
      const r = Hu.getContext("2d");
      e instanceof ImageData
        ? r.putImageData(e, 0, 0)
        : r.drawImage(e, 0, 0, e.width, e.height),
        (n = Hu);
    }
    return n.width > 2048 || n.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        n.toDataURL("image/jpeg", 0.6))
      : n.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const n = zp("canvas");
      (n.width = e.width), (n.height = e.height);
      const r = n.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height),
        o = i.data;
      for (let a = 0; a < o.length; a++) o[a] = Jd(o[a] / 255) * 255;
      return r.putImageData(i, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let r = 0; r < n.length; r++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray
          ? (n[r] = Math.floor(Jd(n[r] / 255) * 255))
          : (n[r] = Jd(n[r]));
      return { data: n, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let zH = 0;
class Hc {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: zH++ }),
      (this.uuid = Ao()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const r = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let o;
      if (Array.isArray(i)) {
        o = [];
        for (let a = 0, s = i.length; a < s; a++)
          i[a].isDataTexture ? o.push(TS(i[a].image)) : o.push(TS(i[a]));
      } else o = TS(i);
      r.url = o;
    }
    return n || (e.images[this.uuid] = r), r;
  }
}
function TS(t) {
  return (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && t instanceof ImageBitmap)
    ? iC.getDataURL(t)
    : t.data
    ? {
        data: Array.from(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let UH = 0;
class sr extends qs {
  constructor(
    e = sr.DEFAULT_IMAGE,
    n = sr.DEFAULT_MAPPING,
    r = pi,
    i = pi,
    o = Yn,
    a = Hl,
    s = Ii,
    l = es,
    c = sr.DEFAULT_ANISOTROPY,
    u = _o
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: UH++ }),
      (this.uuid = Ao()),
      (this.name = ""),
      (this.source = new Hc(e)),
      (this.mipmaps = []),
      (this.mapping = n),
      (this.channel = 0),
      (this.wrapS = r),
      (this.wrapT = i),
      (this.magFilter = o),
      (this.minFilter = a),
      (this.anisotropy = c),
      (this.format = s),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new Ge(0, 0)),
      (this.repeat = new Ge(1, 1)),
      (this.center = new Ge(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Yt()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof u == "string"
        ? (this.colorSpace = u)
        : (Qh(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace = u === Dl ? Tr : _o)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const r = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      n || (e.textures[this.uuid] = r),
      r
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Qy) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Ap:
          e.x = e.x - Math.floor(e.x);
          break;
        case pi:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Rp:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Ap:
          e.y = e.y - Math.floor(e.y);
          break;
        case pi:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Rp:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      Qh("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      this.colorSpace === Tr ? Dl : eC
    );
  }
  set encoding(e) {
    Qh("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      (this.colorSpace = e === Dl ? Tr : _o);
  }
}
sr.DEFAULT_IMAGE = null;
sr.DEFAULT_MAPPING = Qy;
sr.DEFAULT_ANISOTROPY = 1;
class rn {
  constructor(e = 0, n = 0, r = 0, i = 1) {
    (rn.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = n),
      (this.z = r),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, r, i) {
    return (this.x = e), (this.y = n), (this.z = r), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, n) {
    return (
      (this.x = e.x + n.x),
      (this.y = e.y + n.y),
      (this.z = e.z + n.z),
      (this.w = e.w + n.w),
      this
    );
  }
  addScaledVector(e, n) {
    return (
      (this.x += e.x * n),
      (this.y += e.y * n),
      (this.z += e.z * n),
      (this.w += e.w * n),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, n) {
    return (
      (this.x = e.x - n.x),
      (this.y = e.y - n.y),
      (this.z = e.z - n.z),
      (this.w = e.w - n.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      o = this.w,
      a = e.elements;
    return (
      (this.x = a[0] * n + a[4] * r + a[8] * i + a[12] * o),
      (this.y = a[1] * n + a[5] * r + a[9] * i + a[13] * o),
      (this.z = a[2] * n + a[6] * r + a[10] * i + a[14] * o),
      (this.w = a[3] * n + a[7] * r + a[11] * i + a[15] * o),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return (
      n < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / n), (this.y = e.y / n), (this.z = e.z / n)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, r, i, o;
    const l = e.elements,
      c = l[0],
      u = l[4],
      d = l[8],
      p = l[1],
      m = l[5],
      v = l[9],
      S = l[2],
      x = l[6],
      g = l[10];
    if (
      Math.abs(u - p) < 0.01 &&
      Math.abs(d - S) < 0.01 &&
      Math.abs(v - x) < 0.01
    ) {
      if (
        Math.abs(u + p) < 0.1 &&
        Math.abs(d + S) < 0.1 &&
        Math.abs(v + x) < 0.1 &&
        Math.abs(c + m + g - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const y = (c + 1) / 2,
        w = (m + 1) / 2,
        A = (g + 1) / 2,
        M = (u + p) / 4,
        T = (d + S) / 4,
        I = (v + x) / 4;
      return (
        y > w && y > A
          ? y < 0.01
            ? ((r = 0), (i = 0.707106781), (o = 0.707106781))
            : ((r = Math.sqrt(y)), (i = M / r), (o = T / r))
          : w > A
          ? w < 0.01
            ? ((r = 0.707106781), (i = 0), (o = 0.707106781))
            : ((i = Math.sqrt(w)), (r = M / i), (o = I / i))
          : A < 0.01
          ? ((r = 0.707106781), (i = 0.707106781), (o = 0))
          : ((o = Math.sqrt(A)), (r = T / o), (i = I / o)),
        this.set(r, i, o, n),
        this
      );
    }
    let _ = Math.sqrt(
      (x - v) * (x - v) + (d - S) * (d - S) + (p - u) * (p - u)
    );
    return (
      Math.abs(_) < 0.001 && (_ = 1),
      (this.x = (x - v) / _),
      (this.y = (d - S) / _),
      (this.z = (p - u) / _),
      (this.w = Math.acos((c + m + g - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      (this.z = Math.max(e.z, Math.min(n.z, this.z))),
      (this.w = Math.max(e.w, Math.min(n.w, this.w))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      (this.z = Math.max(e, Math.min(n, this.z))),
      (this.w = Math.max(e, Math.min(n, this.w))),
      this
    );
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(n, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (
      (this.x += (e.x - this.x) * n),
      (this.y += (e.y - this.y) * n),
      (this.z += (e.z - this.z) * n),
      (this.w += (e.w - this.w) * n),
      this
    );
  }
  lerpVectors(e, n, r) {
    return (
      (this.x = e.x + (n.x - e.x) * r),
      (this.y = e.y + (n.y - e.y) * r),
      (this.z = e.z + (n.z - e.z) * r),
      (this.w = e.w + (n.w - e.w) * r),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return (
      (this.x = e[n]),
      (this.y = e[n + 1]),
      (this.z = e[n + 2]),
      (this.w = e[n + 3]),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this.x),
      (e[n + 1] = this.y),
      (e[n + 2] = this.z),
      (e[n + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, n) {
    return (
      (this.x = e.getX(n)),
      (this.y = e.getY(n)),
      (this.z = e.getZ(n)),
      (this.w = e.getW(n)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class XF extends qs {
  constructor(e = 1, n = 1, r = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = n),
      (this.depth = 1),
      (this.scissor = new rn(0, 0, e, n)),
      (this.scissorTest = !1),
      (this.viewport = new rn(0, 0, e, n));
    const i = { width: e, height: n, depth: 1 };
    r.encoding !== void 0 &&
      (Qh(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (r.colorSpace = r.encoding === Dl ? Tr : _o)),
      (r = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: Yn,
          depthBuffer: !0,
          stencilBuffer: !1,
          depthTexture: null,
          samples: 0,
        },
        r
      )),
      (this.texture = new sr(
        i,
        r.mapping,
        r.wrapS,
        r.wrapT,
        r.magFilter,
        r.minFilter,
        r.format,
        r.type,
        r.anisotropy,
        r.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps = r.generateMipmaps),
      (this.texture.internalFormat = r.internalFormat),
      (this.depthBuffer = r.depthBuffer),
      (this.stencilBuffer = r.stencilBuffer),
      (this.depthTexture = r.depthTexture),
      (this.samples = r.samples);
  }
  setSize(e, n, r = 1) {
    (this.width !== e || this.height !== n || this.depth !== r) &&
      ((this.width = e),
      (this.height = n),
      (this.depth = r),
      (this.texture.image.width = e),
      (this.texture.image.height = n),
      (this.texture.image.depth = r),
      this.dispose()),
      this.viewport.set(0, 0, e, n),
      this.scissor.set(0, 0, e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const n = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Hc(n)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Pa extends XF {
  constructor(e = 1, n = 1, r = {}) {
    super(e, n, r), (this.isWebGLRenderTarget = !0);
  }
}
class n1 extends sr {
  constructor(e = null, n = 1, r = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: n, height: r, depth: i }),
      (this.magFilter = pr),
      (this.minFilter = pr),
      (this.wrapR = pi),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class kH extends Pa {
  constructor(e = 1, n = 1, r = 1, i = {}) {
    super(e, n, i),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = r),
      (this.texture = new n1(null, e, n, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class oC extends sr {
  constructor(e = null, n = 1, r = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: n, height: r, depth: i }),
      (this.magFilter = pr),
      (this.minFilter = pr),
      (this.wrapR = pi),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class BH extends Pa {
  constructor(e = 1, n = 1, r = 1, i = {}) {
    super(e, n, i),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = r),
      (this.texture = new oC(null, e, n, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class HH extends Pa {
  constructor(e = 1, n = 1, r = 1, i = {}) {
    super(e, n, i), (this.isWebGLMultipleRenderTargets = !0);
    const o = this.texture;
    this.texture = [];
    for (let a = 0; a < r; a++)
      (this.texture[a] = o.clone()),
        (this.texture[a].isRenderTargetTexture = !0);
  }
  setSize(e, n, r = 1) {
    if (this.width !== e || this.height !== n || this.depth !== r) {
      (this.width = e), (this.height = n), (this.depth = r);
      for (let i = 0, o = this.texture.length; i < o; i++)
        (this.texture[i].image.width = e),
          (this.texture[i].image.height = n),
          (this.texture[i].image.depth = r);
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  copy(e) {
    this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.texture.length = 0);
    for (let n = 0, r = e.texture.length; n < r; n++)
      (this.texture[n] = e.texture[n].clone()),
        (this.texture[n].isRenderTargetTexture = !0);
    return this;
  }
}
class mi {
  constructor(e = 0, n = 0, r = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = n),
      (this._z = r),
      (this._w = i);
  }
  static slerpFlat(e, n, r, i, o, a, s) {
    let l = r[i + 0],
      c = r[i + 1],
      u = r[i + 2],
      d = r[i + 3];
    const p = o[a + 0],
      m = o[a + 1],
      v = o[a + 2],
      S = o[a + 3];
    if (s === 0) {
      (e[n + 0] = l), (e[n + 1] = c), (e[n + 2] = u), (e[n + 3] = d);
      return;
    }
    if (s === 1) {
      (e[n + 0] = p), (e[n + 1] = m), (e[n + 2] = v), (e[n + 3] = S);
      return;
    }
    if (d !== S || l !== p || c !== m || u !== v) {
      let x = 1 - s;
      const g = l * p + c * m + u * v + d * S,
        _ = g >= 0 ? 1 : -1,
        y = 1 - g * g;
      if (y > Number.EPSILON) {
        const A = Math.sqrt(y),
          M = Math.atan2(A, g * _);
        (x = Math.sin(x * M) / A), (s = Math.sin(s * M) / A);
      }
      const w = s * _;
      if (
        ((l = l * x + p * w),
        (c = c * x + m * w),
        (u = u * x + v * w),
        (d = d * x + S * w),
        x === 1 - s)
      ) {
        const A = 1 / Math.sqrt(l * l + c * c + u * u + d * d);
        (l *= A), (c *= A), (u *= A), (d *= A);
      }
    }
    (e[n] = l), (e[n + 1] = c), (e[n + 2] = u), (e[n + 3] = d);
  }
  static multiplyQuaternionsFlat(e, n, r, i, o, a) {
    const s = r[i],
      l = r[i + 1],
      c = r[i + 2],
      u = r[i + 3],
      d = o[a],
      p = o[a + 1],
      m = o[a + 2],
      v = o[a + 3];
    return (
      (e[n] = s * v + u * d + l * m - c * p),
      (e[n + 1] = l * v + u * p + c * d - s * m),
      (e[n + 2] = c * v + u * m + s * p - l * d),
      (e[n + 3] = u * v - s * d - l * p - c * m),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, n, r, i) {
    return (
      (this._x = e),
      (this._y = n),
      (this._z = r),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, n = !0) {
    const r = e._x,
      i = e._y,
      o = e._z,
      a = e._order,
      s = Math.cos,
      l = Math.sin,
      c = s(r / 2),
      u = s(i / 2),
      d = s(o / 2),
      p = l(r / 2),
      m = l(i / 2),
      v = l(o / 2);
    switch (a) {
      case "XYZ":
        (this._x = p * u * d + c * m * v),
          (this._y = c * m * d - p * u * v),
          (this._z = c * u * v + p * m * d),
          (this._w = c * u * d - p * m * v);
        break;
      case "YXZ":
        (this._x = p * u * d + c * m * v),
          (this._y = c * m * d - p * u * v),
          (this._z = c * u * v - p * m * d),
          (this._w = c * u * d + p * m * v);
        break;
      case "ZXY":
        (this._x = p * u * d - c * m * v),
          (this._y = c * m * d + p * u * v),
          (this._z = c * u * v + p * m * d),
          (this._w = c * u * d - p * m * v);
        break;
      case "ZYX":
        (this._x = p * u * d - c * m * v),
          (this._y = c * m * d + p * u * v),
          (this._z = c * u * v - p * m * d),
          (this._w = c * u * d + p * m * v);
        break;
      case "YZX":
        (this._x = p * u * d + c * m * v),
          (this._y = c * m * d + p * u * v),
          (this._z = c * u * v - p * m * d),
          (this._w = c * u * d - p * m * v);
        break;
      case "XZY":
        (this._x = p * u * d - c * m * v),
          (this._y = c * m * d - p * u * v),
          (this._z = c * u * v + p * m * d),
          (this._w = c * u * d + p * m * v);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a
        );
    }
    return n === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const r = n / 2,
      i = Math.sin(r);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(r)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const n = e.elements,
      r = n[0],
      i = n[4],
      o = n[8],
      a = n[1],
      s = n[5],
      l = n[9],
      c = n[2],
      u = n[6],
      d = n[10],
      p = r + s + d;
    if (p > 0) {
      const m = 0.5 / Math.sqrt(p + 1);
      (this._w = 0.25 / m),
        (this._x = (u - l) * m),
        (this._y = (o - c) * m),
        (this._z = (a - i) * m);
    } else if (r > s && r > d) {
      const m = 2 * Math.sqrt(1 + r - s - d);
      (this._w = (u - l) / m),
        (this._x = 0.25 * m),
        (this._y = (i + a) / m),
        (this._z = (o + c) / m);
    } else if (s > d) {
      const m = 2 * Math.sqrt(1 + s - r - d);
      (this._w = (o - c) / m),
        (this._x = (i + a) / m),
        (this._y = 0.25 * m),
        (this._z = (l + u) / m);
    } else {
      const m = 2 * Math.sqrt(1 + d - r - s);
      (this._w = (a - i) / m),
        (this._x = (o + c) / m),
        (this._y = (l + u) / m),
        (this._z = 0.25 * m);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let r = e.dot(n) + 1;
    return (
      r < Number.EPSILON
        ? ((r = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = r))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = r)))
        : ((this._x = e.y * n.z - e.z * n.y),
          (this._y = e.z * n.x - e.x * n.z),
          (this._z = e.x * n.y - e.y * n.x),
          (this._w = r)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(ar(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const i = Math.min(1, n / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const r = e._x,
      i = e._y,
      o = e._z,
      a = e._w,
      s = n._x,
      l = n._y,
      c = n._z,
      u = n._w;
    return (
      (this._x = r * u + a * s + i * c - o * l),
      (this._y = i * u + a * l + o * s - r * c),
      (this._z = o * u + a * c + r * l - i * s),
      (this._w = a * u - r * s - i * l - o * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const r = this._x,
      i = this._y,
      o = this._z,
      a = this._w;
    let s = a * e._w + r * e._x + i * e._y + o * e._z;
    if (
      (s < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (s = -s))
        : this.copy(e),
      s >= 1)
    )
      return (this._w = a), (this._x = r), (this._y = i), (this._z = o), this;
    const l = 1 - s * s;
    if (l <= Number.EPSILON) {
      const m = 1 - n;
      return (
        (this._w = m * a + n * this._w),
        (this._x = m * r + n * this._x),
        (this._y = m * i + n * this._y),
        (this._z = m * o + n * this._z),
        this.normalize(),
        this
      );
    }
    const c = Math.sqrt(l),
      u = Math.atan2(c, s),
      d = Math.sin((1 - n) * u) / c,
      p = Math.sin(n * u) / c;
    return (
      (this._w = a * d + this._w * p),
      (this._x = r * d + this._x * p),
      (this._y = i * d + this._y * p),
      (this._z = o * d + this._z * p),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, n, r) {
    return this.copy(e).slerp(n, r);
  }
  random() {
    const e = Math.random(),
      n = Math.sqrt(1 - e),
      r = Math.sqrt(e),
      i = 2 * Math.PI * Math.random(),
      o = 2 * Math.PI * Math.random();
    return this.set(
      n * Math.cos(i),
      r * Math.sin(o),
      r * Math.cos(o),
      n * Math.sin(i)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, n = 0) {
    return (
      (this._x = e[n]),
      (this._y = e[n + 1]),
      (this._z = e[n + 2]),
      (this._w = e[n + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this._x),
      (e[n + 1] = this._y),
      (e[n + 2] = this._z),
      (e[n + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, n) {
    return (
      (this._x = e.getX(n)),
      (this._y = e.getY(n)),
      (this._z = e.getZ(n)),
      (this._w = e.getW(n)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class K {
  constructor(e = 0, n = 0, r = 0) {
    (K.prototype.isVector3 = !0), (this.x = e), (this.y = n), (this.z = r);
  }
  set(e, n, r) {
    return (
      r === void 0 && (r = this.z),
      (this.x = e),
      (this.y = n),
      (this.z = r),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, n) {
    return (
      (this.x = e.x + n.x), (this.y = e.y + n.y), (this.z = e.z + n.z), this
    );
  }
  addScaledVector(e, n) {
    return (this.x += e.x * n), (this.y += e.y * n), (this.z += e.z * n), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, n) {
    return (
      (this.x = e.x - n.x), (this.y = e.y - n.y), (this.z = e.z - n.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, n) {
    return (
      (this.x = e.x * n.x), (this.y = e.y * n.y), (this.z = e.z * n.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(yR.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(yR.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * n + o[3] * r + o[6] * i),
      (this.y = o[1] * n + o[4] * r + o[7] * i),
      (this.z = o[2] * n + o[5] * r + o[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      o = e.elements,
      a = 1 / (o[3] * n + o[7] * r + o[11] * i + o[15]);
    return (
      (this.x = (o[0] * n + o[4] * r + o[8] * i + o[12]) * a),
      (this.y = (o[1] * n + o[5] * r + o[9] * i + o[13]) * a),
      (this.z = (o[2] * n + o[6] * r + o[10] * i + o[14]) * a),
      this
    );
  }
  applyQuaternion(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      o = e.x,
      a = e.y,
      s = e.z,
      l = e.w,
      c = 2 * (a * i - s * r),
      u = 2 * (s * n - o * i),
      d = 2 * (o * r - a * n);
    return (
      (this.x = n + l * c + a * d - s * u),
      (this.y = r + l * u + s * c - o * d),
      (this.z = i + l * d + o * u - a * c),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * n + o[4] * r + o[8] * i),
      (this.y = o[1] * n + o[5] * r + o[9] * i),
      (this.z = o[2] * n + o[6] * r + o[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      (this.z = Math.max(e.z, Math.min(n.z, this.z))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      (this.z = Math.max(e, Math.min(n, this.z))),
      this
    );
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(n, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (
      (this.x += (e.x - this.x) * n),
      (this.y += (e.y - this.y) * n),
      (this.z += (e.z - this.z) * n),
      this
    );
  }
  lerpVectors(e, n, r) {
    return (
      (this.x = e.x + (n.x - e.x) * r),
      (this.y = e.y + (n.y - e.y) * r),
      (this.z = e.z + (n.z - e.z) * r),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const r = e.x,
      i = e.y,
      o = e.z,
      a = n.x,
      s = n.y,
      l = n.z;
    return (
      (this.x = i * l - o * s),
      (this.y = o * a - r * l),
      (this.z = r * s - i * a),
      this
    );
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / n;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return AS.copy(this).projectOnVector(e), this.sub(AS);
  }
  reflect(e) {
    return this.sub(AS.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const r = this.dot(e) / n;
    return Math.acos(ar(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x,
      r = this.y - e.y,
      i = this.z - e.z;
    return n * n + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, r) {
    const i = Math.sin(n) * e;
    return (
      (this.x = i * Math.sin(r)),
      (this.y = Math.cos(n) * e),
      (this.z = i * Math.cos(r)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, r) {
    return (
      (this.x = e * Math.sin(n)), (this.y = r), (this.z = e * Math.cos(n)), this
    );
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return (this.x = n[12]), (this.y = n[13]), (this.z = n[14]), this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(),
      r = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = n), (this.y = r), (this.z = i), this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return (this.x = e[n]), (this.y = e[n + 1]), (this.z = e[n + 2]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.x), (e[n + 1] = this.y), (e[n + 2] = this.z), e;
  }
  fromBufferAttribute(e, n) {
    return (
      (this.x = e.getX(n)), (this.y = e.getY(n)), (this.z = e.getZ(n)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      n = Math.random() * Math.PI * 2,
      r = Math.sqrt(1 - e ** 2);
    return (
      (this.x = r * Math.cos(n)), (this.y = r * Math.sin(n)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const AS = new K(),
  yR = new mi();
class wr {
  constructor(
    e = new K(1 / 0, 1 / 0, 1 / 0),
    n = new K(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = n);
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n += 3)
      this.expandByPoint(ua.fromArray(e, n));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, r = e.count; n < r; n++)
      this.expandByPoint(ua.fromBufferAttribute(e, n));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n++) this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const r = ua.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const o = r.getAttribute("position");
      if (n === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, s = o.count; a < s; a++)
          e.isMesh === !0
            ? e.getVertexPosition(a, ua)
            : ua.fromBufferAttribute(o, a),
            ua.applyMatrix4(e.matrixWorld),
            this.expandByPoint(ua);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            Hg.copy(e.boundingBox))
          : (r.boundingBox === null && r.computeBoundingBox(),
            Hg.copy(r.boundingBox)),
          Hg.applyMatrix4(e.matrixWorld),
          this.union(Hg);
    }
    const i = e.children;
    for (let o = 0, a = i.length; o < a; o++) this.expandByObject(i[o], n);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, ua),
      ua.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let n, r;
    return (
      e.normal.x > 0
        ? ((n = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
        : ((n = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((n += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
        : ((n += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((n += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
        : ((n += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
      n <= -e.constant && r >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(ch),
      jg.subVectors(this.max, ch),
      ju.subVectors(e.a, ch),
      Vu.subVectors(e.b, ch),
      $u.subVectors(e.c, ch),
      sl.subVectors(Vu, ju),
      ll.subVectors($u, Vu),
      hc.subVectors(ju, $u);
    let n = [
      0,
      -sl.z,
      sl.y,
      0,
      -ll.z,
      ll.y,
      0,
      -hc.z,
      hc.y,
      sl.z,
      0,
      -sl.x,
      ll.z,
      0,
      -ll.x,
      hc.z,
      0,
      -hc.x,
      -sl.y,
      sl.x,
      0,
      -ll.y,
      ll.x,
      0,
      -hc.y,
      hc.x,
      0,
    ];
    return !RS(n, ju, Vu, $u, jg) ||
      ((n = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !RS(n, ju, Vu, $u, jg))
      ? !1
      : (Vg.crossVectors(sl, ll),
        (n = [Vg.x, Vg.y, Vg.z]),
        RS(n, ju, Vu, $u, jg));
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ua).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(ua).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (vs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        vs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        vs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        vs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        vs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        vs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        vs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        vs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(vs),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const vs = [
    new K(),
    new K(),
    new K(),
    new K(),
    new K(),
    new K(),
    new K(),
    new K(),
  ],
  ua = new K(),
  Hg = new wr(),
  ju = new K(),
  Vu = new K(),
  $u = new K(),
  sl = new K(),
  ll = new K(),
  hc = new K(),
  ch = new K(),
  jg = new K(),
  Vg = new K(),
  pc = new K();
function RS(t, e, n, r, i) {
  for (let o = 0, a = t.length - 3; o <= a; o += 3) {
    pc.fromArray(t, o);
    const s =
        i.x * Math.abs(pc.x) + i.y * Math.abs(pc.y) + i.z * Math.abs(pc.z),
      l = e.dot(pc),
      c = n.dot(pc),
      u = r.dot(pc);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > s) return !1;
  }
  return !0;
}
const jH = new wr(),
  uh = new K(),
  PS = new K();
class Rr {
  constructor(e = new K(), n = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = n);
  }
  set(e, n) {
    return this.center.copy(e), (this.radius = n), this;
  }
  setFromPoints(e, n) {
    const r = this.center;
    n !== void 0 ? r.copy(n) : jH.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let o = 0, a = e.length; o < a; o++)
      i = Math.max(i, r.distanceToSquared(e[o]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const r = this.center.distanceToSquared(e);
    return (
      n.copy(e),
      r > this.radius * this.radius &&
        (n.sub(this.center).normalize(),
        n.multiplyScalar(this.radius).add(this.center)),
      n
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    uh.subVectors(e, this.center);
    const n = uh.lengthSq();
    if (n > this.radius * this.radius) {
      const r = Math.sqrt(n),
        i = (r - this.radius) * 0.5;
      this.center.addScaledVector(uh, i / r), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (PS.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(uh.copy(e.center).add(PS)),
            this.expandByPoint(uh.copy(e.center).sub(PS))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ys = new K(),
  IS = new K(),
  $g = new K(),
  cl = new K(),
  LS = new K(),
  Gg = new K(),
  OS = new K();
class yu {
  constructor(e = new K(), n = new K(0, 0, -1)) {
    (this.origin = e), (this.direction = n);
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, ys)), this;
  }
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const r = n.dot(this.direction);
    return r < 0
      ? n.copy(this.origin)
      : n.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = ys.subVectors(e, this.origin).dot(this.direction);
    return n < 0
      ? this.origin.distanceToSquared(e)
      : (ys.copy(this.origin).addScaledVector(this.direction, n),
        ys.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, r, i) {
    IS.copy(e).add(n).multiplyScalar(0.5),
      $g.copy(n).sub(e).normalize(),
      cl.copy(this.origin).sub(IS);
    const o = e.distanceTo(n) * 0.5,
      a = -this.direction.dot($g),
      s = cl.dot(this.direction),
      l = -cl.dot($g),
      c = cl.lengthSq(),
      u = Math.abs(1 - a * a);
    let d, p, m, v;
    if (u > 0)
      if (((d = a * l - s), (p = a * s - l), (v = o * u), d >= 0))
        if (p >= -v)
          if (p <= v) {
            const S = 1 / u;
            (d *= S),
              (p *= S),
              (m = d * (d + a * p + 2 * s) + p * (a * d + p + 2 * l) + c);
          } else
            (p = o),
              (d = Math.max(0, -(a * p + s))),
              (m = -d * d + p * (p + 2 * l) + c);
        else
          (p = -o),
            (d = Math.max(0, -(a * p + s))),
            (m = -d * d + p * (p + 2 * l) + c);
      else
        p <= -v
          ? ((d = Math.max(0, -(-a * o + s))),
            (p = d > 0 ? -o : Math.min(Math.max(-o, -l), o)),
            (m = -d * d + p * (p + 2 * l) + c))
          : p <= v
          ? ((d = 0),
            (p = Math.min(Math.max(-o, -l), o)),
            (m = p * (p + 2 * l) + c))
          : ((d = Math.max(0, -(a * o + s))),
            (p = d > 0 ? o : Math.min(Math.max(-o, -l), o)),
            (m = -d * d + p * (p + 2 * l) + c));
    else
      (p = a > 0 ? -o : o),
        (d = Math.max(0, -(a * p + s))),
        (m = -d * d + p * (p + 2 * l) + c);
    return (
      r && r.copy(this.origin).addScaledVector(this.direction, d),
      i && i.copy(IS).addScaledVector($g, p),
      m
    );
  }
  intersectSphere(e, n) {
    ys.subVectors(e.center, this.origin);
    const r = ys.dot(this.direction),
      i = ys.dot(ys) - r * r,
      o = e.radius * e.radius;
    if (i > o) return null;
    const a = Math.sqrt(o - i),
      s = r - a,
      l = r + a;
    return l < 0 ? null : s < 0 ? this.at(l, n) : this.at(s, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / n;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, n) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let r, i, o, a, s, l;
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      d = 1 / this.direction.z,
      p = this.origin;
    return (
      c >= 0
        ? ((r = (e.min.x - p.x) * c), (i = (e.max.x - p.x) * c))
        : ((r = (e.max.x - p.x) * c), (i = (e.min.x - p.x) * c)),
      u >= 0
        ? ((o = (e.min.y - p.y) * u), (a = (e.max.y - p.y) * u))
        : ((o = (e.max.y - p.y) * u), (a = (e.min.y - p.y) * u)),
      r > a ||
      o > i ||
      ((o > r || isNaN(r)) && (r = o),
      (a < i || isNaN(i)) && (i = a),
      d >= 0
        ? ((s = (e.min.z - p.z) * d), (l = (e.max.z - p.z) * d))
        : ((s = (e.max.z - p.z) * d), (l = (e.min.z - p.z) * d)),
      r > l || s > i) ||
      ((s > r || r !== r) && (r = s), (l < i || i !== i) && (i = l), i < 0)
        ? null
        : this.at(r >= 0 ? r : i, n)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, ys) !== null;
  }
  intersectTriangle(e, n, r, i, o) {
    LS.subVectors(n, e), Gg.subVectors(r, e), OS.crossVectors(LS, Gg);
    let a = this.direction.dot(OS),
      s;
    if (a > 0) {
      if (i) return null;
      s = 1;
    } else if (a < 0) (s = -1), (a = -a);
    else return null;
    cl.subVectors(this.origin, e);
    const l = s * this.direction.dot(Gg.crossVectors(cl, Gg));
    if (l < 0) return null;
    const c = s * this.direction.dot(LS.cross(cl));
    if (c < 0 || l + c > a) return null;
    const u = -s * cl.dot(OS);
    return u < 0 ? null : this.at(u / a, o);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class kt {
  constructor(e, n, r, i, o, a, s, l, c, u, d, p, m, v, S, x) {
    (kt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, n, r, i, o, a, s, l, c, u, d, p, m, v, S, x);
  }
  set(e, n, r, i, o, a, s, l, c, u, d, p, m, v, S, x) {
    const g = this.elements;
    return (
      (g[0] = e),
      (g[4] = n),
      (g[8] = r),
      (g[12] = i),
      (g[1] = o),
      (g[5] = a),
      (g[9] = s),
      (g[13] = l),
      (g[2] = c),
      (g[6] = u),
      (g[10] = d),
      (g[14] = p),
      (g[3] = m),
      (g[7] = v),
      (g[11] = S),
      (g[15] = x),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new kt().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements,
      r = e.elements;
    return (
      (n[0] = r[0]),
      (n[1] = r[1]),
      (n[2] = r[2]),
      (n[3] = r[3]),
      (n[4] = r[4]),
      (n[5] = r[5]),
      (n[6] = r[6]),
      (n[7] = r[7]),
      (n[8] = r[8]),
      (n[9] = r[9]),
      (n[10] = r[10]),
      (n[11] = r[11]),
      (n[12] = r[12]),
      (n[13] = r[13]),
      (n[14] = r[14]),
      (n[15] = r[15]),
      this
    );
  }
  copyPosition(e) {
    const n = this.elements,
      r = e.elements;
    return (n[12] = r[12]), (n[13] = r[13]), (n[14] = r[14]), this;
  }
  setFromMatrix3(e) {
    const n = e.elements;
    return (
      this.set(
        n[0],
        n[3],
        n[6],
        0,
        n[1],
        n[4],
        n[7],
        0,
        n[2],
        n[5],
        n[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, n, r) {
    return (
      e.setFromMatrixColumn(this, 0),
      n.setFromMatrixColumn(this, 1),
      r.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, n, r) {
    return (
      this.set(
        e.x,
        n.x,
        r.x,
        0,
        e.y,
        n.y,
        r.y,
        0,
        e.z,
        n.z,
        r.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const n = this.elements,
      r = e.elements,
      i = 1 / Gu.setFromMatrixColumn(e, 0).length(),
      o = 1 / Gu.setFromMatrixColumn(e, 1).length(),
      a = 1 / Gu.setFromMatrixColumn(e, 2).length();
    return (
      (n[0] = r[0] * i),
      (n[1] = r[1] * i),
      (n[2] = r[2] * i),
      (n[3] = 0),
      (n[4] = r[4] * o),
      (n[5] = r[5] * o),
      (n[6] = r[6] * o),
      (n[7] = 0),
      (n[8] = r[8] * a),
      (n[9] = r[9] * a),
      (n[10] = r[10] * a),
      (n[11] = 0),
      (n[12] = 0),
      (n[13] = 0),
      (n[14] = 0),
      (n[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const n = this.elements,
      r = e.x,
      i = e.y,
      o = e.z,
      a = Math.cos(r),
      s = Math.sin(r),
      l = Math.cos(i),
      c = Math.sin(i),
      u = Math.cos(o),
      d = Math.sin(o);
    if (e.order === "XYZ") {
      const p = a * u,
        m = a * d,
        v = s * u,
        S = s * d;
      (n[0] = l * u),
        (n[4] = -l * d),
        (n[8] = c),
        (n[1] = m + v * c),
        (n[5] = p - S * c),
        (n[9] = -s * l),
        (n[2] = S - p * c),
        (n[6] = v + m * c),
        (n[10] = a * l);
    } else if (e.order === "YXZ") {
      const p = l * u,
        m = l * d,
        v = c * u,
        S = c * d;
      (n[0] = p + S * s),
        (n[4] = v * s - m),
        (n[8] = a * c),
        (n[1] = a * d),
        (n[5] = a * u),
        (n[9] = -s),
        (n[2] = m * s - v),
        (n[6] = S + p * s),
        (n[10] = a * l);
    } else if (e.order === "ZXY") {
      const p = l * u,
        m = l * d,
        v = c * u,
        S = c * d;
      (n[0] = p - S * s),
        (n[4] = -a * d),
        (n[8] = v + m * s),
        (n[1] = m + v * s),
        (n[5] = a * u),
        (n[9] = S - p * s),
        (n[2] = -a * c),
        (n[6] = s),
        (n[10] = a * l);
    } else if (e.order === "ZYX") {
      const p = a * u,
        m = a * d,
        v = s * u,
        S = s * d;
      (n[0] = l * u),
        (n[4] = v * c - m),
        (n[8] = p * c + S),
        (n[1] = l * d),
        (n[5] = S * c + p),
        (n[9] = m * c - v),
        (n[2] = -c),
        (n[6] = s * l),
        (n[10] = a * l);
    } else if (e.order === "YZX") {
      const p = a * l,
        m = a * c,
        v = s * l,
        S = s * c;
      (n[0] = l * u),
        (n[4] = S - p * d),
        (n[8] = v * d + m),
        (n[1] = d),
        (n[5] = a * u),
        (n[9] = -s * u),
        (n[2] = -c * u),
        (n[6] = m * d + v),
        (n[10] = p - S * d);
    } else if (e.order === "XZY") {
      const p = a * l,
        m = a * c,
        v = s * l,
        S = s * c;
      (n[0] = l * u),
        (n[4] = -d),
        (n[8] = c * u),
        (n[1] = p * d + S),
        (n[5] = a * u),
        (n[9] = m * d - v),
        (n[2] = v * d - m),
        (n[6] = s * u),
        (n[10] = S * d + p);
    }
    return (
      (n[3] = 0),
      (n[7] = 0),
      (n[11] = 0),
      (n[12] = 0),
      (n[13] = 0),
      (n[14] = 0),
      (n[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(VH, e, $H);
  }
  lookAt(e, n, r) {
    const i = this.elements;
    return (
      mo.subVectors(e, n),
      mo.lengthSq() === 0 && (mo.z = 1),
      mo.normalize(),
      ul.crossVectors(r, mo),
      ul.lengthSq() === 0 &&
        (Math.abs(r.z) === 1 ? (mo.x += 1e-4) : (mo.z += 1e-4),
        mo.normalize(),
        ul.crossVectors(r, mo)),
      ul.normalize(),
      Wg.crossVectors(mo, ul),
      (i[0] = ul.x),
      (i[4] = Wg.x),
      (i[8] = mo.x),
      (i[1] = ul.y),
      (i[5] = Wg.y),
      (i[9] = mo.y),
      (i[2] = ul.z),
      (i[6] = Wg.z),
      (i[10] = mo.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const r = e.elements,
      i = n.elements,
      o = this.elements,
      a = r[0],
      s = r[4],
      l = r[8],
      c = r[12],
      u = r[1],
      d = r[5],
      p = r[9],
      m = r[13],
      v = r[2],
      S = r[6],
      x = r[10],
      g = r[14],
      _ = r[3],
      y = r[7],
      w = r[11],
      A = r[15],
      M = i[0],
      T = i[4],
      I = i[8],
      R = i[12],
      P = i[1],
      F = i[5],
      D = i[9],
      j = i[13],
      N = i[2],
      V = i[6],
      W = i[10],
      Q = i[14],
      B = i[3],
      $ = i[7],
      G = i[11],
      k = i[15];
    return (
      (o[0] = a * M + s * P + l * N + c * B),
      (o[4] = a * T + s * F + l * V + c * $),
      (o[8] = a * I + s * D + l * W + c * G),
      (o[12] = a * R + s * j + l * Q + c * k),
      (o[1] = u * M + d * P + p * N + m * B),
      (o[5] = u * T + d * F + p * V + m * $),
      (o[9] = u * I + d * D + p * W + m * G),
      (o[13] = u * R + d * j + p * Q + m * k),
      (o[2] = v * M + S * P + x * N + g * B),
      (o[6] = v * T + S * F + x * V + g * $),
      (o[10] = v * I + S * D + x * W + g * G),
      (o[14] = v * R + S * j + x * Q + g * k),
      (o[3] = _ * M + y * P + w * N + A * B),
      (o[7] = _ * T + y * F + w * V + A * $),
      (o[11] = _ * I + y * D + w * W + A * G),
      (o[15] = _ * R + y * j + w * Q + A * k),
      this
    );
  }
  multiplyScalar(e) {
    const n = this.elements;
    return (
      (n[0] *= e),
      (n[4] *= e),
      (n[8] *= e),
      (n[12] *= e),
      (n[1] *= e),
      (n[5] *= e),
      (n[9] *= e),
      (n[13] *= e),
      (n[2] *= e),
      (n[6] *= e),
      (n[10] *= e),
      (n[14] *= e),
      (n[3] *= e),
      (n[7] *= e),
      (n[11] *= e),
      (n[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      n = e[0],
      r = e[4],
      i = e[8],
      o = e[12],
      a = e[1],
      s = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      d = e[6],
      p = e[10],
      m = e[14],
      v = e[3],
      S = e[7],
      x = e[11],
      g = e[15];
    return (
      v *
        (+o * l * d -
          i * c * d -
          o * s * p +
          r * c * p +
          i * s * m -
          r * l * m) +
      S *
        (+n * l * m -
          n * c * p +
          o * a * p -
          i * a * m +
          i * c * u -
          o * l * u) +
      x *
        (+n * c * d -
          n * s * m -
          o * a * d +
          r * a * m +
          o * s * u -
          r * c * u) +
      g *
        (-i * s * u - n * l * d + n * s * p + i * a * d - r * a * p + r * l * u)
    );
  }
  transpose() {
    const e = this.elements;
    let n;
    return (
      (n = e[1]),
      (e[1] = e[4]),
      (e[4] = n),
      (n = e[2]),
      (e[2] = e[8]),
      (e[8] = n),
      (n = e[6]),
      (e[6] = e[9]),
      (e[9] = n),
      (n = e[3]),
      (e[3] = e[12]),
      (e[12] = n),
      (n = e[7]),
      (e[7] = e[13]),
      (e[13] = n),
      (n = e[11]),
      (e[11] = e[14]),
      (e[14] = n),
      this
    );
  }
  setPosition(e, n, r) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = n), (i[14] = r)),
      this
    );
  }
  invert() {
    const e = this.elements,
      n = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      a = e[4],
      s = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      d = e[9],
      p = e[10],
      m = e[11],
      v = e[12],
      S = e[13],
      x = e[14],
      g = e[15],
      _ = d * x * c - S * p * c + S * l * m - s * x * m - d * l * g + s * p * g,
      y = v * p * c - u * x * c - v * l * m + a * x * m + u * l * g - a * p * g,
      w = u * S * c - v * d * c + v * s * m - a * S * m - u * s * g + a * d * g,
      A = v * d * l - u * S * l - v * s * p + a * S * p + u * s * x - a * d * x,
      M = n * _ + r * y + i * w + o * A;
    if (M === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / M;
    return (
      (e[0] = _ * T),
      (e[1] =
        (S * p * o -
          d * x * o -
          S * i * m +
          r * x * m +
          d * i * g -
          r * p * g) *
        T),
      (e[2] =
        (s * x * o -
          S * l * o +
          S * i * c -
          r * x * c -
          s * i * g +
          r * l * g) *
        T),
      (e[3] =
        (d * l * o -
          s * p * o -
          d * i * c +
          r * p * c +
          s * i * m -
          r * l * m) *
        T),
      (e[4] = y * T),
      (e[5] =
        (u * x * o -
          v * p * o +
          v * i * m -
          n * x * m -
          u * i * g +
          n * p * g) *
        T),
      (e[6] =
        (v * l * o -
          a * x * o -
          v * i * c +
          n * x * c +
          a * i * g -
          n * l * g) *
        T),
      (e[7] =
        (a * p * o -
          u * l * o +
          u * i * c -
          n * p * c -
          a * i * m +
          n * l * m) *
        T),
      (e[8] = w * T),
      (e[9] =
        (v * d * o -
          u * S * o -
          v * r * m +
          n * S * m +
          u * r * g -
          n * d * g) *
        T),
      (e[10] =
        (a * S * o -
          v * s * o +
          v * r * c -
          n * S * c -
          a * r * g +
          n * s * g) *
        T),
      (e[11] =
        (u * s * o -
          a * d * o -
          u * r * c +
          n * d * c +
          a * r * m -
          n * s * m) *
        T),
      (e[12] = A * T),
      (e[13] =
        (u * S * i -
          v * d * i +
          v * r * p -
          n * S * p -
          u * r * x +
          n * d * x) *
        T),
      (e[14] =
        (v * s * i -
          a * S * i -
          v * r * l +
          n * S * l +
          a * r * x -
          n * s * x) *
        T),
      (e[15] =
        (a * d * i -
          u * s * i +
          u * r * l -
          n * d * l -
          a * r * p +
          n * s * p) *
        T),
      this
    );
  }
  scale(e) {
    const n = this.elements,
      r = e.x,
      i = e.y,
      o = e.z;
    return (
      (n[0] *= r),
      (n[4] *= i),
      (n[8] *= o),
      (n[1] *= r),
      (n[5] *= i),
      (n[9] *= o),
      (n[2] *= r),
      (n[6] *= i),
      (n[10] *= o),
      (n[3] *= r),
      (n[7] *= i),
      (n[11] *= o),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, r, i));
  }
  makeTranslation(e, n, r) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, r, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const n = Math.cos(e),
      r = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, n, -r, 0, 0, r, n, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e),
      r = Math.sin(e);
    return this.set(n, 0, r, 0, 0, 1, 0, 0, -r, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e),
      r = Math.sin(e);
    return this.set(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, n) {
    const r = Math.cos(n),
      i = Math.sin(n),
      o = 1 - r,
      a = e.x,
      s = e.y,
      l = e.z,
      c = o * a,
      u = o * s;
    return (
      this.set(
        c * a + r,
        c * s - i * l,
        c * l + i * s,
        0,
        c * s + i * l,
        u * s + r,
        u * l - i * a,
        0,
        c * l - i * s,
        u * l + i * a,
        o * l * l + r,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, n, r) {
    return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, n, r, i, o, a) {
    return this.set(1, r, o, 0, e, 1, a, 0, n, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, n, r) {
    const i = this.elements,
      o = n._x,
      a = n._y,
      s = n._z,
      l = n._w,
      c = o + o,
      u = a + a,
      d = s + s,
      p = o * c,
      m = o * u,
      v = o * d,
      S = a * u,
      x = a * d,
      g = s * d,
      _ = l * c,
      y = l * u,
      w = l * d,
      A = r.x,
      M = r.y,
      T = r.z;
    return (
      (i[0] = (1 - (S + g)) * A),
      (i[1] = (m + w) * A),
      (i[2] = (v - y) * A),
      (i[3] = 0),
      (i[4] = (m - w) * M),
      (i[5] = (1 - (p + g)) * M),
      (i[6] = (x + _) * M),
      (i[7] = 0),
      (i[8] = (v + y) * T),
      (i[9] = (x - _) * T),
      (i[10] = (1 - (p + S)) * T),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, n, r) {
    const i = this.elements;
    let o = Gu.set(i[0], i[1], i[2]).length();
    const a = Gu.set(i[4], i[5], i[6]).length(),
      s = Gu.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (o = -o),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      da.copy(this);
    const c = 1 / o,
      u = 1 / a,
      d = 1 / s;
    return (
      (da.elements[0] *= c),
      (da.elements[1] *= c),
      (da.elements[2] *= c),
      (da.elements[4] *= u),
      (da.elements[5] *= u),
      (da.elements[6] *= u),
      (da.elements[8] *= d),
      (da.elements[9] *= d),
      (da.elements[10] *= d),
      n.setFromRotationMatrix(da),
      (r.x = o),
      (r.y = a),
      (r.z = s),
      this
    );
  }
  makePerspective(e, n, r, i, o, a, s = Ea) {
    const l = this.elements,
      c = (2 * o) / (n - e),
      u = (2 * o) / (r - i),
      d = (n + e) / (n - e),
      p = (r + i) / (r - i);
    let m, v;
    if (s === Ea) (m = -(a + o) / (a - o)), (v = (-2 * a * o) / (a - o));
    else if (s === ff) (m = -a / (a - o)), (v = (-a * o) / (a - o));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s
      );
    return (
      (l[0] = c),
      (l[4] = 0),
      (l[8] = d),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = u),
      (l[9] = p),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = m),
      (l[14] = v),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, n, r, i, o, a, s = Ea) {
    const l = this.elements,
      c = 1 / (n - e),
      u = 1 / (r - i),
      d = 1 / (a - o),
      p = (n + e) * c,
      m = (r + i) * u;
    let v, S;
    if (s === Ea) (v = (a + o) * d), (S = -2 * d);
    else if (s === ff) (v = o * d), (S = -1 * d);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s
      );
    return (
      (l[0] = 2 * c),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -p),
      (l[1] = 0),
      (l[5] = 2 * u),
      (l[9] = 0),
      (l[13] = -m),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = S),
      (l[14] = -v),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const n = this.elements,
      r = e.elements;
    for (let i = 0; i < 16; i++) if (n[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let r = 0; r < 16; r++) this.elements[r] = e[r + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.elements;
    return (
      (e[n] = r[0]),
      (e[n + 1] = r[1]),
      (e[n + 2] = r[2]),
      (e[n + 3] = r[3]),
      (e[n + 4] = r[4]),
      (e[n + 5] = r[5]),
      (e[n + 6] = r[6]),
      (e[n + 7] = r[7]),
      (e[n + 8] = r[8]),
      (e[n + 9] = r[9]),
      (e[n + 10] = r[10]),
      (e[n + 11] = r[11]),
      (e[n + 12] = r[12]),
      (e[n + 13] = r[13]),
      (e[n + 14] = r[14]),
      (e[n + 15] = r[15]),
      e
    );
  }
}
const Gu = new K(),
  da = new kt(),
  VH = new K(0, 0, 0),
  $H = new K(1, 1, 1),
  ul = new K(),
  Wg = new K(),
  mo = new K(),
  xR = new kt(),
  SR = new mi();
class hm {
  constructor(e = 0, n = 0, r = 0, i = hm.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = n),
      (this._z = r),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, n, r, i = this._order) {
    return (
      (this._x = e),
      (this._y = n),
      (this._z = r),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, n = this._order, r = !0) {
    const i = e.elements,
      o = i[0],
      a = i[4],
      s = i[8],
      l = i[1],
      c = i[5],
      u = i[9],
      d = i[2],
      p = i[6],
      m = i[10];
    switch (n) {
      case "XYZ":
        (this._y = Math.asin(ar(s, -1, 1))),
          Math.abs(s) < 0.9999999
            ? ((this._x = Math.atan2(-u, m)), (this._z = Math.atan2(-a, o)))
            : ((this._x = Math.atan2(p, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-ar(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(s, m)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-d, o)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(ar(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(-d, m)), (this._z = Math.atan2(-a, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, o)));
        break;
      case "ZYX":
        (this._y = Math.asin(-ar(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(p, m)), (this._z = Math.atan2(l, o)))
            : ((this._x = 0), (this._z = Math.atan2(-a, c)));
        break;
      case "YZX":
        (this._z = Math.asin(ar(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-d, o)))
            : ((this._x = 0), (this._y = Math.atan2(s, m)));
        break;
      case "XZY":
        (this._z = Math.asin(-ar(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(p, c)), (this._y = Math.atan2(s, o)))
            : ((this._x = Math.atan2(-u, m)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            n
        );
    }
    return (this._order = n), r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, r) {
    return (
      xR.makeRotationFromQuaternion(e), this.setFromRotationMatrix(xR, n, r)
    );
  }
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  reorder(e) {
    return SR.setFromEuler(this), this.setFromQuaternion(SR, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this._x),
      (e[n + 1] = this._y),
      (e[n + 2] = this._z),
      (e[n + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
hm.DEFAULT_ORDER = "XYZ";
class Yc {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let GH = 0;
const _R = new K(),
  Wu = new mi(),
  xs = new kt(),
  Xg = new K(),
  dh = new K(),
  WH = new K(),
  XH = new mi(),
  bR = new K(1, 0, 0),
  wR = new K(0, 1, 0),
  ER = new K(0, 0, 1),
  qH = { type: "added" },
  KH = { type: "removed" };
class Sn extends qs {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: GH++ }),
      (this.uuid = Ao()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Sn.DEFAULT_UP.clone());
    const e = new K(),
      n = new hm(),
      r = new mi(),
      i = new K(1, 1, 1);
    function o() {
      r.setFromEuler(n, !1);
    }
    function a() {
      n.setFromQuaternion(r, void 0, !1);
    }
    n._onChange(o),
      r._onChange(a),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: n },
        quaternion: { configurable: !0, enumerable: !0, value: r },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new kt() },
        normalMatrix: { value: new Yt() },
      }),
      (this.matrix = new kt()),
      (this.matrixWorld = new kt()),
      (this.matrixAutoUpdate = Sn.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Sn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Yc()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, n) {
    return Wu.setFromAxisAngle(e, n), this.quaternion.multiply(Wu), this;
  }
  rotateOnWorldAxis(e, n) {
    return Wu.setFromAxisAngle(e, n), this.quaternion.premultiply(Wu), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(bR, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(wR, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(ER, e);
  }
  translateOnAxis(e, n) {
    return (
      _R.copy(e).applyQuaternion(this.quaternion),
      this.position.add(_R.multiplyScalar(n)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(bR, e);
  }
  translateY(e) {
    return this.translateOnAxis(wR, e);
  }
  translateZ(e) {
    return this.translateOnAxis(ER, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(xs.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, n, r) {
    e.isVector3 ? Xg.copy(e) : Xg.set(e, n, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      dh.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? xs.lookAt(dh, Xg, this.up)
        : xs.lookAt(Xg, dh, this.up),
      this.quaternion.setFromRotationMatrix(xs),
      i &&
        (xs.extractRotation(i.matrixWorld),
        Wu.setFromRotationMatrix(xs),
        this.quaternion.premultiply(Wu.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.add(arguments[n]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(qH))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
      return this;
    }
    const n = this.children.indexOf(e);
    return (
      n !== -1 &&
        ((e.parent = null), this.children.splice(n, 1), e.dispatchEvent(KH)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      xs.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), xs.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(xs),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const a = this.children[r].getObjectByProperty(e, n);
      if (a !== void 0) return a;
    }
  }
  getObjectsByProperty(e, n, r = []) {
    this[e] === n && r.push(this);
    const i = this.children;
    for (let o = 0, a = i.length; o < a; o++)
      i[o].getObjectsByProperty(e, n, r);
    return r;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(dh, e, WH), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(dh, XH, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const n = this.children;
    for (let r = 0, i = n.length; r < i; r++) n[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const n = this.children;
    for (let r = 0, i = n.length; r < i; r++) n[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const n = this.children;
    for (let r = 0, i = n.length; r < i; r++) {
      const o = n[r];
      (o.matrixWorldAutoUpdate === !0 || e === !0) && o.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, n) {
    const r = this.parent;
    if (
      (e === !0 &&
        r !== null &&
        r.matrixWorldAutoUpdate === !0 &&
        r.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      n === !0)
    ) {
      const i = this.children;
      for (let o = 0, a = i.length; o < a; o++) {
        const s = i[o];
        s.matrixWorldAutoUpdate === !0 && s.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string",
      r = {};
    n &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (r.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = "BatchedMesh"),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.visibility = this._visibility),
        (i.active = this._active),
        (i.bounds = this._bounds.map((s) => ({
          boxInitialized: s.boxInitialized,
          boxMin: s.box.min.toArray(),
          boxMax: s.box.max.toArray(),
          sphereInitialized: s.sphereInitialized,
          sphereRadius: s.sphere.radius,
          sphereCenter: s.sphere.center.toArray(),
        }))),
        (i.maxGeometryCount = this._maxGeometryCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.geometryCount = this._geometryCount),
        (i.matricesTexture = this._matricesTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray(),
          }));
    function o(s, l) {
      return s[l.uuid] === void 0 && (s[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = o(e.geometries, this.geometry);
      const s = this.geometry.parameters;
      if (s !== void 0 && s.shapes !== void 0) {
        const l = s.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const d = l[c];
            o(e.shapes, d);
          }
        else o(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (o(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const s = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          s.push(o(e.materials, this.material[l]));
        i.material = s;
      } else i.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let s = 0; s < this.children.length; s++)
        i.children.push(this.children[s].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let s = 0; s < this.animations.length; s++) {
        const l = this.animations[s];
        i.animations.push(o(e.animations, l));
      }
    }
    if (n) {
      const s = a(e.geometries),
        l = a(e.materials),
        c = a(e.textures),
        u = a(e.images),
        d = a(e.shapes),
        p = a(e.skeletons),
        m = a(e.animations),
        v = a(e.nodes);
      s.length > 0 && (r.geometries = s),
        l.length > 0 && (r.materials = l),
        c.length > 0 && (r.textures = c),
        u.length > 0 && (r.images = u),
        d.length > 0 && (r.shapes = d),
        p.length > 0 && (r.skeletons = p),
        m.length > 0 && (r.animations = m),
        v.length > 0 && (r.nodes = v);
    }
    return (r.object = i), r;
    function a(s) {
      const l = [];
      for (const c in s) {
        const u = s[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, n = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      n === !0)
    )
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
Sn.DEFAULT_UP = new K(0, 1, 0);
Sn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Sn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const fa = new K(),
  Ss = new K(),
  NS = new K(),
  _s = new K(),
  Xu = new K(),
  qu = new K(),
  MR = new K(),
  FS = new K(),
  DS = new K(),
  zS = new K();
let qg = !1;
class qi {
  constructor(e = new K(), n = new K(), r = new K()) {
    (this.a = e), (this.b = n), (this.c = r);
  }
  static getNormal(e, n, r, i) {
    i.subVectors(r, n), fa.subVectors(e, n), i.cross(fa);
    const o = i.lengthSq();
    return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, n, r, i, o) {
    fa.subVectors(i, n), Ss.subVectors(r, n), NS.subVectors(e, n);
    const a = fa.dot(fa),
      s = fa.dot(Ss),
      l = fa.dot(NS),
      c = Ss.dot(Ss),
      u = Ss.dot(NS),
      d = a * c - s * s;
    if (d === 0) return o.set(0, 0, 0), null;
    const p = 1 / d,
      m = (c * l - s * u) * p,
      v = (a * u - s * l) * p;
    return o.set(1 - m - v, v, m);
  }
  static containsPoint(e, n, r, i) {
    return this.getBarycoord(e, n, r, i, _s) === null
      ? !1
      : _s.x >= 0 && _s.y >= 0 && _s.x + _s.y <= 1;
  }
  static getUV(e, n, r, i, o, a, s, l) {
    return (
      qg === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (qg = !0)),
      this.getInterpolation(e, n, r, i, o, a, s, l)
    );
  }
  static getInterpolation(e, n, r, i, o, a, s, l) {
    return this.getBarycoord(e, n, r, i, _s) === null
      ? ((l.x = 0),
        (l.y = 0),
        "z" in l && (l.z = 0),
        "w" in l && (l.w = 0),
        null)
      : (l.setScalar(0),
        l.addScaledVector(o, _s.x),
        l.addScaledVector(a, _s.y),
        l.addScaledVector(s, _s.z),
        l);
  }
  static isFrontFacing(e, n, r, i) {
    return fa.subVectors(r, n), Ss.subVectors(e, n), fa.cross(Ss).dot(i) < 0;
  }
  set(e, n, r) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, n, r, i) {
    return this.a.copy(e[n]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, n, r, i) {
    return (
      this.a.fromBufferAttribute(e, n),
      this.b.fromBufferAttribute(e, r),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      fa.subVectors(this.c, this.b),
      Ss.subVectors(this.a, this.b),
      fa.cross(Ss).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return qi.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return qi.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getUV(e, n, r, i, o) {
    return (
      qg === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (qg = !0)),
      qi.getInterpolation(e, this.a, this.b, this.c, n, r, i, o)
    );
  }
  getInterpolation(e, n, r, i, o) {
    return qi.getInterpolation(e, this.a, this.b, this.c, n, r, i, o);
  }
  containsPoint(e) {
    return qi.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return qi.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    const r = this.a,
      i = this.b,
      o = this.c;
    let a, s;
    Xu.subVectors(i, r), qu.subVectors(o, r), FS.subVectors(e, r);
    const l = Xu.dot(FS),
      c = qu.dot(FS);
    if (l <= 0 && c <= 0) return n.copy(r);
    DS.subVectors(e, i);
    const u = Xu.dot(DS),
      d = qu.dot(DS);
    if (u >= 0 && d <= u) return n.copy(i);
    const p = l * d - u * c;
    if (p <= 0 && l >= 0 && u <= 0)
      return (a = l / (l - u)), n.copy(r).addScaledVector(Xu, a);
    zS.subVectors(e, o);
    const m = Xu.dot(zS),
      v = qu.dot(zS);
    if (v >= 0 && m <= v) return n.copy(o);
    const S = m * c - l * v;
    if (S <= 0 && c >= 0 && v <= 0)
      return (s = c / (c - v)), n.copy(r).addScaledVector(qu, s);
    const x = u * v - m * d;
    if (x <= 0 && d - u >= 0 && m - v >= 0)
      return (
        MR.subVectors(o, i),
        (s = (d - u) / (d - u + (m - v))),
        n.copy(i).addScaledVector(MR, s)
      );
    const g = 1 / (x + S + p);
    return (
      (a = S * g),
      (s = p * g),
      n.copy(r).addScaledVector(Xu, a).addScaledVector(qu, s)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const qF = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  dl = { h: 0, s: 0, l: 0 },
  Kg = { h: 0, s: 0, l: 0 };
function US(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? t + (e - t) * 6 * n
      : n < 1 / 2
      ? e
      : n < 2 / 3
      ? t + (e - t) * 6 * (2 / 3 - n)
      : t
  );
}
class pt {
  constructor(e, n, r) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, n, r)
    );
  }
  set(e, n, r) {
    if (n === void 0 && r === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, n, r);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, n = Tr) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Mn.toWorkingColorSpace(this, n),
      this
    );
  }
  setRGB(e, n, r, i = Mn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = n),
      (this.b = r),
      Mn.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, n, r, i = Mn.workingColorSpace) {
    if (((e = rC(e, 1)), (n = ar(n, 0, 1)), (r = ar(r, 0, 1)), n === 0))
      this.r = this.g = this.b = r;
    else {
      const o = r <= 0.5 ? r * (1 + n) : r + n - r * n,
        a = 2 * r - o;
      (this.r = US(a, o, e + 1 / 3)),
        (this.g = US(a, o, e)),
        (this.b = US(a, o, e - 1 / 3));
    }
    return Mn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, n = Tr) {
    function r(o) {
      o !== void 0 &&
        parseFloat(o) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let o;
      const a = i[1],
        s = i[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (
            (o =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                s
              ))
          )
            return (
              r(o[4]),
              this.setRGB(
                Math.min(255, parseInt(o[1], 10)) / 255,
                Math.min(255, parseInt(o[2], 10)) / 255,
                Math.min(255, parseInt(o[3], 10)) / 255,
                n
              )
            );
          if (
            (o =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                s
              ))
          )
            return (
              r(o[4]),
              this.setRGB(
                Math.min(100, parseInt(o[1], 10)) / 100,
                Math.min(100, parseInt(o[2], 10)) / 100,
                Math.min(100, parseInt(o[3], 10)) / 100,
                n
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (o =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                s
              ))
          )
            return (
              r(o[4]),
              this.setHSL(
                parseFloat(o[1]) / 360,
                parseFloat(o[2]) / 100,
                parseFloat(o[3]) / 100,
                n
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const o = i[1],
        a = o.length;
      if (a === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          n
        );
      if (a === 6) return this.setHex(parseInt(o, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, n);
    return this;
  }
  setColorName(e, n = Tr) {
    const r = qF[e.toLowerCase()];
    return (
      r !== void 0
        ? this.setHex(r, n)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Jd(e.r)), (this.g = Jd(e.g)), (this.b = Jd(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = CS(e.r)), (this.g = CS(e.g)), (this.b = CS(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Tr) {
    return (
      Mn.fromWorkingColorSpace(ci.copy(this), e),
      Math.round(ar(ci.r * 255, 0, 255)) * 65536 +
        Math.round(ar(ci.g * 255, 0, 255)) * 256 +
        Math.round(ar(ci.b * 255, 0, 255))
    );
  }
  getHexString(e = Tr) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, n = Mn.workingColorSpace) {
    Mn.fromWorkingColorSpace(ci.copy(this), n);
    const r = ci.r,
      i = ci.g,
      o = ci.b,
      a = Math.max(r, i, o),
      s = Math.min(r, i, o);
    let l, c;
    const u = (s + a) / 2;
    if (s === a) (l = 0), (c = 0);
    else {
      const d = a - s;
      switch (((c = u <= 0.5 ? d / (a + s) : d / (2 - a - s)), a)) {
        case r:
          l = (i - o) / d + (i < o ? 6 : 0);
          break;
        case i:
          l = (o - r) / d + 2;
          break;
        case o:
          l = (r - i) / d + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = u), e;
  }
  getRGB(e, n = Mn.workingColorSpace) {
    return (
      Mn.fromWorkingColorSpace(ci.copy(this), n),
      (e.r = ci.r),
      (e.g = ci.g),
      (e.b = ci.b),
      e
    );
  }
  getStyle(e = Tr) {
    Mn.fromWorkingColorSpace(ci.copy(this), e);
    const n = ci.r,
      r = ci.g,
      i = ci.b;
    return e !== Tr
      ? `color(${e} ${n.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(n * 255)},${Math.round(r * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, n, r) {
    return this.getHSL(dl), this.setHSL(dl.h + e, dl.s + n, dl.l + r);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, n) {
    return (
      (this.r = e.r + n.r), (this.g = e.g + n.g), (this.b = e.b + n.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, n) {
    return (
      (this.r += (e.r - this.r) * n),
      (this.g += (e.g - this.g) * n),
      (this.b += (e.b - this.b) * n),
      this
    );
  }
  lerpColors(e, n, r) {
    return (
      (this.r = e.r + (n.r - e.r) * r),
      (this.g = e.g + (n.g - e.g) * r),
      (this.b = e.b + (n.b - e.b) * r),
      this
    );
  }
  lerpHSL(e, n) {
    this.getHSL(dl), e.getHSL(Kg);
    const r = Zh(dl.h, Kg.h, n),
      i = Zh(dl.s, Kg.s, n),
      o = Zh(dl.l, Kg.l, n);
    return this.setHSL(r, i, o), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const n = this.r,
      r = this.g,
      i = this.b,
      o = e.elements;
    return (
      (this.r = o[0] * n + o[3] * r + o[6] * i),
      (this.g = o[1] * n + o[4] * r + o[7] * i),
      (this.b = o[2] * n + o[5] * r + o[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return (this.r = e[n]), (this.g = e[n + 1]), (this.b = e[n + 2]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.r), (e[n + 1] = this.g), (e[n + 2] = this.b), e;
  }
  fromBufferAttribute(e, n) {
    return (
      (this.r = e.getX(n)), (this.g = e.getY(n)), (this.b = e.getZ(n)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ci = new pt();
pt.NAMES = qF;
let YH = 0;
class yi extends qs {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: YH++ }),
      (this.uuid = Ao()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = qc),
      (this.side = js),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = sy),
      (this.blendDst = ly),
      (this.blendEquation = xl),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new pt(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = Mp),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = Rw),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Rc),
      (this.stencilZFail = Rc),
      (this.stencilZPass = Rc),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const n in e) {
        const r = e[n];
        if (r === void 0) {
          console.warn(
            `THREE.Material: parameter '${n}' has value of undefined.`
          );
          continue;
        }
        const i = this[n];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${n}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(r)
          : i && i.isVector3 && r && r.isVector3
          ? i.copy(r)
          : (this[n] = r);
      }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    n && (e = { textures: {}, images: {} });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.color && this.color.isColor && (r.color = this.color.getHex()),
      this.roughness !== void 0 && (r.roughness = this.roughness),
      this.metalness !== void 0 && (r.metalness = this.metalness),
      this.sheen !== void 0 && (r.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (r.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (r.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (r.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (r.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (r.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (r.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (r.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (r.shininess = this.shininess),
      this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (r.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (r.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (r.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (r.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (r.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((r.lightMap = this.lightMap.toJSON(e).uuid),
        (r.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((r.aoMap = this.aoMap.toJSON(e).uuid),
        (r.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((r.bumpMap = this.bumpMap.toJSON(e).uuid),
        (r.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((r.normalMap = this.normalMap.toJSON(e).uuid),
        (r.normalMapType = this.normalMapType),
        (r.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
        (r.displacementScale = this.displacementScale),
        (r.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (r.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((r.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (r.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (r.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (r.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (r.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (r.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (r.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (r.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (r.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (r.size = this.size),
      this.shadowSide !== null && (r.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (r.sizeAttenuation = this.sizeAttenuation),
      this.blending !== qc && (r.blending = this.blending),
      this.side !== js && (r.side = this.side),
      this.vertexColors === !0 && (r.vertexColors = !0),
      this.opacity < 1 && (r.opacity = this.opacity),
      this.transparent === !0 && (r.transparent = !0),
      this.blendSrc !== sy && (r.blendSrc = this.blendSrc),
      this.blendDst !== ly && (r.blendDst = this.blendDst),
      this.blendEquation !== xl && (r.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (r.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (r.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha),
      this.depthFunc !== Mp && (r.depthFunc = this.depthFunc),
      this.depthTest === !1 && (r.depthTest = this.depthTest),
      this.depthWrite === !1 && (r.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (r.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (r.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== Rw && (r.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (r.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (r.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Rc && (r.stencilFail = this.stencilFail),
      this.stencilZFail !== Rc && (r.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Rc && (r.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (r.rotation = this.rotation),
      this.polygonOffset === !0 && (r.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (r.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (r.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (r.linewidth = this.linewidth),
      this.dashSize !== void 0 && (r.dashSize = this.dashSize),
      this.gapSize !== void 0 && (r.gapSize = this.gapSize),
      this.scale !== void 0 && (r.scale = this.scale),
      this.dithering === !0 && (r.dithering = !0),
      this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (r.alphaHash = !0),
      this.alphaToCoverage === !0 && (r.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (r.forceSinglePass = !0),
      this.wireframe === !0 && (r.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (r.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (r.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (r.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (r.flatShading = !0),
      this.visible === !1 && (r.visible = !1),
      this.toneMapped === !1 && (r.toneMapped = !1),
      this.fog === !1 && (r.fog = !1),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function i(o) {
      const a = [];
      for (const s in o) {
        const l = o[s];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (n) {
      const o = i(e.textures),
        a = i(e.images);
      o.length > 0 && (r.textures = o), a.length > 0 && (r.images = a);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const n = e.clippingPlanes;
    let r = null;
    if (n !== null) {
      const i = n.length;
      r = new Array(i);
      for (let o = 0; o !== i; ++o) r[o] = n[o].clone();
    }
    return (
      (this.clippingPlanes = r),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Ks extends yi {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new pt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = dm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Rs = ZH();
function ZH() {
  const t = new ArrayBuffer(4),
    e = new Float32Array(t),
    n = new Uint32Array(t),
    r = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27
      ? ((r[l] = 0), (r[l | 256] = 32768), (i[l] = 24), (i[l | 256] = 24))
      : c < -14
      ? ((r[l] = 1024 >> (-c - 14)),
        (r[l | 256] = (1024 >> (-c - 14)) | 32768),
        (i[l] = -c - 1),
        (i[l | 256] = -c - 1))
      : c <= 15
      ? ((r[l] = (c + 15) << 10),
        (r[l | 256] = ((c + 15) << 10) | 32768),
        (i[l] = 13),
        (i[l | 256] = 13))
      : c < 128
      ? ((r[l] = 31744), (r[l | 256] = 64512), (i[l] = 24), (i[l | 256] = 24))
      : ((r[l] = 31744), (r[l | 256] = 64512), (i[l] = 13), (i[l | 256] = 13));
  }
  const o = new Uint32Array(2048),
    a = new Uint32Array(64),
    s = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13,
      u = 0;
    for (; !(c & 8388608); ) (c <<= 1), (u -= 8388608);
    (c &= -8388609), (u += 947912704), (o[l] = c | u);
  }
  for (let l = 1024; l < 2048; ++l) o[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) a[l] = l << 23;
  (a[31] = 1199570944), (a[32] = 2147483648);
  for (let l = 33; l < 63; ++l) a[l] = 2147483648 + ((l - 32) << 23);
  a[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (s[l] = 1024);
  return {
    floatView: e,
    uint32View: n,
    baseTable: r,
    shiftTable: i,
    mantissaTable: o,
    exponentTable: a,
    offsetTable: s,
  };
}
function Wi(t) {
  Math.abs(t) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (t = ar(t, -65504, 65504)),
    (Rs.floatView[0] = t);
  const e = Rs.uint32View[0],
    n = (e >> 23) & 511;
  return Rs.baseTable[n] + ((e & 8388607) >> Rs.shiftTable[n]);
}
function Dh(t) {
  const e = t >> 10;
  return (
    (Rs.uint32View[0] =
      Rs.mantissaTable[Rs.offsetTable[e] + (t & 1023)] + Rs.exponentTable[e]),
    Rs.floatView[0]
  );
}
const QH = { toHalfFloat: Wi, fromHalfFloat: Dh },
  Sr = new K(),
  Yg = new Ge();
class wn {
  constructor(e, n, r = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = n),
      (this.count = e !== void 0 ? e.length / n : 0),
      (this.normalized = r),
      (this.usage = Dp),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.gpuType = wa),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      console.warn(
        "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, n, r) {
    (e *= this.itemSize), (r *= n.itemSize);
    for (let i = 0, o = this.itemSize; i < o; i++)
      this.array[e + i] = n.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, r = this.count; n < r; n++)
        Yg.fromBufferAttribute(this, n),
          Yg.applyMatrix3(e),
          this.setXY(n, Yg.x, Yg.y);
    else if (this.itemSize === 3)
      for (let n = 0, r = this.count; n < r; n++)
        Sr.fromBufferAttribute(this, n),
          Sr.applyMatrix3(e),
          this.setXYZ(n, Sr.x, Sr.y, Sr.z);
    return this;
  }
  applyMatrix4(e) {
    for (let n = 0, r = this.count; n < r; n++)
      Sr.fromBufferAttribute(this, n),
        Sr.applyMatrix4(e),
        this.setXYZ(n, Sr.x, Sr.y, Sr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, r = this.count; n < r; n++)
      Sr.fromBufferAttribute(this, n),
        Sr.applyNormalMatrix(e),
        this.setXYZ(n, Sr.x, Sr.y, Sr.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, r = this.count; n < r; n++)
      Sr.fromBufferAttribute(this, n),
        Sr.transformDirection(e),
        this.setXYZ(n, Sr.x, Sr.y, Sr.z);
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  getComponent(e, n) {
    let r = this.array[e * this.itemSize + n];
    return this.normalized && (r = Ki(r, this.array)), r;
  }
  setComponent(e, n, r) {
    return (
      this.normalized && (r = Zt(r, this.array)),
      (this.array[e * this.itemSize + n] = r),
      this
    );
  }
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = Ki(n, this.array)), n;
  }
  setX(e, n) {
    return (
      this.normalized && (n = Zt(n, this.array)),
      (this.array[e * this.itemSize] = n),
      this
    );
  }
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = Ki(n, this.array)), n;
  }
  setY(e, n) {
    return (
      this.normalized && (n = Zt(n, this.array)),
      (this.array[e * this.itemSize + 1] = n),
      this
    );
  }
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = Ki(n, this.array)), n;
  }
  setZ(e, n) {
    return (
      this.normalized && (n = Zt(n, this.array)),
      (this.array[e * this.itemSize + 2] = n),
      this
    );
  }
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = Ki(n, this.array)), n;
  }
  setW(e, n) {
    return (
      this.normalized && (n = Zt(n, this.array)),
      (this.array[e * this.itemSize + 3] = n),
      this
    );
  }
  setXY(e, n, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((n = Zt(n, this.array)), (r = Zt(r, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, n, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = Zt(n, this.array)),
        (r = Zt(r, this.array)),
        (i = Zt(i, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, n, r, i, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = Zt(n, this.array)),
        (r = Zt(r, this.array)),
        (i = Zt(i, this.array)),
        (o = Zt(o, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      (this.array[e + 3] = o),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Dp && (e.usage = this.usage),
      e
    );
  }
}
class JH extends wn {
  constructor(e, n, r) {
    super(new Int8Array(e), n, r);
  }
}
class e8 extends wn {
  constructor(e, n, r) {
    super(new Uint8Array(e), n, r);
  }
}
class t8 extends wn {
  constructor(e, n, r) {
    super(new Uint8ClampedArray(e), n, r);
  }
}
class n8 extends wn {
  constructor(e, n, r) {
    super(new Int16Array(e), n, r);
  }
}
class aC extends wn {
  constructor(e, n, r) {
    super(new Uint16Array(e), n, r);
  }
}
class r8 extends wn {
  constructor(e, n, r) {
    super(new Int32Array(e), n, r);
  }
}
class sC extends wn {
  constructor(e, n, r) {
    super(new Uint32Array(e), n, r);
  }
}
class i8 extends wn {
  constructor(e, n, r) {
    super(new Uint16Array(e), n, r), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let n = Dh(this.array[e * this.itemSize]);
    return this.normalized && (n = Ki(n, this.array)), n;
  }
  setX(e, n) {
    return (
      this.normalized && (n = Zt(n, this.array)),
      (this.array[e * this.itemSize] = Wi(n)),
      this
    );
  }
  getY(e) {
    let n = Dh(this.array[e * this.itemSize + 1]);
    return this.normalized && (n = Ki(n, this.array)), n;
  }
  setY(e, n) {
    return (
      this.normalized && (n = Zt(n, this.array)),
      (this.array[e * this.itemSize + 1] = Wi(n)),
      this
    );
  }
  getZ(e) {
    let n = Dh(this.array[e * this.itemSize + 2]);
    return this.normalized && (n = Ki(n, this.array)), n;
  }
  setZ(e, n) {
    return (
      this.normalized && (n = Zt(n, this.array)),
      (this.array[e * this.itemSize + 2] = Wi(n)),
      this
    );
  }
  getW(e) {
    let n = Dh(this.array[e * this.itemSize + 3]);
    return this.normalized && (n = Ki(n, this.array)), n;
  }
  setW(e, n) {
    return (
      this.normalized && (n = Zt(n, this.array)),
      (this.array[e * this.itemSize + 3] = Wi(n)),
      this
    );
  }
  setXY(e, n, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((n = Zt(n, this.array)), (r = Zt(r, this.array))),
      (this.array[e + 0] = Wi(n)),
      (this.array[e + 1] = Wi(r)),
      this
    );
  }
  setXYZ(e, n, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = Zt(n, this.array)),
        (r = Zt(r, this.array)),
        (i = Zt(i, this.array))),
      (this.array[e + 0] = Wi(n)),
      (this.array[e + 1] = Wi(r)),
      (this.array[e + 2] = Wi(i)),
      this
    );
  }
  setXYZW(e, n, r, i, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = Zt(n, this.array)),
        (r = Zt(r, this.array)),
        (i = Zt(i, this.array)),
        (o = Zt(o, this.array))),
      (this.array[e + 0] = Wi(n)),
      (this.array[e + 1] = Wi(r)),
      (this.array[e + 2] = Wi(i)),
      (this.array[e + 3] = Wi(o)),
      this
    );
  }
}
class wt extends wn {
  constructor(e, n, r) {
    super(new Float32Array(e), n, r);
  }
}
class o8 extends wn {
  constructor(e, n, r) {
    super(new Float64Array(e), n, r);
  }
}
let a8 = 0;
const Vo = new kt(),
  kS = new Sn(),
  Ku = new K(),
  go = new wr(),
  fh = new wr(),
  kr = new K();
class Jt extends qs {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: a8++ }),
      (this.uuid = Ao()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (GF(e) ? sC : aC)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, n) {
    return (this.attributes[e] = n), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, n, r = 0) {
    this.groups.push({ start: e, count: n, materialIndex: r });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, n) {
    (this.drawRange.start = e), (this.drawRange.count = n);
  }
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), (n.needsUpdate = !0));
    const r = this.attributes.normal;
    if (r !== void 0) {
      const o = new Yt().getNormalMatrix(e);
      r.applyNormalMatrix(o), (r.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Vo.makeRotationFromQuaternion(e), this.applyMatrix4(Vo), this;
  }
  rotateX(e) {
    return Vo.makeRotationX(e), this.applyMatrix4(Vo), this;
  }
  rotateY(e) {
    return Vo.makeRotationY(e), this.applyMatrix4(Vo), this;
  }
  rotateZ(e) {
    return Vo.makeRotationZ(e), this.applyMatrix4(Vo), this;
  }
  translate(e, n, r) {
    return Vo.makeTranslation(e, n, r), this.applyMatrix4(Vo), this;
  }
  scale(e, n, r) {
    return Vo.makeScale(e, n, r), this.applyMatrix4(Vo), this;
  }
  lookAt(e) {
    return kS.lookAt(e), kS.updateMatrix(), this.applyMatrix4(kS.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Ku).negate(),
      this.translate(Ku.x, Ku.y, Ku.z),
      this
    );
  }
  setFromPoints(e) {
    const n = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const o = e[r];
      n.push(o.x, o.y, o.z || 0);
    }
    return this.setAttribute("position", new wt(n, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new wr());
    const e = this.attributes.position,
      n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new K(-1 / 0, -1 / 0, -1 / 0),
          new K(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), n))
        for (let r = 0, i = n.length; r < i; r++) {
          const o = n[r];
          go.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (kr.addVectors(this.boundingBox.min, go.min),
                this.boundingBox.expandByPoint(kr),
                kr.addVectors(this.boundingBox.max, go.max),
                this.boundingBox.expandByPoint(kr))
              : (this.boundingBox.expandByPoint(go.min),
                this.boundingBox.expandByPoint(go.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Rr());
    const e = this.attributes.position,
      n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new K(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if ((go.setFromBufferAttribute(e), n))
        for (let o = 0, a = n.length; o < a; o++) {
          const s = n[o];
          fh.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (kr.addVectors(go.min, fh.min),
                go.expandByPoint(kr),
                kr.addVectors(go.max, fh.max),
                go.expandByPoint(kr))
              : (go.expandByPoint(fh.min), go.expandByPoint(fh.max));
        }
      go.getCenter(r);
      let i = 0;
      for (let o = 0, a = e.count; o < a; o++)
        kr.fromBufferAttribute(e, o),
          (i = Math.max(i, r.distanceToSquared(kr)));
      if (n)
        for (let o = 0, a = n.length; o < a; o++) {
          const s = n[o],
            l = this.morphTargetsRelative;
          for (let c = 0, u = s.count; c < u; c++)
            kr.fromBufferAttribute(s, c),
              l && (Ku.fromBufferAttribute(e, c), kr.add(Ku)),
              (i = Math.max(i, r.distanceToSquared(kr)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      n = this.attributes;
    if (
      e === null ||
      n.position === void 0 ||
      n.normal === void 0 ||
      n.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const r = e.array,
      i = n.position.array,
      o = n.normal.array,
      a = n.uv.array,
      s = i.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new wn(new Float32Array(4 * s), 4));
    const l = this.getAttribute("tangent").array,
      c = [],
      u = [];
    for (let P = 0; P < s; P++) (c[P] = new K()), (u[P] = new K());
    const d = new K(),
      p = new K(),
      m = new K(),
      v = new Ge(),
      S = new Ge(),
      x = new Ge(),
      g = new K(),
      _ = new K();
    function y(P, F, D) {
      d.fromArray(i, P * 3),
        p.fromArray(i, F * 3),
        m.fromArray(i, D * 3),
        v.fromArray(a, P * 2),
        S.fromArray(a, F * 2),
        x.fromArray(a, D * 2),
        p.sub(d),
        m.sub(d),
        S.sub(v),
        x.sub(v);
      const j = 1 / (S.x * x.y - x.x * S.y);
      isFinite(j) &&
        (g
          .copy(p)
          .multiplyScalar(x.y)
          .addScaledVector(m, -S.y)
          .multiplyScalar(j),
        _.copy(m)
          .multiplyScalar(S.x)
          .addScaledVector(p, -x.x)
          .multiplyScalar(j),
        c[P].add(g),
        c[F].add(g),
        c[D].add(g),
        u[P].add(_),
        u[F].add(_),
        u[D].add(_));
    }
    let w = this.groups;
    w.length === 0 && (w = [{ start: 0, count: r.length }]);
    for (let P = 0, F = w.length; P < F; ++P) {
      const D = w[P],
        j = D.start,
        N = D.count;
      for (let V = j, W = j + N; V < W; V += 3) y(r[V + 0], r[V + 1], r[V + 2]);
    }
    const A = new K(),
      M = new K(),
      T = new K(),
      I = new K();
    function R(P) {
      T.fromArray(o, P * 3), I.copy(T);
      const F = c[P];
      A.copy(F),
        A.sub(T.multiplyScalar(T.dot(F))).normalize(),
        M.crossVectors(I, F);
      const j = M.dot(u[P]) < 0 ? -1 : 1;
      (l[P * 4] = A.x),
        (l[P * 4 + 1] = A.y),
        (l[P * 4 + 2] = A.z),
        (l[P * 4 + 3] = j);
    }
    for (let P = 0, F = w.length; P < F; ++P) {
      const D = w[P],
        j = D.start,
        N = D.count;
      for (let V = j, W = j + N; V < W; V += 3)
        R(r[V + 0]), R(r[V + 1]), R(r[V + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      n = this.getAttribute("position");
    if (n !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        (r = new wn(new Float32Array(n.count * 3), 3)),
          this.setAttribute("normal", r);
      else for (let p = 0, m = r.count; p < m; p++) r.setXYZ(p, 0, 0, 0);
      const i = new K(),
        o = new K(),
        a = new K(),
        s = new K(),
        l = new K(),
        c = new K(),
        u = new K(),
        d = new K();
      if (e)
        for (let p = 0, m = e.count; p < m; p += 3) {
          const v = e.getX(p + 0),
            S = e.getX(p + 1),
            x = e.getX(p + 2);
          i.fromBufferAttribute(n, v),
            o.fromBufferAttribute(n, S),
            a.fromBufferAttribute(n, x),
            u.subVectors(a, o),
            d.subVectors(i, o),
            u.cross(d),
            s.fromBufferAttribute(r, v),
            l.fromBufferAttribute(r, S),
            c.fromBufferAttribute(r, x),
            s.add(u),
            l.add(u),
            c.add(u),
            r.setXYZ(v, s.x, s.y, s.z),
            r.setXYZ(S, l.x, l.y, l.z),
            r.setXYZ(x, c.x, c.y, c.z);
        }
      else
        for (let p = 0, m = n.count; p < m; p += 3)
          i.fromBufferAttribute(n, p + 0),
            o.fromBufferAttribute(n, p + 1),
            a.fromBufferAttribute(n, p + 2),
            u.subVectors(a, o),
            d.subVectors(i, o),
            u.cross(d),
            r.setXYZ(p + 0, u.x, u.y, u.z),
            r.setXYZ(p + 1, u.x, u.y, u.z),
            r.setXYZ(p + 2, u.x, u.y, u.z);
      this.normalizeNormals(), (r.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, r = e.count; n < r; n++)
      kr.fromBufferAttribute(e, n),
        kr.normalize(),
        e.setXYZ(n, kr.x, kr.y, kr.z);
  }
  toNonIndexed() {
    function e(s, l) {
      const c = s.array,
        u = s.itemSize,
        d = s.normalized,
        p = new c.constructor(l.length * u);
      let m = 0,
        v = 0;
      for (let S = 0, x = l.length; S < x; S++) {
        s.isInterleavedBufferAttribute
          ? (m = l[S] * s.data.stride + s.offset)
          : (m = l[S] * u);
        for (let g = 0; g < u; g++) p[v++] = c[m++];
      }
      return new wn(p, u, d);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const n = new Jt(),
      r = this.index.array,
      i = this.attributes;
    for (const s in i) {
      const l = i[s],
        c = e(l, r);
      n.setAttribute(s, c);
    }
    const o = this.morphAttributes;
    for (const s in o) {
      const l = [],
        c = o[s];
      for (let u = 0, d = c.length; u < d; u++) {
        const p = c[u],
          m = e(p, r);
        l.push(m);
      }
      n.morphAttributes[s] = l;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let s = 0, l = a.length; s < l; s++) {
      const c = a[s];
      n.addGroup(c.start, c.count, c.materialIndex);
    }
    return n;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null &&
      (e.data.index = {
        type: n.array.constructor.name,
        array: Array.prototype.slice.call(n.array),
      });
    const r = this.attributes;
    for (const l in r) {
      const c = r[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const i = {};
    let o = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = [];
      for (let d = 0, p = c.length; d < p; d++) {
        const m = c[d];
        u.push(m.toJSON(e.data));
      }
      u.length > 0 && ((i[l] = u), (o = !0));
    }
    o &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const s = this.boundingSphere;
    return (
      s !== null &&
        (e.data.boundingSphere = {
          center: s.center.toArray(),
          radius: s.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const n = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(n));
    const i = e.attributes;
    for (const c in i) {
      const u = i[c];
      this.setAttribute(c, u.clone(n));
    }
    const o = e.morphAttributes;
    for (const c in o) {
      const u = [],
        d = o[c];
      for (let p = 0, m = d.length; p < m; p++) u.push(d[p].clone(n));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, u = a.length; c < u; c++) {
      const d = a[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const s = e.boundingBox;
    s !== null && (this.boundingBox = s.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const CR = new kt(),
  mc = new yu(),
  Zg = new Rr(),
  TR = new K(),
  Yu = new K(),
  Zu = new K(),
  Qu = new K(),
  BS = new K(),
  Qg = new K(),
  Jg = new Ge(),
  ev = new Ge(),
  tv = new Ge(),
  AR = new K(),
  RR = new K(),
  PR = new K(),
  nv = new K(),
  rv = new K();
class Jn extends Sn {
  constructor(e = new Jt(), n = new Ks()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      r = Object.keys(n);
    if (r.length > 0) {
      const i = n[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, a = i.length; o < a; o++) {
          const s = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[s] = o);
        }
      }
    }
  }
  getVertexPosition(e, n) {
    const r = this.geometry,
      i = r.attributes.position,
      o = r.morphAttributes.position,
      a = r.morphTargetsRelative;
    n.fromBufferAttribute(i, e);
    const s = this.morphTargetInfluences;
    if (o && s) {
      Qg.set(0, 0, 0);
      for (let l = 0, c = o.length; l < c; l++) {
        const u = s[l],
          d = o[l];
        u !== 0 &&
          (BS.fromBufferAttribute(d, e),
          a ? Qg.addScaledVector(BS, u) : Qg.addScaledVector(BS.sub(n), u));
      }
      n.add(Qg);
    }
    return n;
  }
  raycast(e, n) {
    const r = this.geometry,
      i = this.material,
      o = this.matrixWorld;
    i !== void 0 &&
      (r.boundingSphere === null && r.computeBoundingSphere(),
      Zg.copy(r.boundingSphere),
      Zg.applyMatrix4(o),
      mc.copy(e.ray).recast(e.near),
      !(
        Zg.containsPoint(mc.origin) === !1 &&
        (mc.intersectSphere(Zg, TR) === null ||
          mc.origin.distanceToSquared(TR) > (e.far - e.near) ** 2)
      ) &&
        (CR.copy(o).invert(),
        mc.copy(e.ray).applyMatrix4(CR),
        !(r.boundingBox !== null && mc.intersectsBox(r.boundingBox) === !1) &&
          this._computeIntersections(e, n, mc)));
  }
  _computeIntersections(e, n, r) {
    let i;
    const o = this.geometry,
      a = this.material,
      s = o.index,
      l = o.attributes.position,
      c = o.attributes.uv,
      u = o.attributes.uv1,
      d = o.attributes.normal,
      p = o.groups,
      m = o.drawRange;
    if (s !== null)
      if (Array.isArray(a))
        for (let v = 0, S = p.length; v < S; v++) {
          const x = p[v],
            g = a[x.materialIndex],
            _ = Math.max(x.start, m.start),
            y = Math.min(
              s.count,
              Math.min(x.start + x.count, m.start + m.count)
            );
          for (let w = _, A = y; w < A; w += 3) {
            const M = s.getX(w),
              T = s.getX(w + 1),
              I = s.getX(w + 2);
            (i = iv(this, g, e, r, c, u, d, M, T, I)),
              i &&
                ((i.faceIndex = Math.floor(w / 3)),
                (i.face.materialIndex = x.materialIndex),
                n.push(i));
          }
        }
      else {
        const v = Math.max(0, m.start),
          S = Math.min(s.count, m.start + m.count);
        for (let x = v, g = S; x < g; x += 3) {
          const _ = s.getX(x),
            y = s.getX(x + 1),
            w = s.getX(x + 2);
          (i = iv(this, a, e, r, c, u, d, _, y, w)),
            i && ((i.faceIndex = Math.floor(x / 3)), n.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let v = 0, S = p.length; v < S; v++) {
          const x = p[v],
            g = a[x.materialIndex],
            _ = Math.max(x.start, m.start),
            y = Math.min(
              l.count,
              Math.min(x.start + x.count, m.start + m.count)
            );
          for (let w = _, A = y; w < A; w += 3) {
            const M = w,
              T = w + 1,
              I = w + 2;
            (i = iv(this, g, e, r, c, u, d, M, T, I)),
              i &&
                ((i.faceIndex = Math.floor(w / 3)),
                (i.face.materialIndex = x.materialIndex),
                n.push(i));
          }
        }
      else {
        const v = Math.max(0, m.start),
          S = Math.min(l.count, m.start + m.count);
        for (let x = v, g = S; x < g; x += 3) {
          const _ = x,
            y = x + 1,
            w = x + 2;
          (i = iv(this, a, e, r, c, u, d, _, y, w)),
            i && ((i.faceIndex = Math.floor(x / 3)), n.push(i));
        }
      }
  }
}
function s8(t, e, n, r, i, o, a, s) {
  let l;
  if (
    (e.side === Oi
      ? (l = r.intersectTriangle(a, o, i, !0, s))
      : (l = r.intersectTriangle(i, o, a, e.side === js, s)),
    l === null)
  )
    return null;
  rv.copy(s), rv.applyMatrix4(t.matrixWorld);
  const c = n.ray.origin.distanceTo(rv);
  return c < n.near || c > n.far
    ? null
    : { distance: c, point: rv.clone(), object: t };
}
function iv(t, e, n, r, i, o, a, s, l, c) {
  t.getVertexPosition(s, Yu),
    t.getVertexPosition(l, Zu),
    t.getVertexPosition(c, Qu);
  const u = s8(t, e, n, r, Yu, Zu, Qu, nv);
  if (u) {
    i &&
      (Jg.fromBufferAttribute(i, s),
      ev.fromBufferAttribute(i, l),
      tv.fromBufferAttribute(i, c),
      (u.uv = qi.getInterpolation(nv, Yu, Zu, Qu, Jg, ev, tv, new Ge()))),
      o &&
        (Jg.fromBufferAttribute(o, s),
        ev.fromBufferAttribute(o, l),
        tv.fromBufferAttribute(o, c),
        (u.uv1 = qi.getInterpolation(nv, Yu, Zu, Qu, Jg, ev, tv, new Ge())),
        (u.uv2 = u.uv1)),
      a &&
        (AR.fromBufferAttribute(a, s),
        RR.fromBufferAttribute(a, l),
        PR.fromBufferAttribute(a, c),
        (u.normal = qi.getInterpolation(nv, Yu, Zu, Qu, AR, RR, PR, new K())),
        u.normal.dot(r.direction) > 0 && u.normal.multiplyScalar(-1));
    const d = { a: s, b: l, c, normal: new K(), materialIndex: 0 };
    qi.getNormal(Yu, Zu, Qu, d.normal), (u.face = d);
  }
  return u;
}
class xu extends Jt {
  constructor(e = 1, n = 1, r = 1, i = 1, o = 1, a = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: n,
        depth: r,
        widthSegments: i,
        heightSegments: o,
        depthSegments: a,
      });
    const s = this;
    (i = Math.floor(i)), (o = Math.floor(o)), (a = Math.floor(a));
    const l = [],
      c = [],
      u = [],
      d = [];
    let p = 0,
      m = 0;
    v("z", "y", "x", -1, -1, r, n, e, a, o, 0),
      v("z", "y", "x", 1, -1, r, n, -e, a, o, 1),
      v("x", "z", "y", 1, 1, e, r, n, i, a, 2),
      v("x", "z", "y", 1, -1, e, r, -n, i, a, 3),
      v("x", "y", "z", 1, -1, e, n, r, i, o, 4),
      v("x", "y", "z", -1, -1, e, n, -r, i, o, 5),
      this.setIndex(l),
      this.setAttribute("position", new wt(c, 3)),
      this.setAttribute("normal", new wt(u, 3)),
      this.setAttribute("uv", new wt(d, 2));
    function v(S, x, g, _, y, w, A, M, T, I, R) {
      const P = w / T,
        F = A / I,
        D = w / 2,
        j = A / 2,
        N = M / 2,
        V = T + 1,
        W = I + 1;
      let Q = 0,
        B = 0;
      const $ = new K();
      for (let G = 0; G < W; G++) {
        const k = G * F - j;
        for (let q = 0; q < V; q++) {
          const X = q * P - D;
          ($[S] = X * _),
            ($[x] = k * y),
            ($[g] = N),
            c.push($.x, $.y, $.z),
            ($[S] = 0),
            ($[x] = 0),
            ($[g] = M > 0 ? 1 : -1),
            u.push($.x, $.y, $.z),
            d.push(q / T),
            d.push(1 - G / I),
            (Q += 1);
        }
      }
      for (let G = 0; G < I; G++)
        for (let k = 0; k < T; k++) {
          const q = p + k + V * G,
            X = p + k + V * (G + 1),
            ee = p + (k + 1) + V * (G + 1),
            J = p + (k + 1) + V * G;
          l.push(q, X, J), l.push(X, ee, J), (B += 6);
        }
      s.addGroup(m, B, R), (m += B), (p += Q);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new xu(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function pf(t) {
  const e = {};
  for (const n in t) {
    e[n] = {};
    for (const r in t[n]) {
      const i = t[n][r];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[n][r] = null))
          : (e[n][r] = i.clone())
        : Array.isArray(i)
        ? (e[n][r] = i.slice())
        : (e[n][r] = i);
    }
  }
  return e;
}
function Ai(t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const r = pf(t[n]);
    for (const i in r) e[i] = r[i];
  }
  return e;
}
function l8(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) e.push(t[n].clone());
  return e;
}
function KF(t) {
  return t.getRenderTarget() === null
    ? t.outputColorSpace
    : Mn.workingColorSpace;
}
const Up = { clone: pf, merge: Ai };
var c8 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  u8 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Ia extends yi {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = c8),
      (this.fragmentShader = u8),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
        clipCullDistance: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = pf(e.uniforms)),
      (this.uniformsGroups = l8(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    (n.glslVersion = this.glslVersion), (n.uniforms = {});
    for (const i in this.uniforms) {
      const a = this.uniforms[i].value;
      a && a.isTexture
        ? (n.uniforms[i] = { type: "t", value: a.toJSON(e).uuid })
        : a && a.isColor
        ? (n.uniforms[i] = { type: "c", value: a.getHex() })
        : a && a.isVector2
        ? (n.uniforms[i] = { type: "v2", value: a.toArray() })
        : a && a.isVector3
        ? (n.uniforms[i] = { type: "v3", value: a.toArray() })
        : a && a.isVector4
        ? (n.uniforms[i] = { type: "v4", value: a.toArray() })
        : a && a.isMatrix3
        ? (n.uniforms[i] = { type: "m3", value: a.toArray() })
        : a && a.isMatrix4
        ? (n.uniforms[i] = { type: "m4", value: a.toArray() })
        : (n.uniforms[i] = { value: a });
    }
    Object.keys(this.defines).length > 0 && (n.defines = this.defines),
      (n.vertexShader = this.vertexShader),
      (n.fragmentShader = this.fragmentShader),
      (n.lights = this.lights),
      (n.clipping = this.clipping);
    const r = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (n.extensions = r), n;
  }
}
class pm extends Sn {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new kt()),
      (this.projectionMatrix = new kt()),
      (this.projectionMatrixInverse = new kt()),
      (this.coordinateSystem = Ea);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Zn extends pm {
  constructor(e = 50, n = 1, r = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = r),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = n),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const n = (0.5 * this.getFilmHeight()) / e;
    (this.fov = hf * 2 * Math.atan(n)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Kc * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return hf * 2 * Math.atan(Math.tan(Kc * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, n, r, i, o, a) {
    (this.aspect = e / n),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = n),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = o),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let n = (e * Math.tan(Kc * 0.5 * this.fov)) / this.zoom,
      r = 2 * n,
      i = this.aspect * r,
      o = -0.5 * i;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth,
        c = a.fullHeight;
      (o += (a.offsetX * i) / l),
        (n -= (a.offsetY * r) / c),
        (i *= a.width / l),
        (r *= a.height / c);
    }
    const s = this.filmOffset;
    s !== 0 && (o += (e * s) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        o,
        o + i,
        n,
        n - r,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.fov = this.fov),
      (n.object.zoom = this.zoom),
      (n.object.near = this.near),
      (n.object.far = this.far),
      (n.object.focus = this.focus),
      (n.object.aspect = this.aspect),
      this.view !== null && (n.object.view = Object.assign({}, this.view)),
      (n.object.filmGauge = this.filmGauge),
      (n.object.filmOffset = this.filmOffset),
      n
    );
  }
}
const Ju = -90,
  ed = 1;
class YF extends Sn {
  constructor(e, n, r) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = r),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const i = new Zn(Ju, ed, e, n);
    (i.layers = this.layers), this.add(i);
    const o = new Zn(Ju, ed, e, n);
    (o.layers = this.layers), this.add(o);
    const a = new Zn(Ju, ed, e, n);
    (a.layers = this.layers), this.add(a);
    const s = new Zn(Ju, ed, e, n);
    (s.layers = this.layers), this.add(s);
    const l = new Zn(Ju, ed, e, n);
    (l.layers = this.layers), this.add(l);
    const c = new Zn(Ju, ed, e, n);
    (c.layers = this.layers), this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      n = this.children.concat(),
      [r, i, o, a, s, l] = n;
    for (const c of n) this.remove(c);
    if (e === Ea)
      r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, 1, 0),
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        s.up.set(0, 1, 0),
        s.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === ff)
      r.up.set(0, -1, 0),
        r.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, 1, 0),
        a.up.set(0, 0, -1),
        a.lookAt(0, -1, 0),
        s.up.set(0, -1, 0),
        s.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const c of n) this.add(c), c.updateMatrixWorld();
  }
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: r, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [o, a, s, l, c, u] = this.children,
      d = e.getRenderTarget(),
      p = e.getActiveCubeFace(),
      m = e.getActiveMipmapLevel(),
      v = e.xr.enabled;
    e.xr.enabled = !1;
    const S = r.texture.generateMipmaps;
    (r.texture.generateMipmaps = !1),
      e.setRenderTarget(r, 0, i),
      e.render(n, o),
      e.setRenderTarget(r, 1, i),
      e.render(n, a),
      e.setRenderTarget(r, 2, i),
      e.render(n, s),
      e.setRenderTarget(r, 3, i),
      e.render(n, l),
      e.setRenderTarget(r, 4, i),
      e.render(n, c),
      (r.texture.generateMipmaps = S),
      e.setRenderTarget(r, 5, i),
      e.render(n, u),
      e.setRenderTarget(d, p, m),
      (e.xr.enabled = v),
      (r.texture.needsPMREMUpdate = !0);
  }
}
class mm extends sr {
  constructor(e, n, r, i, o, a, s, l, c, u) {
    (e = e !== void 0 ? e : []),
      (n = n !== void 0 ? n : Vs),
      super(e, n, r, i, o, a, s, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class ZF extends Pa {
  constructor(e = 1, n = {}) {
    super(e, e, n), (this.isWebGLCubeRenderTarget = !0);
    const r = { width: e, height: e, depth: 1 },
      i = [r, r, r, r, r, r];
    n.encoding !== void 0 &&
      (Qh(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (n.colorSpace = n.encoding === Dl ? Tr : _o)),
      (this.texture = new mm(
        i,
        n.mapping,
        n.wrapS,
        n.wrapT,
        n.magFilter,
        n.minFilter,
        n.format,
        n.type,
        n.anisotropy,
        n.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
      (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Yn);
  }
  fromEquirectangularTexture(e, n) {
    (this.texture.type = n.type),
      (this.texture.colorSpace = n.colorSpace),
      (this.texture.generateMipmaps = n.generateMipmaps),
      (this.texture.minFilter = n.minFilter),
      (this.texture.magFilter = n.magFilter);
    const r = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new xu(5, 5, 5),
      o = new Ia({
        name: "CubemapFromEquirect",
        uniforms: pf(r.uniforms),
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        side: Oi,
        blending: Fs,
      });
    o.uniforms.tEquirect.value = n;
    const a = new Jn(i, o),
      s = n.minFilter;
    return (
      n.minFilter === Hl && (n.minFilter = Yn),
      new YF(1, 10, this).update(e, a),
      (n.minFilter = s),
      a.geometry.dispose(),
      a.material.dispose(),
      this
    );
  }
  clear(e, n, r, i) {
    const o = e.getRenderTarget();
    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(n, r, i);
    e.setRenderTarget(o);
  }
}
const HS = new K(),
  d8 = new K(),
  f8 = new Yt();
class Ts {
  constructor(e = new K(1, 0, 0), n = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = n);
  }
  set(e, n) {
    return this.normal.copy(e), (this.constant = n), this;
  }
  setComponents(e, n, r, i) {
    return this.normal.set(e, n, r), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), (this.constant = -n.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, n, r) {
    const i = HS.subVectors(r, n).cross(d8.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, n) {
    const r = e.delta(HS),
      i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / i;
    return o < 0 || o > 1 ? null : n.copy(e.start).addScaledVector(r, o);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start),
      r = this.distanceToPoint(e.end);
    return (n < 0 && r > 0) || (r < 0 && n > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const r = n || f8.getNormalMatrix(e),
      i = this.coplanarPoint(HS).applyMatrix4(e),
      o = this.normal.applyMatrix3(r).normalize();
    return (this.constant = -i.dot(o)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const gc = new Rr(),
  ov = new K();
class gm {
  constructor(
    e = new Ts(),
    n = new Ts(),
    r = new Ts(),
    i = new Ts(),
    o = new Ts(),
    a = new Ts()
  ) {
    this.planes = [e, n, r, i, o, a];
  }
  set(e, n, r, i, o, a) {
    const s = this.planes;
    return (
      s[0].copy(e),
      s[1].copy(n),
      s[2].copy(r),
      s[3].copy(i),
      s[4].copy(o),
      s[5].copy(a),
      this
    );
  }
  copy(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++) n[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, n = Ea) {
    const r = this.planes,
      i = e.elements,
      o = i[0],
      a = i[1],
      s = i[2],
      l = i[3],
      c = i[4],
      u = i[5],
      d = i[6],
      p = i[7],
      m = i[8],
      v = i[9],
      S = i[10],
      x = i[11],
      g = i[12],
      _ = i[13],
      y = i[14],
      w = i[15];
    if (
      (r[0].setComponents(l - o, p - c, x - m, w - g).normalize(),
      r[1].setComponents(l + o, p + c, x + m, w + g).normalize(),
      r[2].setComponents(l + a, p + u, x + v, w + _).normalize(),
      r[3].setComponents(l - a, p - u, x - v, w - _).normalize(),
      r[4].setComponents(l - s, p - d, x - S, w - y).normalize(),
      n === Ea)
    )
      r[5].setComponents(l + s, p + d, x + S, w + y).normalize();
    else if (n === ff) r[5].setComponents(s, d, S, y).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          n
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        gc.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(),
        gc.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(gc);
  }
  intersectsSprite(e) {
    return (
      gc.center.set(0, 0, 0),
      (gc.radius = 0.7071067811865476),
      gc.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(gc)
    );
  }
  intersectsSphere(e) {
    const n = this.planes,
      r = e.center,
      i = -e.radius;
    for (let o = 0; o < 6; o++) if (n[o].distanceToPoint(r) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = n[r];
      if (
        ((ov.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (ov.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (ov.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(ov) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++) if (n[r].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function QF() {
  let t = null,
    e = !1,
    n = null,
    r = null;
  function i(o, a) {
    n(o, a), (r = t.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && n !== null && ((r = t.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      t.cancelAnimationFrame(r), (e = !1);
    },
    setAnimationLoop: function (o) {
      n = o;
    },
    setContext: function (o) {
      t = o;
    },
  };
}
function h8(t, e) {
  const n = e.isWebGL2,
    r = new WeakMap();
  function i(c, u) {
    const d = c.array,
      p = c.usage,
      m = d.byteLength,
      v = t.createBuffer();
    t.bindBuffer(u, v), t.bufferData(u, d, p), c.onUploadCallback();
    let S;
    if (d instanceof Float32Array) S = t.FLOAT;
    else if (d instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (n) S = t.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else S = t.UNSIGNED_SHORT;
    else if (d instanceof Int16Array) S = t.SHORT;
    else if (d instanceof Uint32Array) S = t.UNSIGNED_INT;
    else if (d instanceof Int32Array) S = t.INT;
    else if (d instanceof Int8Array) S = t.BYTE;
    else if (d instanceof Uint8Array) S = t.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray) S = t.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + d
      );
    return {
      buffer: v,
      type: S,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: c.version,
      size: m,
    };
  }
  function o(c, u, d) {
    const p = u.array,
      m = u._updateRange,
      v = u.updateRanges;
    if (
      (t.bindBuffer(d, c),
      m.count === -1 && v.length === 0 && t.bufferSubData(d, 0, p),
      v.length !== 0)
    ) {
      for (let S = 0, x = v.length; S < x; S++) {
        const g = v[S];
        n
          ? t.bufferSubData(
              d,
              g.start * p.BYTES_PER_ELEMENT,
              p,
              g.start,
              g.count
            )
          : t.bufferSubData(
              d,
              g.start * p.BYTES_PER_ELEMENT,
              p.subarray(g.start, g.start + g.count)
            );
      }
      u.clearUpdateRanges();
    }
    m.count !== -1 &&
      (n
        ? t.bufferSubData(
            d,
            m.offset * p.BYTES_PER_ELEMENT,
            p,
            m.offset,
            m.count
          )
        : t.bufferSubData(
            d,
            m.offset * p.BYTES_PER_ELEMENT,
            p.subarray(m.offset, m.offset + m.count)
          ),
      (m.count = -1)),
      u.onUploadCallback();
  }
  function a(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), r.get(c);
  }
  function s(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const u = r.get(c);
    u && (t.deleteBuffer(u.buffer), r.delete(c));
  }
  function l(c, u) {
    if (c.isGLBufferAttribute) {
      const p = r.get(c);
      (!p || p.version < c.version) &&
        r.set(c, {
          buffer: c.buffer,
          type: c.type,
          bytesPerElement: c.elementSize,
          version: c.version,
        });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const d = r.get(c);
    if (d === void 0) r.set(c, i(c, u));
    else if (d.version < c.version) {
      if (d.size !== c.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      o(d.buffer, c, u), (d.version = c.version);
    }
  }
  return { get: a, remove: s, update: l };
}
class Zl extends Jt {
  constructor(e = 1, n = 1, r = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: n,
        widthSegments: r,
        heightSegments: i,
      });
    const o = e / 2,
      a = n / 2,
      s = Math.floor(r),
      l = Math.floor(i),
      c = s + 1,
      u = l + 1,
      d = e / s,
      p = n / l,
      m = [],
      v = [],
      S = [],
      x = [];
    for (let g = 0; g < u; g++) {
      const _ = g * p - a;
      for (let y = 0; y < c; y++) {
        const w = y * d - o;
        v.push(w, -_, 0), S.push(0, 0, 1), x.push(y / s), x.push(1 - g / l);
      }
    }
    for (let g = 0; g < l; g++)
      for (let _ = 0; _ < s; _++) {
        const y = _ + c * g,
          w = _ + c * (g + 1),
          A = _ + 1 + c * (g + 1),
          M = _ + 1 + c * g;
        m.push(y, w, M), m.push(w, A, M);
      }
    this.setIndex(m),
      this.setAttribute("position", new wt(v, 3)),
      this.setAttribute("normal", new wt(S, 3)),
      this.setAttribute("uv", new wt(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Zl(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var p8 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  m8 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  g8 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  v8 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  y8 = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  x8 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  S8 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  _8 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  b8 = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  w8 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,
  E8 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  M8 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  C8 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  T8 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  A8 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  R8 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  P8 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  I8 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  L8 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  O8 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  N8 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  F8 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  D8 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  z8 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  U8 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  k8 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  B8 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  H8 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  j8 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  V8 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  $8 = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  G8 = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
  W8 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  X8 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  q8 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  K8 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  Y8 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  Z8 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  Q8 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  J8 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  ej = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  tj = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  nj = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  rj = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  ij = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  oj = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  aj = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  sj = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  lj = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  cj = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  uj = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  dj = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  fj = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  hj = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  pj = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  mj = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  gj = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  vj = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  yj = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  xj = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  Sj = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  _j = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  bj = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  wj = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  Ej = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Mj = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Cj = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  Tj = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  Aj = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  Rj = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  Pj = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  Ij = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  Lj = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  Oj = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Nj = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Fj = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  Dj = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  zj = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  Uj = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  kj = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  Bj = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  Hj = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  jj = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  Vj = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  $j = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  Gj = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  Wj = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  Xj = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  qj = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  Kj = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  Yj = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  Zj = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  Qj = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  Jj = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  eV = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  tV = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  nV = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  rV = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  iV = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  oV = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  aV = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color *= toneMappingExposure;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  sV = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  lV = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  cV = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  uV = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  dV = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  fV = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const hV = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  pV = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  mV = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  gV = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vV = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  yV = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  xV = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  SV = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  _V = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  bV = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  wV = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  EV = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  MV = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  CV = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  TV = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  AV = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  RV = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  PV = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  IV = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  LV = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  OV = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  NV = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  FV = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  DV = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  zV = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  UV = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  kV = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  BV = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  HV = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  jV = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  VV = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  $V = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  GV = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  WV = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Xt = {
    alphahash_fragment: p8,
    alphahash_pars_fragment: m8,
    alphamap_fragment: g8,
    alphamap_pars_fragment: v8,
    alphatest_fragment: y8,
    alphatest_pars_fragment: x8,
    aomap_fragment: S8,
    aomap_pars_fragment: _8,
    batching_pars_vertex: b8,
    batching_vertex: w8,
    begin_vertex: E8,
    beginnormal_vertex: M8,
    bsdfs: C8,
    iridescence_fragment: T8,
    bumpmap_pars_fragment: A8,
    clipping_planes_fragment: R8,
    clipping_planes_pars_fragment: P8,
    clipping_planes_pars_vertex: I8,
    clipping_planes_vertex: L8,
    color_fragment: O8,
    color_pars_fragment: N8,
    color_pars_vertex: F8,
    color_vertex: D8,
    common: z8,
    cube_uv_reflection_fragment: U8,
    defaultnormal_vertex: k8,
    displacementmap_pars_vertex: B8,
    displacementmap_vertex: H8,
    emissivemap_fragment: j8,
    emissivemap_pars_fragment: V8,
    colorspace_fragment: $8,
    colorspace_pars_fragment: G8,
    envmap_fragment: W8,
    envmap_common_pars_fragment: X8,
    envmap_pars_fragment: q8,
    envmap_pars_vertex: K8,
    envmap_physical_pars_fragment: sj,
    envmap_vertex: Y8,
    fog_vertex: Z8,
    fog_pars_vertex: Q8,
    fog_fragment: J8,
    fog_pars_fragment: ej,
    gradientmap_pars_fragment: tj,
    lightmap_fragment: nj,
    lightmap_pars_fragment: rj,
    lights_lambert_fragment: ij,
    lights_lambert_pars_fragment: oj,
    lights_pars_begin: aj,
    lights_toon_fragment: lj,
    lights_toon_pars_fragment: cj,
    lights_phong_fragment: uj,
    lights_phong_pars_fragment: dj,
    lights_physical_fragment: fj,
    lights_physical_pars_fragment: hj,
    lights_fragment_begin: pj,
    lights_fragment_maps: mj,
    lights_fragment_end: gj,
    logdepthbuf_fragment: vj,
    logdepthbuf_pars_fragment: yj,
    logdepthbuf_pars_vertex: xj,
    logdepthbuf_vertex: Sj,
    map_fragment: _j,
    map_pars_fragment: bj,
    map_particle_fragment: wj,
    map_particle_pars_fragment: Ej,
    metalnessmap_fragment: Mj,
    metalnessmap_pars_fragment: Cj,
    morphcolor_vertex: Tj,
    morphnormal_vertex: Aj,
    morphtarget_pars_vertex: Rj,
    morphtarget_vertex: Pj,
    normal_fragment_begin: Ij,
    normal_fragment_maps: Lj,
    normal_pars_fragment: Oj,
    normal_pars_vertex: Nj,
    normal_vertex: Fj,
    normalmap_pars_fragment: Dj,
    clearcoat_normal_fragment_begin: zj,
    clearcoat_normal_fragment_maps: Uj,
    clearcoat_pars_fragment: kj,
    iridescence_pars_fragment: Bj,
    opaque_fragment: Hj,
    packing: jj,
    premultiplied_alpha_fragment: Vj,
    project_vertex: $j,
    dithering_fragment: Gj,
    dithering_pars_fragment: Wj,
    roughnessmap_fragment: Xj,
    roughnessmap_pars_fragment: qj,
    shadowmap_pars_fragment: Kj,
    shadowmap_pars_vertex: Yj,
    shadowmap_vertex: Zj,
    shadowmask_pars_fragment: Qj,
    skinbase_vertex: Jj,
    skinning_pars_vertex: eV,
    skinning_vertex: tV,
    skinnormal_vertex: nV,
    specularmap_fragment: rV,
    specularmap_pars_fragment: iV,
    tonemapping_fragment: oV,
    tonemapping_pars_fragment: aV,
    transmission_fragment: sV,
    transmission_pars_fragment: lV,
    uv_pars_fragment: cV,
    uv_pars_vertex: uV,
    uv_vertex: dV,
    worldpos_vertex: fV,
    background_vert: hV,
    background_frag: pV,
    backgroundCube_vert: mV,
    backgroundCube_frag: gV,
    cube_vert: vV,
    cube_frag: yV,
    depth_vert: xV,
    depth_frag: SV,
    distanceRGBA_vert: _V,
    distanceRGBA_frag: bV,
    equirect_vert: wV,
    equirect_frag: EV,
    linedashed_vert: MV,
    linedashed_frag: CV,
    meshbasic_vert: TV,
    meshbasic_frag: AV,
    meshlambert_vert: RV,
    meshlambert_frag: PV,
    meshmatcap_vert: IV,
    meshmatcap_frag: LV,
    meshnormal_vert: OV,
    meshnormal_frag: NV,
    meshphong_vert: FV,
    meshphong_frag: DV,
    meshphysical_vert: zV,
    meshphysical_frag: UV,
    meshtoon_vert: kV,
    meshtoon_frag: BV,
    points_vert: HV,
    points_frag: jV,
    shadow_vert: VV,
    shadow_frag: $V,
    sprite_vert: GV,
    sprite_frag: WV,
  },
  lt = {
    common: {
      diffuse: { value: new pt(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Yt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Yt() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Yt() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Yt() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Yt() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Yt() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Yt() },
      normalScale: { value: new Ge(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Yt() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Yt() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Yt() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Yt() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new pt(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new pt(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Yt() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Yt() },
    },
    sprite: {
      diffuse: { value: new pt(16777215) },
      opacity: { value: 1 },
      center: { value: new Ge(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Yt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Yt() },
      alphaTest: { value: 0 },
    },
  },
  _a = {
    basic: {
      uniforms: Ai([
        lt.common,
        lt.specularmap,
        lt.envmap,
        lt.aomap,
        lt.lightmap,
        lt.fog,
      ]),
      vertexShader: Xt.meshbasic_vert,
      fragmentShader: Xt.meshbasic_frag,
    },
    lambert: {
      uniforms: Ai([
        lt.common,
        lt.specularmap,
        lt.envmap,
        lt.aomap,
        lt.lightmap,
        lt.emissivemap,
        lt.bumpmap,
        lt.normalmap,
        lt.displacementmap,
        lt.fog,
        lt.lights,
        { emissive: { value: new pt(0) } },
      ]),
      vertexShader: Xt.meshlambert_vert,
      fragmentShader: Xt.meshlambert_frag,
    },
    phong: {
      uniforms: Ai([
        lt.common,
        lt.specularmap,
        lt.envmap,
        lt.aomap,
        lt.lightmap,
        lt.emissivemap,
        lt.bumpmap,
        lt.normalmap,
        lt.displacementmap,
        lt.fog,
        lt.lights,
        {
          emissive: { value: new pt(0) },
          specular: { value: new pt(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Xt.meshphong_vert,
      fragmentShader: Xt.meshphong_frag,
    },
    standard: {
      uniforms: Ai([
        lt.common,
        lt.envmap,
        lt.aomap,
        lt.lightmap,
        lt.emissivemap,
        lt.bumpmap,
        lt.normalmap,
        lt.displacementmap,
        lt.roughnessmap,
        lt.metalnessmap,
        lt.fog,
        lt.lights,
        {
          emissive: { value: new pt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Xt.meshphysical_vert,
      fragmentShader: Xt.meshphysical_frag,
    },
    toon: {
      uniforms: Ai([
        lt.common,
        lt.aomap,
        lt.lightmap,
        lt.emissivemap,
        lt.bumpmap,
        lt.normalmap,
        lt.displacementmap,
        lt.gradientmap,
        lt.fog,
        lt.lights,
        { emissive: { value: new pt(0) } },
      ]),
      vertexShader: Xt.meshtoon_vert,
      fragmentShader: Xt.meshtoon_frag,
    },
    matcap: {
      uniforms: Ai([
        lt.common,
        lt.bumpmap,
        lt.normalmap,
        lt.displacementmap,
        lt.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Xt.meshmatcap_vert,
      fragmentShader: Xt.meshmatcap_frag,
    },
    points: {
      uniforms: Ai([lt.points, lt.fog]),
      vertexShader: Xt.points_vert,
      fragmentShader: Xt.points_frag,
    },
    dashed: {
      uniforms: Ai([
        lt.common,
        lt.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Xt.linedashed_vert,
      fragmentShader: Xt.linedashed_frag,
    },
    depth: {
      uniforms: Ai([lt.common, lt.displacementmap]),
      vertexShader: Xt.depth_vert,
      fragmentShader: Xt.depth_frag,
    },
    normal: {
      uniforms: Ai([
        lt.common,
        lt.bumpmap,
        lt.normalmap,
        lt.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Xt.meshnormal_vert,
      fragmentShader: Xt.meshnormal_frag,
    },
    sprite: {
      uniforms: Ai([lt.sprite, lt.fog]),
      vertexShader: Xt.sprite_vert,
      fragmentShader: Xt.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Yt() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Xt.background_vert,
      fragmentShader: Xt.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Xt.backgroundCube_vert,
      fragmentShader: Xt.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Xt.cube_vert,
      fragmentShader: Xt.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Xt.equirect_vert,
      fragmentShader: Xt.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Ai([
        lt.common,
        lt.displacementmap,
        {
          referencePosition: { value: new K() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Xt.distanceRGBA_vert,
      fragmentShader: Xt.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Ai([
        lt.lights,
        lt.fog,
        { color: { value: new pt(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Xt.shadow_vert,
      fragmentShader: Xt.shadow_frag,
    },
  };
_a.physical = {
  uniforms: Ai([
    _a.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Yt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Yt() },
      clearcoatNormalScale: { value: new Ge(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Yt() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Yt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Yt() },
      sheen: { value: 0 },
      sheenColor: { value: new pt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Yt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Yt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Yt() },
      transmissionSamplerSize: { value: new Ge() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Yt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new pt(0) },
      specularColor: { value: new pt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Yt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Yt() },
      anisotropyVector: { value: new Ge() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Yt() },
    },
  ]),
  vertexShader: Xt.meshphysical_vert,
  fragmentShader: Xt.meshphysical_frag,
};
const av = { r: 0, b: 0, g: 0 };
function XV(t, e, n, r, i, o, a) {
  const s = new pt(0);
  let l = o === !0 ? 0 : 1,
    c,
    u,
    d = null,
    p = 0,
    m = null;
  function v(x, g) {
    let _ = !1,
      y = g.isScene === !0 ? g.background : null;
    y && y.isTexture && (y = (g.backgroundBlurriness > 0 ? n : e).get(y)),
      y === null ? S(s, l) : y && y.isColor && (S(y, 1), (_ = !0));
    const w = t.xr.getEnvironmentBlendMode();
    w === "additive"
      ? r.buffers.color.setClear(0, 0, 0, 1, a)
      : w === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, a),
      (t.autoClear || _) &&
        t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
      y && (y.isCubeTexture || y.mapping === Tf)
        ? (u === void 0 &&
            ((u = new Jn(
              new xu(1, 1, 1),
              new Ia({
                name: "BackgroundCubeMaterial",
                uniforms: pf(_a.backgroundCube.uniforms),
                vertexShader: _a.backgroundCube.vertexShader,
                fragmentShader: _a.backgroundCube.fragmentShader,
                side: Oi,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            u.geometry.deleteAttribute("normal"),
            u.geometry.deleteAttribute("uv"),
            (u.onBeforeRender = function (A, M, T) {
              this.matrixWorld.copyPosition(T.matrixWorld);
            }),
            Object.defineProperty(u.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            i.update(u)),
          (u.material.uniforms.envMap.value = y),
          (u.material.uniforms.flipEnvMap.value =
            y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1),
          (u.material.uniforms.backgroundBlurriness.value =
            g.backgroundBlurriness),
          (u.material.uniforms.backgroundIntensity.value =
            g.backgroundIntensity),
          (u.material.toneMapped = Mn.getTransfer(y.colorSpace) !== Un),
          (d !== y || p !== y.version || m !== t.toneMapping) &&
            ((u.material.needsUpdate = !0),
            (d = y),
            (p = y.version),
            (m = t.toneMapping)),
          u.layers.enableAll(),
          x.unshift(u, u.geometry, u.material, 0, 0, null))
        : y &&
          y.isTexture &&
          (c === void 0 &&
            ((c = new Jn(
              new Zl(2, 2),
              new Ia({
                name: "BackgroundMaterial",
                uniforms: pf(_a.background.uniforms),
                vertexShader: _a.background.vertexShader,
                fragmentShader: _a.background.fragmentShader,
                side: js,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            c.geometry.deleteAttribute("normal"),
            Object.defineProperty(c.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            i.update(c)),
          (c.material.uniforms.t2D.value = y),
          (c.material.uniforms.backgroundIntensity.value =
            g.backgroundIntensity),
          (c.material.toneMapped = Mn.getTransfer(y.colorSpace) !== Un),
          y.matrixAutoUpdate === !0 && y.updateMatrix(),
          c.material.uniforms.uvTransform.value.copy(y.matrix),
          (d !== y || p !== y.version || m !== t.toneMapping) &&
            ((c.material.needsUpdate = !0),
            (d = y),
            (p = y.version),
            (m = t.toneMapping)),
          c.layers.enableAll(),
          x.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function S(x, g) {
    x.getRGB(av, KF(t)), r.buffers.color.setClear(av.r, av.g, av.b, g, a);
  }
  return {
    getClearColor: function () {
      return s;
    },
    setClearColor: function (x, g = 1) {
      s.set(x), (l = g), S(s, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (x) {
      (l = x), S(s, l);
    },
    render: v,
  };
}
function qV(t, e, n, r) {
  const i = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    o = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    a = r.isWebGL2 || o !== null,
    s = {},
    l = x(null);
  let c = l,
    u = !1;
  function d(N, V, W, Q, B) {
    let $ = !1;
    if (a) {
      const G = S(Q, W, V);
      c !== G && ((c = G), m(c.object)),
        ($ = g(N, Q, W, B)),
        $ && _(N, Q, W, B);
    } else {
      const G = V.wireframe === !0;
      (c.geometry !== Q.id || c.program !== W.id || c.wireframe !== G) &&
        ((c.geometry = Q.id), (c.program = W.id), (c.wireframe = G), ($ = !0));
    }
    B !== null && n.update(B, t.ELEMENT_ARRAY_BUFFER),
      ($ || u) &&
        ((u = !1),
        I(N, V, W, Q),
        B !== null && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(B).buffer));
  }
  function p() {
    return r.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES();
  }
  function m(N) {
    return r.isWebGL2 ? t.bindVertexArray(N) : o.bindVertexArrayOES(N);
  }
  function v(N) {
    return r.isWebGL2 ? t.deleteVertexArray(N) : o.deleteVertexArrayOES(N);
  }
  function S(N, V, W) {
    const Q = W.wireframe === !0;
    let B = s[N.id];
    B === void 0 && ((B = {}), (s[N.id] = B));
    let $ = B[V.id];
    $ === void 0 && (($ = {}), (B[V.id] = $));
    let G = $[Q];
    return G === void 0 && ((G = x(p())), ($[Q] = G)), G;
  }
  function x(N) {
    const V = [],
      W = [],
      Q = [];
    for (let B = 0; B < i; B++) (V[B] = 0), (W[B] = 0), (Q[B] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: V,
      enabledAttributes: W,
      attributeDivisors: Q,
      object: N,
      attributes: {},
      index: null,
    };
  }
  function g(N, V, W, Q) {
    const B = c.attributes,
      $ = V.attributes;
    let G = 0;
    const k = W.getAttributes();
    for (const q in k)
      if (k[q].location >= 0) {
        const ee = B[q];
        let J = $[q];
        if (
          (J === void 0 &&
            (q === "instanceMatrix" &&
              N.instanceMatrix &&
              (J = N.instanceMatrix),
            q === "instanceColor" && N.instanceColor && (J = N.instanceColor)),
          ee === void 0 || ee.attribute !== J || (J && ee.data !== J.data))
        )
          return !0;
        G++;
      }
    return c.attributesNum !== G || c.index !== Q;
  }
  function _(N, V, W, Q) {
    const B = {},
      $ = V.attributes;
    let G = 0;
    const k = W.getAttributes();
    for (const q in k)
      if (k[q].location >= 0) {
        let ee = $[q];
        ee === void 0 &&
          (q === "instanceMatrix" &&
            N.instanceMatrix &&
            (ee = N.instanceMatrix),
          q === "instanceColor" && N.instanceColor && (ee = N.instanceColor));
        const J = {};
        (J.attribute = ee),
          ee && ee.data && (J.data = ee.data),
          (B[q] = J),
          G++;
      }
    (c.attributes = B), (c.attributesNum = G), (c.index = Q);
  }
  function y() {
    const N = c.newAttributes;
    for (let V = 0, W = N.length; V < W; V++) N[V] = 0;
  }
  function w(N) {
    A(N, 0);
  }
  function A(N, V) {
    const W = c.newAttributes,
      Q = c.enabledAttributes,
      B = c.attributeDivisors;
    (W[N] = 1),
      Q[N] === 0 && (t.enableVertexAttribArray(N), (Q[N] = 1)),
      B[N] !== V &&
        ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
          r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](N, V),
        (B[N] = V));
  }
  function M() {
    const N = c.newAttributes,
      V = c.enabledAttributes;
    for (let W = 0, Q = V.length; W < Q; W++)
      V[W] !== N[W] && (t.disableVertexAttribArray(W), (V[W] = 0));
  }
  function T(N, V, W, Q, B, $, G) {
    G === !0
      ? t.vertexAttribIPointer(N, V, W, B, $)
      : t.vertexAttribPointer(N, V, W, Q, B, $);
  }
  function I(N, V, W, Q) {
    if (
      r.isWebGL2 === !1 &&
      (N.isInstancedMesh || Q.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    y();
    const B = Q.attributes,
      $ = W.getAttributes(),
      G = V.defaultAttributeValues;
    for (const k in $) {
      const q = $[k];
      if (q.location >= 0) {
        let X = B[k];
        if (
          (X === void 0 &&
            (k === "instanceMatrix" &&
              N.instanceMatrix &&
              (X = N.instanceMatrix),
            k === "instanceColor" && N.instanceColor && (X = N.instanceColor)),
          X !== void 0)
        ) {
          const ee = X.normalized,
            J = X.itemSize,
            oe = n.get(X);
          if (oe === void 0) continue;
          const ae = oe.buffer,
            le = oe.type,
            _e = oe.bytesPerElement,
            me =
              r.isWebGL2 === !0 &&
              (le === t.INT || le === t.UNSIGNED_INT || X.gpuType === WM);
          if (X.isInterleavedBufferAttribute) {
            const se = X.data,
              Y = se.stride,
              ve = X.offset;
            if (se.isInstancedInterleavedBuffer) {
              for (let de = 0; de < q.locationSize; de++)
                A(q.location + de, se.meshPerAttribute);
              N.isInstancedMesh !== !0 &&
                Q._maxInstanceCount === void 0 &&
                (Q._maxInstanceCount = se.meshPerAttribute * se.count);
            } else
              for (let de = 0; de < q.locationSize; de++) w(q.location + de);
            t.bindBuffer(t.ARRAY_BUFFER, ae);
            for (let de = 0; de < q.locationSize; de++)
              T(
                q.location + de,
                J / q.locationSize,
                le,
                ee,
                Y * _e,
                (ve + (J / q.locationSize) * de) * _e,
                me
              );
          } else {
            if (X.isInstancedBufferAttribute) {
              for (let se = 0; se < q.locationSize; se++)
                A(q.location + se, X.meshPerAttribute);
              N.isInstancedMesh !== !0 &&
                Q._maxInstanceCount === void 0 &&
                (Q._maxInstanceCount = X.meshPerAttribute * X.count);
            } else
              for (let se = 0; se < q.locationSize; se++) w(q.location + se);
            t.bindBuffer(t.ARRAY_BUFFER, ae);
            for (let se = 0; se < q.locationSize; se++)
              T(
                q.location + se,
                J / q.locationSize,
                le,
                ee,
                J * _e,
                (J / q.locationSize) * se * _e,
                me
              );
          }
        } else if (G !== void 0) {
          const ee = G[k];
          if (ee !== void 0)
            switch (ee.length) {
              case 2:
                t.vertexAttrib2fv(q.location, ee);
                break;
              case 3:
                t.vertexAttrib3fv(q.location, ee);
                break;
              case 4:
                t.vertexAttrib4fv(q.location, ee);
                break;
              default:
                t.vertexAttrib1fv(q.location, ee);
            }
        }
      }
    }
    M();
  }
  function R() {
    D();
    for (const N in s) {
      const V = s[N];
      for (const W in V) {
        const Q = V[W];
        for (const B in Q) v(Q[B].object), delete Q[B];
        delete V[W];
      }
      delete s[N];
    }
  }
  function P(N) {
    if (s[N.id] === void 0) return;
    const V = s[N.id];
    for (const W in V) {
      const Q = V[W];
      for (const B in Q) v(Q[B].object), delete Q[B];
      delete V[W];
    }
    delete s[N.id];
  }
  function F(N) {
    for (const V in s) {
      const W = s[V];
      if (W[N.id] === void 0) continue;
      const Q = W[N.id];
      for (const B in Q) v(Q[B].object), delete Q[B];
      delete W[N.id];
    }
  }
  function D() {
    j(), (u = !0), c !== l && ((c = l), m(c.object));
  }
  function j() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: d,
    reset: D,
    resetDefaultState: j,
    dispose: R,
    releaseStatesOfGeometry: P,
    releaseStatesOfProgram: F,
    initAttributes: y,
    enableAttribute: w,
    disableUnusedAttributes: M,
  };
}
function KV(t, e, n, r) {
  const i = r.isWebGL2;
  let o;
  function a(u) {
    o = u;
  }
  function s(u, d) {
    t.drawArrays(o, u, d), n.update(d, o, 1);
  }
  function l(u, d, p) {
    if (p === 0) return;
    let m, v;
    if (i) (m = t), (v = "drawArraysInstanced");
    else if (
      ((m = e.get("ANGLE_instanced_arrays")),
      (v = "drawArraysInstancedANGLE"),
      m === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    m[v](o, u, d, p), n.update(d, o, p);
  }
  function c(u, d, p) {
    if (p === 0) return;
    const m = e.get("WEBGL_multi_draw");
    if (m === null) for (let v = 0; v < p; v++) this.render(u[v], d[v]);
    else {
      m.multiDrawArraysWEBGL(o, u, 0, d, 0, p);
      let v = 0;
      for (let S = 0; S < p; S++) v += d[S];
      n.update(v, o, 1);
    }
  }
  (this.setMode = a),
    (this.render = s),
    (this.renderInstances = l),
    (this.renderMultiDraw = c);
}
function YV(t, e, n) {
  let r;
  function i() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const T = e.get("EXT_texture_filter_anisotropic");
      r = t.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else r = 0;
    return r;
  }
  function o(T) {
    if (T === "highp") {
      if (
        t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision >
          0 &&
        t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      T = "mediump";
    }
    return T === "mediump" &&
      t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision >
        0 &&
      t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const a =
    typeof WebGL2RenderingContext < "u" &&
    t.constructor.name === "WebGL2RenderingContext";
  let s = n.precision !== void 0 ? n.precision : "highp";
  const l = o(s);
  l !== s &&
    (console.warn(
      "THREE.WebGLRenderer:",
      s,
      "not supported, using",
      l,
      "instead."
    ),
    (s = l));
  const c = a || e.has("WEBGL_draw_buffers"),
    u = n.logarithmicDepthBuffer === !0,
    d = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
    p = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    m = t.getParameter(t.MAX_TEXTURE_SIZE),
    v = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
    S = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    x = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
    g = t.getParameter(t.MAX_VARYING_VECTORS),
    _ = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
    y = p > 0,
    w = a || e.has("OES_texture_float"),
    A = y && w,
    M = a ? t.getParameter(t.MAX_SAMPLES) : 0;
  return {
    isWebGL2: a,
    drawBuffers: c,
    getMaxAnisotropy: i,
    getMaxPrecision: o,
    precision: s,
    logarithmicDepthBuffer: u,
    maxTextures: d,
    maxVertexTextures: p,
    maxTextureSize: m,
    maxCubemapSize: v,
    maxAttributes: S,
    maxVertexUniforms: x,
    maxVaryings: g,
    maxFragmentUniforms: _,
    vertexTextures: y,
    floatFragmentTextures: w,
    floatVertexTextures: A,
    maxSamples: M,
  };
}
function ZV(t) {
  const e = this;
  let n = null,
    r = 0,
    i = !1,
    o = !1;
  const a = new Ts(),
    s = new Yt(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (d, p) {
      const m = d.length !== 0 || p || r !== 0 || i;
      return (i = p), (r = d.length), m;
    }),
    (this.beginShadows = function () {
      (o = !0), u(null);
    }),
    (this.endShadows = function () {
      o = !1;
    }),
    (this.setGlobalState = function (d, p) {
      n = u(d, p, 0);
    }),
    (this.setState = function (d, p, m) {
      const v = d.clippingPlanes,
        S = d.clipIntersection,
        x = d.clipShadows,
        g = t.get(d);
      if (!i || v === null || v.length === 0 || (o && !x)) o ? u(null) : c();
      else {
        const _ = o ? 0 : r,
          y = _ * 4;
        let w = g.clippingState || null;
        (l.value = w), (w = u(v, p, y, m));
        for (let A = 0; A !== y; ++A) w[A] = n[A];
        (g.clippingState = w),
          (this.numIntersection = S ? this.numPlanes : 0),
          (this.numPlanes += _);
      }
    });
  function c() {
    l.value !== n && ((l.value = n), (l.needsUpdate = r > 0)),
      (e.numPlanes = r),
      (e.numIntersection = 0);
  }
  function u(d, p, m, v) {
    const S = d !== null ? d.length : 0;
    let x = null;
    if (S !== 0) {
      if (((x = l.value), v !== !0 || x === null)) {
        const g = m + S * 4,
          _ = p.matrixWorldInverse;
        s.getNormalMatrix(_),
          (x === null || x.length < g) && (x = new Float32Array(g));
        for (let y = 0, w = m; y !== S; ++y, w += 4)
          a.copy(d[y]).applyMatrix4(_, s),
            a.normal.toArray(x, w),
            (x[w + 3] = a.constant);
      }
      (l.value = x), (l.needsUpdate = !0);
    }
    return (e.numPlanes = S), (e.numIntersection = 0), x;
  }
}
function QV(t) {
  let e = new WeakMap();
  function n(a, s) {
    return s === Cp ? (a.mapping = Vs) : s === Tp && (a.mapping = Bl), a;
  }
  function r(a) {
    if (a && a.isTexture) {
      const s = a.mapping;
      if (s === Cp || s === Tp)
        if (e.has(a)) {
          const l = e.get(a).texture;
          return n(l, a.mapping);
        } else {
          const l = a.image;
          if (l && l.height > 0) {
            const c = new ZF(l.height / 2);
            return (
              c.fromEquirectangularTexture(t, a),
              e.set(a, c),
              a.addEventListener("dispose", i),
              n(c.texture, a.mapping)
            );
          } else return null;
        }
    }
    return a;
  }
  function i(a) {
    const s = a.target;
    s.removeEventListener("dispose", i);
    const l = e.get(s);
    l !== void 0 && (e.delete(s), l.dispose());
  }
  function o() {
    e = new WeakMap();
  }
  return { get: r, dispose: o };
}
class ts extends pm {
  constructor(e = -1, n = 1, r = 1, i = -1, o = 0.1, a = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = n),
      (this.top = r),
      (this.bottom = i),
      (this.near = o),
      (this.far = a),
      this.updateProjectionMatrix();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, n, r, i, o, a) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = n),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = o),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      n = (this.top - this.bottom) / (2 * this.zoom),
      r = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let o = r - e,
      a = r + e,
      s = i + n,
      l = i - n;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (o += c * this.view.offsetX),
        (a = o + c * this.view.width),
        (s -= u * this.view.offsetY),
        (l = s - u * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      o,
      a,
      s,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.zoom = this.zoom),
      (n.object.left = this.left),
      (n.object.right = this.right),
      (n.object.top = this.top),
      (n.object.bottom = this.bottom),
      (n.object.near = this.near),
      (n.object.far = this.far),
      this.view !== null && (n.object.view = Object.assign({}, this.view)),
      n
    );
  }
}
const kd = 4,
  IR = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Nc = 20,
  jS = new ts(),
  LR = new pt();
let VS = null,
  $S = 0,
  GS = 0;
const Pc = (1 + Math.sqrt(5)) / 2,
  td = 1 / Pc,
  OR = [
    new K(1, 1, 1),
    new K(-1, 1, 1),
    new K(1, 1, -1),
    new K(-1, 1, -1),
    new K(0, Pc, td),
    new K(0, Pc, -td),
    new K(td, 0, Pc),
    new K(-td, 0, Pc),
    new K(Pc, td, 0),
    new K(-Pc, td, 0),
  ];
class Lw {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, n = 0, r = 0.1, i = 100) {
    (VS = this._renderer.getRenderTarget()),
      ($S = this._renderer.getActiveCubeFace()),
      (GS = this._renderer.getActiveMipmapLevel()),
      this._setSize(256);
    const o = this._allocateTargets();
    return (
      (o.depthBuffer = !0),
      this._sceneToCubeUV(e, r, i, o),
      n > 0 && this._blur(o, 0, 0, n),
      this._applyPMREM(o),
      this._cleanup(o),
      o
    );
  }
  fromEquirectangular(e, n = null) {
    return this._fromTexture(e, n);
  }
  fromCubemap(e, n = null) {
    return this._fromTexture(e, n);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = DR()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = FR()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(VS, $S, GS),
      (e.scissorTest = !1),
      sv(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, n) {
    e.mapping === Vs || e.mapping === Bl
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (VS = this._renderer.getRenderTarget()),
      ($S = this._renderer.getActiveCubeFace()),
      (GS = this._renderer.getActiveMipmapLevel());
    const r = n || this._allocateTargets();
    return (
      this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      n = 4 * this._cubeSize,
      r = {
        magFilter: Yn,
        minFilter: Yn,
        generateMipmaps: !1,
        type: df,
        format: Ii,
        colorSpace: rs,
        depthBuffer: !1,
      },
      i = NR(e, n, r);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== n
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = NR(e, n, r));
      const { _lodMax: o } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = JV(o)),
        (this._blurMaterial = e$(o, e, n));
    }
    return i;
  }
  _compileMaterial(e) {
    const n = new Jn(this._lodPlanes[0], e);
    this._renderer.compile(n, jS);
  }
  _sceneToCubeUV(e, n, r, i) {
    const s = new Zn(90, 1, n, r),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      u = this._renderer,
      d = u.autoClear,
      p = u.toneMapping;
    u.getClearColor(LR), (u.toneMapping = Ja), (u.autoClear = !1);
    const m = new Ks({
        name: "PMREM.Background",
        side: Oi,
        depthWrite: !1,
        depthTest: !1,
      }),
      v = new Jn(new xu(), m);
    let S = !1;
    const x = e.background;
    x
      ? x.isColor && (m.color.copy(x), (e.background = null), (S = !0))
      : (m.color.copy(LR), (S = !0));
    for (let g = 0; g < 6; g++) {
      const _ = g % 3;
      _ === 0
        ? (s.up.set(0, l[g], 0), s.lookAt(c[g], 0, 0))
        : _ === 1
        ? (s.up.set(0, 0, l[g]), s.lookAt(0, c[g], 0))
        : (s.up.set(0, l[g], 0), s.lookAt(0, 0, c[g]));
      const y = this._cubeSize;
      sv(i, _ * y, g > 2 ? y : 0, y, y),
        u.setRenderTarget(i),
        S && u.render(v, s),
        u.render(e, s);
    }
    v.geometry.dispose(),
      v.material.dispose(),
      (u.toneMapping = p),
      (u.autoClear = d),
      (e.background = x);
  }
  _textureToCubeUV(e, n) {
    const r = this._renderer,
      i = e.mapping === Vs || e.mapping === Bl;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = DR()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = FR());
    const o = i ? this._cubemapMaterial : this._equirectMaterial,
      a = new Jn(this._lodPlanes[0], o),
      s = o.uniforms;
    s.envMap.value = e;
    const l = this._cubeSize;
    sv(n, 0, 0, 3 * l, 2 * l), r.setRenderTarget(n), r.render(a, jS);
  }
  _applyPMREM(e) {
    const n = this._renderer,
      r = n.autoClear;
    n.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const o = Math.sqrt(
          this._sigmas[i] * this._sigmas[i] -
            this._sigmas[i - 1] * this._sigmas[i - 1]
        ),
        a = OR[(i - 1) % OR.length];
      this._blur(e, i - 1, i, o, a);
    }
    n.autoClear = r;
  }
  _blur(e, n, r, i, o) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(e, a, n, r, i, "latitudinal", o),
      this._halfBlur(a, e, r, r, i, "longitudinal", o);
  }
  _halfBlur(e, n, r, i, o, a, s) {
    const l = this._renderer,
      c = this._blurMaterial;
    a !== "latitudinal" &&
      a !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const u = 3,
      d = new Jn(this._lodPlanes[i], c),
      p = c.uniforms,
      m = this._sizeLods[r] - 1,
      v = isFinite(o) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * Nc - 1),
      S = o / v,
      x = isFinite(o) ? 1 + Math.floor(u * S) : Nc;
    x > Nc &&
      console.warn(
        `sigmaRadians, ${o}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${Nc}`
      );
    const g = [];
    let _ = 0;
    for (let T = 0; T < Nc; ++T) {
      const I = T / S,
        R = Math.exp((-I * I) / 2);
      g.push(R), T === 0 ? (_ += R) : T < x && (_ += 2 * R);
    }
    for (let T = 0; T < g.length; T++) g[T] = g[T] / _;
    (p.envMap.value = e.texture),
      (p.samples.value = x),
      (p.weights.value = g),
      (p.latitudinal.value = a === "latitudinal"),
      s && (p.poleAxis.value = s);
    const { _lodMax: y } = this;
    (p.dTheta.value = v), (p.mipInt.value = y - r);
    const w = this._sizeLods[i],
      A = 3 * w * (i > y - kd ? i - y + kd : 0),
      M = 4 * (this._cubeSize - w);
    sv(n, A, M, 3 * w, 2 * w), l.setRenderTarget(n), l.render(d, jS);
  }
}
function JV(t) {
  const e = [],
    n = [],
    r = [];
  let i = t;
  const o = t - kd + 1 + IR.length;
  for (let a = 0; a < o; a++) {
    const s = Math.pow(2, i);
    n.push(s);
    let l = 1 / s;
    a > t - kd ? (l = IR[a - t + kd - 1]) : a === 0 && (l = 0), r.push(l);
    const c = 1 / (s - 2),
      u = -c,
      d = 1 + c,
      p = [u, u, d, u, d, d, u, u, d, d, u, d],
      m = 6,
      v = 6,
      S = 3,
      x = 2,
      g = 1,
      _ = new Float32Array(S * v * m),
      y = new Float32Array(x * v * m),
      w = new Float32Array(g * v * m);
    for (let M = 0; M < m; M++) {
      const T = ((M % 3) * 2) / 3 - 1,
        I = M > 2 ? 0 : -1,
        R = [
          T,
          I,
          0,
          T + 2 / 3,
          I,
          0,
          T + 2 / 3,
          I + 1,
          0,
          T,
          I,
          0,
          T + 2 / 3,
          I + 1,
          0,
          T,
          I + 1,
          0,
        ];
      _.set(R, S * v * M), y.set(p, x * v * M);
      const P = [M, M, M, M, M, M];
      w.set(P, g * v * M);
    }
    const A = new Jt();
    A.setAttribute("position", new wn(_, S)),
      A.setAttribute("uv", new wn(y, x)),
      A.setAttribute("faceIndex", new wn(w, g)),
      e.push(A),
      i > kd && i--;
  }
  return { lodPlanes: e, sizeLods: n, sigmas: r };
}
function NR(t, e, n) {
  const r = new Pa(t, e, n);
  return (
    (r.texture.mapping = Tf),
    (r.texture.name = "PMREM.cubeUv"),
    (r.scissorTest = !0),
    r
  );
}
function sv(t, e, n, r, i) {
  t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i);
}
function e$(t, e, n) {
  const r = new Float32Array(Nc),
    i = new K(0, 1, 0);
  return new Ia({
    name: "SphericalGaussianBlur",
    defines: {
      n: Nc,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / n,
      CUBEUV_MAX_MIP: `${t}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: lC(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Fs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function FR() {
  return new Ia({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: lC(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Fs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function DR() {
  return new Ia({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: lC(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Fs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function lC() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function t$(t) {
  let e = new WeakMap(),
    n = null;
  function r(s) {
    if (s && s.isTexture) {
      const l = s.mapping,
        c = l === Cp || l === Tp,
        u = l === Vs || l === Bl;
      if (c || u)
        if (s.isRenderTargetTexture && s.needsPMREMUpdate === !0) {
          s.needsPMREMUpdate = !1;
          let d = e.get(s);
          return (
            n === null && (n = new Lw(t)),
            (d = c ? n.fromEquirectangular(s, d) : n.fromCubemap(s, d)),
            e.set(s, d),
            d.texture
          );
        } else {
          if (e.has(s)) return e.get(s).texture;
          {
            const d = s.image;
            if ((c && d && d.height > 0) || (u && d && i(d))) {
              n === null && (n = new Lw(t));
              const p = c ? n.fromEquirectangular(s) : n.fromCubemap(s);
              return e.set(s, p), s.addEventListener("dispose", o), p.texture;
            } else return null;
          }
        }
    }
    return s;
  }
  function i(s) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++) s[u] !== void 0 && l++;
    return l === c;
  }
  function o(s) {
    const l = s.target;
    l.removeEventListener("dispose", o);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    (e = new WeakMap()), n !== null && (n.dispose(), (n = null));
  }
  return { get: r, dispose: a };
}
function n$(t) {
  const e = {};
  function n(r) {
    if (e[r] !== void 0) return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i =
          t.getExtension("WEBGL_depth_texture") ||
          t.getExtension("MOZ_WEBGL_depth_texture") ||
          t.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          t.getExtension("EXT_texture_filter_anisotropic") ||
          t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          t.getExtension("WEBGL_compressed_texture_s3tc") ||
          t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          t.getExtension("WEBGL_compressed_texture_pvrtc") ||
          t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = t.getExtension(r);
    }
    return (e[r] = i), i;
  }
  return {
    has: function (r) {
      return n(r) !== null;
    },
    init: function (r) {
      r.isWebGL2
        ? (n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"))
        : (n("WEBGL_depth_texture"),
          n("OES_texture_float"),
          n("OES_texture_half_float"),
          n("OES_texture_half_float_linear"),
          n("OES_standard_derivatives"),
          n("OES_element_index_uint"),
          n("OES_vertex_array_object"),
          n("ANGLE_instanced_arrays")),
        n("OES_texture_float_linear"),
        n("EXT_color_buffer_half_float"),
        n("WEBGL_multisampled_render_to_texture");
    },
    get: function (r) {
      const i = n(r);
      return (
        i === null &&
          console.warn(
            "THREE.WebGLRenderer: " + r + " extension not supported."
          ),
        i
      );
    },
  };
}
function r$(t, e, n, r) {
  const i = {},
    o = new WeakMap();
  function a(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const v in p.attributes) e.remove(p.attributes[v]);
    for (const v in p.morphAttributes) {
      const S = p.morphAttributes[v];
      for (let x = 0, g = S.length; x < g; x++) e.remove(S[x]);
    }
    p.removeEventListener("dispose", a), delete i[p.id];
    const m = o.get(p);
    m && (e.remove(m), o.delete(p)),
      r.releaseStatesOfGeometry(p),
      p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
      n.memory.geometries--;
  }
  function s(d, p) {
    return (
      i[p.id] === !0 ||
        (p.addEventListener("dispose", a),
        (i[p.id] = !0),
        n.memory.geometries++),
      p
    );
  }
  function l(d) {
    const p = d.attributes;
    for (const v in p) e.update(p[v], t.ARRAY_BUFFER);
    const m = d.morphAttributes;
    for (const v in m) {
      const S = m[v];
      for (let x = 0, g = S.length; x < g; x++) e.update(S[x], t.ARRAY_BUFFER);
    }
  }
  function c(d) {
    const p = [],
      m = d.index,
      v = d.attributes.position;
    let S = 0;
    if (m !== null) {
      const _ = m.array;
      S = m.version;
      for (let y = 0, w = _.length; y < w; y += 3) {
        const A = _[y + 0],
          M = _[y + 1],
          T = _[y + 2];
        p.push(A, M, M, T, T, A);
      }
    } else if (v !== void 0) {
      const _ = v.array;
      S = v.version;
      for (let y = 0, w = _.length / 3 - 1; y < w; y += 3) {
        const A = y + 0,
          M = y + 1,
          T = y + 2;
        p.push(A, M, M, T, T, A);
      }
    } else return;
    const x = new (GF(p) ? sC : aC)(p, 1);
    x.version = S;
    const g = o.get(d);
    g && e.remove(g), o.set(d, x);
  }
  function u(d) {
    const p = o.get(d);
    if (p) {
      const m = d.index;
      m !== null && p.version < m.version && c(d);
    } else c(d);
    return o.get(d);
  }
  return { get: s, update: l, getWireframeAttribute: u };
}
function i$(t, e, n, r) {
  const i = r.isWebGL2;
  let o;
  function a(m) {
    o = m;
  }
  let s, l;
  function c(m) {
    (s = m.type), (l = m.bytesPerElement);
  }
  function u(m, v) {
    t.drawElements(o, v, s, m * l), n.update(v, o, 1);
  }
  function d(m, v, S) {
    if (S === 0) return;
    let x, g;
    if (i) (x = t), (g = "drawElementsInstanced");
    else if (
      ((x = e.get("ANGLE_instanced_arrays")),
      (g = "drawElementsInstancedANGLE"),
      x === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    x[g](o, v, s, m * l, S), n.update(v, o, S);
  }
  function p(m, v, S) {
    if (S === 0) return;
    const x = e.get("WEBGL_multi_draw");
    if (x === null) for (let g = 0; g < S; g++) this.render(m[g] / l, v[g]);
    else {
      x.multiDrawElementsWEBGL(o, v, 0, s, m, 0, S);
      let g = 0;
      for (let _ = 0; _ < S; _++) g += v[_];
      n.update(g, o, 1);
    }
  }
  (this.setMode = a),
    (this.setIndex = c),
    (this.render = u),
    (this.renderInstances = d),
    (this.renderMultiDraw = p);
}
function o$(t) {
  const e = { geometries: 0, textures: 0 },
    n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(o, a, s) {
    switch ((n.calls++, a)) {
      case t.TRIANGLES:
        n.triangles += s * (o / 3);
        break;
      case t.LINES:
        n.lines += s * (o / 2);
        break;
      case t.LINE_STRIP:
        n.lines += s * (o - 1);
        break;
      case t.LINE_LOOP:
        n.lines += s * o;
        break;
      case t.POINTS:
        n.points += s * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function i() {
    (n.calls = 0), (n.triangles = 0), (n.points = 0), (n.lines = 0);
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r,
  };
}
function a$(t, e) {
  return t[0] - e[0];
}
function s$(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}
function l$(t, e, n) {
  const r = {},
    i = new Float32Array(8),
    o = new WeakMap(),
    a = new rn(),
    s = [];
  for (let c = 0; c < 8; c++) s[c] = [c, 0];
  function l(c, u, d) {
    const p = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const m =
          u.morphAttributes.position ||
          u.morphAttributes.normal ||
          u.morphAttributes.color,
        v = m !== void 0 ? m.length : 0;
      let S = o.get(u);
      if (S === void 0 || S.count !== v) {
        let N = function () {
          D.dispose(), o.delete(u), u.removeEventListener("dispose", N);
        };
        S !== void 0 && S.texture.dispose();
        const _ = u.morphAttributes.position !== void 0,
          y = u.morphAttributes.normal !== void 0,
          w = u.morphAttributes.color !== void 0,
          A = u.morphAttributes.position || [],
          M = u.morphAttributes.normal || [],
          T = u.morphAttributes.color || [];
        let I = 0;
        _ === !0 && (I = 1), y === !0 && (I = 2), w === !0 && (I = 3);
        let R = u.attributes.position.count * I,
          P = 1;
        R > e.maxTextureSize &&
          ((P = Math.ceil(R / e.maxTextureSize)), (R = e.maxTextureSize));
        const F = new Float32Array(R * P * 4 * v),
          D = new n1(F, R, P, v);
        (D.type = wa), (D.needsUpdate = !0);
        const j = I * 4;
        for (let V = 0; V < v; V++) {
          const W = A[V],
            Q = M[V],
            B = T[V],
            $ = R * P * 4 * V;
          for (let G = 0; G < W.count; G++) {
            const k = G * j;
            _ === !0 &&
              (a.fromBufferAttribute(W, G),
              (F[$ + k + 0] = a.x),
              (F[$ + k + 1] = a.y),
              (F[$ + k + 2] = a.z),
              (F[$ + k + 3] = 0)),
              y === !0 &&
                (a.fromBufferAttribute(Q, G),
                (F[$ + k + 4] = a.x),
                (F[$ + k + 5] = a.y),
                (F[$ + k + 6] = a.z),
                (F[$ + k + 7] = 0)),
              w === !0 &&
                (a.fromBufferAttribute(B, G),
                (F[$ + k + 8] = a.x),
                (F[$ + k + 9] = a.y),
                (F[$ + k + 10] = a.z),
                (F[$ + k + 11] = B.itemSize === 4 ? a.w : 1));
          }
        }
        (S = { count: v, texture: D, size: new Ge(R, P) }),
          o.set(u, S),
          u.addEventListener("dispose", N);
      }
      let x = 0;
      for (let _ = 0; _ < p.length; _++) x += p[_];
      const g = u.morphTargetsRelative ? 1 : 1 - x;
      d.getUniforms().setValue(t, "morphTargetBaseInfluence", g),
        d.getUniforms().setValue(t, "morphTargetInfluences", p),
        d.getUniforms().setValue(t, "morphTargetsTexture", S.texture, n),
        d.getUniforms().setValue(t, "morphTargetsTextureSize", S.size);
    } else {
      const m = p === void 0 ? 0 : p.length;
      let v = r[u.id];
      if (v === void 0 || v.length !== m) {
        v = [];
        for (let y = 0; y < m; y++) v[y] = [y, 0];
        r[u.id] = v;
      }
      for (let y = 0; y < m; y++) {
        const w = v[y];
        (w[0] = y), (w[1] = p[y]);
      }
      v.sort(s$);
      for (let y = 0; y < 8; y++)
        y < m && v[y][1]
          ? ((s[y][0] = v[y][0]), (s[y][1] = v[y][1]))
          : ((s[y][0] = Number.MAX_SAFE_INTEGER), (s[y][1] = 0));
      s.sort(a$);
      const S = u.morphAttributes.position,
        x = u.morphAttributes.normal;
      let g = 0;
      for (let y = 0; y < 8; y++) {
        const w = s[y],
          A = w[0],
          M = w[1];
        A !== Number.MAX_SAFE_INTEGER && M
          ? (S &&
              u.getAttribute("morphTarget" + y) !== S[A] &&
              u.setAttribute("morphTarget" + y, S[A]),
            x &&
              u.getAttribute("morphNormal" + y) !== x[A] &&
              u.setAttribute("morphNormal" + y, x[A]),
            (i[y] = M),
            (g += M))
          : (S &&
              u.hasAttribute("morphTarget" + y) === !0 &&
              u.deleteAttribute("morphTarget" + y),
            x &&
              u.hasAttribute("morphNormal" + y) === !0 &&
              u.deleteAttribute("morphNormal" + y),
            (i[y] = 0));
      }
      const _ = u.morphTargetsRelative ? 1 : 1 - g;
      d.getUniforms().setValue(t, "morphTargetBaseInfluence", _),
        d.getUniforms().setValue(t, "morphTargetInfluences", i);
    }
  }
  return { update: l };
}
function c$(t, e, n, r) {
  let i = new WeakMap();
  function o(l) {
    const c = r.render.frame,
      u = l.geometry,
      d = e.get(l, u);
    if (
      (i.get(d) !== c && (e.update(d), i.set(d, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", s) === !1 &&
          l.addEventListener("dispose", s),
        i.get(l) !== c &&
          (n.update(l.instanceMatrix, t.ARRAY_BUFFER),
          l.instanceColor !== null && n.update(l.instanceColor, t.ARRAY_BUFFER),
          i.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const p = l.skeleton;
      i.get(p) !== c && (p.update(), i.set(p, c));
    }
    return d;
  }
  function a() {
    i = new WeakMap();
  }
  function s(l) {
    const c = l.target;
    c.removeEventListener("dispose", s),
      n.remove(c.instanceMatrix),
      c.instanceColor !== null && n.remove(c.instanceColor);
  }
  return { update: o, dispose: a };
}
class cC extends sr {
  constructor(e, n, r, i, o, a, s, l, c, u) {
    if (((u = u !== void 0 ? u : Fl), u !== Fl && u !== cu))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    r === void 0 && u === Fl && (r = Ls),
      r === void 0 && u === cu && (r = Nl),
      super(null, i, o, a, s, l, u, r, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: n }),
      (this.magFilter = s !== void 0 ? s : pr),
      (this.minFilter = l !== void 0 ? l : pr),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (n.compareFunction = this.compareFunction),
      n
    );
  }
}
const JF = new sr(),
  eD = new cC(1, 1);
eD.compareFunction = nC;
const tD = new n1(),
  nD = new oC(),
  rD = new mm(),
  zR = [],
  UR = [],
  kR = new Float32Array(16),
  BR = new Float32Array(9),
  HR = new Float32Array(4);
function Af(t, e, n) {
  const r = t[0];
  if (r <= 0 || r > 0) return t;
  const i = e * n;
  let o = zR[i];
  if ((o === void 0 && ((o = new Float32Array(i)), (zR[i] = o)), e !== 0)) {
    r.toArray(o, 0);
    for (let a = 1, s = 0; a !== e; ++a) (s += n), t[a].toArray(o, s);
  }
  return o;
}
function Pr(t, e) {
  if (t.length !== e.length) return !1;
  for (let n = 0, r = t.length; n < r; n++) if (t[n] !== e[n]) return !1;
  return !0;
}
function Ir(t, e) {
  for (let n = 0, r = e.length; n < r; n++) t[n] = e[n];
}
function r1(t, e) {
  let n = UR[e];
  n === void 0 && ((n = new Int32Array(e)), (UR[e] = n));
  for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
  return n;
}
function u$(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
}
function d$(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (Pr(n, e)) return;
    t.uniform2fv(this.addr, e), Ir(n, e);
  }
}
function f$(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3f(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) &&
      (t.uniform3f(this.addr, e.r, e.g, e.b),
      (n[0] = e.r),
      (n[1] = e.g),
      (n[2] = e.b));
  else {
    if (Pr(n, e)) return;
    t.uniform3fv(this.addr, e), Ir(n, e);
  }
}
function h$(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (Pr(n, e)) return;
    t.uniform4fv(this.addr, e), Ir(n, e);
  }
}
function p$(t, e) {
  const n = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Pr(n, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), Ir(n, e);
  } else {
    if (Pr(n, r)) return;
    HR.set(r), t.uniformMatrix2fv(this.addr, !1, HR), Ir(n, r);
  }
}
function m$(t, e) {
  const n = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Pr(n, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), Ir(n, e);
  } else {
    if (Pr(n, r)) return;
    BR.set(r), t.uniformMatrix3fv(this.addr, !1, BR), Ir(n, r);
  }
}
function g$(t, e) {
  const n = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Pr(n, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), Ir(n, e);
  } else {
    if (Pr(n, r)) return;
    kR.set(r), t.uniformMatrix4fv(this.addr, !1, kR), Ir(n, r);
  }
}
function v$(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
}
function y$(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (Pr(n, e)) return;
    t.uniform2iv(this.addr, e), Ir(n, e);
  }
}
function x$(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3i(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else {
    if (Pr(n, e)) return;
    t.uniform3iv(this.addr, e), Ir(n, e);
  }
}
function S$(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (Pr(n, e)) return;
    t.uniform4iv(this.addr, e), Ir(n, e);
  }
}
function _$(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
}
function b$(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (Pr(n, e)) return;
    t.uniform2uiv(this.addr, e), Ir(n, e);
  }
}
function w$(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3ui(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else {
    if (Pr(n, e)) return;
    t.uniform3uiv(this.addr, e), Ir(n, e);
  }
}
function E$(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (Pr(n, e)) return;
    t.uniform4uiv(this.addr, e), Ir(n, e);
  }
}
function M$(t, e, n) {
  const r = this.cache,
    i = n.allocateTextureUnit();
  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i));
  const o = this.type === t.SAMPLER_2D_SHADOW ? eD : JF;
  n.setTexture2D(e || o, i);
}
function C$(t, e, n) {
  const r = this.cache,
    i = n.allocateTextureUnit();
  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
    n.setTexture3D(e || nD, i);
}
function T$(t, e, n) {
  const r = this.cache,
    i = n.allocateTextureUnit();
  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
    n.setTextureCube(e || rD, i);
}
function A$(t, e, n) {
  const r = this.cache,
    i = n.allocateTextureUnit();
  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
    n.setTexture2DArray(e || tD, i);
}
function R$(t) {
  switch (t) {
    case 5126:
      return u$;
    case 35664:
      return d$;
    case 35665:
      return f$;
    case 35666:
      return h$;
    case 35674:
      return p$;
    case 35675:
      return m$;
    case 35676:
      return g$;
    case 5124:
    case 35670:
      return v$;
    case 35667:
    case 35671:
      return y$;
    case 35668:
    case 35672:
      return x$;
    case 35669:
    case 35673:
      return S$;
    case 5125:
      return _$;
    case 36294:
      return b$;
    case 36295:
      return w$;
    case 36296:
      return E$;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return M$;
    case 35679:
    case 36299:
    case 36307:
      return C$;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return T$;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return A$;
  }
}
function P$(t, e) {
  t.uniform1fv(this.addr, e);
}
function I$(t, e) {
  const n = Af(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}
function L$(t, e) {
  const n = Af(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}
function O$(t, e) {
  const n = Af(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}
function N$(t, e) {
  const n = Af(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}
function F$(t, e) {
  const n = Af(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}
function D$(t, e) {
  const n = Af(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}
function z$(t, e) {
  t.uniform1iv(this.addr, e);
}
function U$(t, e) {
  t.uniform2iv(this.addr, e);
}
function k$(t, e) {
  t.uniform3iv(this.addr, e);
}
function B$(t, e) {
  t.uniform4iv(this.addr, e);
}
function H$(t, e) {
  t.uniform1uiv(this.addr, e);
}
function j$(t, e) {
  t.uniform2uiv(this.addr, e);
}
function V$(t, e) {
  t.uniform3uiv(this.addr, e);
}
function $$(t, e) {
  t.uniform4uiv(this.addr, e);
}
function G$(t, e, n) {
  const r = this.cache,
    i = e.length,
    o = r1(n, i);
  Pr(r, o) || (t.uniform1iv(this.addr, o), Ir(r, o));
  for (let a = 0; a !== i; ++a) n.setTexture2D(e[a] || JF, o[a]);
}
function W$(t, e, n) {
  const r = this.cache,
    i = e.length,
    o = r1(n, i);
  Pr(r, o) || (t.uniform1iv(this.addr, o), Ir(r, o));
  for (let a = 0; a !== i; ++a) n.setTexture3D(e[a] || nD, o[a]);
}
function X$(t, e, n) {
  const r = this.cache,
    i = e.length,
    o = r1(n, i);
  Pr(r, o) || (t.uniform1iv(this.addr, o), Ir(r, o));
  for (let a = 0; a !== i; ++a) n.setTextureCube(e[a] || rD, o[a]);
}
function q$(t, e, n) {
  const r = this.cache,
    i = e.length,
    o = r1(n, i);
  Pr(r, o) || (t.uniform1iv(this.addr, o), Ir(r, o));
  for (let a = 0; a !== i; ++a) n.setTexture2DArray(e[a] || tD, o[a]);
}
function K$(t) {
  switch (t) {
    case 5126:
      return P$;
    case 35664:
      return I$;
    case 35665:
      return L$;
    case 35666:
      return O$;
    case 35674:
      return N$;
    case 35675:
      return F$;
    case 35676:
      return D$;
    case 5124:
    case 35670:
      return z$;
    case 35667:
    case 35671:
      return U$;
    case 35668:
    case 35672:
      return k$;
    case 35669:
    case 35673:
      return B$;
    case 5125:
      return H$;
    case 36294:
      return j$;
    case 36295:
      return V$;
    case 36296:
      return $$;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return G$;
    case 35679:
    case 36299:
    case 36307:
      return W$;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return X$;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return q$;
  }
}
class Y$ {
  constructor(e, n, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = n.type),
      (this.setValue = R$(n.type));
  }
}
class Z$ {
  constructor(e, n, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = n.type),
      (this.size = n.size),
      (this.setValue = K$(n.type));
  }
}
class Q$ {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, n, r) {
    const i = this.seq;
    for (let o = 0, a = i.length; o !== a; ++o) {
      const s = i[o];
      s.setValue(e, n[s.id], r);
    }
  }
}
const WS = /(\w+)(\])?(\[|\.)?/g;
function jR(t, e) {
  t.seq.push(e), (t.map[e.id] = e);
}
function J$(t, e, n) {
  const r = t.name,
    i = r.length;
  for (WS.lastIndex = 0; ; ) {
    const o = WS.exec(r),
      a = WS.lastIndex;
    let s = o[1];
    const l = o[2] === "]",
      c = o[3];
    if ((l && (s = s | 0), c === void 0 || (c === "[" && a + 2 === i))) {
      jR(n, c === void 0 ? new Y$(s, t, e) : new Z$(s, t, e));
      break;
    } else {
      let d = n.map[s];
      d === void 0 && ((d = new Q$(s)), jR(n, d)), (n = d);
    }
  }
}
class b0 {
  constructor(e, n) {
    (this.seq = []), (this.map = {});
    const r = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; ++i) {
      const o = e.getActiveUniform(n, i),
        a = e.getUniformLocation(n, o.name);
      J$(o, a, this);
    }
  }
  setValue(e, n, r, i) {
    const o = this.map[n];
    o !== void 0 && o.setValue(e, r, i);
  }
  setOptional(e, n, r) {
    const i = n[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, n, r, i) {
    for (let o = 0, a = n.length; o !== a; ++o) {
      const s = n[o],
        l = r[s.id];
      l.needsUpdate !== !1 && s.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, n) {
    const r = [];
    for (let i = 0, o = e.length; i !== o; ++i) {
      const a = e[i];
      a.id in n && r.push(a);
    }
    return r;
  }
}
function VR(t, e, n) {
  const r = t.createShader(e);
  return t.shaderSource(r, n), t.compileShader(r), r;
}
const eG = 37297;
let tG = 0;
function nG(t, e) {
  const n = t.split(`
`),
    r = [],
    i = Math.max(e - 6, 0),
    o = Math.min(e + 6, n.length);
  for (let a = i; a < o; a++) {
    const s = a + 1;
    r.push(`${s === e ? ">" : " "} ${s}: ${n[a]}`);
  }
  return r.join(`
`);
}
function rG(t) {
  const e = Mn.getPrimaries(Mn.workingColorSpace),
    n = Mn.getPrimaries(t);
  let r;
  switch (
    (e === n
      ? (r = "")
      : e === Fp && n === Np
      ? (r = "LinearDisplayP3ToLinearSRGB")
      : e === Np && n === Fp && (r = "LinearSRGBToLinearDisplayP3"),
    t)
  ) {
    case rs:
    case fm:
      return [r, "LinearTransferOETF"];
    case Tr:
    case t1:
      return [r, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", t),
        [r, "LinearTransferOETF"]
      );
  }
}
function $R(t, e, n) {
  const r = t.getShaderParameter(e, t.COMPILE_STATUS),
    i = t.getShaderInfoLog(e).trim();
  if (r && i === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(i);
  if (o) {
    const a = parseInt(o[1]);
    return (
      n.toUpperCase() +
      `

` +
      i +
      `

` +
      nG(t.getShaderSource(e), a)
    );
  } else return i;
}
function iG(t, e) {
  const n = rG(e);
  return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`;
}
function oG(t, e) {
  let n;
  switch (e) {
    case yF:
      n = "Linear";
      break;
    case xF:
      n = "Reinhard";
      break;
    case SF:
      n = "OptimizedCineon";
      break;
    case $M:
      n = "ACESFilmic";
      break;
    case bF:
      n = "AgX";
      break;
    case _F:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (n = "Linear");
  }
  return (
    "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
  );
}
function aG(t) {
  return [
    t.extensionDerivatives ||
    t.envMapCubeUVHeight ||
    t.bumpMap ||
    t.normalMapTangentSpace ||
    t.clearcoatNormalMap ||
    t.flatShading ||
    t.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
    t.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
    t.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(Bd).join(`
`);
}
function sG(t) {
  return [
    t.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
  ].filter(Bd).join(`
`);
}
function lG(t) {
  const e = [];
  for (const n in t) {
    const r = t[n];
    r !== !1 && e.push("#define " + n + " " + r);
  }
  return e.join(`
`);
}
function cG(t, e) {
  const n = {},
    r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < r; i++) {
    const o = t.getActiveAttrib(e, i),
      a = o.name;
    let s = 1;
    o.type === t.FLOAT_MAT2 && (s = 2),
      o.type === t.FLOAT_MAT3 && (s = 3),
      o.type === t.FLOAT_MAT4 && (s = 4),
      (n[a] = {
        type: o.type,
        location: t.getAttribLocation(e, a),
        locationSize: s,
      });
  }
  return n;
}
function Bd(t) {
  return t !== "";
}
function GR(t, e) {
  const n =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return t
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function WR(t, e) {
  return t
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const uG = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Ow(t) {
  return t.replace(uG, fG);
}
const dG = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function fG(t, e) {
  let n = Xt[e];
  if (n === void 0) {
    const r = dG.get(e);
    if (r !== void 0)
      (n = Xt[r]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          r
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return Ow(n);
}
const hG =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function XR(t) {
  return t.replace(hG, pG);
}
function pG(t, e, n, r) {
  let i = "";
  for (let o = parseInt(e); o < parseInt(n); o++)
    i += r
      .replace(/\[\s*i\s*\]/g, "[ " + o + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, o);
  return i;
}
function qR(t) {
  let e =
    "precision " +
    t.precision +
    ` float;
precision ` +
    t.precision +
    " int;";
  return (
    t.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : t.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : t.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function mG(t) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    t.shadowMapType === Zy
      ? (e = "SHADOWMAP_TYPE_PCF")
      : t.shadowMapType === Kh
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : t.shadowMapType === ma && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function gG(t) {
  let e = "ENVMAP_TYPE_CUBE";
  if (t.envMap)
    switch (t.envMapMode) {
      case Vs:
      case Bl:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Tf:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function vG(t) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (t.envMap)
    switch (t.envMapMode) {
      case Bl:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function yG(t) {
  let e = "ENVMAP_BLENDING_NONE";
  if (t.envMap)
    switch (t.combine) {
      case dm:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case gF:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case vF:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function xG(t) {
  const e = t.envMapCubeUVHeight;
  if (e === null) return null;
  const n = Math.log2(e) - 2,
    r = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)),
    texelHeight: r,
    maxMip: n,
  };
}
function SG(t, e, n, r) {
  const i = t.getContext(),
    o = n.defines;
  let a = n.vertexShader,
    s = n.fragmentShader;
  const l = mG(n),
    c = gG(n),
    u = vG(n),
    d = yG(n),
    p = xG(n),
    m = n.isWebGL2 ? "" : aG(n),
    v = sG(n),
    S = lG(o),
    x = i.createProgram();
  let g,
    _,
    y = n.glslVersion
      ? "#version " +
        n.glslVersion +
        `
`
      : "";
  n.isRawShaderMaterial
    ? ((g = [
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        S,
      ].filter(Bd).join(`
`)),
      g.length > 0 &&
        (g += `
`),
      (_ = [
        m,
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        S,
      ].filter(Bd).join(`
`)),
      _.length > 0 &&
        (_ += `
`))
    : ((g = [
        qR(n),
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        S,
        n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        n.batching ? "#define USE_BATCHING" : "",
        n.instancing ? "#define USE_INSTANCING" : "",
        n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.map ? "#define USE_MAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + u : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.anisotropy ? "#define USE_ANISOTROPY" : "",
        n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.alphaHash ? "#define USE_ALPHAHASH" : "",
        n.transmission ? "#define USE_TRANSMISSION" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        n.mapUv ? "#define MAP_UV " + n.mapUv : "",
        n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
        n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
        n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
        n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
        n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
        n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
        n.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv
          : "",
        n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
        n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
        n.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv
          : "",
        n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
        n.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
          : "",
        n.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv
          : "",
        n.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv
          : "",
        n.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv
          : "",
        n.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv
          : "",
        n.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
          : "",
        n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
        n.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv
          : "",
        n.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
          : "",
        n.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv
          : "",
        n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
        n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
        n.vertexColors ? "#define USE_COLOR" : "",
        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n.vertexUv1s ? "#define USE_UV1" : "",
        n.vertexUv2s ? "#define USE_UV2" : "",
        n.vertexUv3s ? "#define USE_UV3" : "",
        n.pointsUvs ? "#define USE_POINTS_UV" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.skinning ? "#define USE_SKINNING" : "",
        n.morphTargets ? "#define USE_MORPHTARGETS" : "",
        n.morphNormals && n.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        n.morphTargetsCount > 0 && n.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        n.morphTargetsCount > 0 && n.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
          : "",
        n.morphTargetsCount > 0 && n.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
          : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + l : "",
        n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Bd).join(`
`)),
      (_ = [
        m,
        qR(n),
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        S,
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.map ? "#define USE_MAP" : "",
        n.matcap ? "#define USE_MATCAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + c : "",
        n.envMap ? "#define " + u : "",
        n.envMap ? "#define " + d : "",
        p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
        p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
        p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.anisotropy ? "#define USE_ANISOTROPY" : "",
        n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        n.clearcoat ? "#define USE_CLEARCOAT" : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.iridescence ? "#define USE_IRIDESCENCE" : "",
        n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.alphaTest ? "#define USE_ALPHATEST" : "",
        n.alphaHash ? "#define USE_ALPHAHASH" : "",
        n.sheen ? "#define USE_SHEEN" : "",
        n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        n.transmission ? "#define USE_TRANSMISSION" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
        n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n.vertexUv1s ? "#define USE_UV1" : "",
        n.vertexUv2s ? "#define USE_UV2" : "",
        n.vertexUv3s ? "#define USE_UV3" : "",
        n.pointsUvs ? "#define USE_POINTS_UV" : "",
        n.gradientMap ? "#define USE_GRADIENTMAP" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + l : "",
        n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        n.toneMapping !== Ja ? "#define TONE_MAPPING" : "",
        n.toneMapping !== Ja ? Xt.tonemapping_pars_fragment : "",
        n.toneMapping !== Ja ? oG("toneMapping", n.toneMapping) : "",
        n.dithering ? "#define DITHERING" : "",
        n.opaque ? "#define OPAQUE" : "",
        Xt.colorspace_pars_fragment,
        iG("linearToOutputTexel", n.outputColorSpace),
        n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
        `
`,
      ].filter(Bd).join(`
`))),
    (a = Ow(a)),
    (a = GR(a, n)),
    (a = WR(a, n)),
    (s = Ow(s)),
    (s = GR(s, n)),
    (s = WR(s, n)),
    (a = XR(a)),
    (s = XR(s)),
    n.isWebGL2 &&
      n.isRawShaderMaterial !== !0 &&
      ((y = `#version 300 es
`),
      (g =
        [
          v,
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        g),
      (_ =
        [
          "precision mediump sampler2DArray;",
          "#define varying in",
          n.glslVersion === Pw
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          n.glslVersion === Pw ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        _));
  const w = y + g + a,
    A = y + _ + s,
    M = VR(i, i.VERTEX_SHADER, w),
    T = VR(i, i.FRAGMENT_SHADER, A);
  i.attachShader(x, M),
    i.attachShader(x, T),
    n.index0AttributeName !== void 0
      ? i.bindAttribLocation(x, 0, n.index0AttributeName)
      : n.morphTargets === !0 && i.bindAttribLocation(x, 0, "position"),
    i.linkProgram(x);
  function I(D) {
    if (t.debug.checkShaderErrors) {
      const j = i.getProgramInfoLog(x).trim(),
        N = i.getShaderInfoLog(M).trim(),
        V = i.getShaderInfoLog(T).trim();
      let W = !0,
        Q = !0;
      if (i.getProgramParameter(x, i.LINK_STATUS) === !1)
        if (((W = !1), typeof t.debug.onShaderError == "function"))
          t.debug.onShaderError(i, x, M, T);
        else {
          const B = $R(i, M, "vertex"),
            $ = $R(i, T, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              i.getError() +
              " - VALIDATE_STATUS " +
              i.getProgramParameter(x, i.VALIDATE_STATUS) +
              `

Program Info Log: ` +
              j +
              `
` +
              B +
              `
` +
              $
          );
        }
      else
        j !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", j)
          : (N === "" || V === "") && (Q = !1);
      Q &&
        (D.diagnostics = {
          runnable: W,
          programLog: j,
          vertexShader: { log: N, prefix: g },
          fragmentShader: { log: V, prefix: _ },
        });
    }
    i.deleteShader(M), i.deleteShader(T), (R = new b0(i, x)), (P = cG(i, x));
  }
  let R;
  this.getUniforms = function () {
    return R === void 0 && I(this), R;
  };
  let P;
  this.getAttributes = function () {
    return P === void 0 && I(this), P;
  };
  let F = n.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return F === !1 && (F = i.getProgramParameter(x, eG)), F;
    }),
    (this.destroy = function () {
      r.releaseStatesOfProgram(this),
        i.deleteProgram(x),
        (this.program = void 0);
    }),
    (this.type = n.shaderType),
    (this.name = n.shaderName),
    (this.id = tG++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = x),
    (this.vertexShader = M),
    (this.fragmentShader = T),
    this
  );
}
let _G = 0;
class bG {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const n = e.vertexShader,
      r = e.fragmentShader,
      i = this._getShaderStage(n),
      o = this._getShaderStage(r),
      a = this._getShaderCacheForMaterial(e);
    return (
      a.has(i) === !1 && (a.add(i), i.usedTimes++),
      a.has(o) === !1 && (a.add(o), o.usedTimes++),
      this
    );
  }
  remove(e) {
    const n = this.materialCache.get(e);
    for (const r of n)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const n = this.materialCache;
    let r = n.get(e);
    return r === void 0 && ((r = new Set()), n.set(e, r)), r;
  }
  _getShaderStage(e) {
    const n = this.shaderCache;
    let r = n.get(e);
    return r === void 0 && ((r = new wG(e)), n.set(e, r)), r;
  }
}
class wG {
  constructor(e) {
    (this.id = _G++), (this.code = e), (this.usedTimes = 0);
  }
}
function EG(t, e, n, r, i, o, a) {
  const s = new Yc(),
    l = new bG(),
    c = [],
    u = i.isWebGL2,
    d = i.logarithmicDepthBuffer,
    p = i.vertexTextures;
  let m = i.precision;
  const v = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function S(R) {
    return R === 0 ? "uv" : `uv${R}`;
  }
  function x(R, P, F, D, j) {
    const N = D.fog,
      V = j.geometry,
      W = R.isMeshStandardMaterial ? D.environment : null,
      Q = (R.isMeshStandardMaterial ? n : e).get(R.envMap || W),
      B = Q && Q.mapping === Tf ? Q.image.height : null,
      $ = v[R.type];
    R.precision !== null &&
      ((m = i.getMaxPrecision(R.precision)),
      m !== R.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          R.precision,
          "not supported, using",
          m,
          "instead."
        ));
    const G =
        V.morphAttributes.position ||
        V.morphAttributes.normal ||
        V.morphAttributes.color,
      k = G !== void 0 ? G.length : 0;
    let q = 0;
    V.morphAttributes.position !== void 0 && (q = 1),
      V.morphAttributes.normal !== void 0 && (q = 2),
      V.morphAttributes.color !== void 0 && (q = 3);
    let X, ee, J, oe;
    if ($) {
      const ut = _a[$];
      (X = ut.vertexShader), (ee = ut.fragmentShader);
    } else
      (X = R.vertexShader),
        (ee = R.fragmentShader),
        l.update(R),
        (J = l.getVertexShaderID(R)),
        (oe = l.getFragmentShaderID(R));
    const ae = t.getRenderTarget(),
      le = j.isInstancedMesh === !0,
      _e = j.isBatchedMesh === !0,
      me = !!R.map,
      se = !!R.matcap,
      Y = !!Q,
      ve = !!R.aoMap,
      de = !!R.lightMap,
      ue = !!R.bumpMap,
      fe = !!R.normalMap,
      Te = !!R.displacementMap,
      pe = !!R.emissiveMap,
      H = !!R.metalnessMap,
      z = !!R.roughnessMap,
      Z = R.anisotropy > 0,
      ge = R.clearcoat > 0,
      ce = R.iridescence > 0,
      he = R.sheen > 0,
      Me = R.transmission > 0,
      Re = Z && !!R.anisotropyMap,
      Le = ge && !!R.clearcoatMap,
      Oe = ge && !!R.clearcoatNormalMap,
      Pe = ge && !!R.clearcoatRoughnessMap,
      Se = ce && !!R.iridescenceMap,
      Je = ce && !!R.iridescenceThicknessMap,
      st = he && !!R.sheenColorMap,
      Qe = he && !!R.sheenRoughnessMap,
      Ke = !!R.specularMap,
      Ne = !!R.specularColorMap,
      ne = !!R.specularIntensityMap,
      Ie = Me && !!R.transmissionMap,
      et = Me && !!R.thicknessMap,
      We = !!R.gradientMap,
      Ee = !!R.alphaMap,
      ie = R.alphaTest > 0,
      $e = !!R.alphaHash,
      He = !!R.extensions,
      Xe = !!V.attributes.uv1,
      Ue = !!V.attributes.uv2,
      Ye = !!V.attributes.uv3;
    let ke = Ja;
    return (
      R.toneMapped &&
        (ae === null || ae.isXRRenderTarget === !0) &&
        (ke = t.toneMapping),
      {
        isWebGL2: u,
        shaderID: $,
        shaderType: R.type,
        shaderName: R.name,
        vertexShader: X,
        fragmentShader: ee,
        defines: R.defines,
        customVertexShaderID: J,
        customFragmentShaderID: oe,
        isRawShaderMaterial: R.isRawShaderMaterial === !0,
        glslVersion: R.glslVersion,
        precision: m,
        batching: _e,
        instancing: le,
        instancingColor: le && j.instanceColor !== null,
        supportsVertexTextures: p,
        outputColorSpace:
          ae === null
            ? t.outputColorSpace
            : ae.isXRRenderTarget === !0
            ? ae.texture.colorSpace
            : rs,
        map: me,
        matcap: se,
        envMap: Y,
        envMapMode: Y && Q.mapping,
        envMapCubeUVHeight: B,
        aoMap: ve,
        lightMap: de,
        bumpMap: ue,
        normalMap: fe,
        displacementMap: p && Te,
        emissiveMap: pe,
        normalMapObjectSpace: fe && R.normalMapType === DF,
        normalMapTangentSpace: fe && R.normalMapType === Yl,
        metalnessMap: H,
        roughnessMap: z,
        anisotropy: Z,
        anisotropyMap: Re,
        clearcoat: ge,
        clearcoatMap: Le,
        clearcoatNormalMap: Oe,
        clearcoatRoughnessMap: Pe,
        iridescence: ce,
        iridescenceMap: Se,
        iridescenceThicknessMap: Je,
        sheen: he,
        sheenColorMap: st,
        sheenRoughnessMap: Qe,
        specularMap: Ke,
        specularColorMap: Ne,
        specularIntensityMap: ne,
        transmission: Me,
        transmissionMap: Ie,
        thicknessMap: et,
        gradientMap: We,
        opaque: R.transparent === !1 && R.blending === qc,
        alphaMap: Ee,
        alphaTest: ie,
        alphaHash: $e,
        combine: R.combine,
        mapUv: me && S(R.map.channel),
        aoMapUv: ve && S(R.aoMap.channel),
        lightMapUv: de && S(R.lightMap.channel),
        bumpMapUv: ue && S(R.bumpMap.channel),
        normalMapUv: fe && S(R.normalMap.channel),
        displacementMapUv: Te && S(R.displacementMap.channel),
        emissiveMapUv: pe && S(R.emissiveMap.channel),
        metalnessMapUv: H && S(R.metalnessMap.channel),
        roughnessMapUv: z && S(R.roughnessMap.channel),
        anisotropyMapUv: Re && S(R.anisotropyMap.channel),
        clearcoatMapUv: Le && S(R.clearcoatMap.channel),
        clearcoatNormalMapUv: Oe && S(R.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: Pe && S(R.clearcoatRoughnessMap.channel),
        iridescenceMapUv: Se && S(R.iridescenceMap.channel),
        iridescenceThicknessMapUv: Je && S(R.iridescenceThicknessMap.channel),
        sheenColorMapUv: st && S(R.sheenColorMap.channel),
        sheenRoughnessMapUv: Qe && S(R.sheenRoughnessMap.channel),
        specularMapUv: Ke && S(R.specularMap.channel),
        specularColorMapUv: Ne && S(R.specularColorMap.channel),
        specularIntensityMapUv: ne && S(R.specularIntensityMap.channel),
        transmissionMapUv: Ie && S(R.transmissionMap.channel),
        thicknessMapUv: et && S(R.thicknessMap.channel),
        alphaMapUv: Ee && S(R.alphaMap.channel),
        vertexTangents: !!V.attributes.tangent && (fe || Z),
        vertexColors: R.vertexColors,
        vertexAlphas:
          R.vertexColors === !0 &&
          !!V.attributes.color &&
          V.attributes.color.itemSize === 4,
        vertexUv1s: Xe,
        vertexUv2s: Ue,
        vertexUv3s: Ye,
        pointsUvs: j.isPoints === !0 && !!V.attributes.uv && (me || Ee),
        fog: !!N,
        useFog: R.fog === !0,
        fogExp2: N && N.isFogExp2,
        flatShading: R.flatShading === !0,
        sizeAttenuation: R.sizeAttenuation === !0,
        logarithmicDepthBuffer: d,
        skinning: j.isSkinnedMesh === !0,
        morphTargets: V.morphAttributes.position !== void 0,
        morphNormals: V.morphAttributes.normal !== void 0,
        morphColors: V.morphAttributes.color !== void 0,
        morphTargetsCount: k,
        morphTextureStride: q,
        numDirLights: P.directional.length,
        numPointLights: P.point.length,
        numSpotLights: P.spot.length,
        numSpotLightMaps: P.spotLightMap.length,
        numRectAreaLights: P.rectArea.length,
        numHemiLights: P.hemi.length,
        numDirLightShadows: P.directionalShadowMap.length,
        numPointLightShadows: P.pointShadowMap.length,
        numSpotLightShadows: P.spotShadowMap.length,
        numSpotLightShadowsWithMaps: P.numSpotLightShadowsWithMaps,
        numLightProbes: P.numLightProbes,
        numClippingPlanes: a.numPlanes,
        numClipIntersection: a.numIntersection,
        dithering: R.dithering,
        shadowMapEnabled: t.shadowMap.enabled && F.length > 0,
        shadowMapType: t.shadowMap.type,
        toneMapping: ke,
        useLegacyLights: t._useLegacyLights,
        decodeVideoTexture:
          me &&
          R.map.isVideoTexture === !0 &&
          Mn.getTransfer(R.map.colorSpace) === Un,
        premultipliedAlpha: R.premultipliedAlpha,
        doubleSided: R.side === Zo,
        flipSided: R.side === Oi,
        useDepthPacking: R.depthPacking >= 0,
        depthPacking: R.depthPacking || 0,
        index0AttributeName: R.index0AttributeName,
        extensionDerivatives: He && R.extensions.derivatives === !0,
        extensionFragDepth: He && R.extensions.fragDepth === !0,
        extensionDrawBuffers: He && R.extensions.drawBuffers === !0,
        extensionShaderTextureLOD: He && R.extensions.shaderTextureLOD === !0,
        extensionClipCullDistance:
          He &&
          R.extensions.clipCullDistance &&
          r.has("WEBGL_clip_cull_distance"),
        rendererExtensionFragDepth: u || r.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: u || r.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: u || r.has("EXT_shader_texture_lod"),
        rendererExtensionParallelShaderCompile: r.has(
          "KHR_parallel_shader_compile"
        ),
        customProgramCacheKey: R.customProgramCacheKey(),
      }
    );
  }
  function g(R) {
    const P = [];
    if (
      (R.shaderID
        ? P.push(R.shaderID)
        : (P.push(R.customVertexShaderID), P.push(R.customFragmentShaderID)),
      R.defines !== void 0)
    )
      for (const F in R.defines) P.push(F), P.push(R.defines[F]);
    return (
      R.isRawShaderMaterial === !1 &&
        (_(P, R), y(P, R), P.push(t.outputColorSpace)),
      P.push(R.customProgramCacheKey),
      P.join()
    );
  }
  function _(R, P) {
    R.push(P.precision),
      R.push(P.outputColorSpace),
      R.push(P.envMapMode),
      R.push(P.envMapCubeUVHeight),
      R.push(P.mapUv),
      R.push(P.alphaMapUv),
      R.push(P.lightMapUv),
      R.push(P.aoMapUv),
      R.push(P.bumpMapUv),
      R.push(P.normalMapUv),
      R.push(P.displacementMapUv),
      R.push(P.emissiveMapUv),
      R.push(P.metalnessMapUv),
      R.push(P.roughnessMapUv),
      R.push(P.anisotropyMapUv),
      R.push(P.clearcoatMapUv),
      R.push(P.clearcoatNormalMapUv),
      R.push(P.clearcoatRoughnessMapUv),
      R.push(P.iridescenceMapUv),
      R.push(P.iridescenceThicknessMapUv),
      R.push(P.sheenColorMapUv),
      R.push(P.sheenRoughnessMapUv),
      R.push(P.specularMapUv),
      R.push(P.specularColorMapUv),
      R.push(P.specularIntensityMapUv),
      R.push(P.transmissionMapUv),
      R.push(P.thicknessMapUv),
      R.push(P.combine),
      R.push(P.fogExp2),
      R.push(P.sizeAttenuation),
      R.push(P.morphTargetsCount),
      R.push(P.morphAttributeCount),
      R.push(P.numDirLights),
      R.push(P.numPointLights),
      R.push(P.numSpotLights),
      R.push(P.numSpotLightMaps),
      R.push(P.numHemiLights),
      R.push(P.numRectAreaLights),
      R.push(P.numDirLightShadows),
      R.push(P.numPointLightShadows),
      R.push(P.numSpotLightShadows),
      R.push(P.numSpotLightShadowsWithMaps),
      R.push(P.numLightProbes),
      R.push(P.shadowMapType),
      R.push(P.toneMapping),
      R.push(P.numClippingPlanes),
      R.push(P.numClipIntersection),
      R.push(P.depthPacking);
  }
  function y(R, P) {
    s.disableAll(),
      P.isWebGL2 && s.enable(0),
      P.supportsVertexTextures && s.enable(1),
      P.instancing && s.enable(2),
      P.instancingColor && s.enable(3),
      P.matcap && s.enable(4),
      P.envMap && s.enable(5),
      P.normalMapObjectSpace && s.enable(6),
      P.normalMapTangentSpace && s.enable(7),
      P.clearcoat && s.enable(8),
      P.iridescence && s.enable(9),
      P.alphaTest && s.enable(10),
      P.vertexColors && s.enable(11),
      P.vertexAlphas && s.enable(12),
      P.vertexUv1s && s.enable(13),
      P.vertexUv2s && s.enable(14),
      P.vertexUv3s && s.enable(15),
      P.vertexTangents && s.enable(16),
      P.anisotropy && s.enable(17),
      P.alphaHash && s.enable(18),
      P.batching && s.enable(19),
      R.push(s.mask),
      s.disableAll(),
      P.fog && s.enable(0),
      P.useFog && s.enable(1),
      P.flatShading && s.enable(2),
      P.logarithmicDepthBuffer && s.enable(3),
      P.skinning && s.enable(4),
      P.morphTargets && s.enable(5),
      P.morphNormals && s.enable(6),
      P.morphColors && s.enable(7),
      P.premultipliedAlpha && s.enable(8),
      P.shadowMapEnabled && s.enable(9),
      P.useLegacyLights && s.enable(10),
      P.doubleSided && s.enable(11),
      P.flipSided && s.enable(12),
      P.useDepthPacking && s.enable(13),
      P.dithering && s.enable(14),
      P.transmission && s.enable(15),
      P.sheen && s.enable(16),
      P.opaque && s.enable(17),
      P.pointsUvs && s.enable(18),
      P.decodeVideoTexture && s.enable(19),
      R.push(s.mask);
  }
  function w(R) {
    const P = v[R.type];
    let F;
    if (P) {
      const D = _a[P];
      F = Up.clone(D.uniforms);
    } else F = R.uniforms;
    return F;
  }
  function A(R, P) {
    let F;
    for (let D = 0, j = c.length; D < j; D++) {
      const N = c[D];
      if (N.cacheKey === P) {
        (F = N), ++F.usedTimes;
        break;
      }
    }
    return F === void 0 && ((F = new SG(t, P, R, o)), c.push(F)), F;
  }
  function M(R) {
    if (--R.usedTimes === 0) {
      const P = c.indexOf(R);
      (c[P] = c[c.length - 1]), c.pop(), R.destroy();
    }
  }
  function T(R) {
    l.remove(R);
  }
  function I() {
    l.dispose();
  }
  return {
    getParameters: x,
    getProgramCacheKey: g,
    getUniforms: w,
    acquireProgram: A,
    releaseProgram: M,
    releaseShaderCache: T,
    programs: c,
    dispose: I,
  };
}
function MG() {
  let t = new WeakMap();
  function e(o) {
    let a = t.get(o);
    return a === void 0 && ((a = {}), t.set(o, a)), a;
  }
  function n(o) {
    t.delete(o);
  }
  function r(o, a, s) {
    t.get(o)[a] = s;
  }
  function i() {
    t = new WeakMap();
  }
  return { get: e, remove: n, update: r, dispose: i };
}
function CG(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.material.id !== e.material.id
    ? t.material.id - e.material.id
    : t.z !== e.z
    ? t.z - e.z
    : t.id - e.id;
}
function KR(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.z !== e.z
    ? e.z - t.z
    : t.id - e.id;
}
function YR() {
  const t = [];
  let e = 0;
  const n = [],
    r = [],
    i = [];
  function o() {
    (e = 0), (n.length = 0), (r.length = 0), (i.length = 0);
  }
  function a(d, p, m, v, S, x) {
    let g = t[e];
    return (
      g === void 0
        ? ((g = {
            id: d.id,
            object: d,
            geometry: p,
            material: m,
            groupOrder: v,
            renderOrder: d.renderOrder,
            z: S,
            group: x,
          }),
          (t[e] = g))
        : ((g.id = d.id),
          (g.object = d),
          (g.geometry = p),
          (g.material = m),
          (g.groupOrder = v),
          (g.renderOrder = d.renderOrder),
          (g.z = S),
          (g.group = x)),
      e++,
      g
    );
  }
  function s(d, p, m, v, S, x) {
    const g = a(d, p, m, v, S, x);
    m.transmission > 0
      ? r.push(g)
      : m.transparent === !0
      ? i.push(g)
      : n.push(g);
  }
  function l(d, p, m, v, S, x) {
    const g = a(d, p, m, v, S, x);
    m.transmission > 0
      ? r.unshift(g)
      : m.transparent === !0
      ? i.unshift(g)
      : n.unshift(g);
  }
  function c(d, p) {
    n.length > 1 && n.sort(d || CG),
      r.length > 1 && r.sort(p || KR),
      i.length > 1 && i.sort(p || KR);
  }
  function u() {
    for (let d = e, p = t.length; d < p; d++) {
      const m = t[d];
      if (m.id === null) break;
      (m.id = null),
        (m.object = null),
        (m.geometry = null),
        (m.material = null),
        (m.group = null);
    }
  }
  return {
    opaque: n,
    transmissive: r,
    transparent: i,
    init: o,
    push: s,
    unshift: l,
    finish: u,
    sort: c,
  };
}
function TG() {
  let t = new WeakMap();
  function e(r, i) {
    const o = t.get(r);
    let a;
    return (
      o === void 0
        ? ((a = new YR()), t.set(r, [a]))
        : i >= o.length
        ? ((a = new YR()), o.push(a))
        : (a = o[i]),
      a
    );
  }
  function n() {
    t = new WeakMap();
  }
  return { get: e, dispose: n };
}
function AG() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = { direction: new K(), color: new pt() };
          break;
        case "SpotLight":
          n = {
            position: new K(),
            direction: new K(),
            color: new pt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          n = { position: new K(), color: new pt(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          n = { direction: new K(), skyColor: new pt(), groundColor: new pt() };
          break;
        case "RectAreaLight":
          n = {
            color: new pt(),
            position: new K(),
            halfWidth: new K(),
            halfHeight: new K(),
          };
          break;
      }
      return (t[e.id] = n), n;
    },
  };
}
function RG() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ge(),
          };
          break;
        case "SpotLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ge(),
          };
          break;
        case "PointLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ge(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (t[e.id] = n), n;
    },
  };
}
let PG = 0;
function IG(t, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (t.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (t.map ? 1 : 0)
  );
}
function LG(t, e) {
  const n = new AG(),
    r = RG(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let u = 0; u < 9; u++) i.probe.push(new K());
  const o = new K(),
    a = new kt(),
    s = new kt();
  function l(u, d) {
    let p = 0,
      m = 0,
      v = 0;
    for (let D = 0; D < 9; D++) i.probe[D].set(0, 0, 0);
    let S = 0,
      x = 0,
      g = 0,
      _ = 0,
      y = 0,
      w = 0,
      A = 0,
      M = 0,
      T = 0,
      I = 0,
      R = 0;
    u.sort(IG);
    const P = d === !0 ? Math.PI : 1;
    for (let D = 0, j = u.length; D < j; D++) {
      const N = u[D],
        V = N.color,
        W = N.intensity,
        Q = N.distance,
        B = N.shadow && N.shadow.map ? N.shadow.map.texture : null;
      if (N.isAmbientLight)
        (p += V.r * W * P), (m += V.g * W * P), (v += V.b * W * P);
      else if (N.isLightProbe) {
        for (let $ = 0; $ < 9; $++)
          i.probe[$].addScaledVector(N.sh.coefficients[$], W);
        R++;
      } else if (N.isDirectionalLight) {
        const $ = n.get(N);
        if (
          ($.color.copy(N.color).multiplyScalar(N.intensity * P), N.castShadow)
        ) {
          const G = N.shadow,
            k = r.get(N);
          (k.shadowBias = G.bias),
            (k.shadowNormalBias = G.normalBias),
            (k.shadowRadius = G.radius),
            (k.shadowMapSize = G.mapSize),
            (i.directionalShadow[S] = k),
            (i.directionalShadowMap[S] = B),
            (i.directionalShadowMatrix[S] = N.shadow.matrix),
            w++;
        }
        (i.directional[S] = $), S++;
      } else if (N.isSpotLight) {
        const $ = n.get(N);
        $.position.setFromMatrixPosition(N.matrixWorld),
          $.color.copy(V).multiplyScalar(W * P),
          ($.distance = Q),
          ($.coneCos = Math.cos(N.angle)),
          ($.penumbraCos = Math.cos(N.angle * (1 - N.penumbra))),
          ($.decay = N.decay),
          (i.spot[g] = $);
        const G = N.shadow;
        if (
          (N.map &&
            ((i.spotLightMap[T] = N.map),
            T++,
            G.updateMatrices(N),
            N.castShadow && I++),
          (i.spotLightMatrix[g] = G.matrix),
          N.castShadow)
        ) {
          const k = r.get(N);
          (k.shadowBias = G.bias),
            (k.shadowNormalBias = G.normalBias),
            (k.shadowRadius = G.radius),
            (k.shadowMapSize = G.mapSize),
            (i.spotShadow[g] = k),
            (i.spotShadowMap[g] = B),
            M++;
        }
        g++;
      } else if (N.isRectAreaLight) {
        const $ = n.get(N);
        $.color.copy(V).multiplyScalar(W),
          $.halfWidth.set(N.width * 0.5, 0, 0),
          $.halfHeight.set(0, N.height * 0.5, 0),
          (i.rectArea[_] = $),
          _++;
      } else if (N.isPointLight) {
        const $ = n.get(N);
        if (
          ($.color.copy(N.color).multiplyScalar(N.intensity * P),
          ($.distance = N.distance),
          ($.decay = N.decay),
          N.castShadow)
        ) {
          const G = N.shadow,
            k = r.get(N);
          (k.shadowBias = G.bias),
            (k.shadowNormalBias = G.normalBias),
            (k.shadowRadius = G.radius),
            (k.shadowMapSize = G.mapSize),
            (k.shadowCameraNear = G.camera.near),
            (k.shadowCameraFar = G.camera.far),
            (i.pointShadow[x] = k),
            (i.pointShadowMap[x] = B),
            (i.pointShadowMatrix[x] = N.shadow.matrix),
            A++;
        }
        (i.point[x] = $), x++;
      } else if (N.isHemisphereLight) {
        const $ = n.get(N);
        $.skyColor.copy(N.color).multiplyScalar(W * P),
          $.groundColor.copy(N.groundColor).multiplyScalar(W * P),
          (i.hemi[y] = $),
          y++;
      }
    }
    _ > 0 &&
      (e.isWebGL2
        ? t.has("OES_texture_float_linear") === !0
          ? ((i.rectAreaLTC1 = lt.LTC_FLOAT_1),
            (i.rectAreaLTC2 = lt.LTC_FLOAT_2))
          : ((i.rectAreaLTC1 = lt.LTC_HALF_1), (i.rectAreaLTC2 = lt.LTC_HALF_2))
        : t.has("OES_texture_float_linear") === !0
        ? ((i.rectAreaLTC1 = lt.LTC_FLOAT_1), (i.rectAreaLTC2 = lt.LTC_FLOAT_2))
        : t.has("OES_texture_half_float_linear") === !0
        ? ((i.rectAreaLTC1 = lt.LTC_HALF_1), (i.rectAreaLTC2 = lt.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (i.ambient[0] = p),
      (i.ambient[1] = m),
      (i.ambient[2] = v);
    const F = i.hash;
    (F.directionalLength !== S ||
      F.pointLength !== x ||
      F.spotLength !== g ||
      F.rectAreaLength !== _ ||
      F.hemiLength !== y ||
      F.numDirectionalShadows !== w ||
      F.numPointShadows !== A ||
      F.numSpotShadows !== M ||
      F.numSpotMaps !== T ||
      F.numLightProbes !== R) &&
      ((i.directional.length = S),
      (i.spot.length = g),
      (i.rectArea.length = _),
      (i.point.length = x),
      (i.hemi.length = y),
      (i.directionalShadow.length = w),
      (i.directionalShadowMap.length = w),
      (i.pointShadow.length = A),
      (i.pointShadowMap.length = A),
      (i.spotShadow.length = M),
      (i.spotShadowMap.length = M),
      (i.directionalShadowMatrix.length = w),
      (i.pointShadowMatrix.length = A),
      (i.spotLightMatrix.length = M + T - I),
      (i.spotLightMap.length = T),
      (i.numSpotLightShadowsWithMaps = I),
      (i.numLightProbes = R),
      (F.directionalLength = S),
      (F.pointLength = x),
      (F.spotLength = g),
      (F.rectAreaLength = _),
      (F.hemiLength = y),
      (F.numDirectionalShadows = w),
      (F.numPointShadows = A),
      (F.numSpotShadows = M),
      (F.numSpotMaps = T),
      (F.numLightProbes = R),
      (i.version = PG++));
  }
  function c(u, d) {
    let p = 0,
      m = 0,
      v = 0,
      S = 0,
      x = 0;
    const g = d.matrixWorldInverse;
    for (let _ = 0, y = u.length; _ < y; _++) {
      const w = u[_];
      if (w.isDirectionalLight) {
        const A = i.directional[p];
        A.direction.setFromMatrixPosition(w.matrixWorld),
          o.setFromMatrixPosition(w.target.matrixWorld),
          A.direction.sub(o),
          A.direction.transformDirection(g),
          p++;
      } else if (w.isSpotLight) {
        const A = i.spot[v];
        A.position.setFromMatrixPosition(w.matrixWorld),
          A.position.applyMatrix4(g),
          A.direction.setFromMatrixPosition(w.matrixWorld),
          o.setFromMatrixPosition(w.target.matrixWorld),
          A.direction.sub(o),
          A.direction.transformDirection(g),
          v++;
      } else if (w.isRectAreaLight) {
        const A = i.rectArea[S];
        A.position.setFromMatrixPosition(w.matrixWorld),
          A.position.applyMatrix4(g),
          s.identity(),
          a.copy(w.matrixWorld),
          a.premultiply(g),
          s.extractRotation(a),
          A.halfWidth.set(w.width * 0.5, 0, 0),
          A.halfHeight.set(0, w.height * 0.5, 0),
          A.halfWidth.applyMatrix4(s),
          A.halfHeight.applyMatrix4(s),
          S++;
      } else if (w.isPointLight) {
        const A = i.point[m];
        A.position.setFromMatrixPosition(w.matrixWorld),
          A.position.applyMatrix4(g),
          m++;
      } else if (w.isHemisphereLight) {
        const A = i.hemi[x];
        A.direction.setFromMatrixPosition(w.matrixWorld),
          A.direction.transformDirection(g),
          x++;
      }
    }
  }
  return { setup: l, setupView: c, state: i };
}
function ZR(t, e) {
  const n = new LG(t, e),
    r = [],
    i = [];
  function o() {
    (r.length = 0), (i.length = 0);
  }
  function a(d) {
    r.push(d);
  }
  function s(d) {
    i.push(d);
  }
  function l(d) {
    n.setup(r, d);
  }
  function c(d) {
    n.setupView(r, d);
  }
  return {
    init: o,
    state: { lightsArray: r, shadowsArray: i, lights: n },
    setupLights: l,
    setupLightsView: c,
    pushLight: a,
    pushShadow: s,
  };
}
function OG(t, e) {
  let n = new WeakMap();
  function r(o, a = 0) {
    const s = n.get(o);
    let l;
    return (
      s === void 0
        ? ((l = new ZR(t, e)), n.set(o, [l]))
        : a >= s.length
        ? ((l = new ZR(t, e)), s.push(l))
        : (l = s[a]),
      l
    );
  }
  function i() {
    n = new WeakMap();
  }
  return { get: r, dispose: i };
}
class i1 extends yi {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = FF),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class o1 extends yi {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const NG = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  FG = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function DG(t, e, n) {
  let r = new gm();
  const i = new Ge(),
    o = new Ge(),
    a = new rn(),
    s = new i1({ depthPacking: tC }),
    l = new o1(),
    c = {},
    u = n.maxTextureSize,
    d = { [js]: Oi, [Oi]: js, [Zo]: Zo },
    p = new Ia({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Ge() },
        radius: { value: 4 },
      },
      vertexShader: NG,
      fragmentShader: FG,
    }),
    m = p.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const v = new Jt();
  v.setAttribute(
    "position",
    new wn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const S = new Jn(v, p),
    x = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Zy);
  let g = this.type;
  this.render = function (M, T, I) {
    if (
      x.enabled === !1 ||
      (x.autoUpdate === !1 && x.needsUpdate === !1) ||
      M.length === 0
    )
      return;
    const R = t.getRenderTarget(),
      P = t.getActiveCubeFace(),
      F = t.getActiveMipmapLevel(),
      D = t.state;
    D.setBlending(Fs),
      D.buffers.color.setClear(1, 1, 1, 1),
      D.buffers.depth.setTest(!0),
      D.setScissorTest(!1);
    const j = g !== ma && this.type === ma,
      N = g === ma && this.type !== ma;
    for (let V = 0, W = M.length; V < W; V++) {
      const Q = M[V],
        B = Q.shadow;
      if (B === void 0) {
        console.warn("THREE.WebGLShadowMap:", Q, "has no shadow.");
        continue;
      }
      if (B.autoUpdate === !1 && B.needsUpdate === !1) continue;
      i.copy(B.mapSize);
      const $ = B.getFrameExtents();
      if (
        (i.multiply($),
        o.copy(B.mapSize),
        (i.x > u || i.y > u) &&
          (i.x > u &&
            ((o.x = Math.floor(u / $.x)),
            (i.x = o.x * $.x),
            (B.mapSize.x = o.x)),
          i.y > u &&
            ((o.y = Math.floor(u / $.y)),
            (i.y = o.y * $.y),
            (B.mapSize.y = o.y))),
        B.map === null || j === !0 || N === !0)
      ) {
        const k = this.type !== ma ? { minFilter: pr, magFilter: pr } : {};
        B.map !== null && B.map.dispose(),
          (B.map = new Pa(i.x, i.y, k)),
          (B.map.texture.name = Q.name + ".shadowMap"),
          B.camera.updateProjectionMatrix();
      }
      t.setRenderTarget(B.map), t.clear();
      const G = B.getViewportCount();
      for (let k = 0; k < G; k++) {
        const q = B.getViewport(k);
        a.set(o.x * q.x, o.y * q.y, o.x * q.z, o.y * q.w),
          D.viewport(a),
          B.updateMatrices(Q, k),
          (r = B.getFrustum()),
          w(T, I, B.camera, Q, this.type);
      }
      B.isPointLightShadow !== !0 && this.type === ma && _(B, I),
        (B.needsUpdate = !1);
    }
    (g = this.type), (x.needsUpdate = !1), t.setRenderTarget(R, P, F);
  };
  function _(M, T) {
    const I = e.update(S);
    p.defines.VSM_SAMPLES !== M.blurSamples &&
      ((p.defines.VSM_SAMPLES = M.blurSamples),
      (m.defines.VSM_SAMPLES = M.blurSamples),
      (p.needsUpdate = !0),
      (m.needsUpdate = !0)),
      M.mapPass === null && (M.mapPass = new Pa(i.x, i.y)),
      (p.uniforms.shadow_pass.value = M.map.texture),
      (p.uniforms.resolution.value = M.mapSize),
      (p.uniforms.radius.value = M.radius),
      t.setRenderTarget(M.mapPass),
      t.clear(),
      t.renderBufferDirect(T, null, I, p, S, null),
      (m.uniforms.shadow_pass.value = M.mapPass.texture),
      (m.uniforms.resolution.value = M.mapSize),
      (m.uniforms.radius.value = M.radius),
      t.setRenderTarget(M.map),
      t.clear(),
      t.renderBufferDirect(T, null, I, m, S, null);
  }
  function y(M, T, I, R) {
    let P = null;
    const F =
      I.isPointLight === !0 ? M.customDistanceMaterial : M.customDepthMaterial;
    if (F !== void 0) P = F;
    else if (
      ((P = I.isPointLight === !0 ? l : s),
      (t.localClippingEnabled &&
        T.clipShadows === !0 &&
        Array.isArray(T.clippingPlanes) &&
        T.clippingPlanes.length !== 0) ||
        (T.displacementMap && T.displacementScale !== 0) ||
        (T.alphaMap && T.alphaTest > 0) ||
        (T.map && T.alphaTest > 0))
    ) {
      const D = P.uuid,
        j = T.uuid;
      let N = c[D];
      N === void 0 && ((N = {}), (c[D] = N));
      let V = N[j];
      V === void 0 &&
        ((V = P.clone()), (N[j] = V), T.addEventListener("dispose", A)),
        (P = V);
    }
    if (
      ((P.visible = T.visible),
      (P.wireframe = T.wireframe),
      R === ma
        ? (P.side = T.shadowSide !== null ? T.shadowSide : T.side)
        : (P.side = T.shadowSide !== null ? T.shadowSide : d[T.side]),
      (P.alphaMap = T.alphaMap),
      (P.alphaTest = T.alphaTest),
      (P.map = T.map),
      (P.clipShadows = T.clipShadows),
      (P.clippingPlanes = T.clippingPlanes),
      (P.clipIntersection = T.clipIntersection),
      (P.displacementMap = T.displacementMap),
      (P.displacementScale = T.displacementScale),
      (P.displacementBias = T.displacementBias),
      (P.wireframeLinewidth = T.wireframeLinewidth),
      (P.linewidth = T.linewidth),
      I.isPointLight === !0 && P.isMeshDistanceMaterial === !0)
    ) {
      const D = t.properties.get(P);
      D.light = I;
    }
    return P;
  }
  function w(M, T, I, R, P) {
    if (M.visible === !1) return;
    if (
      M.layers.test(T.layers) &&
      (M.isMesh || M.isLine || M.isPoints) &&
      (M.castShadow || (M.receiveShadow && P === ma)) &&
      (!M.frustumCulled || r.intersectsObject(M))
    ) {
      M.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse, M.matrixWorld);
      const j = e.update(M),
        N = M.material;
      if (Array.isArray(N)) {
        const V = j.groups;
        for (let W = 0, Q = V.length; W < Q; W++) {
          const B = V[W],
            $ = N[B.materialIndex];
          if ($ && $.visible) {
            const G = y(M, $, R, P);
            M.onBeforeShadow(t, M, T, I, j, G, B),
              t.renderBufferDirect(I, null, j, G, M, B),
              M.onAfterShadow(t, M, T, I, j, G, B);
          }
        }
      } else if (N.visible) {
        const V = y(M, N, R, P);
        M.onBeforeShadow(t, M, T, I, j, V, null),
          t.renderBufferDirect(I, null, j, V, M, null),
          M.onAfterShadow(t, M, T, I, j, V, null);
      }
    }
    const D = M.children;
    for (let j = 0, N = D.length; j < N; j++) w(D[j], T, I, R, P);
  }
  function A(M) {
    M.target.removeEventListener("dispose", A);
    for (const I in c) {
      const R = c[I],
        P = M.target.uuid;
      P in R && (R[P].dispose(), delete R[P]);
    }
  }
}
function zG(t, e, n) {
  const r = n.isWebGL2;
  function i() {
    let ie = !1;
    const $e = new rn();
    let He = null;
    const Xe = new rn(0, 0, 0, 0);
    return {
      setMask: function (Ue) {
        He !== Ue && !ie && (t.colorMask(Ue, Ue, Ue, Ue), (He = Ue));
      },
      setLocked: function (Ue) {
        ie = Ue;
      },
      setClear: function (Ue, Ye, ke, tt, ut) {
        ut === !0 && ((Ue *= tt), (Ye *= tt), (ke *= tt)),
          $e.set(Ue, Ye, ke, tt),
          Xe.equals($e) === !1 && (t.clearColor(Ue, Ye, ke, tt), Xe.copy($e));
      },
      reset: function () {
        (ie = !1), (He = null), Xe.set(-1, 0, 0, 0);
      },
    };
  }
  function o() {
    let ie = !1,
      $e = null,
      He = null,
      Xe = null;
    return {
      setTest: function (Ue) {
        Ue ? _e(t.DEPTH_TEST) : me(t.DEPTH_TEST);
      },
      setMask: function (Ue) {
        $e !== Ue && !ie && (t.depthMask(Ue), ($e = Ue));
      },
      setFunc: function (Ue) {
        if (He !== Ue) {
          switch (Ue) {
            case cF:
              t.depthFunc(t.NEVER);
              break;
            case uF:
              t.depthFunc(t.ALWAYS);
              break;
            case dF:
              t.depthFunc(t.LESS);
              break;
            case Mp:
              t.depthFunc(t.LEQUAL);
              break;
            case fF:
              t.depthFunc(t.EQUAL);
              break;
            case hF:
              t.depthFunc(t.GEQUAL);
              break;
            case pF:
              t.depthFunc(t.GREATER);
              break;
            case mF:
              t.depthFunc(t.NOTEQUAL);
              break;
            default:
              t.depthFunc(t.LEQUAL);
          }
          He = Ue;
        }
      },
      setLocked: function (Ue) {
        ie = Ue;
      },
      setClear: function (Ue) {
        Xe !== Ue && (t.clearDepth(Ue), (Xe = Ue));
      },
      reset: function () {
        (ie = !1), ($e = null), (He = null), (Xe = null);
      },
    };
  }
  function a() {
    let ie = !1,
      $e = null,
      He = null,
      Xe = null,
      Ue = null,
      Ye = null,
      ke = null,
      tt = null,
      ut = null;
    return {
      setTest: function (dt) {
        ie || (dt ? _e(t.STENCIL_TEST) : me(t.STENCIL_TEST));
      },
      setMask: function (dt) {
        $e !== dt && !ie && (t.stencilMask(dt), ($e = dt));
      },
      setFunc: function (dt, Rt, Bt) {
        (He !== dt || Xe !== Rt || Ue !== Bt) &&
          (t.stencilFunc(dt, Rt, Bt), (He = dt), (Xe = Rt), (Ue = Bt));
      },
      setOp: function (dt, Rt, Bt) {
        (Ye !== dt || ke !== Rt || tt !== Bt) &&
          (t.stencilOp(dt, Rt, Bt), (Ye = dt), (ke = Rt), (tt = Bt));
      },
      setLocked: function (dt) {
        ie = dt;
      },
      setClear: function (dt) {
        ut !== dt && (t.clearStencil(dt), (ut = dt));
      },
      reset: function () {
        (ie = !1),
          ($e = null),
          (He = null),
          (Xe = null),
          (Ue = null),
          (Ye = null),
          (ke = null),
          (tt = null),
          (ut = null);
      },
    };
  }
  const s = new i(),
    l = new o(),
    c = new a(),
    u = new WeakMap(),
    d = new WeakMap();
  let p = {},
    m = {},
    v = new WeakMap(),
    S = [],
    x = null,
    g = !1,
    _ = null,
    y = null,
    w = null,
    A = null,
    M = null,
    T = null,
    I = null,
    R = new pt(0, 0, 0),
    P = 0,
    F = !1,
    D = null,
    j = null,
    N = null,
    V = null,
    W = null;
  const Q = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let B = !1,
    $ = 0;
  const G = t.getParameter(t.VERSION);
  G.indexOf("WebGL") !== -1
    ? (($ = parseFloat(/^WebGL (\d)/.exec(G)[1])), (B = $ >= 1))
    : G.indexOf("OpenGL ES") !== -1 &&
      (($ = parseFloat(/^OpenGL ES (\d)/.exec(G)[1])), (B = $ >= 2));
  let k = null,
    q = {};
  const X = t.getParameter(t.SCISSOR_BOX),
    ee = t.getParameter(t.VIEWPORT),
    J = new rn().fromArray(X),
    oe = new rn().fromArray(ee);
  function ae(ie, $e, He, Xe) {
    const Ue = new Uint8Array(4),
      Ye = t.createTexture();
    t.bindTexture(ie, Ye),
      t.texParameteri(ie, t.TEXTURE_MIN_FILTER, t.NEAREST),
      t.texParameteri(ie, t.TEXTURE_MAG_FILTER, t.NEAREST);
    for (let ke = 0; ke < He; ke++)
      r && (ie === t.TEXTURE_3D || ie === t.TEXTURE_2D_ARRAY)
        ? t.texImage3D($e, 0, t.RGBA, 1, 1, Xe, 0, t.RGBA, t.UNSIGNED_BYTE, Ue)
        : t.texImage2D(
            $e + ke,
            0,
            t.RGBA,
            1,
            1,
            0,
            t.RGBA,
            t.UNSIGNED_BYTE,
            Ue
          );
    return Ye;
  }
  const le = {};
  (le[t.TEXTURE_2D] = ae(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
    (le[t.TEXTURE_CUBE_MAP] = ae(
      t.TEXTURE_CUBE_MAP,
      t.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    r &&
      ((le[t.TEXTURE_2D_ARRAY] = ae(
        t.TEXTURE_2D_ARRAY,
        t.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (le[t.TEXTURE_3D] = ae(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1))),
    s.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    _e(t.DEPTH_TEST),
    l.setFunc(Mp),
    pe(!1),
    H(Zb),
    _e(t.CULL_FACE),
    fe(Fs);
  function _e(ie) {
    p[ie] !== !0 && (t.enable(ie), (p[ie] = !0));
  }
  function me(ie) {
    p[ie] !== !1 && (t.disable(ie), (p[ie] = !1));
  }
  function se(ie, $e) {
    return m[ie] !== $e
      ? (t.bindFramebuffer(ie, $e),
        (m[ie] = $e),
        r &&
          (ie === t.DRAW_FRAMEBUFFER && (m[t.FRAMEBUFFER] = $e),
          ie === t.FRAMEBUFFER && (m[t.DRAW_FRAMEBUFFER] = $e)),
        !0)
      : !1;
  }
  function Y(ie, $e) {
    let He = S,
      Xe = !1;
    if (ie)
      if (
        ((He = v.get($e)),
        He === void 0 && ((He = []), v.set($e, He)),
        ie.isWebGLMultipleRenderTargets)
      ) {
        const Ue = ie.texture;
        if (He.length !== Ue.length || He[0] !== t.COLOR_ATTACHMENT0) {
          for (let Ye = 0, ke = Ue.length; Ye < ke; Ye++)
            He[Ye] = t.COLOR_ATTACHMENT0 + Ye;
          (He.length = Ue.length), (Xe = !0);
        }
      } else
        He[0] !== t.COLOR_ATTACHMENT0 &&
          ((He[0] = t.COLOR_ATTACHMENT0), (Xe = !0));
    else He[0] !== t.BACK && ((He[0] = t.BACK), (Xe = !0));
    Xe &&
      (n.isWebGL2
        ? t.drawBuffers(He)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(He));
  }
  function ve(ie) {
    return x !== ie ? (t.useProgram(ie), (x = ie), !0) : !1;
  }
  const de = {
    [xl]: t.FUNC_ADD,
    [qN]: t.FUNC_SUBTRACT,
    [KN]: t.FUNC_REVERSE_SUBTRACT,
  };
  if (r) (de[tw] = t.MIN), (de[nw] = t.MAX);
  else {
    const ie = e.get("EXT_blend_minmax");
    ie !== null && ((de[tw] = ie.MIN_EXT), (de[nw] = ie.MAX_EXT));
  }
  const ue = {
    [YN]: t.ZERO,
    [ZN]: t.ONE,
    [QN]: t.SRC_COLOR,
    [sy]: t.SRC_ALPHA,
    [iF]: t.SRC_ALPHA_SATURATE,
    [nF]: t.DST_COLOR,
    [eF]: t.DST_ALPHA,
    [JN]: t.ONE_MINUS_SRC_COLOR,
    [ly]: t.ONE_MINUS_SRC_ALPHA,
    [rF]: t.ONE_MINUS_DST_COLOR,
    [tF]: t.ONE_MINUS_DST_ALPHA,
    [oF]: t.CONSTANT_COLOR,
    [aF]: t.ONE_MINUS_CONSTANT_COLOR,
    [sF]: t.CONSTANT_ALPHA,
    [lF]: t.ONE_MINUS_CONSTANT_ALPHA,
  };
  function fe(ie, $e, He, Xe, Ue, Ye, ke, tt, ut, dt) {
    if (ie === Fs) {
      g === !0 && (me(t.BLEND), (g = !1));
      return;
    }
    if ((g === !1 && (_e(t.BLEND), (g = !0)), ie !== XN)) {
      if (ie !== _ || dt !== F) {
        if (
          ((y !== xl || M !== xl) &&
            (t.blendEquation(t.FUNC_ADD), (y = xl), (M = xl)),
          dt)
        )
          switch (ie) {
            case qc:
              t.blendFuncSeparate(
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Qb:
              t.blendFunc(t.ONE, t.ONE);
              break;
            case Jb:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case ew:
              t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ie);
              break;
          }
        else
          switch (ie) {
            case qc:
              t.blendFuncSeparate(
                t.SRC_ALPHA,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Qb:
              t.blendFunc(t.SRC_ALPHA, t.ONE);
              break;
            case Jb:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case ew:
              t.blendFunc(t.ZERO, t.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ie);
              break;
          }
        (w = null),
          (A = null),
          (T = null),
          (I = null),
          R.set(0, 0, 0),
          (P = 0),
          (_ = ie),
          (F = dt);
      }
      return;
    }
    (Ue = Ue || $e),
      (Ye = Ye || He),
      (ke = ke || Xe),
      ($e !== y || Ue !== M) &&
        (t.blendEquationSeparate(de[$e], de[Ue]), (y = $e), (M = Ue)),
      (He !== w || Xe !== A || Ye !== T || ke !== I) &&
        (t.blendFuncSeparate(ue[He], ue[Xe], ue[Ye], ue[ke]),
        (w = He),
        (A = Xe),
        (T = Ye),
        (I = ke)),
      (tt.equals(R) === !1 || ut !== P) &&
        (t.blendColor(tt.r, tt.g, tt.b, ut), R.copy(tt), (P = ut)),
      (_ = ie),
      (F = !1);
  }
  function Te(ie, $e) {
    ie.side === Zo ? me(t.CULL_FACE) : _e(t.CULL_FACE);
    let He = ie.side === Oi;
    $e && (He = !He),
      pe(He),
      ie.blending === qc && ie.transparent === !1
        ? fe(Fs)
        : fe(
            ie.blending,
            ie.blendEquation,
            ie.blendSrc,
            ie.blendDst,
            ie.blendEquationAlpha,
            ie.blendSrcAlpha,
            ie.blendDstAlpha,
            ie.blendColor,
            ie.blendAlpha,
            ie.premultipliedAlpha
          ),
      l.setFunc(ie.depthFunc),
      l.setTest(ie.depthTest),
      l.setMask(ie.depthWrite),
      s.setMask(ie.colorWrite);
    const Xe = ie.stencilWrite;
    c.setTest(Xe),
      Xe &&
        (c.setMask(ie.stencilWriteMask),
        c.setFunc(ie.stencilFunc, ie.stencilRef, ie.stencilFuncMask),
        c.setOp(ie.stencilFail, ie.stencilZFail, ie.stencilZPass)),
      Z(ie.polygonOffset, ie.polygonOffsetFactor, ie.polygonOffsetUnits),
      ie.alphaToCoverage === !0
        ? _e(t.SAMPLE_ALPHA_TO_COVERAGE)
        : me(t.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function pe(ie) {
    D !== ie && (ie ? t.frontFace(t.CW) : t.frontFace(t.CCW), (D = ie));
  }
  function H(ie) {
    ie !== $N
      ? (_e(t.CULL_FACE),
        ie !== j &&
          (ie === Zb
            ? t.cullFace(t.BACK)
            : ie === GN
            ? t.cullFace(t.FRONT)
            : t.cullFace(t.FRONT_AND_BACK)))
      : me(t.CULL_FACE),
      (j = ie);
  }
  function z(ie) {
    ie !== N && (B && t.lineWidth(ie), (N = ie));
  }
  function Z(ie, $e, He) {
    ie
      ? (_e(t.POLYGON_OFFSET_FILL),
        (V !== $e || W !== He) && (t.polygonOffset($e, He), (V = $e), (W = He)))
      : me(t.POLYGON_OFFSET_FILL);
  }
  function ge(ie) {
    ie ? _e(t.SCISSOR_TEST) : me(t.SCISSOR_TEST);
  }
  function ce(ie) {
    ie === void 0 && (ie = t.TEXTURE0 + Q - 1),
      k !== ie && (t.activeTexture(ie), (k = ie));
  }
  function he(ie, $e, He) {
    He === void 0 && (k === null ? (He = t.TEXTURE0 + Q - 1) : (He = k));
    let Xe = q[He];
    Xe === void 0 && ((Xe = { type: void 0, texture: void 0 }), (q[He] = Xe)),
      (Xe.type !== ie || Xe.texture !== $e) &&
        (k !== He && (t.activeTexture(He), (k = He)),
        t.bindTexture(ie, $e || le[ie]),
        (Xe.type = ie),
        (Xe.texture = $e));
  }
  function Me() {
    const ie = q[k];
    ie !== void 0 &&
      ie.type !== void 0 &&
      (t.bindTexture(ie.type, null), (ie.type = void 0), (ie.texture = void 0));
  }
  function Re() {
    try {
      t.compressedTexImage2D.apply(t, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function Le() {
    try {
      t.compressedTexImage3D.apply(t, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function Oe() {
    try {
      t.texSubImage2D.apply(t, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function Pe() {
    try {
      t.texSubImage3D.apply(t, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function Se() {
    try {
      t.compressedTexSubImage2D.apply(t, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function Je() {
    try {
      t.compressedTexSubImage3D.apply(t, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function st() {
    try {
      t.texStorage2D.apply(t, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function Qe() {
    try {
      t.texStorage3D.apply(t, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function Ke() {
    try {
      t.texImage2D.apply(t, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function Ne() {
    try {
      t.texImage3D.apply(t, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function ne(ie) {
    J.equals(ie) === !1 && (t.scissor(ie.x, ie.y, ie.z, ie.w), J.copy(ie));
  }
  function Ie(ie) {
    oe.equals(ie) === !1 && (t.viewport(ie.x, ie.y, ie.z, ie.w), oe.copy(ie));
  }
  function et(ie, $e) {
    let He = d.get($e);
    He === void 0 && ((He = new WeakMap()), d.set($e, He));
    let Xe = He.get(ie);
    Xe === void 0 &&
      ((Xe = t.getUniformBlockIndex($e, ie.name)), He.set(ie, Xe));
  }
  function We(ie, $e) {
    const Xe = d.get($e).get(ie);
    u.get($e) !== Xe &&
      (t.uniformBlockBinding($e, Xe, ie.__bindingPointIndex), u.set($e, Xe));
  }
  function Ee() {
    t.disable(t.BLEND),
      t.disable(t.CULL_FACE),
      t.disable(t.DEPTH_TEST),
      t.disable(t.POLYGON_OFFSET_FILL),
      t.disable(t.SCISSOR_TEST),
      t.disable(t.STENCIL_TEST),
      t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
      t.blendEquation(t.FUNC_ADD),
      t.blendFunc(t.ONE, t.ZERO),
      t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
      t.blendColor(0, 0, 0, 0),
      t.colorMask(!0, !0, !0, !0),
      t.clearColor(0, 0, 0, 0),
      t.depthMask(!0),
      t.depthFunc(t.LESS),
      t.clearDepth(1),
      t.stencilMask(4294967295),
      t.stencilFunc(t.ALWAYS, 0, 4294967295),
      t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
      t.clearStencil(0),
      t.cullFace(t.BACK),
      t.frontFace(t.CCW),
      t.polygonOffset(0, 0),
      t.activeTexture(t.TEXTURE0),
      t.bindFramebuffer(t.FRAMEBUFFER, null),
      r === !0 &&
        (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
        t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
      t.useProgram(null),
      t.lineWidth(1),
      t.scissor(0, 0, t.canvas.width, t.canvas.height),
      t.viewport(0, 0, t.canvas.width, t.canvas.height),
      (p = {}),
      (k = null),
      (q = {}),
      (m = {}),
      (v = new WeakMap()),
      (S = []),
      (x = null),
      (g = !1),
      (_ = null),
      (y = null),
      (w = null),
      (A = null),
      (M = null),
      (T = null),
      (I = null),
      (R = new pt(0, 0, 0)),
      (P = 0),
      (F = !1),
      (D = null),
      (j = null),
      (N = null),
      (V = null),
      (W = null),
      J.set(0, 0, t.canvas.width, t.canvas.height),
      oe.set(0, 0, t.canvas.width, t.canvas.height),
      s.reset(),
      l.reset(),
      c.reset();
  }
  return {
    buffers: { color: s, depth: l, stencil: c },
    enable: _e,
    disable: me,
    bindFramebuffer: se,
    drawBuffers: Y,
    useProgram: ve,
    setBlending: fe,
    setMaterial: Te,
    setFlipSided: pe,
    setCullFace: H,
    setLineWidth: z,
    setPolygonOffset: Z,
    setScissorTest: ge,
    activeTexture: ce,
    bindTexture: he,
    unbindTexture: Me,
    compressedTexImage2D: Re,
    compressedTexImage3D: Le,
    texImage2D: Ke,
    texImage3D: Ne,
    updateUBOMapping: et,
    uniformBlockBinding: We,
    texStorage2D: st,
    texStorage3D: Qe,
    texSubImage2D: Oe,
    texSubImage3D: Pe,
    compressedTexSubImage2D: Se,
    compressedTexSubImage3D: Je,
    scissor: ne,
    viewport: Ie,
    reset: Ee,
  };
}
function UG(t, e, n, r, i, o, a) {
  const s = i.isWebGL2,
    l = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    c =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    u = new WeakMap();
  let d;
  const p = new WeakMap();
  let m = !1;
  try {
    m =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function v(H, z) {
    return m ? new OffscreenCanvas(H, z) : zp("canvas");
  }
  function S(H, z, Z, ge) {
    let ce = 1;
    if (
      ((H.width > ge || H.height > ge) &&
        (ce = ge / Math.max(H.width, H.height)),
      ce < 1 || z === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && H instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && H instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && H instanceof ImageBitmap)
      ) {
        const he = z ? dy : Math.floor,
          Me = he(ce * H.width),
          Re = he(ce * H.height);
        d === void 0 && (d = v(Me, Re));
        const Le = Z ? v(Me, Re) : d;
        return (
          (Le.width = Me),
          (Le.height = Re),
          Le.getContext("2d").drawImage(H, 0, 0, Me, Re),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              H.width +
              "x" +
              H.height +
              ") to (" +
              Me +
              "x" +
              Re +
              ")."
          ),
          Le
        );
      } else
        return (
          "data" in H &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                H.width +
                "x" +
                H.height +
                ")."
            ),
          H
        );
    return H;
  }
  function x(H) {
    return Iw(H.width) && Iw(H.height);
  }
  function g(H) {
    return s
      ? !1
      : H.wrapS !== pi ||
          H.wrapT !== pi ||
          (H.minFilter !== pr && H.minFilter !== Yn);
  }
  function _(H, z) {
    return H.generateMipmaps && z && H.minFilter !== pr && H.minFilter !== Yn;
  }
  function y(H) {
    t.generateMipmap(H);
  }
  function w(H, z, Z, ge, ce = !1) {
    if (s === !1) return z;
    if (H !== null) {
      if (t[H] !== void 0) return t[H];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          H +
          "'"
      );
    }
    let he = z;
    if (
      (z === t.RED &&
        (Z === t.FLOAT && (he = t.R32F),
        Z === t.HALF_FLOAT && (he = t.R16F),
        Z === t.UNSIGNED_BYTE && (he = t.R8)),
      z === t.RED_INTEGER &&
        (Z === t.UNSIGNED_BYTE && (he = t.R8UI),
        Z === t.UNSIGNED_SHORT && (he = t.R16UI),
        Z === t.UNSIGNED_INT && (he = t.R32UI),
        Z === t.BYTE && (he = t.R8I),
        Z === t.SHORT && (he = t.R16I),
        Z === t.INT && (he = t.R32I)),
      z === t.RG &&
        (Z === t.FLOAT && (he = t.RG32F),
        Z === t.HALF_FLOAT && (he = t.RG16F),
        Z === t.UNSIGNED_BYTE && (he = t.RG8)),
      z === t.RGBA)
    ) {
      const Me = ce ? Op : Mn.getTransfer(ge);
      Z === t.FLOAT && (he = t.RGBA32F),
        Z === t.HALF_FLOAT && (he = t.RGBA16F),
        Z === t.UNSIGNED_BYTE && (he = Me === Un ? t.SRGB8_ALPHA8 : t.RGBA8),
        Z === t.UNSIGNED_SHORT_4_4_4_4 && (he = t.RGBA4),
        Z === t.UNSIGNED_SHORT_5_5_5_1 && (he = t.RGB5_A1);
    }
    return (
      (he === t.R16F ||
        he === t.R32F ||
        he === t.RG16F ||
        he === t.RG32F ||
        he === t.RGBA16F ||
        he === t.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      he
    );
  }
  function A(H, z, Z) {
    return _(H, Z) === !0 ||
      (H.isFramebufferTexture && H.minFilter !== pr && H.minFilter !== Yn)
      ? Math.log2(Math.max(z.width, z.height)) + 1
      : H.mipmaps !== void 0 && H.mipmaps.length > 0
      ? H.mipmaps.length
      : H.isCompressedTexture && Array.isArray(H.image)
      ? z.mipmaps.length
      : 1;
  }
  function M(H) {
    return H === pr || H === cy || H === Yh ? t.NEAREST : t.LINEAR;
  }
  function T(H) {
    const z = H.target;
    z.removeEventListener("dispose", T), R(z), z.isVideoTexture && u.delete(z);
  }
  function I(H) {
    const z = H.target;
    z.removeEventListener("dispose", I), F(z);
  }
  function R(H) {
    const z = r.get(H);
    if (z.__webglInit === void 0) return;
    const Z = H.source,
      ge = p.get(Z);
    if (ge) {
      const ce = ge[z.__cacheKey];
      ce.usedTimes--,
        ce.usedTimes === 0 && P(H),
        Object.keys(ge).length === 0 && p.delete(Z);
    }
    r.remove(H);
  }
  function P(H) {
    const z = r.get(H);
    t.deleteTexture(z.__webglTexture);
    const Z = H.source,
      ge = p.get(Z);
    delete ge[z.__cacheKey], a.memory.textures--;
  }
  function F(H) {
    const z = H.texture,
      Z = r.get(H),
      ge = r.get(z);
    if (
      (ge.__webglTexture !== void 0 &&
        (t.deleteTexture(ge.__webglTexture), a.memory.textures--),
      H.depthTexture && H.depthTexture.dispose(),
      H.isWebGLCubeRenderTarget)
    )
      for (let ce = 0; ce < 6; ce++) {
        if (Array.isArray(Z.__webglFramebuffer[ce]))
          for (let he = 0; he < Z.__webglFramebuffer[ce].length; he++)
            t.deleteFramebuffer(Z.__webglFramebuffer[ce][he]);
        else t.deleteFramebuffer(Z.__webglFramebuffer[ce]);
        Z.__webglDepthbuffer && t.deleteRenderbuffer(Z.__webglDepthbuffer[ce]);
      }
    else {
      if (Array.isArray(Z.__webglFramebuffer))
        for (let ce = 0; ce < Z.__webglFramebuffer.length; ce++)
          t.deleteFramebuffer(Z.__webglFramebuffer[ce]);
      else t.deleteFramebuffer(Z.__webglFramebuffer);
      if (
        (Z.__webglDepthbuffer && t.deleteRenderbuffer(Z.__webglDepthbuffer),
        Z.__webglMultisampledFramebuffer &&
          t.deleteFramebuffer(Z.__webglMultisampledFramebuffer),
        Z.__webglColorRenderbuffer)
      )
        for (let ce = 0; ce < Z.__webglColorRenderbuffer.length; ce++)
          Z.__webglColorRenderbuffer[ce] &&
            t.deleteRenderbuffer(Z.__webglColorRenderbuffer[ce]);
      Z.__webglDepthRenderbuffer &&
        t.deleteRenderbuffer(Z.__webglDepthRenderbuffer);
    }
    if (H.isWebGLMultipleRenderTargets)
      for (let ce = 0, he = z.length; ce < he; ce++) {
        const Me = r.get(z[ce]);
        Me.__webglTexture &&
          (t.deleteTexture(Me.__webglTexture), a.memory.textures--),
          r.remove(z[ce]);
      }
    r.remove(z), r.remove(H);
  }
  let D = 0;
  function j() {
    D = 0;
  }
  function N() {
    const H = D;
    return (
      H >= i.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            H +
            " texture units while this GPU supports only " +
            i.maxTextures
        ),
      (D += 1),
      H
    );
  }
  function V(H) {
    const z = [];
    return (
      z.push(H.wrapS),
      z.push(H.wrapT),
      z.push(H.wrapR || 0),
      z.push(H.magFilter),
      z.push(H.minFilter),
      z.push(H.anisotropy),
      z.push(H.internalFormat),
      z.push(H.format),
      z.push(H.type),
      z.push(H.generateMipmaps),
      z.push(H.premultiplyAlpha),
      z.push(H.flipY),
      z.push(H.unpackAlignment),
      z.push(H.colorSpace),
      z.join()
    );
  }
  function W(H, z) {
    const Z = r.get(H);
    if (
      (H.isVideoTexture && Te(H),
      H.isRenderTargetTexture === !1 &&
        H.version > 0 &&
        Z.__version !== H.version)
    ) {
      const ge = H.image;
      if (ge === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (ge.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        J(Z, H, z);
        return;
      }
    }
    n.bindTexture(t.TEXTURE_2D, Z.__webglTexture, t.TEXTURE0 + z);
  }
  function Q(H, z) {
    const Z = r.get(H);
    if (H.version > 0 && Z.__version !== H.version) {
      J(Z, H, z);
      return;
    }
    n.bindTexture(t.TEXTURE_2D_ARRAY, Z.__webglTexture, t.TEXTURE0 + z);
  }
  function B(H, z) {
    const Z = r.get(H);
    if (H.version > 0 && Z.__version !== H.version) {
      J(Z, H, z);
      return;
    }
    n.bindTexture(t.TEXTURE_3D, Z.__webglTexture, t.TEXTURE0 + z);
  }
  function $(H, z) {
    const Z = r.get(H);
    if (H.version > 0 && Z.__version !== H.version) {
      oe(Z, H, z);
      return;
    }
    n.bindTexture(t.TEXTURE_CUBE_MAP, Z.__webglTexture, t.TEXTURE0 + z);
  }
  const G = { [Ap]: t.REPEAT, [pi]: t.CLAMP_TO_EDGE, [Rp]: t.MIRRORED_REPEAT },
    k = {
      [pr]: t.NEAREST,
      [cy]: t.NEAREST_MIPMAP_NEAREST,
      [Yh]: t.NEAREST_MIPMAP_LINEAR,
      [Yn]: t.LINEAR,
      [GM]: t.LINEAR_MIPMAP_NEAREST,
      [Hl]: t.LINEAR_MIPMAP_LINEAR,
    },
    q = {
      [zF]: t.NEVER,
      [VF]: t.ALWAYS,
      [UF]: t.LESS,
      [nC]: t.LEQUAL,
      [kF]: t.EQUAL,
      [jF]: t.GEQUAL,
      [BF]: t.GREATER,
      [HF]: t.NOTEQUAL,
    };
  function X(H, z, Z) {
    if (
      (Z
        ? (t.texParameteri(H, t.TEXTURE_WRAP_S, G[z.wrapS]),
          t.texParameteri(H, t.TEXTURE_WRAP_T, G[z.wrapT]),
          (H === t.TEXTURE_3D || H === t.TEXTURE_2D_ARRAY) &&
            t.texParameteri(H, t.TEXTURE_WRAP_R, G[z.wrapR]),
          t.texParameteri(H, t.TEXTURE_MAG_FILTER, k[z.magFilter]),
          t.texParameteri(H, t.TEXTURE_MIN_FILTER, k[z.minFilter]))
        : (t.texParameteri(H, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
          t.texParameteri(H, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
          (H === t.TEXTURE_3D || H === t.TEXTURE_2D_ARRAY) &&
            t.texParameteri(H, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
          (z.wrapS !== pi || z.wrapT !== pi) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          t.texParameteri(H, t.TEXTURE_MAG_FILTER, M(z.magFilter)),
          t.texParameteri(H, t.TEXTURE_MIN_FILTER, M(z.minFilter)),
          z.minFilter !== pr &&
            z.minFilter !== Yn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      z.compareFunction &&
        (t.texParameteri(H, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
        t.texParameteri(H, t.TEXTURE_COMPARE_FUNC, q[z.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const ge = e.get("EXT_texture_filter_anisotropic");
      if (
        z.magFilter === pr ||
        (z.minFilter !== Yh && z.minFilter !== Hl) ||
        (z.type === wa && e.has("OES_texture_float_linear") === !1) ||
        (s === !1 &&
          z.type === df &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (z.anisotropy > 1 || r.get(z).__currentAnisotropy) &&
        (t.texParameterf(
          H,
          ge.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(z.anisotropy, i.getMaxAnisotropy())
        ),
        (r.get(z).__currentAnisotropy = z.anisotropy));
    }
  }
  function ee(H, z) {
    let Z = !1;
    H.__webglInit === void 0 &&
      ((H.__webglInit = !0), z.addEventListener("dispose", T));
    const ge = z.source;
    let ce = p.get(ge);
    ce === void 0 && ((ce = {}), p.set(ge, ce));
    const he = V(z);
    if (he !== H.__cacheKey) {
      ce[he] === void 0 &&
        ((ce[he] = { texture: t.createTexture(), usedTimes: 0 }),
        a.memory.textures++,
        (Z = !0)),
        ce[he].usedTimes++;
      const Me = ce[H.__cacheKey];
      Me !== void 0 &&
        (ce[H.__cacheKey].usedTimes--, Me.usedTimes === 0 && P(z)),
        (H.__cacheKey = he),
        (H.__webglTexture = ce[he].texture);
    }
    return Z;
  }
  function J(H, z, Z) {
    let ge = t.TEXTURE_2D;
    (z.isDataArrayTexture || z.isCompressedArrayTexture) &&
      (ge = t.TEXTURE_2D_ARRAY),
      z.isData3DTexture && (ge = t.TEXTURE_3D);
    const ce = ee(H, z),
      he = z.source;
    n.bindTexture(ge, H.__webglTexture, t.TEXTURE0 + Z);
    const Me = r.get(he);
    if (he.version !== Me.__version || ce === !0) {
      n.activeTexture(t.TEXTURE0 + Z);
      const Re = Mn.getPrimaries(Mn.workingColorSpace),
        Le = z.colorSpace === _o ? null : Mn.getPrimaries(z.colorSpace),
        Oe =
          z.colorSpace === _o || Re === Le ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, z.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, z.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, z.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, Oe);
      const Pe = g(z) && x(z.image) === !1;
      let Se = S(z.image, Pe, !1, i.maxTextureSize);
      Se = pe(z, Se);
      const Je = x(Se) || s,
        st = o.convert(z.format, z.colorSpace);
      let Qe = o.convert(z.type),
        Ke = w(z.internalFormat, st, Qe, z.colorSpace, z.isVideoTexture);
      X(ge, z, Je);
      let Ne;
      const ne = z.mipmaps,
        Ie = s && z.isVideoTexture !== !0 && Ke !== QM,
        et = Me.__version === void 0 || ce === !0,
        We = A(z, Se, Je);
      if (z.isDepthTexture)
        (Ke = t.DEPTH_COMPONENT),
          s
            ? z.type === wa
              ? (Ke = t.DEPTH_COMPONENT32F)
              : z.type === Ls
              ? (Ke = t.DEPTH_COMPONENT24)
              : z.type === Nl
              ? (Ke = t.DEPTH24_STENCIL8)
              : (Ke = t.DEPTH_COMPONENT16)
            : z.type === wa &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          z.format === Fl &&
            Ke === t.DEPTH_COMPONENT &&
            z.type !== Jy &&
            z.type !== Ls &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (z.type = Ls),
            (Qe = o.convert(z.type))),
          z.format === cu &&
            Ke === t.DEPTH_COMPONENT &&
            ((Ke = t.DEPTH_STENCIL),
            z.type !== Nl &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (z.type = Nl),
              (Qe = o.convert(z.type)))),
          et &&
            (Ie
              ? n.texStorage2D(t.TEXTURE_2D, 1, Ke, Se.width, Se.height)
              : n.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  Ke,
                  Se.width,
                  Se.height,
                  0,
                  st,
                  Qe,
                  null
                ));
      else if (z.isDataTexture)
        if (ne.length > 0 && Je) {
          Ie &&
            et &&
            n.texStorage2D(t.TEXTURE_2D, We, Ke, ne[0].width, ne[0].height);
          for (let Ee = 0, ie = ne.length; Ee < ie; Ee++)
            (Ne = ne[Ee]),
              Ie
                ? n.texSubImage2D(
                    t.TEXTURE_2D,
                    Ee,
                    0,
                    0,
                    Ne.width,
                    Ne.height,
                    st,
                    Qe,
                    Ne.data
                  )
                : n.texImage2D(
                    t.TEXTURE_2D,
                    Ee,
                    Ke,
                    Ne.width,
                    Ne.height,
                    0,
                    st,
                    Qe,
                    Ne.data
                  );
          z.generateMipmaps = !1;
        } else
          Ie
            ? (et && n.texStorage2D(t.TEXTURE_2D, We, Ke, Se.width, Se.height),
              n.texSubImage2D(
                t.TEXTURE_2D,
                0,
                0,
                0,
                Se.width,
                Se.height,
                st,
                Qe,
                Se.data
              ))
            : n.texImage2D(
                t.TEXTURE_2D,
                0,
                Ke,
                Se.width,
                Se.height,
                0,
                st,
                Qe,
                Se.data
              );
      else if (z.isCompressedTexture)
        if (z.isCompressedArrayTexture) {
          Ie &&
            et &&
            n.texStorage3D(
              t.TEXTURE_2D_ARRAY,
              We,
              Ke,
              ne[0].width,
              ne[0].height,
              Se.depth
            );
          for (let Ee = 0, ie = ne.length; Ee < ie; Ee++)
            (Ne = ne[Ee]),
              z.format !== Ii
                ? st !== null
                  ? Ie
                    ? n.compressedTexSubImage3D(
                        t.TEXTURE_2D_ARRAY,
                        Ee,
                        0,
                        0,
                        0,
                        Ne.width,
                        Ne.height,
                        Se.depth,
                        st,
                        Ne.data,
                        0,
                        0
                      )
                    : n.compressedTexImage3D(
                        t.TEXTURE_2D_ARRAY,
                        Ee,
                        Ke,
                        Ne.width,
                        Ne.height,
                        Se.depth,
                        0,
                        Ne.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Ie
                ? n.texSubImage3D(
                    t.TEXTURE_2D_ARRAY,
                    Ee,
                    0,
                    0,
                    0,
                    Ne.width,
                    Ne.height,
                    Se.depth,
                    st,
                    Qe,
                    Ne.data
                  )
                : n.texImage3D(
                    t.TEXTURE_2D_ARRAY,
                    Ee,
                    Ke,
                    Ne.width,
                    Ne.height,
                    Se.depth,
                    0,
                    st,
                    Qe,
                    Ne.data
                  );
        } else {
          Ie &&
            et &&
            n.texStorage2D(t.TEXTURE_2D, We, Ke, ne[0].width, ne[0].height);
          for (let Ee = 0, ie = ne.length; Ee < ie; Ee++)
            (Ne = ne[Ee]),
              z.format !== Ii
                ? st !== null
                  ? Ie
                    ? n.compressedTexSubImage2D(
                        t.TEXTURE_2D,
                        Ee,
                        0,
                        0,
                        Ne.width,
                        Ne.height,
                        st,
                        Ne.data
                      )
                    : n.compressedTexImage2D(
                        t.TEXTURE_2D,
                        Ee,
                        Ke,
                        Ne.width,
                        Ne.height,
                        0,
                        Ne.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Ie
                ? n.texSubImage2D(
                    t.TEXTURE_2D,
                    Ee,
                    0,
                    0,
                    Ne.width,
                    Ne.height,
                    st,
                    Qe,
                    Ne.data
                  )
                : n.texImage2D(
                    t.TEXTURE_2D,
                    Ee,
                    Ke,
                    Ne.width,
                    Ne.height,
                    0,
                    st,
                    Qe,
                    Ne.data
                  );
        }
      else if (z.isDataArrayTexture)
        Ie
          ? (et &&
              n.texStorage3D(
                t.TEXTURE_2D_ARRAY,
                We,
                Ke,
                Se.width,
                Se.height,
                Se.depth
              ),
            n.texSubImage3D(
              t.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              Se.width,
              Se.height,
              Se.depth,
              st,
              Qe,
              Se.data
            ))
          : n.texImage3D(
              t.TEXTURE_2D_ARRAY,
              0,
              Ke,
              Se.width,
              Se.height,
              Se.depth,
              0,
              st,
              Qe,
              Se.data
            );
      else if (z.isData3DTexture)
        Ie
          ? (et &&
              n.texStorage3D(
                t.TEXTURE_3D,
                We,
                Ke,
                Se.width,
                Se.height,
                Se.depth
              ),
            n.texSubImage3D(
              t.TEXTURE_3D,
              0,
              0,
              0,
              0,
              Se.width,
              Se.height,
              Se.depth,
              st,
              Qe,
              Se.data
            ))
          : n.texImage3D(
              t.TEXTURE_3D,
              0,
              Ke,
              Se.width,
              Se.height,
              Se.depth,
              0,
              st,
              Qe,
              Se.data
            );
      else if (z.isFramebufferTexture) {
        if (et)
          if (Ie) n.texStorage2D(t.TEXTURE_2D, We, Ke, Se.width, Se.height);
          else {
            let Ee = Se.width,
              ie = Se.height;
            for (let $e = 0; $e < We; $e++)
              n.texImage2D(t.TEXTURE_2D, $e, Ke, Ee, ie, 0, st, Qe, null),
                (Ee >>= 1),
                (ie >>= 1);
          }
      } else if (ne.length > 0 && Je) {
        Ie &&
          et &&
          n.texStorage2D(t.TEXTURE_2D, We, Ke, ne[0].width, ne[0].height);
        for (let Ee = 0, ie = ne.length; Ee < ie; Ee++)
          (Ne = ne[Ee]),
            Ie
              ? n.texSubImage2D(t.TEXTURE_2D, Ee, 0, 0, st, Qe, Ne)
              : n.texImage2D(t.TEXTURE_2D, Ee, Ke, st, Qe, Ne);
        z.generateMipmaps = !1;
      } else
        Ie
          ? (et && n.texStorage2D(t.TEXTURE_2D, We, Ke, Se.width, Se.height),
            n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, st, Qe, Se))
          : n.texImage2D(t.TEXTURE_2D, 0, Ke, st, Qe, Se);
      _(z, Je) && y(ge),
        (Me.__version = he.version),
        z.onUpdate && z.onUpdate(z);
    }
    H.__version = z.version;
  }
  function oe(H, z, Z) {
    if (z.image.length !== 6) return;
    const ge = ee(H, z),
      ce = z.source;
    n.bindTexture(t.TEXTURE_CUBE_MAP, H.__webglTexture, t.TEXTURE0 + Z);
    const he = r.get(ce);
    if (ce.version !== he.__version || ge === !0) {
      n.activeTexture(t.TEXTURE0 + Z);
      const Me = Mn.getPrimaries(Mn.workingColorSpace),
        Re = z.colorSpace === _o ? null : Mn.getPrimaries(z.colorSpace),
        Le =
          z.colorSpace === _o || Me === Re ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, z.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, z.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, z.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, Le);
      const Oe = z.isCompressedTexture || z.image[0].isCompressedTexture,
        Pe = z.image[0] && z.image[0].isDataTexture,
        Se = [];
      for (let Ee = 0; Ee < 6; Ee++)
        !Oe && !Pe
          ? (Se[Ee] = S(z.image[Ee], !1, !0, i.maxCubemapSize))
          : (Se[Ee] = Pe ? z.image[Ee].image : z.image[Ee]),
          (Se[Ee] = pe(z, Se[Ee]));
      const Je = Se[0],
        st = x(Je) || s,
        Qe = o.convert(z.format, z.colorSpace),
        Ke = o.convert(z.type),
        Ne = w(z.internalFormat, Qe, Ke, z.colorSpace),
        ne = s && z.isVideoTexture !== !0,
        Ie = he.__version === void 0 || ge === !0;
      let et = A(z, Je, st);
      X(t.TEXTURE_CUBE_MAP, z, st);
      let We;
      if (Oe) {
        ne &&
          Ie &&
          n.texStorage2D(t.TEXTURE_CUBE_MAP, et, Ne, Je.width, Je.height);
        for (let Ee = 0; Ee < 6; Ee++) {
          We = Se[Ee].mipmaps;
          for (let ie = 0; ie < We.length; ie++) {
            const $e = We[ie];
            z.format !== Ii
              ? Qe !== null
                ? ne
                  ? n.compressedTexSubImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                      ie,
                      0,
                      0,
                      $e.width,
                      $e.height,
                      Qe,
                      $e.data
                    )
                  : n.compressedTexImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                      ie,
                      Ne,
                      $e.width,
                      $e.height,
                      0,
                      $e.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : ne
              ? n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                  ie,
                  0,
                  0,
                  $e.width,
                  $e.height,
                  Qe,
                  Ke,
                  $e.data
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                  ie,
                  Ne,
                  $e.width,
                  $e.height,
                  0,
                  Qe,
                  Ke,
                  $e.data
                );
          }
        }
      } else {
        (We = z.mipmaps),
          ne &&
            Ie &&
            (We.length > 0 && et++,
            n.texStorage2D(
              t.TEXTURE_CUBE_MAP,
              et,
              Ne,
              Se[0].width,
              Se[0].height
            ));
        for (let Ee = 0; Ee < 6; Ee++)
          if (Pe) {
            ne
              ? n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                  0,
                  0,
                  0,
                  Se[Ee].width,
                  Se[Ee].height,
                  Qe,
                  Ke,
                  Se[Ee].data
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                  0,
                  Ne,
                  Se[Ee].width,
                  Se[Ee].height,
                  0,
                  Qe,
                  Ke,
                  Se[Ee].data
                );
            for (let ie = 0; ie < We.length; ie++) {
              const He = We[ie].image[Ee].image;
              ne
                ? n.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                    ie + 1,
                    0,
                    0,
                    He.width,
                    He.height,
                    Qe,
                    Ke,
                    He.data
                  )
                : n.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                    ie + 1,
                    Ne,
                    He.width,
                    He.height,
                    0,
                    Qe,
                    Ke,
                    He.data
                  );
            }
          } else {
            ne
              ? n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                  0,
                  0,
                  0,
                  Qe,
                  Ke,
                  Se[Ee]
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                  0,
                  Ne,
                  Qe,
                  Ke,
                  Se[Ee]
                );
            for (let ie = 0; ie < We.length; ie++) {
              const $e = We[ie];
              ne
                ? n.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                    ie + 1,
                    0,
                    0,
                    Qe,
                    Ke,
                    $e.image[Ee]
                  )
                : n.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                    ie + 1,
                    Ne,
                    Qe,
                    Ke,
                    $e.image[Ee]
                  );
            }
          }
      }
      _(z, st) && y(t.TEXTURE_CUBE_MAP),
        (he.__version = ce.version),
        z.onUpdate && z.onUpdate(z);
    }
    H.__version = z.version;
  }
  function ae(H, z, Z, ge, ce, he) {
    const Me = o.convert(Z.format, Z.colorSpace),
      Re = o.convert(Z.type),
      Le = w(Z.internalFormat, Me, Re, Z.colorSpace);
    if (!r.get(z).__hasExternalTextures) {
      const Pe = Math.max(1, z.width >> he),
        Se = Math.max(1, z.height >> he);
      ce === t.TEXTURE_3D || ce === t.TEXTURE_2D_ARRAY
        ? n.texImage3D(ce, he, Le, Pe, Se, z.depth, 0, Me, Re, null)
        : n.texImage2D(ce, he, Le, Pe, Se, 0, Me, Re, null);
    }
    n.bindFramebuffer(t.FRAMEBUFFER, H),
      fe(z)
        ? l.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            ge,
            ce,
            r.get(Z).__webglTexture,
            0,
            ue(z)
          )
        : (ce === t.TEXTURE_2D ||
            (ce >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
              ce <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          t.framebufferTexture2D(
            t.FRAMEBUFFER,
            ge,
            ce,
            r.get(Z).__webglTexture,
            he
          ),
      n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function le(H, z, Z) {
    if (
      (t.bindRenderbuffer(t.RENDERBUFFER, H), z.depthBuffer && !z.stencilBuffer)
    ) {
      let ge = s === !0 ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
      if (Z || fe(z)) {
        const ce = z.depthTexture;
        ce &&
          ce.isDepthTexture &&
          (ce.type === wa
            ? (ge = t.DEPTH_COMPONENT32F)
            : ce.type === Ls && (ge = t.DEPTH_COMPONENT24));
        const he = ue(z);
        fe(z)
          ? l.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              he,
              ge,
              z.width,
              z.height
            )
          : t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              he,
              ge,
              z.width,
              z.height
            );
      } else t.renderbufferStorage(t.RENDERBUFFER, ge, z.width, z.height);
      t.framebufferRenderbuffer(
        t.FRAMEBUFFER,
        t.DEPTH_ATTACHMENT,
        t.RENDERBUFFER,
        H
      );
    } else if (z.depthBuffer && z.stencilBuffer) {
      const ge = ue(z);
      Z && fe(z) === !1
        ? t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            ge,
            t.DEPTH24_STENCIL8,
            z.width,
            z.height
          )
        : fe(z)
        ? l.renderbufferStorageMultisampleEXT(
            t.RENDERBUFFER,
            ge,
            t.DEPTH24_STENCIL8,
            z.width,
            z.height
          )
        : t.renderbufferStorage(
            t.RENDERBUFFER,
            t.DEPTH_STENCIL,
            z.width,
            z.height
          ),
        t.framebufferRenderbuffer(
          t.FRAMEBUFFER,
          t.DEPTH_STENCIL_ATTACHMENT,
          t.RENDERBUFFER,
          H
        );
    } else {
      const ge =
        z.isWebGLMultipleRenderTargets === !0 ? z.texture : [z.texture];
      for (let ce = 0; ce < ge.length; ce++) {
        const he = ge[ce],
          Me = o.convert(he.format, he.colorSpace),
          Re = o.convert(he.type),
          Le = w(he.internalFormat, Me, Re, he.colorSpace),
          Oe = ue(z);
        Z && fe(z) === !1
          ? t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              Oe,
              Le,
              z.width,
              z.height
            )
          : fe(z)
          ? l.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              Oe,
              Le,
              z.width,
              z.height
            )
          : t.renderbufferStorage(t.RENDERBUFFER, Le, z.width, z.height);
      }
    }
    t.bindRenderbuffer(t.RENDERBUFFER, null);
  }
  function _e(H, z) {
    if (z && z.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (n.bindFramebuffer(t.FRAMEBUFFER, H),
      !(z.depthTexture && z.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!r.get(z.depthTexture).__webglTexture ||
      z.depthTexture.image.width !== z.width ||
      z.depthTexture.image.height !== z.height) &&
      ((z.depthTexture.image.width = z.width),
      (z.depthTexture.image.height = z.height),
      (z.depthTexture.needsUpdate = !0)),
      W(z.depthTexture, 0);
    const ge = r.get(z.depthTexture).__webglTexture,
      ce = ue(z);
    if (z.depthTexture.format === Fl)
      fe(z)
        ? l.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            ge,
            0,
            ce
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            ge,
            0
          );
    else if (z.depthTexture.format === cu)
      fe(z)
        ? l.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            ge,
            0,
            ce
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            ge,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function me(H) {
    const z = r.get(H),
      Z = H.isWebGLCubeRenderTarget === !0;
    if (H.depthTexture && !z.__autoAllocateDepthBuffer) {
      if (Z)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      _e(z.__webglFramebuffer, H);
    } else if (Z) {
      z.__webglDepthbuffer = [];
      for (let ge = 0; ge < 6; ge++)
        n.bindFramebuffer(t.FRAMEBUFFER, z.__webglFramebuffer[ge]),
          (z.__webglDepthbuffer[ge] = t.createRenderbuffer()),
          le(z.__webglDepthbuffer[ge], H, !1);
    } else
      n.bindFramebuffer(t.FRAMEBUFFER, z.__webglFramebuffer),
        (z.__webglDepthbuffer = t.createRenderbuffer()),
        le(z.__webglDepthbuffer, H, !1);
    n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function se(H, z, Z) {
    const ge = r.get(H);
    z !== void 0 &&
      ae(
        ge.__webglFramebuffer,
        H,
        H.texture,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        0
      ),
      Z !== void 0 && me(H);
  }
  function Y(H) {
    const z = H.texture,
      Z = r.get(H),
      ge = r.get(z);
    H.addEventListener("dispose", I),
      H.isWebGLMultipleRenderTargets !== !0 &&
        (ge.__webglTexture === void 0 &&
          (ge.__webglTexture = t.createTexture()),
        (ge.__version = z.version),
        a.memory.textures++);
    const ce = H.isWebGLCubeRenderTarget === !0,
      he = H.isWebGLMultipleRenderTargets === !0,
      Me = x(H) || s;
    if (ce) {
      Z.__webglFramebuffer = [];
      for (let Re = 0; Re < 6; Re++)
        if (s && z.mipmaps && z.mipmaps.length > 0) {
          Z.__webglFramebuffer[Re] = [];
          for (let Le = 0; Le < z.mipmaps.length; Le++)
            Z.__webglFramebuffer[Re][Le] = t.createFramebuffer();
        } else Z.__webglFramebuffer[Re] = t.createFramebuffer();
    } else {
      if (s && z.mipmaps && z.mipmaps.length > 0) {
        Z.__webglFramebuffer = [];
        for (let Re = 0; Re < z.mipmaps.length; Re++)
          Z.__webglFramebuffer[Re] = t.createFramebuffer();
      } else Z.__webglFramebuffer = t.createFramebuffer();
      if (he)
        if (i.drawBuffers) {
          const Re = H.texture;
          for (let Le = 0, Oe = Re.length; Le < Oe; Le++) {
            const Pe = r.get(Re[Le]);
            Pe.__webglTexture === void 0 &&
              ((Pe.__webglTexture = t.createTexture()), a.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (s && H.samples > 0 && fe(H) === !1) {
        const Re = he ? z : [z];
        (Z.__webglMultisampledFramebuffer = t.createFramebuffer()),
          (Z.__webglColorRenderbuffer = []),
          n.bindFramebuffer(t.FRAMEBUFFER, Z.__webglMultisampledFramebuffer);
        for (let Le = 0; Le < Re.length; Le++) {
          const Oe = Re[Le];
          (Z.__webglColorRenderbuffer[Le] = t.createRenderbuffer()),
            t.bindRenderbuffer(t.RENDERBUFFER, Z.__webglColorRenderbuffer[Le]);
          const Pe = o.convert(Oe.format, Oe.colorSpace),
            Se = o.convert(Oe.type),
            Je = w(
              Oe.internalFormat,
              Pe,
              Se,
              Oe.colorSpace,
              H.isXRRenderTarget === !0
            ),
            st = ue(H);
          t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            st,
            Je,
            H.width,
            H.height
          ),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + Le,
              t.RENDERBUFFER,
              Z.__webglColorRenderbuffer[Le]
            );
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null),
          H.depthBuffer &&
            ((Z.__webglDepthRenderbuffer = t.createRenderbuffer()),
            le(Z.__webglDepthRenderbuffer, H, !0)),
          n.bindFramebuffer(t.FRAMEBUFFER, null);
      }
    }
    if (ce) {
      n.bindTexture(t.TEXTURE_CUBE_MAP, ge.__webglTexture),
        X(t.TEXTURE_CUBE_MAP, z, Me);
      for (let Re = 0; Re < 6; Re++)
        if (s && z.mipmaps && z.mipmaps.length > 0)
          for (let Le = 0; Le < z.mipmaps.length; Le++)
            ae(
              Z.__webglFramebuffer[Re][Le],
              H,
              z,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_CUBE_MAP_POSITIVE_X + Re,
              Le
            );
        else
          ae(
            Z.__webglFramebuffer[Re],
            H,
            z,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_CUBE_MAP_POSITIVE_X + Re,
            0
          );
      _(z, Me) && y(t.TEXTURE_CUBE_MAP), n.unbindTexture();
    } else if (he) {
      const Re = H.texture;
      for (let Le = 0, Oe = Re.length; Le < Oe; Le++) {
        const Pe = Re[Le],
          Se = r.get(Pe);
        n.bindTexture(t.TEXTURE_2D, Se.__webglTexture),
          X(t.TEXTURE_2D, Pe, Me),
          ae(
            Z.__webglFramebuffer,
            H,
            Pe,
            t.COLOR_ATTACHMENT0 + Le,
            t.TEXTURE_2D,
            0
          ),
          _(Pe, Me) && y(t.TEXTURE_2D);
      }
      n.unbindTexture();
    } else {
      let Re = t.TEXTURE_2D;
      if (
        ((H.isWebGL3DRenderTarget || H.isWebGLArrayRenderTarget) &&
          (s
            ? (Re = H.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY)
            : console.error(
                "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
              )),
        n.bindTexture(Re, ge.__webglTexture),
        X(Re, z, Me),
        s && z.mipmaps && z.mipmaps.length > 0)
      )
        for (let Le = 0; Le < z.mipmaps.length; Le++)
          ae(Z.__webglFramebuffer[Le], H, z, t.COLOR_ATTACHMENT0, Re, Le);
      else ae(Z.__webglFramebuffer, H, z, t.COLOR_ATTACHMENT0, Re, 0);
      _(z, Me) && y(Re), n.unbindTexture();
    }
    H.depthBuffer && me(H);
  }
  function ve(H) {
    const z = x(H) || s,
      Z = H.isWebGLMultipleRenderTargets === !0 ? H.texture : [H.texture];
    for (let ge = 0, ce = Z.length; ge < ce; ge++) {
      const he = Z[ge];
      if (_(he, z)) {
        const Me = H.isWebGLCubeRenderTarget
            ? t.TEXTURE_CUBE_MAP
            : t.TEXTURE_2D,
          Re = r.get(he).__webglTexture;
        n.bindTexture(Me, Re), y(Me), n.unbindTexture();
      }
    }
  }
  function de(H) {
    if (s && H.samples > 0 && fe(H) === !1) {
      const z = H.isWebGLMultipleRenderTargets ? H.texture : [H.texture],
        Z = H.width,
        ge = H.height;
      let ce = t.COLOR_BUFFER_BIT;
      const he = [],
        Me = H.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
        Re = r.get(H),
        Le = H.isWebGLMultipleRenderTargets === !0;
      if (Le)
        for (let Oe = 0; Oe < z.length; Oe++)
          n.bindFramebuffer(t.FRAMEBUFFER, Re.__webglMultisampledFramebuffer),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + Oe,
              t.RENDERBUFFER,
              null
            ),
            n.bindFramebuffer(t.FRAMEBUFFER, Re.__webglFramebuffer),
            t.framebufferTexture2D(
              t.DRAW_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + Oe,
              t.TEXTURE_2D,
              null,
              0
            );
      n.bindFramebuffer(t.READ_FRAMEBUFFER, Re.__webglMultisampledFramebuffer),
        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Re.__webglFramebuffer);
      for (let Oe = 0; Oe < z.length; Oe++) {
        he.push(t.COLOR_ATTACHMENT0 + Oe), H.depthBuffer && he.push(Me);
        const Pe =
          Re.__ignoreDepthValues !== void 0 ? Re.__ignoreDepthValues : !1;
        if (
          (Pe === !1 &&
            (H.depthBuffer && (ce |= t.DEPTH_BUFFER_BIT),
            H.stencilBuffer && (ce |= t.STENCIL_BUFFER_BIT)),
          Le &&
            t.framebufferRenderbuffer(
              t.READ_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0,
              t.RENDERBUFFER,
              Re.__webglColorRenderbuffer[Oe]
            ),
          Pe === !0 &&
            (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [Me]),
            t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [Me])),
          Le)
        ) {
          const Se = r.get(z[Oe]).__webglTexture;
          t.framebufferTexture2D(
            t.DRAW_FRAMEBUFFER,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_2D,
            Se,
            0
          );
        }
        t.blitFramebuffer(0, 0, Z, ge, 0, 0, Z, ge, ce, t.NEAREST),
          c && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, he);
      }
      if (
        (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
        Le)
      )
        for (let Oe = 0; Oe < z.length; Oe++) {
          n.bindFramebuffer(t.FRAMEBUFFER, Re.__webglMultisampledFramebuffer),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + Oe,
              t.RENDERBUFFER,
              Re.__webglColorRenderbuffer[Oe]
            );
          const Pe = r.get(z[Oe]).__webglTexture;
          n.bindFramebuffer(t.FRAMEBUFFER, Re.__webglFramebuffer),
            t.framebufferTexture2D(
              t.DRAW_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + Oe,
              t.TEXTURE_2D,
              Pe,
              0
            );
        }
      n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Re.__webglMultisampledFramebuffer);
    }
  }
  function ue(H) {
    return Math.min(i.maxSamples, H.samples);
  }
  function fe(H) {
    const z = r.get(H);
    return (
      s &&
      H.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      z.__useRenderToTexture !== !1
    );
  }
  function Te(H) {
    const z = a.render.frame;
    u.get(H) !== z && (u.set(H, z), H.update());
  }
  function pe(H, z) {
    const Z = H.colorSpace,
      ge = H.format,
      ce = H.type;
    return (
      H.isCompressedTexture === !0 ||
        H.isVideoTexture === !0 ||
        H.format === uy ||
        (Z !== rs &&
          Z !== _o &&
          (Mn.getTransfer(Z) === Un
            ? s === !1
              ? e.has("EXT_sRGB") === !0 && ge === Ii
                ? ((H.format = uy),
                  (H.minFilter = Yn),
                  (H.generateMipmaps = !1))
                : (z = iC.sRGBToLinear(z))
              : (ge !== Ii || ce !== es) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                Z
              ))),
      z
    );
  }
  (this.allocateTextureUnit = N),
    (this.resetTextureUnits = j),
    (this.setTexture2D = W),
    (this.setTexture2DArray = Q),
    (this.setTexture3D = B),
    (this.setTextureCube = $),
    (this.rebindTextures = se),
    (this.setupRenderTarget = Y),
    (this.updateRenderTargetMipmap = ve),
    (this.updateMultisampleRenderTarget = de),
    (this.setupDepthRenderbuffer = me),
    (this.setupFrameBufferTexture = ae),
    (this.useMultisampledRTT = fe);
}
function iD(t, e, n) {
  const r = n.isWebGL2;
  function i(o, a = _o) {
    let s;
    const l = Mn.getTransfer(a);
    if (o === es) return t.UNSIGNED_BYTE;
    if (o === XM) return t.UNSIGNED_SHORT_4_4_4_4;
    if (o === qM) return t.UNSIGNED_SHORT_5_5_5_1;
    if (o === EF) return t.BYTE;
    if (o === MF) return t.SHORT;
    if (o === Jy) return t.UNSIGNED_SHORT;
    if (o === WM) return t.INT;
    if (o === Ls) return t.UNSIGNED_INT;
    if (o === wa) return t.FLOAT;
    if (o === df)
      return r
        ? t.HALF_FLOAT
        : ((s = e.get("OES_texture_half_float")),
          s !== null ? s.HALF_FLOAT_OES : null);
    if (o === CF) return t.ALPHA;
    if (o === Ii) return t.RGBA;
    if (o === TF) return t.LUMINANCE;
    if (o === AF) return t.LUMINANCE_ALPHA;
    if (o === Fl) return t.DEPTH_COMPONENT;
    if (o === cu) return t.DEPTH_STENCIL;
    if (o === uy)
      return (s = e.get("EXT_sRGB")), s !== null ? s.SRGB_ALPHA_EXT : null;
    if (o === RF) return t.RED;
    if (o === KM) return t.RED_INTEGER;
    if (o === PF) return t.RG;
    if (o === YM) return t.RG_INTEGER;
    if (o === ZM) return t.RGBA_INTEGER;
    if (o === g0 || o === v0 || o === y0 || o === x0)
      if (l === Un)
        if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), s !== null)) {
          if (o === g0) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (o === v0) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (o === y0) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (o === x0) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((s = e.get("WEBGL_compressed_texture_s3tc")), s !== null)) {
        if (o === g0) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (o === v0) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (o === y0) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (o === x0) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (o === iw || o === ow || o === aw || o === sw)
      if (((s = e.get("WEBGL_compressed_texture_pvrtc")), s !== null)) {
        if (o === iw) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (o === ow) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (o === aw) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (o === sw) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (o === QM)
      return (
        (s = e.get("WEBGL_compressed_texture_etc1")),
        s !== null ? s.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (o === lw || o === cw)
      if (((s = e.get("WEBGL_compressed_texture_etc")), s !== null)) {
        if (o === lw)
          return l === Un ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (o === cw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : s.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      o === uw ||
      o === dw ||
      o === fw ||
      o === hw ||
      o === pw ||
      o === mw ||
      o === gw ||
      o === vw ||
      o === yw ||
      o === xw ||
      o === Sw ||
      o === _w ||
      o === bw ||
      o === ww
    )
      if (((s = e.get("WEBGL_compressed_texture_astc")), s !== null)) {
        if (o === uw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (o === dw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (o === fw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (o === hw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (o === pw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (o === mw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (o === gw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (o === vw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (o === yw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (o === xw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (o === Sw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (o === _w)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (o === bw)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (o === ww)
          return l === Un
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (o === S0 || o === Ew || o === Mw)
      if (((s = e.get("EXT_texture_compression_bptc")), s !== null)) {
        if (o === S0)
          return l === Un
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (o === Ew) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (o === Mw) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (o === IF || o === Cw || o === Tw || o === Aw)
      if (((s = e.get("EXT_texture_compression_rgtc")), s !== null)) {
        if (o === S0) return s.COMPRESSED_RED_RGTC1_EXT;
        if (o === Cw) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (o === Tw) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (o === Aw) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return o === Nl
      ? r
        ? t.UNSIGNED_INT_24_8
        : ((s = e.get("WEBGL_depth_texture")),
          s !== null ? s.UNSIGNED_INT_24_8_WEBGL : null)
      : t[o] !== void 0
      ? t[o]
      : null;
  }
  return { convert: i };
}
class oD extends Zn {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
let Hd = class extends Sn {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
};
const kG = { type: "move" };
class XS {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Hd()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Hd()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new K()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new K())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Hd()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new K()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new K())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const n = this._hand;
      if (n) for (const r of e.hand.values()) this._getHandJoint(n, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, n, r) {
    let i = null,
      o = null,
      a = null;
    const s = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && n.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        a = !0;
        for (const S of e.hand.values()) {
          const x = n.getJointPose(S, r),
            g = this._getHandJoint(c, S);
          x !== null &&
            (g.matrix.fromArray(x.transform.matrix),
            g.matrix.decompose(g.position, g.rotation, g.scale),
            (g.matrixWorldNeedsUpdate = !0),
            (g.jointRadius = x.radius)),
            (g.visible = x !== null);
        }
        const u = c.joints["index-finger-tip"],
          d = c.joints["thumb-tip"],
          p = u.position.distanceTo(d.position),
          m = 0.02,
          v = 0.005;
        c.inputState.pinching && p > m + v
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            p <= m - v &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((o = n.getPose(e.gripSpace, r)),
          o !== null &&
            (l.matrix.fromArray(o.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            o.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(o.linearVelocity))
              : (l.hasLinearVelocity = !1),
            o.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(o.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      s !== null &&
        ((i = n.getPose(e.targetRaySpace, r)),
        i === null && o !== null && (i = o),
        i !== null &&
          (s.matrix.fromArray(i.transform.matrix),
          s.matrix.decompose(s.position, s.rotation, s.scale),
          (s.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((s.hasLinearVelocity = !0),
              s.linearVelocity.copy(i.linearVelocity))
            : (s.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((s.hasAngularVelocity = !0),
              s.angularVelocity.copy(i.angularVelocity))
            : (s.hasAngularVelocity = !1),
          this.dispatchEvent(kG)));
    }
    return (
      s !== null && (s.visible = i !== null),
      l !== null && (l.visible = o !== null),
      c !== null && (c.visible = a !== null),
      this
    );
  }
  _getHandJoint(e, n) {
    if (e.joints[n.jointName] === void 0) {
      const r = new Hd();
      (r.matrixAutoUpdate = !1),
        (r.visible = !1),
        (e.joints[n.jointName] = r),
        e.add(r);
    }
    return e.joints[n.jointName];
  }
}
class BG extends qs {
  constructor(e, n) {
    super();
    const r = this;
    let i = null,
      o = 1,
      a = null,
      s = "local-floor",
      l = 1,
      c = null,
      u = null,
      d = null,
      p = null,
      m = null,
      v = null;
    const S = n.getContextAttributes();
    let x = null,
      g = null;
    const _ = [],
      y = [],
      w = new Ge();
    let A = null;
    const M = new Zn();
    M.layers.enable(1), (M.viewport = new rn());
    const T = new Zn();
    T.layers.enable(2), (T.viewport = new rn());
    const I = [M, T],
      R = new oD();
    R.layers.enable(1), R.layers.enable(2);
    let P = null,
      F = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (X) {
        let ee = _[X];
        return (
          ee === void 0 && ((ee = new XS()), (_[X] = ee)),
          ee.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (X) {
        let ee = _[X];
        return (
          ee === void 0 && ((ee = new XS()), (_[X] = ee)), ee.getGripSpace()
        );
      }),
      (this.getHand = function (X) {
        let ee = _[X];
        return (
          ee === void 0 && ((ee = new XS()), (_[X] = ee)), ee.getHandSpace()
        );
      });
    function D(X) {
      const ee = y.indexOf(X.inputSource);
      if (ee === -1) return;
      const J = _[ee];
      J !== void 0 &&
        (J.update(X.inputSource, X.frame, c || a),
        J.dispatchEvent({ type: X.type, data: X.inputSource }));
    }
    function j() {
      i.removeEventListener("select", D),
        i.removeEventListener("selectstart", D),
        i.removeEventListener("selectend", D),
        i.removeEventListener("squeeze", D),
        i.removeEventListener("squeezestart", D),
        i.removeEventListener("squeezeend", D),
        i.removeEventListener("end", j),
        i.removeEventListener("inputsourceschange", N);
      for (let X = 0; X < _.length; X++) {
        const ee = y[X];
        ee !== null && ((y[X] = null), _[X].disconnect(ee));
      }
      (P = null),
        (F = null),
        e.setRenderTarget(x),
        (m = null),
        (p = null),
        (d = null),
        (i = null),
        (g = null),
        q.stop(),
        (r.isPresenting = !1),
        e.setPixelRatio(A),
        e.setSize(w.width, w.height, !1),
        r.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (X) {
      (o = X),
        r.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (X) {
        (s = X),
          r.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || a;
      }),
      (this.setReferenceSpace = function (X) {
        c = X;
      }),
      (this.getBaseLayer = function () {
        return p !== null ? p : m;
      }),
      (this.getBinding = function () {
        return d;
      }),
      (this.getFrame = function () {
        return v;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (X) {
        if (((i = X), i !== null)) {
          if (
            ((x = e.getRenderTarget()),
            i.addEventListener("select", D),
            i.addEventListener("selectstart", D),
            i.addEventListener("selectend", D),
            i.addEventListener("squeeze", D),
            i.addEventListener("squeezestart", D),
            i.addEventListener("squeezeend", D),
            i.addEventListener("end", j),
            i.addEventListener("inputsourceschange", N),
            S.xrCompatible !== !0 && (await n.makeXRCompatible()),
            (A = e.getPixelRatio()),
            e.getSize(w),
            i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const ee = {
              antialias: i.renderState.layers === void 0 ? S.antialias : !0,
              alpha: !0,
              depth: S.depth,
              stencil: S.stencil,
              framebufferScaleFactor: o,
            };
            (m = new XRWebGLLayer(i, n, ee)),
              i.updateRenderState({ baseLayer: m }),
              e.setPixelRatio(1),
              e.setSize(m.framebufferWidth, m.framebufferHeight, !1),
              (g = new Pa(m.framebufferWidth, m.framebufferHeight, {
                format: Ii,
                type: es,
                colorSpace: e.outputColorSpace,
                stencilBuffer: S.stencil,
              }));
          } else {
            let ee = null,
              J = null,
              oe = null;
            S.depth &&
              ((oe = S.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24),
              (ee = S.stencil ? cu : Fl),
              (J = S.stencil ? Nl : Ls));
            const ae = {
              colorFormat: n.RGBA8,
              depthFormat: oe,
              scaleFactor: o,
            };
            (d = new XRWebGLBinding(i, n)),
              (p = d.createProjectionLayer(ae)),
              i.updateRenderState({ layers: [p] }),
              e.setPixelRatio(1),
              e.setSize(p.textureWidth, p.textureHeight, !1),
              (g = new Pa(p.textureWidth, p.textureHeight, {
                format: Ii,
                type: es,
                depthTexture: new cC(
                  p.textureWidth,
                  p.textureHeight,
                  J,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  ee
                ),
                stencilBuffer: S.stencil,
                colorSpace: e.outputColorSpace,
                samples: S.antialias ? 4 : 0,
              }));
            const le = e.properties.get(g);
            le.__ignoreDepthValues = p.ignoreDepthValues;
          }
          (g.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (a = await i.requestReferenceSpace(s)),
            q.setContext(i),
            q.start(),
            (r.isPresenting = !0),
            r.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      });
    function N(X) {
      for (let ee = 0; ee < X.removed.length; ee++) {
        const J = X.removed[ee],
          oe = y.indexOf(J);
        oe >= 0 && ((y[oe] = null), _[oe].disconnect(J));
      }
      for (let ee = 0; ee < X.added.length; ee++) {
        const J = X.added[ee];
        let oe = y.indexOf(J);
        if (oe === -1) {
          for (let le = 0; le < _.length; le++)
            if (le >= y.length) {
              y.push(J), (oe = le);
              break;
            } else if (y[le] === null) {
              (y[le] = J), (oe = le);
              break;
            }
          if (oe === -1) break;
        }
        const ae = _[oe];
        ae && ae.connect(J);
      }
    }
    const V = new K(),
      W = new K();
    function Q(X, ee, J) {
      V.setFromMatrixPosition(ee.matrixWorld),
        W.setFromMatrixPosition(J.matrixWorld);
      const oe = V.distanceTo(W),
        ae = ee.projectionMatrix.elements,
        le = J.projectionMatrix.elements,
        _e = ae[14] / (ae[10] - 1),
        me = ae[14] / (ae[10] + 1),
        se = (ae[9] + 1) / ae[5],
        Y = (ae[9] - 1) / ae[5],
        ve = (ae[8] - 1) / ae[0],
        de = (le[8] + 1) / le[0],
        ue = _e * ve,
        fe = _e * de,
        Te = oe / (-ve + de),
        pe = Te * -ve;
      ee.matrixWorld.decompose(X.position, X.quaternion, X.scale),
        X.translateX(pe),
        X.translateZ(Te),
        X.matrixWorld.compose(X.position, X.quaternion, X.scale),
        X.matrixWorldInverse.copy(X.matrixWorld).invert();
      const H = _e + Te,
        z = me + Te,
        Z = ue - pe,
        ge = fe + (oe - pe),
        ce = ((se * me) / z) * H,
        he = ((Y * me) / z) * H;
      X.projectionMatrix.makePerspective(Z, ge, ce, he, H, z),
        X.projectionMatrixInverse.copy(X.projectionMatrix).invert();
    }
    function B(X, ee) {
      ee === null
        ? X.matrixWorld.copy(X.matrix)
        : X.matrixWorld.multiplyMatrices(ee.matrixWorld, X.matrix),
        X.matrixWorldInverse.copy(X.matrixWorld).invert();
    }
    this.updateCamera = function (X) {
      if (i === null) return;
      (R.near = T.near = M.near = X.near),
        (R.far = T.far = M.far = X.far),
        (P !== R.near || F !== R.far) &&
          (i.updateRenderState({ depthNear: R.near, depthFar: R.far }),
          (P = R.near),
          (F = R.far));
      const ee = X.parent,
        J = R.cameras;
      B(R, ee);
      for (let oe = 0; oe < J.length; oe++) B(J[oe], ee);
      J.length === 2 ? Q(R, M, T) : R.projectionMatrix.copy(M.projectionMatrix),
        $(X, R, ee);
    };
    function $(X, ee, J) {
      J === null
        ? X.matrix.copy(ee.matrixWorld)
        : (X.matrix.copy(J.matrixWorld),
          X.matrix.invert(),
          X.matrix.multiply(ee.matrixWorld)),
        X.matrix.decompose(X.position, X.quaternion, X.scale),
        X.updateMatrixWorld(!0),
        X.projectionMatrix.copy(ee.projectionMatrix),
        X.projectionMatrixInverse.copy(ee.projectionMatrixInverse),
        X.isPerspectiveCamera &&
          ((X.fov = hf * 2 * Math.atan(1 / X.projectionMatrix.elements[5])),
          (X.zoom = 1));
    }
    (this.getCamera = function () {
      return R;
    }),
      (this.getFoveation = function () {
        if (!(p === null && m === null)) return l;
      }),
      (this.setFoveation = function (X) {
        (l = X),
          p !== null && (p.fixedFoveation = X),
          m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = X);
      });
    let G = null;
    function k(X, ee) {
      if (((u = ee.getViewerPose(c || a)), (v = ee), u !== null)) {
        const J = u.views;
        m !== null &&
          (e.setRenderTargetFramebuffer(g, m.framebuffer),
          e.setRenderTarget(g));
        let oe = !1;
        J.length !== R.cameras.length && ((R.cameras.length = 0), (oe = !0));
        for (let ae = 0; ae < J.length; ae++) {
          const le = J[ae];
          let _e = null;
          if (m !== null) _e = m.getViewport(le);
          else {
            const se = d.getViewSubImage(p, le);
            (_e = se.viewport),
              ae === 0 &&
                (e.setRenderTargetTextures(
                  g,
                  se.colorTexture,
                  p.ignoreDepthValues ? void 0 : se.depthStencilTexture
                ),
                e.setRenderTarget(g));
          }
          let me = I[ae];
          me === void 0 &&
            ((me = new Zn()),
            me.layers.enable(ae),
            (me.viewport = new rn()),
            (I[ae] = me)),
            me.matrix.fromArray(le.transform.matrix),
            me.matrix.decompose(me.position, me.quaternion, me.scale),
            me.projectionMatrix.fromArray(le.projectionMatrix),
            me.projectionMatrixInverse.copy(me.projectionMatrix).invert(),
            me.viewport.set(_e.x, _e.y, _e.width, _e.height),
            ae === 0 &&
              (R.matrix.copy(me.matrix),
              R.matrix.decompose(R.position, R.quaternion, R.scale)),
            oe === !0 && R.cameras.push(me);
        }
      }
      for (let J = 0; J < _.length; J++) {
        const oe = y[J],
          ae = _[J];
        oe !== null && ae !== void 0 && ae.update(oe, ee, c || a);
      }
      G && G(X, ee),
        ee.detectedPlanes &&
          r.dispatchEvent({ type: "planesdetected", data: ee }),
        (v = null);
    }
    const q = new QF();
    q.setAnimationLoop(k),
      (this.setAnimationLoop = function (X) {
        G = X;
      }),
      (this.dispose = function () {});
  }
}
function HG(t, e) {
  function n(x, g) {
    x.matrixAutoUpdate === !0 && x.updateMatrix(), g.value.copy(x.matrix);
  }
  function r(x, g) {
    g.color.getRGB(x.fogColor.value, KF(t)),
      g.isFog
        ? ((x.fogNear.value = g.near), (x.fogFar.value = g.far))
        : g.isFogExp2 && (x.fogDensity.value = g.density);
  }
  function i(x, g, _, y, w) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial
      ? o(x, g)
      : g.isMeshToonMaterial
      ? (o(x, g), d(x, g))
      : g.isMeshPhongMaterial
      ? (o(x, g), u(x, g))
      : g.isMeshStandardMaterial
      ? (o(x, g), p(x, g), g.isMeshPhysicalMaterial && m(x, g, w))
      : g.isMeshMatcapMaterial
      ? (o(x, g), v(x, g))
      : g.isMeshDepthMaterial
      ? o(x, g)
      : g.isMeshDistanceMaterial
      ? (o(x, g), S(x, g))
      : g.isMeshNormalMaterial
      ? o(x, g)
      : g.isLineBasicMaterial
      ? (a(x, g), g.isLineDashedMaterial && s(x, g))
      : g.isPointsMaterial
      ? l(x, g, _, y)
      : g.isSpriteMaterial
      ? c(x, g)
      : g.isShadowMaterial
      ? (x.color.value.copy(g.color), (x.opacity.value = g.opacity))
      : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function o(x, g) {
    (x.opacity.value = g.opacity),
      g.color && x.diffuse.value.copy(g.color),
      g.emissive &&
        x.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
      g.map && ((x.map.value = g.map), n(g.map, x.mapTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), n(g.alphaMap, x.alphaMapTransform)),
      g.bumpMap &&
        ((x.bumpMap.value = g.bumpMap),
        n(g.bumpMap, x.bumpMapTransform),
        (x.bumpScale.value = g.bumpScale),
        g.side === Oi && (x.bumpScale.value *= -1)),
      g.normalMap &&
        ((x.normalMap.value = g.normalMap),
        n(g.normalMap, x.normalMapTransform),
        x.normalScale.value.copy(g.normalScale),
        g.side === Oi && x.normalScale.value.negate()),
      g.displacementMap &&
        ((x.displacementMap.value = g.displacementMap),
        n(g.displacementMap, x.displacementMapTransform),
        (x.displacementScale.value = g.displacementScale),
        (x.displacementBias.value = g.displacementBias)),
      g.emissiveMap &&
        ((x.emissiveMap.value = g.emissiveMap),
        n(g.emissiveMap, x.emissiveMapTransform)),
      g.specularMap &&
        ((x.specularMap.value = g.specularMap),
        n(g.specularMap, x.specularMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
    const _ = e.get(g).envMap;
    if (
      (_ &&
        ((x.envMap.value = _),
        (x.flipEnvMap.value =
          _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
        (x.reflectivity.value = g.reflectivity),
        (x.ior.value = g.ior),
        (x.refractionRatio.value = g.refractionRatio)),
      g.lightMap)
    ) {
      x.lightMap.value = g.lightMap;
      const y = t._useLegacyLights === !0 ? Math.PI : 1;
      (x.lightMapIntensity.value = g.lightMapIntensity * y),
        n(g.lightMap, x.lightMapTransform);
    }
    g.aoMap &&
      ((x.aoMap.value = g.aoMap),
      (x.aoMapIntensity.value = g.aoMapIntensity),
      n(g.aoMap, x.aoMapTransform));
  }
  function a(x, g) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      g.map && ((x.map.value = g.map), n(g.map, x.mapTransform));
  }
  function s(x, g) {
    (x.dashSize.value = g.dashSize),
      (x.totalSize.value = g.dashSize + g.gapSize),
      (x.scale.value = g.scale);
  }
  function l(x, g, _, y) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      (x.size.value = g.size * _),
      (x.scale.value = y * 0.5),
      g.map && ((x.map.value = g.map), n(g.map, x.uvTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), n(g.alphaMap, x.alphaMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
  }
  function c(x, g) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      (x.rotation.value = g.rotation),
      g.map && ((x.map.value = g.map), n(g.map, x.mapTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), n(g.alphaMap, x.alphaMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
  }
  function u(x, g) {
    x.specular.value.copy(g.specular),
      (x.shininess.value = Math.max(g.shininess, 1e-4));
  }
  function d(x, g) {
    g.gradientMap && (x.gradientMap.value = g.gradientMap);
  }
  function p(x, g) {
    (x.metalness.value = g.metalness),
      g.metalnessMap &&
        ((x.metalnessMap.value = g.metalnessMap),
        n(g.metalnessMap, x.metalnessMapTransform)),
      (x.roughness.value = g.roughness),
      g.roughnessMap &&
        ((x.roughnessMap.value = g.roughnessMap),
        n(g.roughnessMap, x.roughnessMapTransform)),
      e.get(g).envMap && (x.envMapIntensity.value = g.envMapIntensity);
  }
  function m(x, g, _) {
    (x.ior.value = g.ior),
      g.sheen > 0 &&
        (x.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        (x.sheenRoughness.value = g.sheenRoughness),
        g.sheenColorMap &&
          ((x.sheenColorMap.value = g.sheenColorMap),
          n(g.sheenColorMap, x.sheenColorMapTransform)),
        g.sheenRoughnessMap &&
          ((x.sheenRoughnessMap.value = g.sheenRoughnessMap),
          n(g.sheenRoughnessMap, x.sheenRoughnessMapTransform))),
      g.clearcoat > 0 &&
        ((x.clearcoat.value = g.clearcoat),
        (x.clearcoatRoughness.value = g.clearcoatRoughness),
        g.clearcoatMap &&
          ((x.clearcoatMap.value = g.clearcoatMap),
          n(g.clearcoatMap, x.clearcoatMapTransform)),
        g.clearcoatRoughnessMap &&
          ((x.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
          n(g.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)),
        g.clearcoatNormalMap &&
          ((x.clearcoatNormalMap.value = g.clearcoatNormalMap),
          n(g.clearcoatNormalMap, x.clearcoatNormalMapTransform),
          x.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
          g.side === Oi && x.clearcoatNormalScale.value.negate())),
      g.iridescence > 0 &&
        ((x.iridescence.value = g.iridescence),
        (x.iridescenceIOR.value = g.iridescenceIOR),
        (x.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0]),
        (x.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1]),
        g.iridescenceMap &&
          ((x.iridescenceMap.value = g.iridescenceMap),
          n(g.iridescenceMap, x.iridescenceMapTransform)),
        g.iridescenceThicknessMap &&
          ((x.iridescenceThicknessMap.value = g.iridescenceThicknessMap),
          n(g.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))),
      g.transmission > 0 &&
        ((x.transmission.value = g.transmission),
        (x.transmissionSamplerMap.value = _.texture),
        x.transmissionSamplerSize.value.set(_.width, _.height),
        g.transmissionMap &&
          ((x.transmissionMap.value = g.transmissionMap),
          n(g.transmissionMap, x.transmissionMapTransform)),
        (x.thickness.value = g.thickness),
        g.thicknessMap &&
          ((x.thicknessMap.value = g.thicknessMap),
          n(g.thicknessMap, x.thicknessMapTransform)),
        (x.attenuationDistance.value = g.attenuationDistance),
        x.attenuationColor.value.copy(g.attenuationColor)),
      g.anisotropy > 0 &&
        (x.anisotropyVector.value.set(
          g.anisotropy * Math.cos(g.anisotropyRotation),
          g.anisotropy * Math.sin(g.anisotropyRotation)
        ),
        g.anisotropyMap &&
          ((x.anisotropyMap.value = g.anisotropyMap),
          n(g.anisotropyMap, x.anisotropyMapTransform))),
      (x.specularIntensity.value = g.specularIntensity),
      x.specularColor.value.copy(g.specularColor),
      g.specularColorMap &&
        ((x.specularColorMap.value = g.specularColorMap),
        n(g.specularColorMap, x.specularColorMapTransform)),
      g.specularIntensityMap &&
        ((x.specularIntensityMap.value = g.specularIntensityMap),
        n(g.specularIntensityMap, x.specularIntensityMapTransform));
  }
  function v(x, g) {
    g.matcap && (x.matcap.value = g.matcap);
  }
  function S(x, g) {
    const _ = e.get(g).light;
    x.referencePosition.value.setFromMatrixPosition(_.matrixWorld),
      (x.nearDistance.value = _.shadow.camera.near),
      (x.farDistance.value = _.shadow.camera.far);
  }
  return { refreshFogUniforms: r, refreshMaterialUniforms: i };
}
function jG(t, e, n, r) {
  let i = {},
    o = {},
    a = [];
  const s = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(_, y) {
    const w = y.program;
    r.uniformBlockBinding(_, w);
  }
  function c(_, y) {
    let w = i[_.id];
    w === void 0 &&
      (v(_), (w = u(_)), (i[_.id] = w), _.addEventListener("dispose", x));
    const A = y.program;
    r.updateUBOMapping(_, A);
    const M = e.render.frame;
    o[_.id] !== M && (p(_), (o[_.id] = M));
  }
  function u(_) {
    const y = d();
    _.__bindingPointIndex = y;
    const w = t.createBuffer(),
      A = _.__size,
      M = _.usage;
    return (
      t.bindBuffer(t.UNIFORM_BUFFER, w),
      t.bufferData(t.UNIFORM_BUFFER, A, M),
      t.bindBuffer(t.UNIFORM_BUFFER, null),
      t.bindBufferBase(t.UNIFORM_BUFFER, y, w),
      w
    );
  }
  function d() {
    for (let _ = 0; _ < s; _++) if (a.indexOf(_) === -1) return a.push(_), _;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function p(_) {
    const y = i[_.id],
      w = _.uniforms,
      A = _.__cache;
    t.bindBuffer(t.UNIFORM_BUFFER, y);
    for (let M = 0, T = w.length; M < T; M++) {
      const I = Array.isArray(w[M]) ? w[M] : [w[M]];
      for (let R = 0, P = I.length; R < P; R++) {
        const F = I[R];
        if (m(F, M, R, A) === !0) {
          const D = F.__offset,
            j = Array.isArray(F.value) ? F.value : [F.value];
          let N = 0;
          for (let V = 0; V < j.length; V++) {
            const W = j[V],
              Q = S(W);
            typeof W == "number" || typeof W == "boolean"
              ? ((F.__data[0] = W),
                t.bufferSubData(t.UNIFORM_BUFFER, D + N, F.__data))
              : W.isMatrix3
              ? ((F.__data[0] = W.elements[0]),
                (F.__data[1] = W.elements[1]),
                (F.__data[2] = W.elements[2]),
                (F.__data[3] = 0),
                (F.__data[4] = W.elements[3]),
                (F.__data[5] = W.elements[4]),
                (F.__data[6] = W.elements[5]),
                (F.__data[7] = 0),
                (F.__data[8] = W.elements[6]),
                (F.__data[9] = W.elements[7]),
                (F.__data[10] = W.elements[8]),
                (F.__data[11] = 0))
              : (W.toArray(F.__data, N),
                (N += Q.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          t.bufferSubData(t.UNIFORM_BUFFER, D, F.__data);
        }
      }
    }
    t.bindBuffer(t.UNIFORM_BUFFER, null);
  }
  function m(_, y, w, A) {
    const M = _.value,
      T = y + "_" + w;
    if (A[T] === void 0)
      return (
        typeof M == "number" || typeof M == "boolean"
          ? (A[T] = M)
          : (A[T] = M.clone()),
        !0
      );
    {
      const I = A[T];
      if (typeof M == "number" || typeof M == "boolean") {
        if (I !== M) return (A[T] = M), !0;
      } else if (I.equals(M) === !1) return I.copy(M), !0;
    }
    return !1;
  }
  function v(_) {
    const y = _.uniforms;
    let w = 0;
    const A = 16;
    for (let T = 0, I = y.length; T < I; T++) {
      const R = Array.isArray(y[T]) ? y[T] : [y[T]];
      for (let P = 0, F = R.length; P < F; P++) {
        const D = R[P],
          j = Array.isArray(D.value) ? D.value : [D.value];
        for (let N = 0, V = j.length; N < V; N++) {
          const W = j[N],
            Q = S(W),
            B = w % A;
          B !== 0 && A - B < Q.boundary && (w += A - B),
            (D.__data = new Float32Array(
              Q.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (D.__offset = w),
            (w += Q.storage);
        }
      }
    }
    const M = w % A;
    return M > 0 && (w += A - M), (_.__size = w), (_.__cache = {}), this;
  }
  function S(_) {
    const y = { boundary: 0, storage: 0 };
    return (
      typeof _ == "number" || typeof _ == "boolean"
        ? ((y.boundary = 4), (y.storage = 4))
        : _.isVector2
        ? ((y.boundary = 8), (y.storage = 8))
        : _.isVector3 || _.isColor
        ? ((y.boundary = 16), (y.storage = 12))
        : _.isVector4
        ? ((y.boundary = 16), (y.storage = 16))
        : _.isMatrix3
        ? ((y.boundary = 48), (y.storage = 48))
        : _.isMatrix4
        ? ((y.boundary = 64), (y.storage = 64))
        : _.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            _
          ),
      y
    );
  }
  function x(_) {
    const y = _.target;
    y.removeEventListener("dispose", x);
    const w = a.indexOf(y.__bindingPointIndex);
    a.splice(w, 1), t.deleteBuffer(i[y.id]), delete i[y.id], delete o[y.id];
  }
  function g() {
    for (const _ in i) t.deleteBuffer(i[_]);
    (a = []), (i = {}), (o = {});
  }
  return { bind: l, update: c, dispose: g };
}
class uC {
  constructor(e = {}) {
    const {
      canvas: n = WF(),
      context: r = null,
      depth: i = !0,
      stencil: o = !0,
      alpha: a = !1,
      antialias: s = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    r !== null ? (p = r.getContextAttributes().alpha) : (p = a);
    const m = new Uint32Array(4),
      v = new Int32Array(4);
    let S = null,
      x = null;
    const g = [],
      _ = [];
    (this.domElement = n),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Tr),
      (this._useLegacyLights = !1),
      (this.toneMapping = Ja),
      (this.toneMappingExposure = 1);
    const y = this;
    let w = !1,
      A = 0,
      M = 0,
      T = null,
      I = -1,
      R = null;
    const P = new rn(),
      F = new rn();
    let D = null;
    const j = new pt(0);
    let N = 0,
      V = n.width,
      W = n.height,
      Q = 1,
      B = null,
      $ = null;
    const G = new rn(0, 0, V, W),
      k = new rn(0, 0, V, W);
    let q = !1;
    const X = new gm();
    let ee = !1,
      J = !1,
      oe = null;
    const ae = new kt(),
      le = new Ge(),
      _e = new K(),
      me = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function se() {
      return T === null ? Q : 1;
    }
    let Y = r;
    function ve(te, ye) {
      for (let Ae = 0; Ae < te.length; Ae++) {
        const ze = te[Ae],
          Ce = n.getContext(ze, ye);
        if (Ce !== null) return Ce;
      }
      return null;
    }
    try {
      const te = {
        alpha: !0,
        depth: i,
        stencil: o,
        antialias: s,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: d,
      };
      if (
        ("setAttribute" in n &&
          n.setAttribute("data-engine", `three.js r${um}`),
        n.addEventListener("webglcontextlost", Ee, !1),
        n.addEventListener("webglcontextrestored", ie, !1),
        n.addEventListener("webglcontextcreationerror", $e, !1),
        Y === null)
      ) {
        const ye = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (y.isWebGL1Renderer === !0 && ye.shift(),
          (Y = ve(ye, te)),
          Y === null)
        )
          throw ve(ye)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" &&
        Y instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        Y.getShaderPrecisionFormat === void 0 &&
          (Y.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (te) {
      throw (console.error("THREE.WebGLRenderer: " + te.message), te);
    }
    let de,
      ue,
      fe,
      Te,
      pe,
      H,
      z,
      Z,
      ge,
      ce,
      he,
      Me,
      Re,
      Le,
      Oe,
      Pe,
      Se,
      Je,
      st,
      Qe,
      Ke,
      Ne,
      ne,
      Ie;
    function et() {
      (de = new n$(Y)),
        (ue = new YV(Y, de, e)),
        de.init(ue),
        (Ne = new iD(Y, de, ue)),
        (fe = new zG(Y, de, ue)),
        (Te = new o$(Y)),
        (pe = new MG()),
        (H = new UG(Y, de, fe, pe, ue, Ne, Te)),
        (z = new QV(y)),
        (Z = new t$(y)),
        (ge = new h8(Y, ue)),
        (ne = new qV(Y, de, ge, ue)),
        (ce = new r$(Y, ge, Te, ne)),
        (he = new c$(Y, ce, ge, Te)),
        (st = new l$(Y, ue, H)),
        (Pe = new ZV(pe)),
        (Me = new EG(y, z, Z, de, ue, ne, Pe)),
        (Re = new HG(y, pe)),
        (Le = new TG()),
        (Oe = new OG(de, ue)),
        (Je = new XV(y, z, Z, fe, he, p, l)),
        (Se = new DG(y, he, ue)),
        (Ie = new jG(Y, Te, ue, fe)),
        (Qe = new KV(Y, de, Te, ue)),
        (Ke = new i$(Y, de, Te, ue)),
        (Te.programs = Me.programs),
        (y.capabilities = ue),
        (y.extensions = de),
        (y.properties = pe),
        (y.renderLists = Le),
        (y.shadowMap = Se),
        (y.state = fe),
        (y.info = Te);
    }
    et();
    const We = new BG(y, Y);
    (this.xr = We),
      (this.getContext = function () {
        return Y;
      }),
      (this.getContextAttributes = function () {
        return Y.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const te = de.get("WEBGL_lose_context");
        te && te.loseContext();
      }),
      (this.forceContextRestore = function () {
        const te = de.get("WEBGL_lose_context");
        te && te.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return Q;
      }),
      (this.setPixelRatio = function (te) {
        te !== void 0 && ((Q = te), this.setSize(V, W, !1));
      }),
      (this.getSize = function (te) {
        return te.set(V, W);
      }),
      (this.setSize = function (te, ye, Ae = !0) {
        if (We.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (V = te),
          (W = ye),
          (n.width = Math.floor(te * Q)),
          (n.height = Math.floor(ye * Q)),
          Ae === !0 &&
            ((n.style.width = te + "px"), (n.style.height = ye + "px")),
          this.setViewport(0, 0, te, ye);
      }),
      (this.getDrawingBufferSize = function (te) {
        return te.set(V * Q, W * Q).floor();
      }),
      (this.setDrawingBufferSize = function (te, ye, Ae) {
        (V = te),
          (W = ye),
          (Q = Ae),
          (n.width = Math.floor(te * Ae)),
          (n.height = Math.floor(ye * Ae)),
          this.setViewport(0, 0, te, ye);
      }),
      (this.getCurrentViewport = function (te) {
        return te.copy(P);
      }),
      (this.getViewport = function (te) {
        return te.copy(G);
      }),
      (this.setViewport = function (te, ye, Ae, ze) {
        te.isVector4 ? G.set(te.x, te.y, te.z, te.w) : G.set(te, ye, Ae, ze),
          fe.viewport(P.copy(G).multiplyScalar(Q).floor());
      }),
      (this.getScissor = function (te) {
        return te.copy(k);
      }),
      (this.setScissor = function (te, ye, Ae, ze) {
        te.isVector4 ? k.set(te.x, te.y, te.z, te.w) : k.set(te, ye, Ae, ze),
          fe.scissor(F.copy(k).multiplyScalar(Q).floor());
      }),
      (this.getScissorTest = function () {
        return q;
      }),
      (this.setScissorTest = function (te) {
        fe.setScissorTest((q = te));
      }),
      (this.setOpaqueSort = function (te) {
        B = te;
      }),
      (this.setTransparentSort = function (te) {
        $ = te;
      }),
      (this.getClearColor = function (te) {
        return te.copy(Je.getClearColor());
      }),
      (this.setClearColor = function () {
        Je.setClearColor.apply(Je, arguments);
      }),
      (this.getClearAlpha = function () {
        return Je.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Je.setClearAlpha.apply(Je, arguments);
      }),
      (this.clear = function (te = !0, ye = !0, Ae = !0) {
        let ze = 0;
        if (te) {
          let Ce = !1;
          if (T !== null) {
            const ot = T.texture.format;
            Ce = ot === ZM || ot === YM || ot === KM;
          }
          if (Ce) {
            const ot = T.texture.type,
              ht =
                ot === es ||
                ot === Ls ||
                ot === Jy ||
                ot === Nl ||
                ot === XM ||
                ot === qM,
              xt = Je.getClearColor(),
              qe = Je.getClearAlpha(),
              bt = xt.r,
              Lt = xt.g,
              Mt = xt.b;
            ht
              ? ((m[0] = bt),
                (m[1] = Lt),
                (m[2] = Mt),
                (m[3] = qe),
                Y.clearBufferuiv(Y.COLOR, 0, m))
              : ((v[0] = bt),
                (v[1] = Lt),
                (v[2] = Mt),
                (v[3] = qe),
                Y.clearBufferiv(Y.COLOR, 0, v));
          } else ze |= Y.COLOR_BUFFER_BIT;
        }
        ye && (ze |= Y.DEPTH_BUFFER_BIT),
          Ae &&
            ((ze |= Y.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          Y.clear(ze);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        n.removeEventListener("webglcontextlost", Ee, !1),
          n.removeEventListener("webglcontextrestored", ie, !1),
          n.removeEventListener("webglcontextcreationerror", $e, !1),
          Le.dispose(),
          Oe.dispose(),
          pe.dispose(),
          z.dispose(),
          Z.dispose(),
          he.dispose(),
          ne.dispose(),
          Ie.dispose(),
          Me.dispose(),
          We.dispose(),
          We.removeEventListener("sessionstart", ut),
          We.removeEventListener("sessionend", dt),
          oe && (oe.dispose(), (oe = null)),
          Rt.stop();
      });
    function Ee(te) {
      te.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (w = !0);
    }
    function ie() {
      console.log("THREE.WebGLRenderer: Context Restored."), (w = !1);
      const te = Te.autoReset,
        ye = Se.enabled,
        Ae = Se.autoUpdate,
        ze = Se.needsUpdate,
        Ce = Se.type;
      et(),
        (Te.autoReset = te),
        (Se.enabled = ye),
        (Se.autoUpdate = Ae),
        (Se.needsUpdate = ze),
        (Se.type = Ce);
    }
    function $e(te) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        te.statusMessage
      );
    }
    function He(te) {
      const ye = te.target;
      ye.removeEventListener("dispose", He), Xe(ye);
    }
    function Xe(te) {
      Ue(te), pe.remove(te);
    }
    function Ue(te) {
      const ye = pe.get(te).programs;
      ye !== void 0 &&
        (ye.forEach(function (Ae) {
          Me.releaseProgram(Ae);
        }),
        te.isShaderMaterial && Me.releaseShaderCache(te));
    }
    this.renderBufferDirect = function (te, ye, Ae, ze, Ce, ot) {
      ye === null && (ye = me);
      const ht = Ce.isMesh && Ce.matrixWorld.determinant() < 0,
        xt = Dt(te, ye, Ae, ze, Ce);
      fe.setMaterial(ze, ht);
      let qe = Ae.index,
        bt = 1;
      if (ze.wireframe === !0) {
        if (((qe = ce.getWireframeAttribute(Ae)), qe === void 0)) return;
        bt = 2;
      }
      const Lt = Ae.drawRange,
        Mt = Ae.attributes.position;
      let qt = Lt.start * bt,
        On = (Lt.start + Lt.count) * bt;
      ot !== null &&
        ((qt = Math.max(qt, ot.start * bt)),
        (On = Math.min(On, (ot.start + ot.count) * bt))),
        qe !== null
          ? ((qt = Math.max(qt, 0)), (On = Math.min(On, qe.count)))
          : Mt != null &&
            ((qt = Math.max(qt, 0)), (On = Math.min(On, Mt.count)));
      const tn = On - qt;
      if (tn < 0 || tn === 1 / 0) return;
      ne.setup(Ce, ze, xt, Ae, qe);
      let cn,
        St = Qe;
      if (
        (qe !== null && ((cn = ge.get(qe)), (St = Ke), St.setIndex(cn)),
        Ce.isMesh)
      )
        ze.wireframe === !0
          ? (fe.setLineWidth(ze.wireframeLinewidth * se()), St.setMode(Y.LINES))
          : St.setMode(Y.TRIANGLES);
      else if (Ce.isLine) {
        let ct = ze.linewidth;
        ct === void 0 && (ct = 1),
          fe.setLineWidth(ct * se()),
          Ce.isLineSegments
            ? St.setMode(Y.LINES)
            : Ce.isLineLoop
            ? St.setMode(Y.LINE_LOOP)
            : St.setMode(Y.LINE_STRIP);
      } else
        Ce.isPoints
          ? St.setMode(Y.POINTS)
          : Ce.isSprite && St.setMode(Y.TRIANGLES);
      if (Ce.isBatchedMesh)
        St.renderMultiDraw(
          Ce._multiDrawStarts,
          Ce._multiDrawCounts,
          Ce._multiDrawCount
        );
      else if (Ce.isInstancedMesh) St.renderInstances(qt, tn, Ce.count);
      else if (Ae.isInstancedBufferGeometry) {
        const ct =
            Ae._maxInstanceCount !== void 0 ? Ae._maxInstanceCount : 1 / 0,
          zn = Math.min(Ae.instanceCount, ct);
        St.renderInstances(qt, tn, zn);
      } else St.render(qt, tn);
    };
    function Ye(te, ye, Ae) {
      te.transparent === !0 && te.side === Zo && te.forceSinglePass === !1
        ? ((te.side = Oi),
          (te.needsUpdate = !0),
          Gt(te, ye, Ae),
          (te.side = js),
          (te.needsUpdate = !0),
          Gt(te, ye, Ae),
          (te.side = Zo))
        : Gt(te, ye, Ae);
    }
    (this.compile = function (te, ye, Ae = null) {
      Ae === null && (Ae = te),
        (x = Oe.get(Ae)),
        x.init(),
        _.push(x),
        Ae.traverseVisible(function (Ce) {
          Ce.isLight &&
            Ce.layers.test(ye.layers) &&
            (x.pushLight(Ce), Ce.castShadow && x.pushShadow(Ce));
        }),
        te !== Ae &&
          te.traverseVisible(function (Ce) {
            Ce.isLight &&
              Ce.layers.test(ye.layers) &&
              (x.pushLight(Ce), Ce.castShadow && x.pushShadow(Ce));
          }),
        x.setupLights(y._useLegacyLights);
      const ze = new Set();
      return (
        te.traverse(function (Ce) {
          const ot = Ce.material;
          if (ot)
            if (Array.isArray(ot))
              for (let ht = 0; ht < ot.length; ht++) {
                const xt = ot[ht];
                Ye(xt, Ae, Ce), ze.add(xt);
              }
            else Ye(ot, Ae, Ce), ze.add(ot);
        }),
        _.pop(),
        (x = null),
        ze
      );
    }),
      (this.compileAsync = function (te, ye, Ae = null) {
        const ze = this.compile(te, ye, Ae);
        return new Promise((Ce) => {
          function ot() {
            if (
              (ze.forEach(function (ht) {
                pe.get(ht).currentProgram.isReady() && ze.delete(ht);
              }),
              ze.size === 0)
            ) {
              Ce(te);
              return;
            }
            setTimeout(ot, 10);
          }
          de.get("KHR_parallel_shader_compile") !== null
            ? ot()
            : setTimeout(ot, 10);
        });
      });
    let ke = null;
    function tt(te) {
      ke && ke(te);
    }
    function ut() {
      Rt.stop();
    }
    function dt() {
      Rt.start();
    }
    const Rt = new QF();
    Rt.setAnimationLoop(tt),
      typeof self < "u" && Rt.setContext(self),
      (this.setAnimationLoop = function (te) {
        (ke = te),
          We.setAnimationLoop(te),
          te === null ? Rt.stop() : Rt.start();
      }),
      We.addEventListener("sessionstart", ut),
      We.addEventListener("sessionend", dt),
      (this.render = function (te, ye) {
        if (ye !== void 0 && ye.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (w === !0) return;
        te.matrixWorldAutoUpdate === !0 && te.updateMatrixWorld(),
          ye.parent === null &&
            ye.matrixWorldAutoUpdate === !0 &&
            ye.updateMatrixWorld(),
          We.enabled === !0 &&
            We.isPresenting === !0 &&
            (We.cameraAutoUpdate === !0 && We.updateCamera(ye),
            (ye = We.getCamera())),
          te.isScene === !0 && te.onBeforeRender(y, te, ye, T),
          (x = Oe.get(te, _.length)),
          x.init(),
          _.push(x),
          ae.multiplyMatrices(ye.projectionMatrix, ye.matrixWorldInverse),
          X.setFromProjectionMatrix(ae),
          (J = this.localClippingEnabled),
          (ee = Pe.init(this.clippingPlanes, J)),
          (S = Le.get(te, g.length)),
          S.init(),
          g.push(S),
          Bt(te, ye, 0, y.sortObjects),
          S.finish(),
          y.sortObjects === !0 && S.sort(B, $),
          this.info.render.frame++,
          ee === !0 && Pe.beginShadows();
        const Ae = x.state.shadowsArray;
        if (
          (Se.render(Ae, te, ye),
          ee === !0 && Pe.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          Je.render(S, te),
          x.setupLights(y._useLegacyLights),
          ye.isArrayCamera)
        ) {
          const ze = ye.cameras;
          for (let Ce = 0, ot = ze.length; Ce < ot; Ce++) {
            const ht = ze[Ce];
            In(S, te, ht, ht.viewport);
          }
        } else In(S, te, ye);
        T !== null &&
          (H.updateMultisampleRenderTarget(T), H.updateRenderTargetMipmap(T)),
          te.isScene === !0 && te.onAfterRender(y, te, ye),
          ne.resetDefaultState(),
          (I = -1),
          (R = null),
          _.pop(),
          _.length > 0 ? (x = _[_.length - 1]) : (x = null),
          g.pop(),
          g.length > 0 ? (S = g[g.length - 1]) : (S = null);
      });
    function Bt(te, ye, Ae, ze) {
      if (te.visible === !1) return;
      if (te.layers.test(ye.layers)) {
        if (te.isGroup) Ae = te.renderOrder;
        else if (te.isLOD) te.autoUpdate === !0 && te.update(ye);
        else if (te.isLight) x.pushLight(te), te.castShadow && x.pushShadow(te);
        else if (te.isSprite) {
          if (!te.frustumCulled || X.intersectsSprite(te)) {
            ze && _e.setFromMatrixPosition(te.matrixWorld).applyMatrix4(ae);
            const ht = he.update(te),
              xt = te.material;
            xt.visible && S.push(te, ht, xt, Ae, _e.z, null);
          }
        } else if (
          (te.isMesh || te.isLine || te.isPoints) &&
          (!te.frustumCulled || X.intersectsObject(te))
        ) {
          const ht = he.update(te),
            xt = te.material;
          if (
            (ze &&
              (te.boundingSphere !== void 0
                ? (te.boundingSphere === null && te.computeBoundingSphere(),
                  _e.copy(te.boundingSphere.center))
                : (ht.boundingSphere === null && ht.computeBoundingSphere(),
                  _e.copy(ht.boundingSphere.center)),
              _e.applyMatrix4(te.matrixWorld).applyMatrix4(ae)),
            Array.isArray(xt))
          ) {
            const qe = ht.groups;
            for (let bt = 0, Lt = qe.length; bt < Lt; bt++) {
              const Mt = qe[bt],
                qt = xt[Mt.materialIndex];
              qt && qt.visible && S.push(te, ht, qt, Ae, _e.z, Mt);
            }
          } else xt.visible && S.push(te, ht, xt, Ae, _e.z, null);
        }
      }
      const ot = te.children;
      for (let ht = 0, xt = ot.length; ht < xt; ht++) Bt(ot[ht], ye, Ae, ze);
    }
    function In(te, ye, Ae, ze) {
      const Ce = te.opaque,
        ot = te.transmissive,
        ht = te.transparent;
      x.setupLightsView(Ae),
        ee === !0 && Pe.setGlobalState(y.clippingPlanes, Ae),
        ot.length > 0 && dn(Ce, ot, ye, Ae),
        ze && fe.viewport(P.copy(ze)),
        Ce.length > 0 && _n(Ce, ye, Ae),
        ot.length > 0 && _n(ot, ye, Ae),
        ht.length > 0 && _n(ht, ye, Ae),
        fe.buffers.depth.setTest(!0),
        fe.buffers.depth.setMask(!0),
        fe.buffers.color.setMask(!0),
        fe.setPolygonOffset(!1);
    }
    function dn(te, ye, Ae, ze) {
      if ((Ae.isScene === !0 ? Ae.overrideMaterial : null) !== null) return;
      const ot = ue.isWebGL2;
      oe === null &&
        (oe = new Pa(1, 1, {
          generateMipmaps: !0,
          type: de.has("EXT_color_buffer_half_float") ? df : es,
          minFilter: Hl,
          samples: ot ? 4 : 0,
        })),
        y.getDrawingBufferSize(le),
        ot ? oe.setSize(le.x, le.y) : oe.setSize(dy(le.x), dy(le.y));
      const ht = y.getRenderTarget();
      y.setRenderTarget(oe),
        y.getClearColor(j),
        (N = y.getClearAlpha()),
        N < 1 && y.setClearColor(16777215, 0.5),
        y.clear();
      const xt = y.toneMapping;
      (y.toneMapping = Ja),
        _n(te, Ae, ze),
        H.updateMultisampleRenderTarget(oe),
        H.updateRenderTargetMipmap(oe);
      let qe = !1;
      for (let bt = 0, Lt = ye.length; bt < Lt; bt++) {
        const Mt = ye[bt],
          qt = Mt.object,
          On = Mt.geometry,
          tn = Mt.material,
          cn = Mt.group;
        if (tn.side === Zo && qt.layers.test(ze.layers)) {
          const St = tn.side;
          (tn.side = Oi),
            (tn.needsUpdate = !0),
            gn(qt, Ae, ze, On, tn, cn),
            (tn.side = St),
            (tn.needsUpdate = !0),
            (qe = !0);
        }
      }
      qe === !0 &&
        (H.updateMultisampleRenderTarget(oe), H.updateRenderTargetMipmap(oe)),
        y.setRenderTarget(ht),
        y.setClearColor(j, N),
        (y.toneMapping = xt);
    }
    function _n(te, ye, Ae) {
      const ze = ye.isScene === !0 ? ye.overrideMaterial : null;
      for (let Ce = 0, ot = te.length; Ce < ot; Ce++) {
        const ht = te[Ce],
          xt = ht.object,
          qe = ht.geometry,
          bt = ze === null ? ht.material : ze,
          Lt = ht.group;
        xt.layers.test(Ae.layers) && gn(xt, ye, Ae, qe, bt, Lt);
      }
    }
    function gn(te, ye, Ae, ze, Ce, ot) {
      te.onBeforeRender(y, ye, Ae, ze, Ce, ot),
        te.modelViewMatrix.multiplyMatrices(
          Ae.matrixWorldInverse,
          te.matrixWorld
        ),
        te.normalMatrix.getNormalMatrix(te.modelViewMatrix),
        Ce.onBeforeRender(y, ye, Ae, ze, te, ot),
        Ce.transparent === !0 && Ce.side === Zo && Ce.forceSinglePass === !1
          ? ((Ce.side = Oi),
            (Ce.needsUpdate = !0),
            y.renderBufferDirect(Ae, ye, ze, Ce, te, ot),
            (Ce.side = js),
            (Ce.needsUpdate = !0),
            y.renderBufferDirect(Ae, ye, ze, Ce, te, ot),
            (Ce.side = Zo))
          : y.renderBufferDirect(Ae, ye, ze, Ce, te, ot),
        te.onAfterRender(y, ye, Ae, ze, Ce, ot);
    }
    function Gt(te, ye, Ae) {
      ye.isScene !== !0 && (ye = me);
      const ze = pe.get(te),
        Ce = x.state.lights,
        ot = x.state.shadowsArray,
        ht = Ce.state.version,
        xt = Me.getParameters(te, Ce.state, ot, ye, Ae),
        qe = Me.getProgramCacheKey(xt);
      let bt = ze.programs;
      (ze.environment = te.isMeshStandardMaterial ? ye.environment : null),
        (ze.fog = ye.fog),
        (ze.envMap = (te.isMeshStandardMaterial ? Z : z).get(
          te.envMap || ze.environment
        )),
        bt === void 0 &&
          (te.addEventListener("dispose", He),
          (bt = new Map()),
          (ze.programs = bt));
      let Lt = bt.get(qe);
      if (Lt !== void 0) {
        if (ze.currentProgram === Lt && ze.lightsStateVersion === ht)
          return Ht(te, xt), Lt;
      } else
        (xt.uniforms = Me.getUniforms(te)),
          te.onBuild(Ae, xt, y),
          te.onBeforeCompile(xt, y),
          (Lt = Me.acquireProgram(xt, qe)),
          bt.set(qe, Lt),
          (ze.uniforms = xt.uniforms);
      const Mt = ze.uniforms;
      return (
        ((!te.isShaderMaterial && !te.isRawShaderMaterial) ||
          te.clipping === !0) &&
          (Mt.clippingPlanes = Pe.uniform),
        Ht(te, xt),
        (ze.needsLights = Ln(te)),
        (ze.lightsStateVersion = ht),
        ze.needsLights &&
          ((Mt.ambientLightColor.value = Ce.state.ambient),
          (Mt.lightProbe.value = Ce.state.probe),
          (Mt.directionalLights.value = Ce.state.directional),
          (Mt.directionalLightShadows.value = Ce.state.directionalShadow),
          (Mt.spotLights.value = Ce.state.spot),
          (Mt.spotLightShadows.value = Ce.state.spotShadow),
          (Mt.rectAreaLights.value = Ce.state.rectArea),
          (Mt.ltc_1.value = Ce.state.rectAreaLTC1),
          (Mt.ltc_2.value = Ce.state.rectAreaLTC2),
          (Mt.pointLights.value = Ce.state.point),
          (Mt.pointLightShadows.value = Ce.state.pointShadow),
          (Mt.hemisphereLights.value = Ce.state.hemi),
          (Mt.directionalShadowMap.value = Ce.state.directionalShadowMap),
          (Mt.directionalShadowMatrix.value = Ce.state.directionalShadowMatrix),
          (Mt.spotShadowMap.value = Ce.state.spotShadowMap),
          (Mt.spotLightMatrix.value = Ce.state.spotLightMatrix),
          (Mt.spotLightMap.value = Ce.state.spotLightMap),
          (Mt.pointShadowMap.value = Ce.state.pointShadowMap),
          (Mt.pointShadowMatrix.value = Ce.state.pointShadowMatrix)),
        (ze.currentProgram = Lt),
        (ze.uniformsList = null),
        Lt
      );
    }
    function ln(te) {
      if (te.uniformsList === null) {
        const ye = te.currentProgram.getUniforms();
        te.uniformsList = b0.seqWithValue(ye.seq, te.uniforms);
      }
      return te.uniformsList;
    }
    function Ht(te, ye) {
      const Ae = pe.get(te);
      (Ae.outputColorSpace = ye.outputColorSpace),
        (Ae.batching = ye.batching),
        (Ae.instancing = ye.instancing),
        (Ae.instancingColor = ye.instancingColor),
        (Ae.skinning = ye.skinning),
        (Ae.morphTargets = ye.morphTargets),
        (Ae.morphNormals = ye.morphNormals),
        (Ae.morphColors = ye.morphColors),
        (Ae.morphTargetsCount = ye.morphTargetsCount),
        (Ae.numClippingPlanes = ye.numClippingPlanes),
        (Ae.numIntersection = ye.numClipIntersection),
        (Ae.vertexAlphas = ye.vertexAlphas),
        (Ae.vertexTangents = ye.vertexTangents),
        (Ae.toneMapping = ye.toneMapping);
    }
    function Dt(te, ye, Ae, ze, Ce) {
      ye.isScene !== !0 && (ye = me), H.resetTextureUnits();
      const ot = ye.fog,
        ht = ze.isMeshStandardMaterial ? ye.environment : null,
        xt =
          T === null
            ? y.outputColorSpace
            : T.isXRRenderTarget === !0
            ? T.texture.colorSpace
            : rs,
        qe = (ze.isMeshStandardMaterial ? Z : z).get(ze.envMap || ht),
        bt =
          ze.vertexColors === !0 &&
          !!Ae.attributes.color &&
          Ae.attributes.color.itemSize === 4,
        Lt = !!Ae.attributes.tangent && (!!ze.normalMap || ze.anisotropy > 0),
        Mt = !!Ae.morphAttributes.position,
        qt = !!Ae.morphAttributes.normal,
        On = !!Ae.morphAttributes.color;
      let tn = Ja;
      ze.toneMapped &&
        (T === null || T.isXRRenderTarget === !0) &&
        (tn = y.toneMapping);
      const cn =
          Ae.morphAttributes.position ||
          Ae.morphAttributes.normal ||
          Ae.morphAttributes.color,
        St = cn !== void 0 ? cn.length : 0,
        ct = pe.get(ze),
        zn = x.state.lights;
      if (ee === !0 && (J === !0 || te !== R)) {
        const bn = te === R && ze.id === I;
        Pe.setState(ze, te, bn);
      }
      let Ot = !1;
      ze.version === ct.__version
        ? ((ct.needsLights && ct.lightsStateVersion !== zn.state.version) ||
            ct.outputColorSpace !== xt ||
            (Ce.isBatchedMesh && ct.batching === !1) ||
            (!Ce.isBatchedMesh && ct.batching === !0) ||
            (Ce.isInstancedMesh && ct.instancing === !1) ||
            (!Ce.isInstancedMesh && ct.instancing === !0) ||
            (Ce.isSkinnedMesh && ct.skinning === !1) ||
            (!Ce.isSkinnedMesh && ct.skinning === !0) ||
            (Ce.isInstancedMesh &&
              ct.instancingColor === !0 &&
              Ce.instanceColor === null) ||
            (Ce.isInstancedMesh &&
              ct.instancingColor === !1 &&
              Ce.instanceColor !== null) ||
            ct.envMap !== qe ||
            (ze.fog === !0 && ct.fog !== ot) ||
            (ct.numClippingPlanes !== void 0 &&
              (ct.numClippingPlanes !== Pe.numPlanes ||
                ct.numIntersection !== Pe.numIntersection)) ||
            ct.vertexAlphas !== bt ||
            ct.vertexTangents !== Lt ||
            ct.morphTargets !== Mt ||
            ct.morphNormals !== qt ||
            ct.morphColors !== On ||
            ct.toneMapping !== tn ||
            (ue.isWebGL2 === !0 && ct.morphTargetsCount !== St)) &&
          (Ot = !0)
        : ((Ot = !0), (ct.__version = ze.version));
      let fn = ct.currentProgram;
      Ot === !0 && (fn = Gt(ze, ye, Ce));
      let Xn = !1,
        Ut = !1,
        Pt = !1;
      const Tt = fn.getUniforms(),
        vn = ct.uniforms;
      if (
        (fe.useProgram(fn.program) && ((Xn = !0), (Ut = !0), (Pt = !0)),
        ze.id !== I && ((I = ze.id), (Ut = !0)),
        Xn || R !== te)
      ) {
        Tt.setValue(Y, "projectionMatrix", te.projectionMatrix),
          Tt.setValue(Y, "viewMatrix", te.matrixWorldInverse);
        const bn = Tt.map.cameraPosition;
        bn !== void 0 &&
          bn.setValue(Y, _e.setFromMatrixPosition(te.matrixWorld)),
          ue.logarithmicDepthBuffer &&
            Tt.setValue(
              Y,
              "logDepthBufFC",
              2 / (Math.log(te.far + 1) / Math.LN2)
            ),
          (ze.isMeshPhongMaterial ||
            ze.isMeshToonMaterial ||
            ze.isMeshLambertMaterial ||
            ze.isMeshBasicMaterial ||
            ze.isMeshStandardMaterial ||
            ze.isShaderMaterial) &&
            Tt.setValue(Y, "isOrthographic", te.isOrthographicCamera === !0),
          R !== te && ((R = te), (Ut = !0), (Pt = !0));
      }
      if (Ce.isSkinnedMesh) {
        Tt.setOptional(Y, Ce, "bindMatrix"),
          Tt.setOptional(Y, Ce, "bindMatrixInverse");
        const bn = Ce.skeleton;
        bn &&
          (ue.floatVertexTextures
            ? (bn.boneTexture === null && bn.computeBoneTexture(),
              Tt.setValue(Y, "boneTexture", bn.boneTexture, H))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      Ce.isBatchedMesh &&
        (Tt.setOptional(Y, Ce, "batchingTexture"),
        Tt.setValue(Y, "batchingTexture", Ce._matricesTexture, H));
      const En = Ae.morphAttributes;
      if (
        ((En.position !== void 0 ||
          En.normal !== void 0 ||
          (En.color !== void 0 && ue.isWebGL2 === !0)) &&
          st.update(Ce, Ae, fn),
        (Ut || ct.receiveShadow !== Ce.receiveShadow) &&
          ((ct.receiveShadow = Ce.receiveShadow),
          Tt.setValue(Y, "receiveShadow", Ce.receiveShadow)),
        ze.isMeshGouraudMaterial &&
          ze.envMap !== null &&
          ((vn.envMap.value = qe),
          (vn.flipEnvMap.value =
            qe.isCubeTexture && qe.isRenderTargetTexture === !1 ? -1 : 1)),
        Ut &&
          (Tt.setValue(Y, "toneMappingExposure", y.toneMappingExposure),
          ct.needsLights && nn(vn, Pt),
          ot && ze.fog === !0 && Re.refreshFogUniforms(vn, ot),
          Re.refreshMaterialUniforms(vn, ze, Q, W, oe),
          b0.upload(Y, ln(ct), vn, H)),
        ze.isShaderMaterial &&
          ze.uniformsNeedUpdate === !0 &&
          (b0.upload(Y, ln(ct), vn, H), (ze.uniformsNeedUpdate = !1)),
        ze.isSpriteMaterial && Tt.setValue(Y, "center", Ce.center),
        Tt.setValue(Y, "modelViewMatrix", Ce.modelViewMatrix),
        Tt.setValue(Y, "normalMatrix", Ce.normalMatrix),
        Tt.setValue(Y, "modelMatrix", Ce.matrixWorld),
        ze.isShaderMaterial || ze.isRawShaderMaterial)
      ) {
        const bn = ze.uniformsGroups;
        for (let Bn = 0, lr = bn.length; Bn < lr; Bn++)
          if (ue.isWebGL2) {
            const Vr = bn[Bn];
            Ie.update(Vr, fn), Ie.bind(Vr, fn);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return fn;
    }
    function nn(te, ye) {
      (te.ambientLightColor.needsUpdate = ye),
        (te.lightProbe.needsUpdate = ye),
        (te.directionalLights.needsUpdate = ye),
        (te.directionalLightShadows.needsUpdate = ye),
        (te.pointLights.needsUpdate = ye),
        (te.pointLightShadows.needsUpdate = ye),
        (te.spotLights.needsUpdate = ye),
        (te.spotLightShadows.needsUpdate = ye),
        (te.rectAreaLights.needsUpdate = ye),
        (te.hemisphereLights.needsUpdate = ye);
    }
    function Ln(te) {
      return (
        te.isMeshLambertMaterial ||
        te.isMeshToonMaterial ||
        te.isMeshPhongMaterial ||
        te.isMeshStandardMaterial ||
        te.isShadowMaterial ||
        (te.isShaderMaterial && te.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return A;
    }),
      (this.getActiveMipmapLevel = function () {
        return M;
      }),
      (this.getRenderTarget = function () {
        return T;
      }),
      (this.setRenderTargetTextures = function (te, ye, Ae) {
        (pe.get(te.texture).__webglTexture = ye),
          (pe.get(te.depthTexture).__webglTexture = Ae);
        const ze = pe.get(te);
        (ze.__hasExternalTextures = !0),
          ze.__hasExternalTextures &&
            ((ze.__autoAllocateDepthBuffer = Ae === void 0),
            ze.__autoAllocateDepthBuffer ||
              (de.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (ze.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (te, ye) {
        const Ae = pe.get(te);
        (Ae.__webglFramebuffer = ye),
          (Ae.__useDefaultFramebuffer = ye === void 0);
      }),
      (this.setRenderTarget = function (te, ye = 0, Ae = 0) {
        (T = te), (A = ye), (M = Ae);
        let ze = !0,
          Ce = null,
          ot = !1,
          ht = !1;
        if (te) {
          const qe = pe.get(te);
          qe.__useDefaultFramebuffer !== void 0
            ? (fe.bindFramebuffer(Y.FRAMEBUFFER, null), (ze = !1))
            : qe.__webglFramebuffer === void 0
            ? H.setupRenderTarget(te)
            : qe.__hasExternalTextures &&
              H.rebindTextures(
                te,
                pe.get(te.texture).__webglTexture,
                pe.get(te.depthTexture).__webglTexture
              );
          const bt = te.texture;
          (bt.isData3DTexture ||
            bt.isDataArrayTexture ||
            bt.isCompressedArrayTexture) &&
            (ht = !0);
          const Lt = pe.get(te).__webglFramebuffer;
          te.isWebGLCubeRenderTarget
            ? (Array.isArray(Lt[ye]) ? (Ce = Lt[ye][Ae]) : (Ce = Lt[ye]),
              (ot = !0))
            : ue.isWebGL2 && te.samples > 0 && H.useMultisampledRTT(te) === !1
            ? (Ce = pe.get(te).__webglMultisampledFramebuffer)
            : Array.isArray(Lt)
            ? (Ce = Lt[Ae])
            : (Ce = Lt),
            P.copy(te.viewport),
            F.copy(te.scissor),
            (D = te.scissorTest);
        } else
          P.copy(G).multiplyScalar(Q).floor(),
            F.copy(k).multiplyScalar(Q).floor(),
            (D = q);
        if (
          (fe.bindFramebuffer(Y.FRAMEBUFFER, Ce) &&
            ue.drawBuffers &&
            ze &&
            fe.drawBuffers(te, Ce),
          fe.viewport(P),
          fe.scissor(F),
          fe.setScissorTest(D),
          ot)
        ) {
          const qe = pe.get(te.texture);
          Y.framebufferTexture2D(
            Y.FRAMEBUFFER,
            Y.COLOR_ATTACHMENT0,
            Y.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
            qe.__webglTexture,
            Ae
          );
        } else if (ht) {
          const qe = pe.get(te.texture),
            bt = ye || 0;
          Y.framebufferTextureLayer(
            Y.FRAMEBUFFER,
            Y.COLOR_ATTACHMENT0,
            qe.__webglTexture,
            Ae || 0,
            bt
          );
        }
        I = -1;
      }),
      (this.readRenderTargetPixels = function (te, ye, Ae, ze, Ce, ot, ht) {
        if (!(te && te.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let xt = pe.get(te).__webglFramebuffer;
        if (
          (te.isWebGLCubeRenderTarget && ht !== void 0 && (xt = xt[ht]), xt)
        ) {
          fe.bindFramebuffer(Y.FRAMEBUFFER, xt);
          try {
            const qe = te.texture,
              bt = qe.format,
              Lt = qe.type;
            if (
              bt !== Ii &&
              Ne.convert(bt) !==
                Y.getParameter(Y.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const Mt =
              Lt === df &&
              (de.has("EXT_color_buffer_half_float") ||
                (ue.isWebGL2 && de.has("EXT_color_buffer_float")));
            if (
              Lt !== es &&
              Ne.convert(Lt) !==
                Y.getParameter(Y.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                Lt === wa &&
                (ue.isWebGL2 ||
                  de.has("OES_texture_float") ||
                  de.has("WEBGL_color_buffer_float"))
              ) &&
              !Mt
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            ye >= 0 &&
              ye <= te.width - ze &&
              Ae >= 0 &&
              Ae <= te.height - Ce &&
              Y.readPixels(ye, Ae, ze, Ce, Ne.convert(bt), Ne.convert(Lt), ot);
          } finally {
            const qe = T !== null ? pe.get(T).__webglFramebuffer : null;
            fe.bindFramebuffer(Y.FRAMEBUFFER, qe);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (te, ye, Ae = 0) {
        const ze = Math.pow(2, -Ae),
          Ce = Math.floor(ye.image.width * ze),
          ot = Math.floor(ye.image.height * ze);
        H.setTexture2D(ye, 0),
          Y.copyTexSubImage2D(Y.TEXTURE_2D, Ae, 0, 0, te.x, te.y, Ce, ot),
          fe.unbindTexture();
      }),
      (this.copyTextureToTexture = function (te, ye, Ae, ze = 0) {
        const Ce = ye.image.width,
          ot = ye.image.height,
          ht = Ne.convert(Ae.format),
          xt = Ne.convert(Ae.type);
        H.setTexture2D(Ae, 0),
          Y.pixelStorei(Y.UNPACK_FLIP_Y_WEBGL, Ae.flipY),
          Y.pixelStorei(Y.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ae.premultiplyAlpha),
          Y.pixelStorei(Y.UNPACK_ALIGNMENT, Ae.unpackAlignment),
          ye.isDataTexture
            ? Y.texSubImage2D(
                Y.TEXTURE_2D,
                ze,
                te.x,
                te.y,
                Ce,
                ot,
                ht,
                xt,
                ye.image.data
              )
            : ye.isCompressedTexture
            ? Y.compressedTexSubImage2D(
                Y.TEXTURE_2D,
                ze,
                te.x,
                te.y,
                ye.mipmaps[0].width,
                ye.mipmaps[0].height,
                ht,
                ye.mipmaps[0].data
              )
            : Y.texSubImage2D(Y.TEXTURE_2D, ze, te.x, te.y, ht, xt, ye.image),
          ze === 0 && Ae.generateMipmaps && Y.generateMipmap(Y.TEXTURE_2D),
          fe.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (te, ye, Ae, ze, Ce = 0) {
        if (y.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const ot = te.max.x - te.min.x + 1,
          ht = te.max.y - te.min.y + 1,
          xt = te.max.z - te.min.z + 1,
          qe = Ne.convert(ze.format),
          bt = Ne.convert(ze.type);
        let Lt;
        if (ze.isData3DTexture) H.setTexture3D(ze, 0), (Lt = Y.TEXTURE_3D);
        else if (ze.isDataArrayTexture || ze.isCompressedArrayTexture)
          H.setTexture2DArray(ze, 0), (Lt = Y.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        Y.pixelStorei(Y.UNPACK_FLIP_Y_WEBGL, ze.flipY),
          Y.pixelStorei(Y.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ze.premultiplyAlpha),
          Y.pixelStorei(Y.UNPACK_ALIGNMENT, ze.unpackAlignment);
        const Mt = Y.getParameter(Y.UNPACK_ROW_LENGTH),
          qt = Y.getParameter(Y.UNPACK_IMAGE_HEIGHT),
          On = Y.getParameter(Y.UNPACK_SKIP_PIXELS),
          tn = Y.getParameter(Y.UNPACK_SKIP_ROWS),
          cn = Y.getParameter(Y.UNPACK_SKIP_IMAGES),
          St = Ae.isCompressedTexture ? Ae.mipmaps[Ce] : Ae.image;
        Y.pixelStorei(Y.UNPACK_ROW_LENGTH, St.width),
          Y.pixelStorei(Y.UNPACK_IMAGE_HEIGHT, St.height),
          Y.pixelStorei(Y.UNPACK_SKIP_PIXELS, te.min.x),
          Y.pixelStorei(Y.UNPACK_SKIP_ROWS, te.min.y),
          Y.pixelStorei(Y.UNPACK_SKIP_IMAGES, te.min.z),
          Ae.isDataTexture || Ae.isData3DTexture
            ? Y.texSubImage3D(
                Lt,
                Ce,
                ye.x,
                ye.y,
                ye.z,
                ot,
                ht,
                xt,
                qe,
                bt,
                St.data
              )
            : Ae.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              Y.compressedTexSubImage3D(
                Lt,
                Ce,
                ye.x,
                ye.y,
                ye.z,
                ot,
                ht,
                xt,
                qe,
                St.data
              ))
            : Y.texSubImage3D(Lt, Ce, ye.x, ye.y, ye.z, ot, ht, xt, qe, bt, St),
          Y.pixelStorei(Y.UNPACK_ROW_LENGTH, Mt),
          Y.pixelStorei(Y.UNPACK_IMAGE_HEIGHT, qt),
          Y.pixelStorei(Y.UNPACK_SKIP_PIXELS, On),
          Y.pixelStorei(Y.UNPACK_SKIP_ROWS, tn),
          Y.pixelStorei(Y.UNPACK_SKIP_IMAGES, cn),
          Ce === 0 && ze.generateMipmaps && Y.generateMipmap(Lt),
          fe.unbindTexture();
      }),
      (this.initTexture = function (te) {
        te.isCubeTexture
          ? H.setTextureCube(te, 0)
          : te.isData3DTexture
          ? H.setTexture3D(te, 0)
          : te.isDataArrayTexture || te.isCompressedArrayTexture
          ? H.setTexture2DArray(te, 0)
          : H.setTexture2D(te, 0),
          fe.unbindTexture();
      }),
      (this.resetState = function () {
        (A = 0), (M = 0), (T = null), fe.reset(), ne.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Ea;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const n = this.getContext();
    (n.drawingBufferColorSpace = e === t1 ? "display-p3" : "srgb"),
      (n.unpackColorSpace =
        Mn.workingColorSpace === fm ? "display-p3" : "srgb");
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === Tr ? Dl : eC
    );
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace = e === Dl ? Tr : rs);
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
    ),
      (this._useLegacyLights = e);
  }
}
class aD extends uC {}
aD.prototype.isWebGL1Renderer = !0;
class a1 {
  constructor(e, n = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new pt(e)),
      (this.density = n);
  }
  clone() {
    return new a1(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class s1 {
  constructor(e, n = 1, r = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new pt(e)),
      (this.near = n),
      (this.far = r);
  }
  clone() {
    return new s1(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class dC extends Sn {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      this.fog !== null && (n.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (n.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (n.object.backgroundIntensity = this.backgroundIntensity),
      n
    );
  }
}
class l1 {
  constructor(e, n) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = n),
      (this.count = e !== void 0 ? e.length / n : 0),
      (this.usage = Dp),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = Ao());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      console.warn(
        "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, n, r) {
    (e *= this.stride), (r *= n.stride);
    for (let i = 0, o = this.stride; i < o; i++)
      this.array[e + i] = n.array[r + i];
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ao()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const n = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      r = new this.constructor(n, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ao()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const Ti = new K();
class wo {
  constructor(e, n, r, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = n),
      (this.offset = r),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let n = 0, r = this.data.count; n < r; n++)
      Ti.fromBufferAttribute(this, n),
        Ti.applyMatrix4(e),
        this.setXYZ(n, Ti.x, Ti.y, Ti.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, r = this.count; n < r; n++)
      Ti.fromBufferAttribute(this, n),
        Ti.applyNormalMatrix(e),
        this.setXYZ(n, Ti.x, Ti.y, Ti.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, r = this.count; n < r; n++)
      Ti.fromBufferAttribute(this, n),
        Ti.transformDirection(e),
        this.setXYZ(n, Ti.x, Ti.y, Ti.z);
    return this;
  }
  setX(e, n) {
    return (
      this.normalized && (n = Zt(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = n),
      this
    );
  }
  setY(e, n) {
    return (
      this.normalized && (n = Zt(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = n),
      this
    );
  }
  setZ(e, n) {
    return (
      this.normalized && (n = Zt(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = n),
      this
    );
  }
  setW(e, n) {
    return (
      this.normalized && (n = Zt(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = n),
      this
    );
  }
  getX(e) {
    let n = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (n = Ki(n, this.array)), n;
  }
  getY(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (n = Ki(n, this.array)), n;
  }
  getZ(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (n = Ki(n, this.array)), n;
  }
  getW(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (n = Ki(n, this.array)), n;
  }
  setXY(e, n, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((n = Zt(n, this.array)), (r = Zt(r, this.array))),
      (this.data.array[e + 0] = n),
      (this.data.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, n, r, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((n = Zt(n, this.array)),
        (r = Zt(r, this.array)),
        (i = Zt(i, this.array))),
      (this.data.array[e + 0] = n),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, n, r, i, o) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((n = Zt(n, this.array)),
        (r = Zt(r, this.array)),
        (i = Zt(i, this.array)),
        (o = Zt(o, this.array))),
      (this.data.array[e + 0] = n),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = o),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const n = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) n.push(this.data.array[i + o]);
      }
      return new wn(
        new this.array.constructor(n),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new wo(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const n = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) n.push(this.data.array[i + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: n,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class fC extends yi {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new pt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let nd;
const hh = new K(),
  rd = new K(),
  id = new K(),
  od = new Ge(),
  ph = new Ge(),
  sD = new kt(),
  lv = new K(),
  mh = new K(),
  cv = new K(),
  QR = new Ge(),
  qS = new Ge(),
  JR = new Ge();
class lD extends Sn {
  constructor(e = new fC()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), nd === void 0)
    ) {
      nd = new Jt();
      const n = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        r = new l1(n, 5);
      nd.setIndex([0, 1, 2, 0, 2, 3]),
        nd.setAttribute("position", new wo(r, 3, 0, !1)),
        nd.setAttribute("uv", new wo(r, 2, 3, !1));
    }
    (this.geometry = nd), (this.material = e), (this.center = new Ge(0.5, 0.5));
  }
  raycast(e, n) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      rd.setFromMatrixScale(this.matrixWorld),
      sD.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      id.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        rd.multiplyScalar(-id.z);
    const r = this.material.rotation;
    let i, o;
    r !== 0 && ((o = Math.cos(r)), (i = Math.sin(r)));
    const a = this.center;
    uv(lv.set(-0.5, -0.5, 0), id, a, rd, i, o),
      uv(mh.set(0.5, -0.5, 0), id, a, rd, i, o),
      uv(cv.set(0.5, 0.5, 0), id, a, rd, i, o),
      QR.set(0, 0),
      qS.set(1, 0),
      JR.set(1, 1);
    let s = e.ray.intersectTriangle(lv, mh, cv, !1, hh);
    if (
      s === null &&
      (uv(mh.set(-0.5, 0.5, 0), id, a, rd, i, o),
      qS.set(0, 1),
      (s = e.ray.intersectTriangle(lv, cv, mh, !1, hh)),
      s === null)
    )
      return;
    const l = e.ray.origin.distanceTo(hh);
    l < e.near ||
      l > e.far ||
      n.push({
        distance: l,
        point: hh.clone(),
        uv: qi.getInterpolation(hh, lv, mh, cv, QR, qS, JR, new Ge()),
        face: null,
        object: this,
      });
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function uv(t, e, n, r, i, o) {
  od.subVectors(t, n).addScalar(0.5).multiply(r),
    i !== void 0
      ? ((ph.x = o * od.x - i * od.y), (ph.y = i * od.x + o * od.y))
      : ph.copy(od),
    t.copy(e),
    (t.x += ph.x),
    (t.y += ph.y),
    t.applyMatrix4(sD);
}
const dv = new K(),
  eP = new K();
class cD extends Sn {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const n = e.levels;
    for (let r = 0, i = n.length; r < i; r++) {
      const o = n[r];
      this.addLevel(o.object.clone(), o.distance, o.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, n = 0, r = 0) {
    n = Math.abs(n);
    const i = this.levels;
    let o;
    for (o = 0; o < i.length && !(n < i[o].distance); o++);
    return (
      i.splice(o, 0, { distance: n, hysteresis: r, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const n = this.levels;
    if (n.length > 0) {
      let r, i;
      for (r = 1, i = n.length; r < i; r++) {
        let o = n[r].distance;
        if ((n[r].object.visible && (o -= o * n[r].hysteresis), e < o)) break;
      }
      return n[r - 1].object;
    }
    return null;
  }
  raycast(e, n) {
    if (this.levels.length > 0) {
      dv.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(dv);
      this.getObjectForDistance(i).raycast(e, n);
    }
  }
  update(e) {
    const n = this.levels;
    if (n.length > 1) {
      dv.setFromMatrixPosition(e.matrixWorld),
        eP.setFromMatrixPosition(this.matrixWorld);
      const r = dv.distanceTo(eP) / e.zoom;
      n[0].object.visible = !0;
      let i, o;
      for (i = 1, o = n.length; i < o; i++) {
        let a = n[i].distance;
        if ((n[i].object.visible && (a -= a * n[i].hysteresis), r >= a))
          (n[i - 1].object.visible = !1), (n[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < o; i++) n[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const n = super.toJSON(e);
    this.autoUpdate === !1 && (n.object.autoUpdate = !1),
      (n.object.levels = []);
    const r = this.levels;
    for (let i = 0, o = r.length; i < o; i++) {
      const a = r[i];
      n.object.levels.push({
        object: a.object.uuid,
        distance: a.distance,
        hysteresis: a.hysteresis,
      });
    }
    return n;
  }
}
const tP = new K(),
  nP = new rn(),
  rP = new rn(),
  VG = new K(),
  iP = new kt(),
  fv = new K(),
  KS = new Rr(),
  oP = new kt(),
  YS = new yu();
class uD extends Jn {
  constructor(e, n) {
    super(e, n),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = rw),
      (this.bindMatrix = new kt()),
      (this.bindMatrixInverse = new kt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new wr()),
      this.boundingBox.makeEmpty();
    const n = e.getAttribute("position");
    for (let r = 0; r < n.count; r++)
      this.getVertexPosition(r, fv), this.boundingBox.expandByPoint(fv);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Rr()),
      this.boundingSphere.makeEmpty();
    const n = e.getAttribute("position");
    for (let r = 0; r < n.count; r++)
      this.getVertexPosition(r, fv), this.boundingSphere.expandByPoint(fv);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, n) {
    const r = this.material,
      i = this.matrixWorld;
    r !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      KS.copy(this.boundingSphere),
      KS.applyMatrix4(i),
      e.ray.intersectsSphere(KS) !== !1 &&
        (oP.copy(i).invert(),
        YS.copy(e.ray).applyMatrix4(oP),
        !(
          this.boundingBox !== null && YS.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, n, YS)));
  }
  getVertexPosition(e, n) {
    return super.getVertexPosition(e, n), this.applyBoneTransform(e, n), n;
  }
  bind(e, n) {
    (this.skeleton = e),
      n === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (n = this.matrixWorld)),
      this.bindMatrix.copy(n),
      this.bindMatrixInverse.copy(n).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new rn(),
      n = this.geometry.attributes.skinWeight;
    for (let r = 0, i = n.count; r < i; r++) {
      e.fromBufferAttribute(n, r);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0),
        n.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === rw
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === wF
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, n) {
    const r = this.skeleton,
      i = this.geometry;
    nP.fromBufferAttribute(i.attributes.skinIndex, e),
      rP.fromBufferAttribute(i.attributes.skinWeight, e),
      tP.copy(n).applyMatrix4(this.bindMatrix),
      n.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const a = rP.getComponent(o);
      if (a !== 0) {
        const s = nP.getComponent(o);
        iP.multiplyMatrices(r.bones[s].matrixWorld, r.boneInverses[s]),
          n.addScaledVector(VG.copy(tP).applyMatrix4(iP), a);
      }
    }
    return n.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, n) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, n)
    );
  }
}
class hC extends Sn {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Zc extends sr {
  constructor(e = null, n = 1, r = 1, i, o, a, s, l, c = pr, u = pr, d, p) {
    super(null, a, s, l, c, u, i, o, d, p),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: n, height: r }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const aP = new kt(),
  $G = new kt();
let dD = class fD {
  constructor(e = [], n = []) {
    (this.uuid = Ao()),
      (this.bones = e.slice(0)),
      (this.boneInverses = n),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      n = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), n.length === 0))
      this.calculateInverses();
    else if (e.length !== n.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new kt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const r = new kt();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const r = this.bones[e];
      r &&
        (r.parent && r.parent.isBone
          ? (r.matrix.copy(r.parent.matrixWorld).invert(),
            r.matrix.multiply(r.matrixWorld))
          : r.matrix.copy(r.matrixWorld),
        r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones,
      n = this.boneInverses,
      r = this.boneMatrices,
      i = this.boneTexture;
    for (let o = 0, a = e.length; o < a; o++) {
      const s = e[o] ? e[o].matrixWorld : $G;
      aP.multiplyMatrices(s, n[o]), aP.toArray(r, o * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new fD(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const n = new Float32Array(e * e * 4);
    n.set(this.boneMatrices);
    const r = new Zc(n, e, e, Ii, wa);
    return (
      (r.needsUpdate = !0),
      (this.boneMatrices = n),
      (this.boneTexture = r),
      this
    );
  }
  getBoneByName(e) {
    for (let n = 0, r = this.bones.length; n < r; n++) {
      const i = this.bones[n];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, n) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const o = e.bones[r];
      let a = n[o];
      a === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", o),
        (a = new hC())),
        this.bones.push(a),
        this.boneInverses.push(new kt().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const n = this.bones,
      r = this.boneInverses;
    for (let i = 0, o = n.length; i < o; i++) {
      const a = n[i];
      e.bones.push(a.uuid);
      const s = r[i];
      e.boneInverses.push(s.toArray());
    }
    return e;
  }
};
class uu extends wn {
  constructor(e, n, r, i = 1) {
    super(e, n, r),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const ad = new kt(),
  sP = new kt(),
  hv = [],
  lP = new wr(),
  GG = new kt(),
  gh = new Jn(),
  vh = new Rr();
class hD extends Jn {
  constructor(e, n, r) {
    super(e, n),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new uu(new Float32Array(r * 16), 16)),
      (this.instanceColor = null),
      (this.count = r),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < r; i++) this.setMatrixAt(i, GG);
  }
  computeBoundingBox() {
    const e = this.geometry,
      n = this.count;
    this.boundingBox === null && (this.boundingBox = new wr()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let r = 0; r < n; r++)
      this.getMatrixAt(r, ad),
        lP.copy(e.boundingBox).applyMatrix4(ad),
        this.boundingBox.union(lP);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      n = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Rr()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let r = 0; r < n; r++)
      this.getMatrixAt(r, ad),
        vh.copy(e.boundingSphere).applyMatrix4(ad),
        this.boundingSphere.union(vh);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, n) {
    n.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, n) {
    n.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, n) {
    const r = this.matrixWorld,
      i = this.count;
    if (
      ((gh.geometry = this.geometry),
      (gh.material = this.material),
      gh.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        vh.copy(this.boundingSphere),
        vh.applyMatrix4(r),
        e.ray.intersectsSphere(vh) !== !1))
    )
      for (let o = 0; o < i; o++) {
        this.getMatrixAt(o, ad),
          sP.multiplyMatrices(r, ad),
          (gh.matrixWorld = sP),
          gh.raycast(e, hv);
        for (let a = 0, s = hv.length; a < s; a++) {
          const l = hv[a];
          (l.instanceId = o), (l.object = this), n.push(l);
        }
        hv.length = 0;
      }
  }
  setColorAt(e, n) {
    this.instanceColor === null &&
      (this.instanceColor = new uu(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      n.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, n) {
    n.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
function WG(t, e) {
  return t.z - e.z;
}
function XG(t, e) {
  return e.z - t.z;
}
class qG {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, n) {
    const r = this.pool,
      i = this.list;
    this.index >= r.length && r.push({ start: -1, count: -1, z: -1 });
    const o = r[this.index];
    i.push(o),
      this.index++,
      (o.start = e.start),
      (o.count = e.count),
      (o.z = n);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const sd = "batchId",
  fl = new kt(),
  cP = new kt(),
  KG = new kt(),
  uP = new kt(),
  ZS = new gm(),
  pv = new wr(),
  vc = new Rr(),
  yh = new K(),
  QS = new qG(),
  ui = new Jn(),
  mv = [];
function YG(t, e, n = 0) {
  const r = e.itemSize;
  if (
    t.isInterleavedBufferAttribute ||
    t.array.constructor !== e.array.constructor
  ) {
    const i = t.count;
    for (let o = 0; o < i; o++)
      for (let a = 0; a < r; a++)
        e.setComponent(o + n, a, t.getComponent(o, a));
  } else e.array.set(t.array, n * r);
  e.needsUpdate = !0;
}
class pD extends Jn {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, n, r = n * 2, i) {
    super(new Jt(), i),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._drawRanges = []),
      (this._reservedRanges = []),
      (this._visibility = []),
      (this._active = []),
      (this._bounds = []),
      (this._maxGeometryCount = e),
      (this._maxVertexCount = n),
      (this._maxIndexCount = r),
      (this._geometryInitialized = !1),
      (this._geometryCount = 0),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._visibilityChanged = !0),
      (this._matricesTexture = null),
      this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const n = new Float32Array(e * e * 4),
      r = new Zc(n, e, e, Ii, wa);
    this._matricesTexture = r;
  }
  _initializeGeometry(e) {
    const n = this.geometry,
      r = this._maxVertexCount,
      i = this._maxGeometryCount,
      o = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const s in e.attributes) {
        const l = e.getAttribute(s),
          { array: c, itemSize: u, normalized: d } = l,
          p = new c.constructor(r * u),
          m = new l.constructor(p, u, d);
        m.setUsage(l.usage), n.setAttribute(s, m);
      }
      if (e.getIndex() !== null) {
        const s = r > 65536 ? new Uint32Array(o) : new Uint16Array(o);
        n.setIndex(new wn(s, 1));
      }
      const a = i > 65536 ? new Uint32Array(r) : new Uint16Array(r);
      n.setAttribute(sd, new wn(a, 1)), (this._geometryInitialized = !0);
    }
  }
  _validateGeometry(e) {
    if (e.getAttribute(sd))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${sd}"`);
    const n = this.geometry;
    if (!!e.getIndex() != !!n.getIndex())
      throw new Error(
        'BatchedMesh: All geometries must consistently have "index".'
      );
    for (const r in n.attributes) {
      if (r === sd) continue;
      if (!e.hasAttribute(r))
        throw new Error(
          `BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`
        );
      const i = e.getAttribute(r),
        o = n.getAttribute(r);
      if (i.itemSize !== o.itemSize || i.normalized !== o.normalized)
        throw new Error(
          "BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new wr());
    const e = this._geometryCount,
      n = this.boundingBox,
      r = this._active;
    n.makeEmpty();
    for (let i = 0; i < e; i++)
      r[i] !== !1 &&
        (this.getMatrixAt(i, fl),
        this.getBoundingBoxAt(i, pv).applyMatrix4(fl),
        n.union(pv));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Rr());
    const e = this._geometryCount,
      n = this.boundingSphere,
      r = this._active;
    n.makeEmpty();
    for (let i = 0; i < e; i++)
      r[i] !== !1 &&
        (this.getMatrixAt(i, fl),
        this.getBoundingSphereAt(i, vc).applyMatrix4(fl),
        n.union(vc));
  }
  addGeometry(e, n = -1, r = -1) {
    if (
      (this._initializeGeometry(e),
      this._validateGeometry(e),
      this._geometryCount >= this._maxGeometryCount)
    )
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1,
    };
    let o = null;
    const a = this._reservedRanges,
      s = this._drawRanges,
      l = this._bounds;
    this._geometryCount !== 0 && (o = a[a.length - 1]),
      n === -1
        ? (i.vertexCount = e.getAttribute("position").count)
        : (i.vertexCount = n),
      o === null
        ? (i.vertexStart = 0)
        : (i.vertexStart = o.vertexStart + o.vertexCount);
    const c = e.getIndex(),
      u = c !== null;
    if (
      (u &&
        (r === -1 ? (i.indexCount = c.count) : (i.indexCount = r),
        o === null
          ? (i.indexStart = 0)
          : (i.indexStart = o.indexStart + o.indexCount)),
      (i.indexStart !== -1 &&
        i.indexStart + i.indexCount > this._maxIndexCount) ||
        i.vertexStart + i.vertexCount > this._maxVertexCount)
    )
      throw new Error(
        "BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    const d = this._visibility,
      p = this._active,
      m = this._matricesTexture,
      v = this._matricesTexture.image.data;
    d.push(!0), p.push(!0);
    const S = this._geometryCount;
    this._geometryCount++,
      KG.toArray(v, S * 16),
      (m.needsUpdate = !0),
      a.push(i),
      s.push({ start: u ? i.indexStart : i.vertexStart, count: -1 }),
      l.push({
        boxInitialized: !1,
        box: new wr(),
        sphereInitialized: !1,
        sphere: new Rr(),
      });
    const x = this.geometry.getAttribute(sd);
    for (let g = 0; g < i.vertexCount; g++) x.setX(i.vertexStart + g, S);
    return (x.needsUpdate = !0), this.setGeometryAt(S, e), S;
  }
  setGeometryAt(e, n) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(n);
    const r = this.geometry,
      i = r.getIndex() !== null,
      o = r.getIndex(),
      a = n.getIndex(),
      s = this._reservedRanges[e];
    if (
      (i && a.count > s.indexCount) ||
      n.attributes.position.count > s.vertexCount
    )
      throw new Error(
        "BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const l = s.vertexStart,
      c = s.vertexCount;
    for (const m in r.attributes) {
      if (m === sd) continue;
      const v = n.getAttribute(m),
        S = r.getAttribute(m);
      YG(v, S, l);
      const x = v.itemSize;
      for (let g = v.count, _ = c; g < _; g++) {
        const y = l + g;
        for (let w = 0; w < x; w++) S.setComponent(y, w, 0);
      }
      S.needsUpdate = !0;
    }
    if (i) {
      const m = s.indexStart;
      for (let v = 0; v < a.count; v++) o.setX(m + v, l + a.getX(v));
      for (let v = a.count, S = s.indexCount; v < S; v++) o.setX(m + v, l);
      o.needsUpdate = !0;
    }
    const u = this._bounds[e];
    n.boundingBox !== null
      ? (u.box.copy(n.boundingBox), (u.boxInitialized = !0))
      : (u.boxInitialized = !1),
      n.boundingSphere !== null
        ? (u.sphere.copy(n.boundingSphere), (u.sphereInitialized = !0))
        : (u.sphereInitialized = !1);
    const d = this._drawRanges[e],
      p = n.getAttribute("position");
    return (d.count = i ? a.count : p.count), (this._visibilityChanged = !0), e;
  }
  deleteGeometry(e) {
    const n = this._active;
    return e >= n.length || n[e] === !1
      ? this
      : ((n[e] = !1), (this._visibilityChanged = !0), this);
  }
  getBoundingBoxAt(e, n) {
    if (this._active[e] === !1) return this;
    const i = this._bounds[e],
      o = i.box,
      a = this.geometry;
    if (i.boxInitialized === !1) {
      o.makeEmpty();
      const s = a.index,
        l = a.attributes.position,
        c = this._drawRanges[e];
      for (let u = c.start, d = c.start + c.count; u < d; u++) {
        let p = u;
        s && (p = s.getX(p)), o.expandByPoint(yh.fromBufferAttribute(l, p));
      }
      i.boxInitialized = !0;
    }
    return n.copy(o), n;
  }
  getBoundingSphereAt(e, n) {
    if (this._active[e] === !1) return this;
    const i = this._bounds[e],
      o = i.sphere,
      a = this.geometry;
    if (i.sphereInitialized === !1) {
      o.makeEmpty(), this.getBoundingBoxAt(e, pv), pv.getCenter(o.center);
      const s = a.index,
        l = a.attributes.position,
        c = this._drawRanges[e];
      let u = 0;
      for (let d = c.start, p = c.start + c.count; d < p; d++) {
        let m = d;
        s && (m = s.getX(m)),
          yh.fromBufferAttribute(l, m),
          (u = Math.max(u, o.center.distanceToSquared(yh)));
      }
      (o.radius = Math.sqrt(u)), (i.sphereInitialized = !0);
    }
    return n.copy(o), n;
  }
  setMatrixAt(e, n) {
    const r = this._active,
      i = this._matricesTexture,
      o = this._matricesTexture.image.data,
      a = this._geometryCount;
    return e >= a || r[e] === !1
      ? this
      : (n.toArray(o, e * 16), (i.needsUpdate = !0), this);
  }
  getMatrixAt(e, n) {
    const r = this._active,
      i = this._matricesTexture.image.data,
      o = this._geometryCount;
    return e >= o || r[e] === !1 ? null : n.fromArray(i, e * 16);
  }
  setVisibleAt(e, n) {
    const r = this._visibility,
      i = this._active,
      o = this._geometryCount;
    return e >= o || i[e] === !1 || r[e] === n
      ? this
      : ((r[e] = n), (this._visibilityChanged = !0), this);
  }
  getVisibleAt(e) {
    const n = this._visibility,
      r = this._active,
      i = this._geometryCount;
    return e >= i || r[e] === !1 ? !1 : n[e];
  }
  raycast(e, n) {
    const r = this._visibility,
      i = this._active,
      o = this._drawRanges,
      a = this._geometryCount,
      s = this.matrixWorld,
      l = this.geometry;
    (ui.material = this.material),
      (ui.geometry.index = l.index),
      (ui.geometry.attributes = l.attributes),
      ui.geometry.boundingBox === null && (ui.geometry.boundingBox = new wr()),
      ui.geometry.boundingSphere === null &&
        (ui.geometry.boundingSphere = new Rr());
    for (let c = 0; c < a; c++) {
      if (!r[c] || !i[c]) continue;
      const u = o[c];
      ui.geometry.setDrawRange(u.start, u.count),
        this.getMatrixAt(c, ui.matrixWorld).premultiply(s),
        this.getBoundingBoxAt(c, ui.geometry.boundingBox),
        this.getBoundingSphereAt(c, ui.geometry.boundingSphere),
        ui.raycast(e, mv);
      for (let d = 0, p = mv.length; d < p; d++) {
        const m = mv[d];
        (m.object = this), (m.batchId = c), n.push(m);
      }
      mv.length = 0;
    }
    (ui.material = null),
      (ui.geometry.index = null),
      (ui.geometry.attributes = {}),
      ui.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._drawRanges = e._drawRanges.map((n) => ({ ...n }))),
      (this._reservedRanges = e._reservedRanges.map((n) => ({ ...n }))),
      (this._visibility = e._visibility.slice()),
      (this._active = e._active.slice()),
      (this._bounds = e._bounds.map((n) => ({
        boxInitialized: n.boxInitialized,
        box: n.box.clone(),
        sphereInitialized: n.sphereInitialized,
        sphere: n.sphere.clone(),
      }))),
      (this._maxGeometryCount = e._maxGeometryCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data = this._matricesTexture.image.slice()),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this
    );
  }
  onBeforeRender(e, n, r, i, o) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const a = i.getIndex(),
      s = a === null ? 1 : a.array.BYTES_PER_ELEMENT,
      l = this._visibility,
      c = this._multiDrawStarts,
      u = this._multiDrawCounts,
      d = this._drawRanges,
      p = this.perObjectFrustumCulled;
    p &&
      (uP
        .multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse)
        .multiply(this.matrixWorld),
      ZS.setFromProjectionMatrix(uP, e.isWebGPURenderer ? ff : Ea));
    let m = 0;
    if (this.sortObjects) {
      cP.copy(this.matrixWorld).invert(),
        yh.setFromMatrixPosition(r.matrixWorld).applyMatrix4(cP);
      for (let x = 0, g = l.length; x < g; x++)
        if (l[x]) {
          this.getMatrixAt(x, fl),
            this.getBoundingSphereAt(x, vc).applyMatrix4(fl);
          let _ = !1;
          if ((p && (_ = !ZS.intersectsSphere(vc)), !_)) {
            const y = yh.distanceTo(vc.center);
            QS.push(d[x], y);
          }
        }
      const v = QS.list,
        S = this.customSort;
      S === null ? v.sort(o.transparent ? XG : WG) : S.call(this, v, r);
      for (let x = 0, g = v.length; x < g; x++) {
        const _ = v[x];
        (c[m] = _.start * s), (u[m] = _.count), m++;
      }
      QS.reset();
    } else
      for (let v = 0, S = l.length; v < S; v++)
        if (l[v]) {
          let x = !1;
          if (
            (p &&
              (this.getMatrixAt(v, fl),
              this.getBoundingSphereAt(v, vc).applyMatrix4(fl),
              (x = !ZS.intersectsSphere(vc))),
            !x)
          ) {
            const g = d[v];
            (c[m] = g.start * s), (u[m] = g.count), m++;
          }
        }
    (this._multiDrawCount = m), (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, n, r, i, o, a) {
    this.onBeforeRender(e, null, i, o, a);
  }
}
class zi extends yi {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new pt(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const dP = new K(),
  fP = new K(),
  hP = new kt(),
  JS = new yu(),
  gv = new Rr();
let jl = class extends Sn {
  constructor(e = new Jt(), n = new zi()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position,
        r = [0];
      for (let i = 1, o = n.count; i < o; i++)
        dP.fromBufferAttribute(n, i - 1),
          fP.fromBufferAttribute(n, i),
          (r[i] = r[i - 1]),
          (r[i] += dP.distanceTo(fP));
      e.setAttribute("lineDistance", new wt(r, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, n) {
    const r = this.geometry,
      i = this.matrixWorld,
      o = e.params.Line.threshold,
      a = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      gv.copy(r.boundingSphere),
      gv.applyMatrix4(i),
      (gv.radius += o),
      e.ray.intersectsSphere(gv) === !1)
    )
      return;
    hP.copy(i).invert(), JS.copy(e.ray).applyMatrix4(hP);
    const s = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = s * s,
      c = new K(),
      u = new K(),
      d = new K(),
      p = new K(),
      m = this.isLineSegments ? 2 : 1,
      v = r.index,
      x = r.attributes.position;
    if (v !== null) {
      const g = Math.max(0, a.start),
        _ = Math.min(v.count, a.start + a.count);
      for (let y = g, w = _ - 1; y < w; y += m) {
        const A = v.getX(y),
          M = v.getX(y + 1);
        if (
          (c.fromBufferAttribute(x, A),
          u.fromBufferAttribute(x, M),
          JS.distanceSqToSegment(c, u, p, d) > l)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const I = e.ray.origin.distanceTo(p);
        I < e.near ||
          I > e.far ||
          n.push({
            distance: I,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: y,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const g = Math.max(0, a.start),
        _ = Math.min(x.count, a.start + a.count);
      for (let y = g, w = _ - 1; y < w; y += m) {
        if (
          (c.fromBufferAttribute(x, y),
          u.fromBufferAttribute(x, y + 1),
          JS.distanceSqToSegment(c, u, p, d) > l)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const M = e.ray.origin.distanceTo(p);
        M < e.near ||
          M > e.far ||
          n.push({
            distance: M,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: y,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      r = Object.keys(n);
    if (r.length > 0) {
      const i = n[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, a = i.length; o < a; o++) {
          const s = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[s] = o);
        }
      }
    }
  }
};
const pP = new K(),
  mP = new K();
class as extends jl {
  constructor(e, n) {
    super(e, n), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position,
        r = [];
      for (let i = 0, o = n.count; i < o; i += 2)
        pP.fromBufferAttribute(n, i),
          mP.fromBufferAttribute(n, i + 1),
          (r[i] = i === 0 ? 0 : r[i - 1]),
          (r[i + 1] = r[i] + pP.distanceTo(mP));
      e.setAttribute("lineDistance", new wt(r, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class mD extends jl {
  constructor(e, n) {
    super(e, n), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class pC extends yi {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new pt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const gP = new kt(),
  Nw = new yu(),
  vv = new Rr(),
  yv = new K();
class gD extends Sn {
  constructor(e = new Jt(), n = new pC()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, n) {
    const r = this.geometry,
      i = this.matrixWorld,
      o = e.params.Points.threshold,
      a = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      vv.copy(r.boundingSphere),
      vv.applyMatrix4(i),
      (vv.radius += o),
      e.ray.intersectsSphere(vv) === !1)
    )
      return;
    gP.copy(i).invert(), Nw.copy(e.ray).applyMatrix4(gP);
    const s = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = s * s,
      c = r.index,
      d = r.attributes.position;
    if (c !== null) {
      const p = Math.max(0, a.start),
        m = Math.min(c.count, a.start + a.count);
      for (let v = p, S = m; v < S; v++) {
        const x = c.getX(v);
        yv.fromBufferAttribute(d, x), vP(yv, x, l, i, e, n, this);
      }
    } else {
      const p = Math.max(0, a.start),
        m = Math.min(d.count, a.start + a.count);
      for (let v = p, S = m; v < S; v++)
        yv.fromBufferAttribute(d, v), vP(yv, v, l, i, e, n, this);
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      r = Object.keys(n);
    if (r.length > 0) {
      const i = n[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, a = i.length; o < a; o++) {
          const s = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[s] = o);
        }
      }
    }
  }
}
function vP(t, e, n, r, i, o, a) {
  const s = Nw.distanceSqToPoint(t);
  if (s < n) {
    const l = new K();
    Nw.closestPointToPoint(t, l), l.applyMatrix4(r);
    const c = i.ray.origin.distanceTo(l);
    if (c < i.near || c > i.far) return;
    o.push({
      distance: c,
      distanceToRay: Math.sqrt(s),
      point: l,
      index: e,
      face: null,
      object: a,
    });
  }
}
class ZG extends sr {
  constructor(e, n, r, i, o, a, s, l, c) {
    super(e, n, r, i, o, a, s, l, c),
      (this.isVideoTexture = !0),
      (this.minFilter = a !== void 0 ? a : Yn),
      (this.magFilter = o !== void 0 ? o : Yn),
      (this.generateMipmaps = !1);
    const u = this;
    function d() {
      (u.needsUpdate = !0), e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class QG extends sr {
  constructor(e, n) {
    super({ width: e, height: n }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = pr),
      (this.minFilter = pr),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class c1 extends sr {
  constructor(e, n, r, i, o, a, s, l, c, u, d, p) {
    super(null, a, s, l, c, u, i, o, d, p),
      (this.isCompressedTexture = !0),
      (this.image = { width: n, height: r }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class JG extends c1 {
  constructor(e, n, r, i, o, a) {
    super(e, n, r, o, a),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = pi);
  }
}
class eW extends c1 {
  constructor(e, n, r) {
    super(void 0, e[0].width, e[0].height, n, r, Vs),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class tW extends sr {
  constructor(e, n, r, i, o, a, s, l, c) {
    super(e, n, r, i, o, a, s, l, c),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class Oa {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, n) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, n);
  }
  getPoints(e = 5) {
    const n = [];
    for (let r = 0; r <= e; r++) n.push(this.getPoint(r / e));
    return n;
  }
  getSpacedPoints(e = 5) {
    const n = [];
    for (let r = 0; r <= e; r++) n.push(this.getPointAt(r / e));
    return n;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const n = [];
    let r,
      i = this.getPoint(0),
      o = 0;
    n.push(0);
    for (let a = 1; a <= e; a++)
      (r = this.getPoint(a / e)), (o += r.distanceTo(i)), n.push(o), (i = r);
    return (this.cacheArcLengths = n), n;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, n) {
    const r = this.getLengths();
    let i = 0;
    const o = r.length;
    let a;
    n ? (a = n) : (a = e * r[o - 1]);
    let s = 0,
      l = o - 1,
      c;
    for (; s <= l; )
      if (((i = Math.floor(s + (l - s) / 2)), (c = r[i] - a), c < 0)) s = i + 1;
      else if (c > 0) l = i - 1;
      else {
        l = i;
        break;
      }
    if (((i = l), r[i] === a)) return i / (o - 1);
    const u = r[i],
      p = r[i + 1] - u,
      m = (a - u) / p;
    return (i + m) / (o - 1);
  }
  getTangent(e, n) {
    let i = e - 1e-4,
      o = e + 1e-4;
    i < 0 && (i = 0), o > 1 && (o = 1);
    const a = this.getPoint(i),
      s = this.getPoint(o),
      l = n || (a.isVector2 ? new Ge() : new K());
    return l.copy(s).sub(a).normalize(), l;
  }
  getTangentAt(e, n) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, n);
  }
  computeFrenetFrames(e, n) {
    const r = new K(),
      i = [],
      o = [],
      a = [],
      s = new K(),
      l = new kt();
    for (let m = 0; m <= e; m++) {
      const v = m / e;
      i[m] = this.getTangentAt(v, new K());
    }
    (o[0] = new K()), (a[0] = new K());
    let c = Number.MAX_VALUE;
    const u = Math.abs(i[0].x),
      d = Math.abs(i[0].y),
      p = Math.abs(i[0].z);
    u <= c && ((c = u), r.set(1, 0, 0)),
      d <= c && ((c = d), r.set(0, 1, 0)),
      p <= c && r.set(0, 0, 1),
      s.crossVectors(i[0], r).normalize(),
      o[0].crossVectors(i[0], s),
      a[0].crossVectors(i[0], o[0]);
    for (let m = 1; m <= e; m++) {
      if (
        ((o[m] = o[m - 1].clone()),
        (a[m] = a[m - 1].clone()),
        s.crossVectors(i[m - 1], i[m]),
        s.length() > Number.EPSILON)
      ) {
        s.normalize();
        const v = Math.acos(ar(i[m - 1].dot(i[m]), -1, 1));
        o[m].applyMatrix4(l.makeRotationAxis(s, v));
      }
      a[m].crossVectors(i[m], o[m]);
    }
    if (n === !0) {
      let m = Math.acos(ar(o[0].dot(o[e]), -1, 1));
      (m /= e), i[0].dot(s.crossVectors(o[0], o[e])) > 0 && (m = -m);
      for (let v = 1; v <= e; v++)
        o[v].applyMatrix4(l.makeRotationAxis(i[v], m * v)),
          a[v].crossVectors(i[v], o[v]);
    }
    return { tangents: i, normals: o, binormals: a };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class u1 extends Oa {
  constructor(
    e = 0,
    n = 0,
    r = 1,
    i = 1,
    o = 0,
    a = Math.PI * 2,
    s = !1,
    l = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = n),
      (this.xRadius = r),
      (this.yRadius = i),
      (this.aStartAngle = o),
      (this.aEndAngle = a),
      (this.aClockwise = s),
      (this.aRotation = l);
  }
  getPoint(e, n) {
    const r = n || new Ge(),
      i = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += i;
    for (; o > i; ) o -= i;
    o < Number.EPSILON && (a ? (o = 0) : (o = i)),
      this.aClockwise === !0 && !a && (o === i ? (o = -i) : (o = o - i));
    const s = this.aStartAngle + e * o;
    let l = this.aX + this.xRadius * Math.cos(s),
      c = this.aY + this.yRadius * Math.sin(s);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation),
        d = Math.sin(this.aRotation),
        p = l - this.aX,
        m = c - this.aY;
      (l = p * u - m * d + this.aX), (c = p * d + m * u + this.aY);
    }
    return r.set(l, c);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class vD extends u1 {
  constructor(e, n, r, i, o, a) {
    super(e, n, r, r, i, o, a),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function mC() {
  let t = 0,
    e = 0,
    n = 0,
    r = 0;
  function i(o, a, s, l) {
    (t = o),
      (e = s),
      (n = -3 * o + 3 * a - 2 * s - l),
      (r = 2 * o - 2 * a + s + l);
  }
  return {
    initCatmullRom: function (o, a, s, l, c) {
      i(a, s, c * (s - o), c * (l - a));
    },
    initNonuniformCatmullRom: function (o, a, s, l, c, u, d) {
      let p = (a - o) / c - (s - o) / (c + u) + (s - a) / u,
        m = (s - a) / u - (l - a) / (u + d) + (l - s) / d;
      (p *= u), (m *= u), i(a, s, p, m);
    },
    calc: function (o) {
      const a = o * o,
        s = a * o;
      return t + e * o + n * a + r * s;
    },
  };
}
const xv = new K(),
  e_ = new mC(),
  t_ = new mC(),
  n_ = new mC();
class yD extends Oa {
  constructor(e = [], n = !1, r = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = n),
      (this.curveType = r),
      (this.tension = i);
  }
  getPoint(e, n = new K()) {
    const r = n,
      i = this.points,
      o = i.length,
      a = (o - (this.closed ? 0 : 1)) * e;
    let s = Math.floor(a),
      l = a - s;
    this.closed
      ? (s += s > 0 ? 0 : (Math.floor(Math.abs(s) / o) + 1) * o)
      : l === 0 && s === o - 1 && ((s = o - 2), (l = 1));
    let c, u;
    this.closed || s > 0
      ? (c = i[(s - 1) % o])
      : (xv.subVectors(i[0], i[1]).add(i[0]), (c = xv));
    const d = i[s % o],
      p = i[(s + 1) % o];
    if (
      (this.closed || s + 2 < o
        ? (u = i[(s + 2) % o])
        : (xv.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), (u = xv)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const m = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(c.distanceToSquared(d), m),
        S = Math.pow(d.distanceToSquared(p), m),
        x = Math.pow(p.distanceToSquared(u), m);
      S < 1e-4 && (S = 1),
        v < 1e-4 && (v = S),
        x < 1e-4 && (x = S),
        e_.initNonuniformCatmullRom(c.x, d.x, p.x, u.x, v, S, x),
        t_.initNonuniformCatmullRom(c.y, d.y, p.y, u.y, v, S, x),
        n_.initNonuniformCatmullRom(c.z, d.z, p.z, u.z, v, S, x);
    } else
      this.curveType === "catmullrom" &&
        (e_.initCatmullRom(c.x, d.x, p.x, u.x, this.tension),
        t_.initCatmullRom(c.y, d.y, p.y, u.y, this.tension),
        n_.initCatmullRom(c.z, d.z, p.z, u.z, this.tension));
    return r.set(e_.calc(l), t_.calc(l), n_.calc(l)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let n = 0, r = e.points.length; n < r; n++) {
      const i = e.points[n];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, r = this.points.length; n < r; n++) {
      const i = this.points[n];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let n = 0, r = e.points.length; n < r; n++) {
      const i = e.points[n];
      this.points.push(new K().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function yP(t, e, n, r, i) {
  const o = (r - e) * 0.5,
    a = (i - n) * 0.5,
    s = t * t,
    l = t * s;
  return (
    (2 * n - 2 * r + o + a) * l + (-3 * n + 3 * r - 2 * o - a) * s + o * t + n
  );
}
function nW(t, e) {
  const n = 1 - t;
  return n * n * e;
}
function rW(t, e) {
  return 2 * (1 - t) * t * e;
}
function iW(t, e) {
  return t * t * e;
}
function Jh(t, e, n, r) {
  return nW(t, e) + rW(t, n) + iW(t, r);
}
function oW(t, e) {
  const n = 1 - t;
  return n * n * n * e;
}
function aW(t, e) {
  const n = 1 - t;
  return 3 * n * n * t * e;
}
function sW(t, e) {
  return 3 * (1 - t) * t * t * e;
}
function lW(t, e) {
  return t * t * t * e;
}
function ep(t, e, n, r, i) {
  return oW(t, e) + aW(t, n) + sW(t, r) + lW(t, i);
}
class gC extends Oa {
  constructor(e = new Ge(), n = new Ge(), r = new Ge(), i = new Ge()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = n),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, n = new Ge()) {
    const r = n,
      i = this.v0,
      o = this.v1,
      a = this.v2,
      s = this.v3;
    return r.set(ep(e, i.x, o.x, a.x, s.x), ep(e, i.y, o.y, a.y, s.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class xD extends Oa {
  constructor(e = new K(), n = new K(), r = new K(), i = new K()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = n),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, n = new K()) {
    const r = n,
      i = this.v0,
      o = this.v1,
      a = this.v2,
      s = this.v3;
    return (
      r.set(
        ep(e, i.x, o.x, a.x, s.x),
        ep(e, i.y, o.y, a.y, s.y),
        ep(e, i.z, o.z, a.z, s.z)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class vC extends Oa {
  constructor(e = new Ge(), n = new Ge()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = n);
  }
  getPoint(e, n = new Ge()) {
    const r = n;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new Ge()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class SD extends Oa {
  constructor(e = new K(), n = new K()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = n);
  }
  getPoint(e, n = new K()) {
    const r = n;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new K()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class yC extends Oa {
  constructor(e = new Ge(), n = new Ge(), r = new Ge()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = n),
      (this.v2 = r);
  }
  getPoint(e, n = new Ge()) {
    const r = n,
      i = this.v0,
      o = this.v1,
      a = this.v2;
    return r.set(Jh(e, i.x, o.x, a.x), Jh(e, i.y, o.y, a.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class xC extends Oa {
  constructor(e = new K(), n = new K(), r = new K()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = n),
      (this.v2 = r);
  }
  getPoint(e, n = new K()) {
    const r = n,
      i = this.v0,
      o = this.v1,
      a = this.v2;
    return (
      r.set(Jh(e, i.x, o.x, a.x), Jh(e, i.y, o.y, a.y), Jh(e, i.z, o.z, a.z)), r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class SC extends Oa {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, n = new Ge()) {
    const r = n,
      i = this.points,
      o = (i.length - 1) * e,
      a = Math.floor(o),
      s = o - a,
      l = i[a === 0 ? a : a - 1],
      c = i[a],
      u = i[a > i.length - 2 ? i.length - 1 : a + 1],
      d = i[a > i.length - 3 ? i.length - 1 : a + 2];
    return r.set(yP(s, l.x, c.x, u.x, d.x), yP(s, l.y, c.y, u.y, d.y)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let n = 0, r = e.points.length; n < r; n++) {
      const i = e.points[n];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, r = this.points.length; n < r; n++) {
      const i = this.points[n];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let n = 0, r = e.points.length; n < r; n++) {
      const i = e.points[n];
      this.points.push(new Ge().fromArray(i));
    }
    return this;
  }
}
var fy = Object.freeze({
  __proto__: null,
  ArcCurve: vD,
  CatmullRomCurve3: yD,
  CubicBezierCurve: gC,
  CubicBezierCurve3: xD,
  EllipseCurve: u1,
  LineCurve: vC,
  LineCurve3: SD,
  QuadraticBezierCurve: yC,
  QuadraticBezierCurve3: xC,
  SplineCurve: SC,
});
class _D extends Oa {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      n = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(n)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new fy[r](n, e));
    }
    return this;
  }
  getPoint(e, n) {
    const r = e * this.getLength(),
      i = this.getCurveLengths();
    let o = 0;
    for (; o < i.length; ) {
      if (i[o] >= r) {
        const a = i[o] - r,
          s = this.curves[o],
          l = s.getLength(),
          c = l === 0 ? 0 : 1 - a / l;
        return s.getPointAt(c, n);
      }
      o++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let n = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      (n += this.curves[r].getLength()), e.push(n);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const n = [];
    for (let r = 0; r <= e; r++) n.push(this.getPoint(r / e));
    return this.autoClose && n.push(n[0]), n;
  }
  getPoints(e = 12) {
    const n = [];
    let r;
    for (let i = 0, o = this.curves; i < o.length; i++) {
      const a = o[i],
        s = a.isEllipseCurve
          ? e * 2
          : a.isLineCurve || a.isLineCurve3
          ? 1
          : a.isSplineCurve
          ? e * a.points.length
          : e,
        l = a.getPoints(s);
      for (let c = 0; c < l.length; c++) {
        const u = l[c];
        (r && r.equals(u)) || (n.push(u), (r = u));
      }
    }
    return (
      this.autoClose &&
        n.length > 1 &&
        !n[n.length - 1].equals(n[0]) &&
        n.push(n[0]),
      n
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let n = 0, r = e.curves.length; n < r; n++) {
      const i = e.curves[n];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let n = 0, r = this.curves.length; n < r; n++) {
      const i = this.curves[n];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let n = 0, r = e.curves.length; n < r; n++) {
      const i = e.curves[n];
      this.curves.push(new fy[i.type]().fromJSON(i));
    }
    return this;
  }
}
class kp extends _D {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new Ge()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let n = 1, r = e.length; n < r; n++) this.lineTo(e[n].x, e[n].y);
    return this;
  }
  moveTo(e, n) {
    return this.currentPoint.set(e, n), this;
  }
  lineTo(e, n) {
    const r = new vC(this.currentPoint.clone(), new Ge(e, n));
    return this.curves.push(r), this.currentPoint.set(e, n), this;
  }
  quadraticCurveTo(e, n, r, i) {
    const o = new yC(this.currentPoint.clone(), new Ge(e, n), new Ge(r, i));
    return this.curves.push(o), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, n, r, i, o, a) {
    const s = new gC(
      this.currentPoint.clone(),
      new Ge(e, n),
      new Ge(r, i),
      new Ge(o, a)
    );
    return this.curves.push(s), this.currentPoint.set(o, a), this;
  }
  splineThru(e) {
    const n = [this.currentPoint.clone()].concat(e),
      r = new SC(n);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, n, r, i, o, a) {
    const s = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absarc(e + s, n + l, r, i, o, a), this;
  }
  absarc(e, n, r, i, o, a) {
    return this.absellipse(e, n, r, r, i, o, a), this;
  }
  ellipse(e, n, r, i, o, a, s, l) {
    const c = this.currentPoint.x,
      u = this.currentPoint.y;
    return this.absellipse(e + c, n + u, r, i, o, a, s, l), this;
  }
  absellipse(e, n, r, i, o, a, s, l) {
    const c = new u1(e, n, r, i, o, a, s, l);
    if (this.curves.length > 0) {
      const d = c.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(c);
    const u = c.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class vm extends Jt {
  constructor(
    e = [new Ge(0, -0.5), new Ge(0.5, 0), new Ge(0, 0.5)],
    n = 12,
    r = 0,
    i = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: n, phiStart: r, phiLength: i }),
      (n = Math.floor(n)),
      (i = ar(i, 0, Math.PI * 2));
    const o = [],
      a = [],
      s = [],
      l = [],
      c = [],
      u = 1 / n,
      d = new K(),
      p = new Ge(),
      m = new K(),
      v = new K(),
      S = new K();
    let x = 0,
      g = 0;
    for (let _ = 0; _ <= e.length - 1; _++)
      switch (_) {
        case 0:
          (x = e[_ + 1].x - e[_].x),
            (g = e[_ + 1].y - e[_].y),
            (m.x = g * 1),
            (m.y = -x),
            (m.z = g * 0),
            S.copy(m),
            m.normalize(),
            l.push(m.x, m.y, m.z);
          break;
        case e.length - 1:
          l.push(S.x, S.y, S.z);
          break;
        default:
          (x = e[_ + 1].x - e[_].x),
            (g = e[_ + 1].y - e[_].y),
            (m.x = g * 1),
            (m.y = -x),
            (m.z = g * 0),
            v.copy(m),
            (m.x += S.x),
            (m.y += S.y),
            (m.z += S.z),
            m.normalize(),
            l.push(m.x, m.y, m.z),
            S.copy(v);
      }
    for (let _ = 0; _ <= n; _++) {
      const y = r + _ * u * i,
        w = Math.sin(y),
        A = Math.cos(y);
      for (let M = 0; M <= e.length - 1; M++) {
        (d.x = e[M].x * w),
          (d.y = e[M].y),
          (d.z = e[M].x * A),
          a.push(d.x, d.y, d.z),
          (p.x = _ / n),
          (p.y = M / (e.length - 1)),
          s.push(p.x, p.y);
        const T = l[3 * M + 0] * w,
          I = l[3 * M + 1],
          R = l[3 * M + 0] * A;
        c.push(T, I, R);
      }
    }
    for (let _ = 0; _ < n; _++)
      for (let y = 0; y < e.length - 1; y++) {
        const w = y + _ * e.length,
          A = w,
          M = w + e.length,
          T = w + e.length + 1,
          I = w + 1;
        o.push(A, M, I), o.push(T, I, M);
      }
    this.setIndex(o),
      this.setAttribute("position", new wt(a, 3)),
      this.setAttribute("uv", new wt(s, 2)),
      this.setAttribute("normal", new wt(c, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new vm(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class d1 extends vm {
  constructor(e = 1, n = 1, r = 4, i = 8) {
    const o = new kp();
    o.absarc(0, -n / 2, e, Math.PI * 1.5, 0),
      o.absarc(0, n / 2, e, 0, Math.PI * 0.5),
      super(o.getPoints(r), i),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: n,
        capSegments: r,
        radialSegments: i,
      });
  }
  static fromJSON(e) {
    return new d1(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class f1 extends Jt {
  constructor(e = 1, n = 32, r = 0, i = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: n,
        thetaStart: r,
        thetaLength: i,
      }),
      (n = Math.max(3, n));
    const o = [],
      a = [],
      s = [],
      l = [],
      c = new K(),
      u = new Ge();
    a.push(0, 0, 0), s.push(0, 0, 1), l.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= n; d++, p += 3) {
      const m = r + (d / n) * i;
      (c.x = e * Math.cos(m)),
        (c.y = e * Math.sin(m)),
        a.push(c.x, c.y, c.z),
        s.push(0, 0, 1),
        (u.x = (a[p] / e + 1) / 2),
        (u.y = (a[p + 1] / e + 1) / 2),
        l.push(u.x, u.y);
    }
    for (let d = 1; d <= n; d++) o.push(d, d + 1, 0);
    this.setIndex(o),
      this.setAttribute("position", new wt(a, 3)),
      this.setAttribute("normal", new wt(s, 3)),
      this.setAttribute("uv", new wt(l, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new f1(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Rf extends Jt {
  constructor(
    e = 1,
    n = 1,
    r = 1,
    i = 32,
    o = 1,
    a = !1,
    s = 0,
    l = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: n,
        height: r,
        radialSegments: i,
        heightSegments: o,
        openEnded: a,
        thetaStart: s,
        thetaLength: l,
      });
    const c = this;
    (i = Math.floor(i)), (o = Math.floor(o));
    const u = [],
      d = [],
      p = [],
      m = [];
    let v = 0;
    const S = [],
      x = r / 2;
    let g = 0;
    _(),
      a === !1 && (e > 0 && y(!0), n > 0 && y(!1)),
      this.setIndex(u),
      this.setAttribute("position", new wt(d, 3)),
      this.setAttribute("normal", new wt(p, 3)),
      this.setAttribute("uv", new wt(m, 2));
    function _() {
      const w = new K(),
        A = new K();
      let M = 0;
      const T = (n - e) / r;
      for (let I = 0; I <= o; I++) {
        const R = [],
          P = I / o,
          F = P * (n - e) + e;
        for (let D = 0; D <= i; D++) {
          const j = D / i,
            N = j * l + s,
            V = Math.sin(N),
            W = Math.cos(N);
          (A.x = F * V),
            (A.y = -P * r + x),
            (A.z = F * W),
            d.push(A.x, A.y, A.z),
            w.set(V, T, W).normalize(),
            p.push(w.x, w.y, w.z),
            m.push(j, 1 - P),
            R.push(v++);
        }
        S.push(R);
      }
      for (let I = 0; I < i; I++)
        for (let R = 0; R < o; R++) {
          const P = S[R][I],
            F = S[R + 1][I],
            D = S[R + 1][I + 1],
            j = S[R][I + 1];
          u.push(P, F, j), u.push(F, D, j), (M += 6);
        }
      c.addGroup(g, M, 0), (g += M);
    }
    function y(w) {
      const A = v,
        M = new Ge(),
        T = new K();
      let I = 0;
      const R = w === !0 ? e : n,
        P = w === !0 ? 1 : -1;
      for (let D = 1; D <= i; D++)
        d.push(0, x * P, 0), p.push(0, P, 0), m.push(0.5, 0.5), v++;
      const F = v;
      for (let D = 0; D <= i; D++) {
        const N = (D / i) * l + s,
          V = Math.cos(N),
          W = Math.sin(N);
        (T.x = R * W),
          (T.y = x * P),
          (T.z = R * V),
          d.push(T.x, T.y, T.z),
          p.push(0, P, 0),
          (M.x = V * 0.5 + 0.5),
          (M.y = W * 0.5 * P + 0.5),
          m.push(M.x, M.y),
          v++;
      }
      for (let D = 0; D < i; D++) {
        const j = A + D,
          N = F + D;
        w === !0 ? u.push(N, N + 1, j) : u.push(N + 1, N, j), (I += 3);
      }
      c.addGroup(g, I, w === !0 ? 1 : 2), (g += I);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Rf(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class h1 extends Rf {
  constructor(e = 1, n = 1, r = 32, i = 1, o = !1, a = 0, s = Math.PI * 2) {
    super(0, e, n, r, i, o, a, s),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: n,
        radialSegments: r,
        heightSegments: i,
        openEnded: o,
        thetaStart: a,
        thetaLength: s,
      });
  }
  static fromJSON(e) {
    return new h1(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Ql extends Jt {
  constructor(e = [], n = [], r = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: n, radius: r, detail: i });
    const o = [],
      a = [];
    s(i),
      c(r),
      u(),
      this.setAttribute("position", new wt(o, 3)),
      this.setAttribute("normal", new wt(o.slice(), 3)),
      this.setAttribute("uv", new wt(a, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function s(_) {
      const y = new K(),
        w = new K(),
        A = new K();
      for (let M = 0; M < n.length; M += 3)
        m(n[M + 0], y), m(n[M + 1], w), m(n[M + 2], A), l(y, w, A, _);
    }
    function l(_, y, w, A) {
      const M = A + 1,
        T = [];
      for (let I = 0; I <= M; I++) {
        T[I] = [];
        const R = _.clone().lerp(w, I / M),
          P = y.clone().lerp(w, I / M),
          F = M - I;
        for (let D = 0; D <= F; D++)
          D === 0 && I === M
            ? (T[I][D] = R)
            : (T[I][D] = R.clone().lerp(P, D / F));
      }
      for (let I = 0; I < M; I++)
        for (let R = 0; R < 2 * (M - I) - 1; R++) {
          const P = Math.floor(R / 2);
          R % 2 === 0
            ? (p(T[I][P + 1]), p(T[I + 1][P]), p(T[I][P]))
            : (p(T[I][P + 1]), p(T[I + 1][P + 1]), p(T[I + 1][P]));
        }
    }
    function c(_) {
      const y = new K();
      for (let w = 0; w < o.length; w += 3)
        (y.x = o[w + 0]),
          (y.y = o[w + 1]),
          (y.z = o[w + 2]),
          y.normalize().multiplyScalar(_),
          (o[w + 0] = y.x),
          (o[w + 1] = y.y),
          (o[w + 2] = y.z);
    }
    function u() {
      const _ = new K();
      for (let y = 0; y < o.length; y += 3) {
        (_.x = o[y + 0]), (_.y = o[y + 1]), (_.z = o[y + 2]);
        const w = x(_) / 2 / Math.PI + 0.5,
          A = g(_) / Math.PI + 0.5;
        a.push(w, 1 - A);
      }
      v(), d();
    }
    function d() {
      for (let _ = 0; _ < a.length; _ += 6) {
        const y = a[_ + 0],
          w = a[_ + 2],
          A = a[_ + 4],
          M = Math.max(y, w, A),
          T = Math.min(y, w, A);
        M > 0.9 &&
          T < 0.1 &&
          (y < 0.2 && (a[_ + 0] += 1),
          w < 0.2 && (a[_ + 2] += 1),
          A < 0.2 && (a[_ + 4] += 1));
      }
    }
    function p(_) {
      o.push(_.x, _.y, _.z);
    }
    function m(_, y) {
      const w = _ * 3;
      (y.x = e[w + 0]), (y.y = e[w + 1]), (y.z = e[w + 2]);
    }
    function v() {
      const _ = new K(),
        y = new K(),
        w = new K(),
        A = new K(),
        M = new Ge(),
        T = new Ge(),
        I = new Ge();
      for (let R = 0, P = 0; R < o.length; R += 9, P += 6) {
        _.set(o[R + 0], o[R + 1], o[R + 2]),
          y.set(o[R + 3], o[R + 4], o[R + 5]),
          w.set(o[R + 6], o[R + 7], o[R + 8]),
          M.set(a[P + 0], a[P + 1]),
          T.set(a[P + 2], a[P + 3]),
          I.set(a[P + 4], a[P + 5]),
          A.copy(_).add(y).add(w).divideScalar(3);
        const F = x(A);
        S(M, P + 0, _, F), S(T, P + 2, y, F), S(I, P + 4, w, F);
      }
    }
    function S(_, y, w, A) {
      A < 0 && _.x === 1 && (a[y] = _.x - 1),
        w.x === 0 && w.z === 0 && (a[y] = A / 2 / Math.PI + 0.5);
    }
    function x(_) {
      return Math.atan2(_.z, -_.x);
    }
    function g(_) {
      return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ql(e.vertices, e.indices, e.radius, e.details);
  }
}
class p1 extends Ql {
  constructor(e = 1, n = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = 1 / r,
      o = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        0,
        -r,
        0,
        -i,
        r,
        0,
        -i,
        -r,
        0,
        i,
        r,
        0,
        i,
      ],
      a = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(o, a, e, n),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: n });
  }
  static fromJSON(e) {
    return new p1(e.radius, e.detail);
  }
}
const Sv = new K(),
  _v = new K(),
  r_ = new K(),
  bv = new qi();
class bD extends Jt {
  constructor(e = null, n = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: n }),
      e !== null)
    ) {
      const i = Math.pow(10, 4),
        o = Math.cos(Kc * n),
        a = e.getIndex(),
        s = e.getAttribute("position"),
        l = a ? a.count : s.count,
        c = [0, 0, 0],
        u = ["a", "b", "c"],
        d = new Array(3),
        p = {},
        m = [];
      for (let v = 0; v < l; v += 3) {
        a
          ? ((c[0] = a.getX(v)), (c[1] = a.getX(v + 1)), (c[2] = a.getX(v + 2)))
          : ((c[0] = v), (c[1] = v + 1), (c[2] = v + 2));
        const { a: S, b: x, c: g } = bv;
        if (
          (S.fromBufferAttribute(s, c[0]),
          x.fromBufferAttribute(s, c[1]),
          g.fromBufferAttribute(s, c[2]),
          bv.getNormal(r_),
          (d[0] = `${Math.round(S.x * i)},${Math.round(S.y * i)},${Math.round(
            S.z * i
          )}`),
          (d[1] = `${Math.round(x.x * i)},${Math.round(x.y * i)},${Math.round(
            x.z * i
          )}`),
          (d[2] = `${Math.round(g.x * i)},${Math.round(g.y * i)},${Math.round(
            g.z * i
          )}`),
          !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
        )
          for (let _ = 0; _ < 3; _++) {
            const y = (_ + 1) % 3,
              w = d[_],
              A = d[y],
              M = bv[u[_]],
              T = bv[u[y]],
              I = `${w}_${A}`,
              R = `${A}_${w}`;
            R in p && p[R]
              ? (r_.dot(p[R].normal) <= o &&
                  (m.push(M.x, M.y, M.z), m.push(T.x, T.y, T.z)),
                (p[R] = null))
              : I in p ||
                (p[I] = { index0: c[_], index1: c[y], normal: r_.clone() });
          }
      }
      for (const v in p)
        if (p[v]) {
          const { index0: S, index1: x } = p[v];
          Sv.fromBufferAttribute(s, S),
            _v.fromBufferAttribute(s, x),
            m.push(Sv.x, Sv.y, Sv.z),
            m.push(_v.x, _v.y, _v.z);
        }
      this.setAttribute("position", new wt(m, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class zl extends kp {
  constructor(e) {
    super(e), (this.uuid = Ao()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const n = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      n[r] = this.holes[r].getPoints(e);
    return n;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let n = 0, r = e.holes.length; n < r; n++) {
      const i = e.holes[n];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let n = 0, r = this.holes.length; n < r; n++) {
      const i = this.holes[n];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let n = 0, r = e.holes.length; n < r; n++) {
      const i = e.holes[n];
      this.holes.push(new kp().fromJSON(i));
    }
    return this;
  }
}
const cW = {
  triangulate: function (t, e, n = 2) {
    const r = e && e.length,
      i = r ? e[0] * n : t.length;
    let o = wD(t, 0, i, n, !0);
    const a = [];
    if (!o || o.next === o.prev) return a;
    let s, l, c, u, d, p, m;
    if ((r && (o = pW(t, e, o, n)), t.length > 80 * n)) {
      (s = c = t[0]), (l = u = t[1]);
      for (let v = n; v < i; v += n)
        (d = t[v]),
          (p = t[v + 1]),
          d < s && (s = d),
          p < l && (l = p),
          d > c && (c = d),
          p > u && (u = p);
      (m = Math.max(c - s, u - l)), (m = m !== 0 ? 32767 / m : 0);
    }
    return Bp(o, a, n, s, l, m, 0), a;
  },
};
function wD(t, e, n, r, i) {
  let o, a;
  if (i === MW(t, e, n, r) > 0)
    for (o = e; o < n; o += r) a = xP(o, t[o], t[o + 1], a);
  else for (o = n - r; o >= e; o -= r) a = xP(o, t[o], t[o + 1], a);
  return a && m1(a, a.next) && (jp(a), (a = a.next)), a;
}
function du(t, e) {
  if (!t) return t;
  e || (e = t);
  let n = t,
    r;
  do
    if (
      ((r = !1), !n.steiner && (m1(n, n.next) || Qn(n.prev, n, n.next) === 0))
    ) {
      if ((jp(n), (n = e = n.prev), n === n.next)) break;
      r = !0;
    } else n = n.next;
  while (r || n !== e);
  return e;
}
function Bp(t, e, n, r, i, o, a) {
  if (!t) return;
  !a && o && xW(t, r, i, o);
  let s = t,
    l,
    c;
  for (; t.prev !== t.next; ) {
    if (((l = t.prev), (c = t.next), o ? dW(t, r, i, o) : uW(t))) {
      e.push((l.i / n) | 0),
        e.push((t.i / n) | 0),
        e.push((c.i / n) | 0),
        jp(t),
        (t = c.next),
        (s = c.next);
      continue;
    }
    if (((t = c), t === s)) {
      a
        ? a === 1
          ? ((t = fW(du(t), e, n)), Bp(t, e, n, r, i, o, 2))
          : a === 2 && hW(t, e, n, r, i, o)
        : Bp(du(t), e, n, r, i, o, 1);
      break;
    }
  }
}
function uW(t) {
  const e = t.prev,
    n = t,
    r = t.next;
  if (Qn(e, n, r) >= 0) return !1;
  const i = e.x,
    o = n.x,
    a = r.x,
    s = e.y,
    l = n.y,
    c = r.y,
    u = i < o ? (i < a ? i : a) : o < a ? o : a,
    d = s < l ? (s < c ? s : c) : l < c ? l : c,
    p = i > o ? (i > a ? i : a) : o > a ? o : a,
    m = s > l ? (s > c ? s : c) : l > c ? l : c;
  let v = r.next;
  for (; v !== e; ) {
    if (
      v.x >= u &&
      v.x <= p &&
      v.y >= d &&
      v.y <= m &&
      jd(i, s, o, l, a, c, v.x, v.y) &&
      Qn(v.prev, v, v.next) >= 0
    )
      return !1;
    v = v.next;
  }
  return !0;
}
function dW(t, e, n, r) {
  const i = t.prev,
    o = t,
    a = t.next;
  if (Qn(i, o, a) >= 0) return !1;
  const s = i.x,
    l = o.x,
    c = a.x,
    u = i.y,
    d = o.y,
    p = a.y,
    m = s < l ? (s < c ? s : c) : l < c ? l : c,
    v = u < d ? (u < p ? u : p) : d < p ? d : p,
    S = s > l ? (s > c ? s : c) : l > c ? l : c,
    x = u > d ? (u > p ? u : p) : d > p ? d : p,
    g = Fw(m, v, e, n, r),
    _ = Fw(S, x, e, n, r);
  let y = t.prevZ,
    w = t.nextZ;
  for (; y && y.z >= g && w && w.z <= _; ) {
    if (
      (y.x >= m &&
        y.x <= S &&
        y.y >= v &&
        y.y <= x &&
        y !== i &&
        y !== a &&
        jd(s, u, l, d, c, p, y.x, y.y) &&
        Qn(y.prev, y, y.next) >= 0) ||
      ((y = y.prevZ),
      w.x >= m &&
        w.x <= S &&
        w.y >= v &&
        w.y <= x &&
        w !== i &&
        w !== a &&
        jd(s, u, l, d, c, p, w.x, w.y) &&
        Qn(w.prev, w, w.next) >= 0)
    )
      return !1;
    w = w.nextZ;
  }
  for (; y && y.z >= g; ) {
    if (
      y.x >= m &&
      y.x <= S &&
      y.y >= v &&
      y.y <= x &&
      y !== i &&
      y !== a &&
      jd(s, u, l, d, c, p, y.x, y.y) &&
      Qn(y.prev, y, y.next) >= 0
    )
      return !1;
    y = y.prevZ;
  }
  for (; w && w.z <= _; ) {
    if (
      w.x >= m &&
      w.x <= S &&
      w.y >= v &&
      w.y <= x &&
      w !== i &&
      w !== a &&
      jd(s, u, l, d, c, p, w.x, w.y) &&
      Qn(w.prev, w, w.next) >= 0
    )
      return !1;
    w = w.nextZ;
  }
  return !0;
}
function fW(t, e, n) {
  let r = t;
  do {
    const i = r.prev,
      o = r.next.next;
    !m1(i, o) &&
      ED(i, r, r.next, o) &&
      Hp(i, o) &&
      Hp(o, i) &&
      (e.push((i.i / n) | 0),
      e.push((r.i / n) | 0),
      e.push((o.i / n) | 0),
      jp(r),
      jp(r.next),
      (r = t = o)),
      (r = r.next);
  } while (r !== t);
  return du(r);
}
function hW(t, e, n, r, i, o) {
  let a = t;
  do {
    let s = a.next.next;
    for (; s !== a.prev; ) {
      if (a.i !== s.i && bW(a, s)) {
        let l = MD(a, s);
        (a = du(a, a.next)),
          (l = du(l, l.next)),
          Bp(a, e, n, r, i, o, 0),
          Bp(l, e, n, r, i, o, 0);
        return;
      }
      s = s.next;
    }
    a = a.next;
  } while (a !== t);
}
function pW(t, e, n, r) {
  const i = [];
  let o, a, s, l, c;
  for (o = 0, a = e.length; o < a; o++)
    (s = e[o] * r),
      (l = o < a - 1 ? e[o + 1] * r : t.length),
      (c = wD(t, s, l, r, !1)),
      c === c.next && (c.steiner = !0),
      i.push(_W(c));
  for (i.sort(mW), o = 0; o < i.length; o++) n = gW(i[o], n);
  return n;
}
function mW(t, e) {
  return t.x - e.x;
}
function gW(t, e) {
  const n = vW(t, e);
  if (!n) return e;
  const r = MD(n, t);
  return du(r, r.next), du(n, n.next);
}
function vW(t, e) {
  let n = e,
    r = -1 / 0,
    i;
  const o = t.x,
    a = t.y;
  do {
    if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
      const p = n.x + ((a - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
      if (
        p <= o &&
        p > r &&
        ((r = p), (i = n.x < n.next.x ? n : n.next), p === o)
      )
        return i;
    }
    n = n.next;
  } while (n !== e);
  if (!i) return null;
  const s = i,
    l = i.x,
    c = i.y;
  let u = 1 / 0,
    d;
  n = i;
  do
    o >= n.x &&
      n.x >= l &&
      o !== n.x &&
      jd(a < c ? o : r, a, l, c, a < c ? r : o, a, n.x, n.y) &&
      ((d = Math.abs(a - n.y) / (o - n.x)),
      Hp(n, t) &&
        (d < u || (d === u && (n.x > i.x || (n.x === i.x && yW(i, n))))) &&
        ((i = n), (u = d))),
      (n = n.next);
  while (n !== s);
  return i;
}
function yW(t, e) {
  return Qn(t.prev, t, e.prev) < 0 && Qn(e.next, t, t.next) < 0;
}
function xW(t, e, n, r) {
  let i = t;
  do
    i.z === 0 && (i.z = Fw(i.x, i.y, e, n, r)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== t);
  (i.prevZ.nextZ = null), (i.prevZ = null), SW(i);
}
function SW(t) {
  let e,
    n,
    r,
    i,
    o,
    a,
    s,
    l,
    c = 1;
  do {
    for (n = t, t = null, o = null, a = 0; n; ) {
      for (a++, r = n, s = 0, e = 0; e < c && (s++, (r = r.nextZ), !!r); e++);
      for (l = c; s > 0 || (l > 0 && r); )
        s !== 0 && (l === 0 || !r || n.z <= r.z)
          ? ((i = n), (n = n.nextZ), s--)
          : ((i = r), (r = r.nextZ), l--),
          o ? (o.nextZ = i) : (t = i),
          (i.prevZ = o),
          (o = i);
      n = r;
    }
    (o.nextZ = null), (c *= 2);
  } while (a > 1);
  return t;
}
function Fw(t, e, n, r, i) {
  return (
    (t = ((t - n) * i) | 0),
    (e = ((e - r) * i) | 0),
    (t = (t | (t << 8)) & 16711935),
    (t = (t | (t << 4)) & 252645135),
    (t = (t | (t << 2)) & 858993459),
    (t = (t | (t << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    t | (e << 1)
  );
}
function _W(t) {
  let e = t,
    n = t;
  do (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
  while (e !== t);
  return n;
}
function jd(t, e, n, r, i, o, a, s) {
  return (
    (i - a) * (e - s) >= (t - a) * (o - s) &&
    (t - a) * (r - s) >= (n - a) * (e - s) &&
    (n - a) * (o - s) >= (i - a) * (r - s)
  );
}
function bW(t, e) {
  return (
    t.next.i !== e.i &&
    t.prev.i !== e.i &&
    !wW(t, e) &&
    ((Hp(t, e) &&
      Hp(e, t) &&
      EW(t, e) &&
      (Qn(t.prev, t, e.prev) || Qn(t, e.prev, e))) ||
      (m1(t, e) && Qn(t.prev, t, t.next) > 0 && Qn(e.prev, e, e.next) > 0))
  );
}
function Qn(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
}
function m1(t, e) {
  return t.x === e.x && t.y === e.y;
}
function ED(t, e, n, r) {
  const i = Ev(Qn(t, e, n)),
    o = Ev(Qn(t, e, r)),
    a = Ev(Qn(n, r, t)),
    s = Ev(Qn(n, r, e));
  return !!(
    (i !== o && a !== s) ||
    (i === 0 && wv(t, n, e)) ||
    (o === 0 && wv(t, r, e)) ||
    (a === 0 && wv(n, t, r)) ||
    (s === 0 && wv(n, e, r))
  );
}
function wv(t, e, n) {
  return (
    e.x <= Math.max(t.x, n.x) &&
    e.x >= Math.min(t.x, n.x) &&
    e.y <= Math.max(t.y, n.y) &&
    e.y >= Math.min(t.y, n.y)
  );
}
function Ev(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function wW(t, e) {
  let n = t;
  do {
    if (
      n.i !== t.i &&
      n.next.i !== t.i &&
      n.i !== e.i &&
      n.next.i !== e.i &&
      ED(n, n.next, t, e)
    )
      return !0;
    n = n.next;
  } while (n !== t);
  return !1;
}
function Hp(t, e) {
  return Qn(t.prev, t, t.next) < 0
    ? Qn(t, e, t.next) >= 0 && Qn(t, t.prev, e) >= 0
    : Qn(t, e, t.prev) < 0 || Qn(t, t.next, e) < 0;
}
function EW(t, e) {
  let n = t,
    r = !1;
  const i = (t.x + e.x) / 2,
    o = (t.y + e.y) / 2;
  do
    n.y > o != n.next.y > o &&
      n.next.y !== n.y &&
      i < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x &&
      (r = !r),
      (n = n.next);
  while (n !== t);
  return r;
}
function MD(t, e) {
  const n = new Dw(t.i, t.x, t.y),
    r = new Dw(e.i, e.x, e.y),
    i = t.next,
    o = e.prev;
  return (
    (t.next = e),
    (e.prev = t),
    (n.next = i),
    (i.prev = n),
    (r.next = n),
    (n.prev = r),
    (o.next = r),
    (r.prev = o),
    r
  );
}
function xP(t, e, n, r) {
  const i = new Dw(t, e, n);
  return (
    r
      ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function jp(t) {
  (t.next.prev = t.prev),
    (t.prev.next = t.next),
    t.prevZ && (t.prevZ.nextZ = t.nextZ),
    t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function Dw(t, e, n) {
  (this.i = t),
    (this.x = e),
    (this.y = n),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function MW(t, e, n, r) {
  let i = 0;
  for (let o = e, a = n - r; o < n; o += r)
    (i += (t[a] - t[o]) * (t[o + 1] + t[a + 1])), (a = o);
  return i;
}
class ns {
  static area(e) {
    const n = e.length;
    let r = 0;
    for (let i = n - 1, o = 0; o < n; i = o++)
      r += e[i].x * e[o].y - e[o].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return ns.area(e) < 0;
  }
  static triangulateShape(e, n) {
    const r = [],
      i = [],
      o = [];
    SP(e), _P(r, e);
    let a = e.length;
    n.forEach(SP);
    for (let l = 0; l < n.length; l++)
      i.push(a), (a += n[l].length), _P(r, n[l]);
    const s = cW.triangulate(r, i);
    for (let l = 0; l < s.length; l += 3) o.push(s.slice(l, l + 3));
    return o;
  }
}
function SP(t) {
  const e = t.length;
  e > 2 && t[e - 1].equals(t[0]) && t.pop();
}
function _P(t, e) {
  for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
}
class g1 extends Jt {
  constructor(
    e = new zl([
      new Ge(0.5, 0.5),
      new Ge(-0.5, 0.5),
      new Ge(-0.5, -0.5),
      new Ge(0.5, -0.5),
    ]),
    n = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: n }),
      (e = Array.isArray(e) ? e : [e]);
    const r = this,
      i = [],
      o = [];
    for (let s = 0, l = e.length; s < l; s++) {
      const c = e[s];
      a(c);
    }
    this.setAttribute("position", new wt(i, 3)),
      this.setAttribute("uv", new wt(o, 2)),
      this.computeVertexNormals();
    function a(s) {
      const l = [],
        c = n.curveSegments !== void 0 ? n.curveSegments : 12,
        u = n.steps !== void 0 ? n.steps : 1,
        d = n.depth !== void 0 ? n.depth : 1;
      let p = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0,
        m = n.bevelThickness !== void 0 ? n.bevelThickness : 0.2,
        v = n.bevelSize !== void 0 ? n.bevelSize : m - 0.1,
        S = n.bevelOffset !== void 0 ? n.bevelOffset : 0,
        x = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
      const g = n.extrudePath,
        _ = n.UVGenerator !== void 0 ? n.UVGenerator : CW;
      let y,
        w = !1,
        A,
        M,
        T,
        I;
      g &&
        ((y = g.getSpacedPoints(u)),
        (w = !0),
        (p = !1),
        (A = g.computeFrenetFrames(u, !1)),
        (M = new K()),
        (T = new K()),
        (I = new K())),
        p || ((x = 0), (m = 0), (v = 0), (S = 0));
      const R = s.extractPoints(c);
      let P = R.shape;
      const F = R.holes;
      if (!ns.isClockWise(P)) {
        P = P.reverse();
        for (let Y = 0, ve = F.length; Y < ve; Y++) {
          const de = F[Y];
          ns.isClockWise(de) && (F[Y] = de.reverse());
        }
      }
      const j = ns.triangulateShape(P, F),
        N = P;
      for (let Y = 0, ve = F.length; Y < ve; Y++) {
        const de = F[Y];
        P = P.concat(de);
      }
      function V(Y, ve, de) {
        return (
          ve || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          Y.clone().addScaledVector(ve, de)
        );
      }
      const W = P.length,
        Q = j.length;
      function B(Y, ve, de) {
        let ue, fe, Te;
        const pe = Y.x - ve.x,
          H = Y.y - ve.y,
          z = de.x - Y.x,
          Z = de.y - Y.y,
          ge = pe * pe + H * H,
          ce = pe * Z - H * z;
        if (Math.abs(ce) > Number.EPSILON) {
          const he = Math.sqrt(ge),
            Me = Math.sqrt(z * z + Z * Z),
            Re = ve.x - H / he,
            Le = ve.y + pe / he,
            Oe = de.x - Z / Me,
            Pe = de.y + z / Me,
            Se = ((Oe - Re) * Z - (Pe - Le) * z) / (pe * Z - H * z);
          (ue = Re + pe * Se - Y.x), (fe = Le + H * Se - Y.y);
          const Je = ue * ue + fe * fe;
          if (Je <= 2) return new Ge(ue, fe);
          Te = Math.sqrt(Je / 2);
        } else {
          let he = !1;
          pe > Number.EPSILON
            ? z > Number.EPSILON && (he = !0)
            : pe < -Number.EPSILON
            ? z < -Number.EPSILON && (he = !0)
            : Math.sign(H) === Math.sign(Z) && (he = !0),
            he
              ? ((ue = -H), (fe = pe), (Te = Math.sqrt(ge)))
              : ((ue = pe), (fe = H), (Te = Math.sqrt(ge / 2)));
        }
        return new Ge(ue / Te, fe / Te);
      }
      const $ = [];
      for (
        let Y = 0, ve = N.length, de = ve - 1, ue = Y + 1;
        Y < ve;
        Y++, de++, ue++
      )
        de === ve && (de = 0),
          ue === ve && (ue = 0),
          ($[Y] = B(N[Y], N[de], N[ue]));
      const G = [];
      let k,
        q = $.concat();
      for (let Y = 0, ve = F.length; Y < ve; Y++) {
        const de = F[Y];
        k = [];
        for (
          let ue = 0, fe = de.length, Te = fe - 1, pe = ue + 1;
          ue < fe;
          ue++, Te++, pe++
        )
          Te === fe && (Te = 0),
            pe === fe && (pe = 0),
            (k[ue] = B(de[ue], de[Te], de[pe]));
        G.push(k), (q = q.concat(k));
      }
      for (let Y = 0; Y < x; Y++) {
        const ve = Y / x,
          de = m * Math.cos((ve * Math.PI) / 2),
          ue = v * Math.sin((ve * Math.PI) / 2) + S;
        for (let fe = 0, Te = N.length; fe < Te; fe++) {
          const pe = V(N[fe], $[fe], ue);
          ae(pe.x, pe.y, -de);
        }
        for (let fe = 0, Te = F.length; fe < Te; fe++) {
          const pe = F[fe];
          k = G[fe];
          for (let H = 0, z = pe.length; H < z; H++) {
            const Z = V(pe[H], k[H], ue);
            ae(Z.x, Z.y, -de);
          }
        }
      }
      const X = v + S;
      for (let Y = 0; Y < W; Y++) {
        const ve = p ? V(P[Y], q[Y], X) : P[Y];
        w
          ? (T.copy(A.normals[0]).multiplyScalar(ve.x),
            M.copy(A.binormals[0]).multiplyScalar(ve.y),
            I.copy(y[0]).add(T).add(M),
            ae(I.x, I.y, I.z))
          : ae(ve.x, ve.y, 0);
      }
      for (let Y = 1; Y <= u; Y++)
        for (let ve = 0; ve < W; ve++) {
          const de = p ? V(P[ve], q[ve], X) : P[ve];
          w
            ? (T.copy(A.normals[Y]).multiplyScalar(de.x),
              M.copy(A.binormals[Y]).multiplyScalar(de.y),
              I.copy(y[Y]).add(T).add(M),
              ae(I.x, I.y, I.z))
            : ae(de.x, de.y, (d / u) * Y);
        }
      for (let Y = x - 1; Y >= 0; Y--) {
        const ve = Y / x,
          de = m * Math.cos((ve * Math.PI) / 2),
          ue = v * Math.sin((ve * Math.PI) / 2) + S;
        for (let fe = 0, Te = N.length; fe < Te; fe++) {
          const pe = V(N[fe], $[fe], ue);
          ae(pe.x, pe.y, d + de);
        }
        for (let fe = 0, Te = F.length; fe < Te; fe++) {
          const pe = F[fe];
          k = G[fe];
          for (let H = 0, z = pe.length; H < z; H++) {
            const Z = V(pe[H], k[H], ue);
            w
              ? ae(Z.x, Z.y + y[u - 1].y, y[u - 1].x + de)
              : ae(Z.x, Z.y, d + de);
          }
        }
      }
      ee(), J();
      function ee() {
        const Y = i.length / 3;
        if (p) {
          let ve = 0,
            de = W * ve;
          for (let ue = 0; ue < Q; ue++) {
            const fe = j[ue];
            le(fe[2] + de, fe[1] + de, fe[0] + de);
          }
          (ve = u + x * 2), (de = W * ve);
          for (let ue = 0; ue < Q; ue++) {
            const fe = j[ue];
            le(fe[0] + de, fe[1] + de, fe[2] + de);
          }
        } else {
          for (let ve = 0; ve < Q; ve++) {
            const de = j[ve];
            le(de[2], de[1], de[0]);
          }
          for (let ve = 0; ve < Q; ve++) {
            const de = j[ve];
            le(de[0] + W * u, de[1] + W * u, de[2] + W * u);
          }
        }
        r.addGroup(Y, i.length / 3 - Y, 0);
      }
      function J() {
        const Y = i.length / 3;
        let ve = 0;
        oe(N, ve), (ve += N.length);
        for (let de = 0, ue = F.length; de < ue; de++) {
          const fe = F[de];
          oe(fe, ve), (ve += fe.length);
        }
        r.addGroup(Y, i.length / 3 - Y, 1);
      }
      function oe(Y, ve) {
        let de = Y.length;
        for (; --de >= 0; ) {
          const ue = de;
          let fe = de - 1;
          fe < 0 && (fe = Y.length - 1);
          for (let Te = 0, pe = u + x * 2; Te < pe; Te++) {
            const H = W * Te,
              z = W * (Te + 1),
              Z = ve + ue + H,
              ge = ve + fe + H,
              ce = ve + fe + z,
              he = ve + ue + z;
            _e(Z, ge, ce, he);
          }
        }
      }
      function ae(Y, ve, de) {
        l.push(Y), l.push(ve), l.push(de);
      }
      function le(Y, ve, de) {
        me(Y), me(ve), me(de);
        const ue = i.length / 3,
          fe = _.generateTopUV(r, i, ue - 3, ue - 2, ue - 1);
        se(fe[0]), se(fe[1]), se(fe[2]);
      }
      function _e(Y, ve, de, ue) {
        me(Y), me(ve), me(ue), me(ve), me(de), me(ue);
        const fe = i.length / 3,
          Te = _.generateSideWallUV(r, i, fe - 6, fe - 3, fe - 2, fe - 1);
        se(Te[0]), se(Te[1]), se(Te[3]), se(Te[1]), se(Te[2]), se(Te[3]);
      }
      function me(Y) {
        i.push(l[Y * 3 + 0]), i.push(l[Y * 3 + 1]), i.push(l[Y * 3 + 2]);
      }
      function se(Y) {
        o.push(Y.x), o.push(Y.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      n = this.parameters.shapes,
      r = this.parameters.options;
    return TW(n, r, e);
  }
  static fromJSON(e, n) {
    const r = [];
    for (let o = 0, a = e.shapes.length; o < a; o++) {
      const s = n[e.shapes[o]];
      r.push(s);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new fy[i.type]().fromJSON(i)),
      new g1(r, e.options)
    );
  }
}
const CW = {
  generateTopUV: function (t, e, n, r, i) {
    const o = e[n * 3],
      a = e[n * 3 + 1],
      s = e[r * 3],
      l = e[r * 3 + 1],
      c = e[i * 3],
      u = e[i * 3 + 1];
    return [new Ge(o, a), new Ge(s, l), new Ge(c, u)];
  },
  generateSideWallUV: function (t, e, n, r, i, o) {
    const a = e[n * 3],
      s = e[n * 3 + 1],
      l = e[n * 3 + 2],
      c = e[r * 3],
      u = e[r * 3 + 1],
      d = e[r * 3 + 2],
      p = e[i * 3],
      m = e[i * 3 + 1],
      v = e[i * 3 + 2],
      S = e[o * 3],
      x = e[o * 3 + 1],
      g = e[o * 3 + 2];
    return Math.abs(s - u) < Math.abs(a - c)
      ? [new Ge(a, 1 - l), new Ge(c, 1 - d), new Ge(p, 1 - v), new Ge(S, 1 - g)]
      : [
          new Ge(s, 1 - l),
          new Ge(u, 1 - d),
          new Ge(m, 1 - v),
          new Ge(x, 1 - g),
        ];
  },
};
function TW(t, e, n) {
  if (((n.shapes = []), Array.isArray(t)))
    for (let r = 0, i = t.length; r < i; r++) {
      const o = t[r];
      n.shapes.push(o.uuid);
    }
  else n.shapes.push(t.uuid);
  return (
    (n.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (n.options.extrudePath = e.extrudePath.toJSON()),
    n
  );
}
class v1 extends Ql {
  constructor(e = 1, n = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        0,
        0,
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        r,
        0,
        -1,
        r,
        0,
        1,
        -r,
        0,
        -1,
        -r,
        0,
        1,
      ],
      o = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(i, o, e, n),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: n });
  }
  static fromJSON(e) {
    return new v1(e.radius, e.detail);
  }
}
class ym extends Ql {
  constructor(e = 1, n = 0) {
    const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(r, i, e, n),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: n });
  }
  static fromJSON(e) {
    return new ym(e.radius, e.detail);
  }
}
class y1 extends Jt {
  constructor(e = 0.5, n = 1, r = 32, i = 1, o = 0, a = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: n,
        thetaSegments: r,
        phiSegments: i,
        thetaStart: o,
        thetaLength: a,
      }),
      (r = Math.max(3, r)),
      (i = Math.max(1, i));
    const s = [],
      l = [],
      c = [],
      u = [];
    let d = e;
    const p = (n - e) / i,
      m = new K(),
      v = new Ge();
    for (let S = 0; S <= i; S++) {
      for (let x = 0; x <= r; x++) {
        const g = o + (x / r) * a;
        (m.x = d * Math.cos(g)),
          (m.y = d * Math.sin(g)),
          l.push(m.x, m.y, m.z),
          c.push(0, 0, 1),
          (v.x = (m.x / n + 1) / 2),
          (v.y = (m.y / n + 1) / 2),
          u.push(v.x, v.y);
      }
      d += p;
    }
    for (let S = 0; S < i; S++) {
      const x = S * (r + 1);
      for (let g = 0; g < r; g++) {
        const _ = g + x,
          y = _,
          w = _ + r + 1,
          A = _ + r + 2,
          M = _ + 1;
        s.push(y, w, M), s.push(w, A, M);
      }
    }
    this.setIndex(s),
      this.setAttribute("position", new wt(l, 3)),
      this.setAttribute("normal", new wt(c, 3)),
      this.setAttribute("uv", new wt(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new y1(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class x1 extends Jt {
  constructor(
    e = new zl([new Ge(0, 0.5), new Ge(-0.5, -0.5), new Ge(0.5, -0.5)]),
    n = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: n });
    const r = [],
      i = [],
      o = [],
      a = [];
    let s = 0,
      l = 0;
    if (Array.isArray(e) === !1) c(e);
    else
      for (let u = 0; u < e.length; u++)
        c(e[u]), this.addGroup(s, l, u), (s += l), (l = 0);
    this.setIndex(r),
      this.setAttribute("position", new wt(i, 3)),
      this.setAttribute("normal", new wt(o, 3)),
      this.setAttribute("uv", new wt(a, 2));
    function c(u) {
      const d = i.length / 3,
        p = u.extractPoints(n);
      let m = p.shape;
      const v = p.holes;
      ns.isClockWise(m) === !1 && (m = m.reverse());
      for (let x = 0, g = v.length; x < g; x++) {
        const _ = v[x];
        ns.isClockWise(_) === !0 && (v[x] = _.reverse());
      }
      const S = ns.triangulateShape(m, v);
      for (let x = 0, g = v.length; x < g; x++) {
        const _ = v[x];
        m = m.concat(_);
      }
      for (let x = 0, g = m.length; x < g; x++) {
        const _ = m[x];
        i.push(_.x, _.y, 0), o.push(0, 0, 1), a.push(_.x, _.y);
      }
      for (let x = 0, g = S.length; x < g; x++) {
        const _ = S[x],
          y = _[0] + d,
          w = _[1] + d,
          A = _[2] + d;
        r.push(y, w, A), (l += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      n = this.parameters.shapes;
    return AW(n, e);
  }
  static fromJSON(e, n) {
    const r = [];
    for (let i = 0, o = e.shapes.length; i < o; i++) {
      const a = n[e.shapes[i]];
      r.push(a);
    }
    return new x1(r, e.curveSegments);
  }
}
function AW(t, e) {
  if (((e.shapes = []), Array.isArray(t)))
    for (let n = 0, r = t.length; n < r; n++) {
      const i = t[n];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(t.uuid);
  return e;
}
class xm extends Jt {
  constructor(
    e = 1,
    n = 32,
    r = 16,
    i = 0,
    o = Math.PI * 2,
    a = 0,
    s = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: n,
        heightSegments: r,
        phiStart: i,
        phiLength: o,
        thetaStart: a,
        thetaLength: s,
      }),
      (n = Math.max(3, Math.floor(n))),
      (r = Math.max(2, Math.floor(r)));
    const l = Math.min(a + s, Math.PI);
    let c = 0;
    const u = [],
      d = new K(),
      p = new K(),
      m = [],
      v = [],
      S = [],
      x = [];
    for (let g = 0; g <= r; g++) {
      const _ = [],
        y = g / r;
      let w = 0;
      g === 0 && a === 0
        ? (w = 0.5 / n)
        : g === r && l === Math.PI && (w = -0.5 / n);
      for (let A = 0; A <= n; A++) {
        const M = A / n;
        (d.x = -e * Math.cos(i + M * o) * Math.sin(a + y * s)),
          (d.y = e * Math.cos(a + y * s)),
          (d.z = e * Math.sin(i + M * o) * Math.sin(a + y * s)),
          v.push(d.x, d.y, d.z),
          p.copy(d).normalize(),
          S.push(p.x, p.y, p.z),
          x.push(M + w, 1 - y),
          _.push(c++);
      }
      u.push(_);
    }
    for (let g = 0; g < r; g++)
      for (let _ = 0; _ < n; _++) {
        const y = u[g][_ + 1],
          w = u[g][_],
          A = u[g + 1][_],
          M = u[g + 1][_ + 1];
        (g !== 0 || a > 0) && m.push(y, w, M),
          (g !== r - 1 || l < Math.PI) && m.push(w, A, M);
      }
    this.setIndex(m),
      this.setAttribute("position", new wt(v, 3)),
      this.setAttribute("normal", new wt(S, 3)),
      this.setAttribute("uv", new wt(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new xm(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class S1 extends Ql {
  constructor(e = 1, n = 0) {
    const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(r, i, e, n),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: n });
  }
  static fromJSON(e) {
    return new S1(e.radius, e.detail);
  }
}
class _1 extends Jt {
  constructor(e = 1, n = 0.4, r = 12, i = 48, o = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: n,
        radialSegments: r,
        tubularSegments: i,
        arc: o,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const a = [],
      s = [],
      l = [],
      c = [],
      u = new K(),
      d = new K(),
      p = new K();
    for (let m = 0; m <= r; m++)
      for (let v = 0; v <= i; v++) {
        const S = (v / i) * o,
          x = (m / r) * Math.PI * 2;
        (d.x = (e + n * Math.cos(x)) * Math.cos(S)),
          (d.y = (e + n * Math.cos(x)) * Math.sin(S)),
          (d.z = n * Math.sin(x)),
          s.push(d.x, d.y, d.z),
          (u.x = e * Math.cos(S)),
          (u.y = e * Math.sin(S)),
          p.subVectors(d, u).normalize(),
          l.push(p.x, p.y, p.z),
          c.push(v / i),
          c.push(m / r);
      }
    for (let m = 1; m <= r; m++)
      for (let v = 1; v <= i; v++) {
        const S = (i + 1) * m + v - 1,
          x = (i + 1) * (m - 1) + v - 1,
          g = (i + 1) * (m - 1) + v,
          _ = (i + 1) * m + v;
        a.push(S, x, _), a.push(x, g, _);
      }
    this.setIndex(a),
      this.setAttribute("position", new wt(s, 3)),
      this.setAttribute("normal", new wt(l, 3)),
      this.setAttribute("uv", new wt(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new _1(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class b1 extends Jt {
  constructor(e = 1, n = 0.4, r = 64, i = 8, o = 2, a = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: n,
        tubularSegments: r,
        radialSegments: i,
        p: o,
        q: a,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const s = [],
      l = [],
      c = [],
      u = [],
      d = new K(),
      p = new K(),
      m = new K(),
      v = new K(),
      S = new K(),
      x = new K(),
      g = new K();
    for (let y = 0; y <= r; ++y) {
      const w = (y / r) * o * Math.PI * 2;
      _(w, o, a, e, m),
        _(w + 0.01, o, a, e, v),
        x.subVectors(v, m),
        g.addVectors(v, m),
        S.crossVectors(x, g),
        g.crossVectors(S, x),
        S.normalize(),
        g.normalize();
      for (let A = 0; A <= i; ++A) {
        const M = (A / i) * Math.PI * 2,
          T = -n * Math.cos(M),
          I = n * Math.sin(M);
        (d.x = m.x + (T * g.x + I * S.x)),
          (d.y = m.y + (T * g.y + I * S.y)),
          (d.z = m.z + (T * g.z + I * S.z)),
          l.push(d.x, d.y, d.z),
          p.subVectors(d, m).normalize(),
          c.push(p.x, p.y, p.z),
          u.push(y / r),
          u.push(A / i);
      }
    }
    for (let y = 1; y <= r; y++)
      for (let w = 1; w <= i; w++) {
        const A = (i + 1) * (y - 1) + (w - 1),
          M = (i + 1) * y + (w - 1),
          T = (i + 1) * y + w,
          I = (i + 1) * (y - 1) + w;
        s.push(A, M, I), s.push(M, T, I);
      }
    this.setIndex(s),
      this.setAttribute("position", new wt(l, 3)),
      this.setAttribute("normal", new wt(c, 3)),
      this.setAttribute("uv", new wt(u, 2));
    function _(y, w, A, M, T) {
      const I = Math.cos(y),
        R = Math.sin(y),
        P = (A / w) * y,
        F = Math.cos(P);
      (T.x = M * (2 + F) * 0.5 * I),
        (T.y = M * (2 + F) * R * 0.5),
        (T.z = M * Math.sin(P) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new b1(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class w1 extends Jt {
  constructor(
    e = new xC(new K(-1, -1, 0), new K(-1, 1, 0), new K(1, 1, 0)),
    n = 64,
    r = 1,
    i = 8,
    o = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: n,
        radius: r,
        radialSegments: i,
        closed: o,
      });
    const a = e.computeFrenetFrames(n, o);
    (this.tangents = a.tangents),
      (this.normals = a.normals),
      (this.binormals = a.binormals);
    const s = new K(),
      l = new K(),
      c = new Ge();
    let u = new K();
    const d = [],
      p = [],
      m = [],
      v = [];
    S(),
      this.setIndex(v),
      this.setAttribute("position", new wt(d, 3)),
      this.setAttribute("normal", new wt(p, 3)),
      this.setAttribute("uv", new wt(m, 2));
    function S() {
      for (let y = 0; y < n; y++) x(y);
      x(o === !1 ? n : 0), _(), g();
    }
    function x(y) {
      u = e.getPointAt(y / n, u);
      const w = a.normals[y],
        A = a.binormals[y];
      for (let M = 0; M <= i; M++) {
        const T = (M / i) * Math.PI * 2,
          I = Math.sin(T),
          R = -Math.cos(T);
        (l.x = R * w.x + I * A.x),
          (l.y = R * w.y + I * A.y),
          (l.z = R * w.z + I * A.z),
          l.normalize(),
          p.push(l.x, l.y, l.z),
          (s.x = u.x + r * l.x),
          (s.y = u.y + r * l.y),
          (s.z = u.z + r * l.z),
          d.push(s.x, s.y, s.z);
      }
    }
    function g() {
      for (let y = 1; y <= n; y++)
        for (let w = 1; w <= i; w++) {
          const A = (i + 1) * (y - 1) + (w - 1),
            M = (i + 1) * y + (w - 1),
            T = (i + 1) * y + w,
            I = (i + 1) * (y - 1) + w;
          v.push(A, M, I), v.push(M, T, I);
        }
    }
    function _() {
      for (let y = 0; y <= n; y++)
        for (let w = 0; w <= i; w++)
          (c.x = y / n), (c.y = w / i), m.push(c.x, c.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new w1(
      new fy[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class _C extends Jt {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const n = [],
        r = new Set(),
        i = new K(),
        o = new K();
      if (e.index !== null) {
        const a = e.attributes.position,
          s = e.index;
        let l = e.groups;
        l.length === 0 &&
          (l = [{ start: 0, count: s.count, materialIndex: 0 }]);
        for (let c = 0, u = l.length; c < u; ++c) {
          const d = l[c],
            p = d.start,
            m = d.count;
          for (let v = p, S = p + m; v < S; v += 3)
            for (let x = 0; x < 3; x++) {
              const g = s.getX(v + x),
                _ = s.getX(v + ((x + 1) % 3));
              i.fromBufferAttribute(a, g),
                o.fromBufferAttribute(a, _),
                bP(i, o, r) === !0 &&
                  (n.push(i.x, i.y, i.z), n.push(o.x, o.y, o.z));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let s = 0, l = a.count / 3; s < l; s++)
          for (let c = 0; c < 3; c++) {
            const u = 3 * s + c,
              d = 3 * s + ((c + 1) % 3);
            i.fromBufferAttribute(a, u),
              o.fromBufferAttribute(a, d),
              bP(i, o, r) === !0 &&
                (n.push(i.x, i.y, i.z), n.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute("position", new wt(n, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function bP(t, e, n) {
  const r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
  return n.has(r) === !0 || n.has(i) === !0 ? !1 : (n.add(r), n.add(i), !0);
}
var wP = Object.freeze({
  __proto__: null,
  BoxGeometry: xu,
  CapsuleGeometry: d1,
  CircleGeometry: f1,
  ConeGeometry: h1,
  CylinderGeometry: Rf,
  DodecahedronGeometry: p1,
  EdgesGeometry: bD,
  ExtrudeGeometry: g1,
  IcosahedronGeometry: v1,
  LatheGeometry: vm,
  OctahedronGeometry: ym,
  PlaneGeometry: Zl,
  PolyhedronGeometry: Ql,
  RingGeometry: y1,
  ShapeGeometry: x1,
  SphereGeometry: xm,
  TetrahedronGeometry: S1,
  TorusGeometry: _1,
  TorusKnotGeometry: b1,
  TubeGeometry: w1,
  WireframeGeometry: _C,
});
class CD extends yi {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new pt(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class TD extends Ia {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class bC extends yi {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new pt(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new pt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Yl),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class AD extends bC {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Ge(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return ar((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (n) {
          this.ior = (1 + 0.4 * n) / (1 - 0.4 * n);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new pt(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new pt(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new pt(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class RD extends yi {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new pt(16777215)),
      (this.specular = new pt(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new pt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Yl),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = dm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class PD extends yi {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new pt(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new pt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Yl),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class ID extends yi {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Yl),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class LD extends yi {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new pt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new pt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Yl),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = dm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class OD extends yi {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new pt(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Yl),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class ND extends zi {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function jc(t, e, n) {
  return !t || (!n && t.constructor === e)
    ? t
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(t)
    : Array.prototype.slice.call(t);
}
function FD(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function DD(t) {
  function e(i, o) {
    return t[i] - t[o];
  }
  const n = t.length,
    r = new Array(n);
  for (let i = 0; i !== n; ++i) r[i] = i;
  return r.sort(e), r;
}
function zw(t, e, n) {
  const r = t.length,
    i = new t.constructor(r);
  for (let o = 0, a = 0; a !== r; ++o) {
    const s = n[o] * e;
    for (let l = 0; l !== e; ++l) i[a++] = t[s + l];
  }
  return i;
}
function wC(t, e, n, r) {
  let i = 1,
    o = t[0];
  for (; o !== void 0 && o[r] === void 0; ) o = t[i++];
  if (o === void 0) return;
  let a = o[r];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        (a = o[r]),
          a !== void 0 && (e.push(o.time), n.push.apply(n, a)),
          (o = t[i++]);
      while (o !== void 0);
    else if (a.toArray !== void 0)
      do
        (a = o[r]),
          a !== void 0 && (e.push(o.time), a.toArray(n, n.length)),
          (o = t[i++]);
      while (o !== void 0);
    else
      do (a = o[r]), a !== void 0 && (e.push(o.time), n.push(a)), (o = t[i++]);
      while (o !== void 0);
}
function RW(t, e, n, r, i = 30) {
  const o = t.clone();
  o.name = e;
  const a = [];
  for (let l = 0; l < o.tracks.length; ++l) {
    const c = o.tracks[l],
      u = c.getValueSize(),
      d = [],
      p = [];
    for (let m = 0; m < c.times.length; ++m) {
      const v = c.times[m] * i;
      if (!(v < n || v >= r)) {
        d.push(c.times[m]);
        for (let S = 0; S < u; ++S) p.push(c.values[m * u + S]);
      }
    }
    d.length !== 0 &&
      ((c.times = jc(d, c.times.constructor)),
      (c.values = jc(p, c.values.constructor)),
      a.push(c));
  }
  o.tracks = a;
  let s = 1 / 0;
  for (let l = 0; l < o.tracks.length; ++l)
    s > o.tracks[l].times[0] && (s = o.tracks[l].times[0]);
  for (let l = 0; l < o.tracks.length; ++l) o.tracks[l].shift(-1 * s);
  return o.resetDuration(), o;
}
function PW(t, e = 0, n = t, r = 30) {
  r <= 0 && (r = 30);
  const i = n.tracks.length,
    o = e / r;
  for (let a = 0; a < i; ++a) {
    const s = n.tracks[a],
      l = s.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const c = t.tracks.find(function (g) {
      return g.name === s.name && g.ValueTypeName === l;
    });
    if (c === void 0) continue;
    let u = 0;
    const d = s.getValueSize();
    s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (u = d / 3);
    let p = 0;
    const m = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = m / 3);
    const v = s.times.length - 1;
    let S;
    if (o <= s.times[0]) {
      const g = u,
        _ = d - u;
      S = s.values.slice(g, _);
    } else if (o >= s.times[v]) {
      const g = v * d + u,
        _ = g + d - u;
      S = s.values.slice(g, _);
    } else {
      const g = s.createInterpolant(),
        _ = u,
        y = d - u;
      g.evaluate(o), (S = g.resultBuffer.slice(_, y));
    }
    l === "quaternion" &&
      new mi().fromArray(S).normalize().conjugate().toArray(S);
    const x = c.times.length;
    for (let g = 0; g < x; ++g) {
      const _ = g * m + p;
      if (l === "quaternion")
        mi.multiplyQuaternionsFlat(c.values, _, S, 0, c.values, _);
      else {
        const y = m - p * 2;
        for (let w = 0; w < y; ++w) c.values[_ + w] -= S[w];
      }
    }
  }
  return (t.blendMode = JM), t;
}
const IW = {
  convertArray: jc,
  isTypedArray: FD,
  getKeyframeOrder: DD,
  sortedArray: zw,
  flattenJSON: wC,
  subclip: RW,
  makeClipAdditive: PW,
};
class Sm {
  constructor(e, n, r, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new n.constructor(r)),
      (this.sampleValues = n),
      (this.valueSize = r),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const n = this.parameterPositions;
    let r = this._cachedIndex,
      i = n[r],
      o = n[r - 1];
    e: {
      t: {
        let a;
        n: {
          r: if (!(e < i)) {
            for (let s = r + 2; ; ) {
              if (i === void 0) {
                if (e < o) break r;
                return (
                  (r = n.length),
                  (this._cachedIndex = r),
                  this.copySampleValue_(r - 1)
                );
              }
              if (r === s) break;
              if (((o = i), (i = n[++r]), e < i)) break t;
            }
            a = n.length;
            break n;
          }
          if (!(e >= o)) {
            const s = n[1];
            e < s && ((r = 2), (o = s));
            for (let l = r - 2; ; ) {
              if (o === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (r === l) break;
              if (((i = o), (o = n[--r - 1]), e >= o)) break t;
            }
            (a = r), (r = 0);
            break n;
          }
          break e;
        }
        for (; r < a; ) {
          const s = (r + a) >>> 1;
          e < n[s] ? (a = s) : (r = s + 1);
        }
        if (((i = n[r]), (o = n[r - 1]), o === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (r = n.length),
            (this._cachedIndex = r),
            this.copySampleValue_(r - 1)
          );
      }
      (this._cachedIndex = r), this.intervalChanged_(r, o, i);
    }
    return this.interpolate_(r, o, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const n = this.resultBuffer,
      r = this.sampleValues,
      i = this.valueSize,
      o = e * i;
    for (let a = 0; a !== i; ++a) n[a] = r[o + a];
    return n;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class zD extends Sm {
  constructor(e, n, r, i) {
    super(e, n, r, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: kc, endingEnd: kc });
  }
  intervalChanged_(e, n, r) {
    const i = this.parameterPositions;
    let o = e - 2,
      a = e + 1,
      s = i[o],
      l = i[a];
    if (s === void 0)
      switch (this.getSettings_().endingStart) {
        case Bc:
          (o = e), (s = 2 * n - r);
          break;
        case Lp:
          (o = i.length - 2), (s = n + i[o] - i[o + 1]);
          break;
        default:
          (o = e), (s = r);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case Bc:
          (a = e), (l = 2 * r - n);
          break;
        case Lp:
          (a = 1), (l = r + i[1] - i[0]);
          break;
        default:
          (a = e - 1), (l = n);
      }
    const c = (r - n) * 0.5,
      u = this.valueSize;
    (this._weightPrev = c / (n - s)),
      (this._weightNext = c / (l - r)),
      (this._offsetPrev = o * u),
      (this._offsetNext = a * u);
  }
  interpolate_(e, n, r, i) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      s = this.valueSize,
      l = e * s,
      c = l - s,
      u = this._offsetPrev,
      d = this._offsetNext,
      p = this._weightPrev,
      m = this._weightNext,
      v = (r - n) / (i - n),
      S = v * v,
      x = S * v,
      g = -p * x + 2 * p * S - p * v,
      _ = (1 + p) * x + (-1.5 - 2 * p) * S + (-0.5 + p) * v + 1,
      y = (-1 - m) * x + (1.5 + m) * S + 0.5 * v,
      w = m * x - m * S;
    for (let A = 0; A !== s; ++A)
      o[A] = g * a[u + A] + _ * a[c + A] + y * a[l + A] + w * a[d + A];
    return o;
  }
}
class EC extends Sm {
  constructor(e, n, r, i) {
    super(e, n, r, i);
  }
  interpolate_(e, n, r, i) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      s = this.valueSize,
      l = e * s,
      c = l - s,
      u = (r - n) / (i - n),
      d = 1 - u;
    for (let p = 0; p !== s; ++p) o[p] = a[c + p] * d + a[l + p] * u;
    return o;
  }
}
class UD extends Sm {
  constructor(e, n, r, i) {
    super(e, n, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Na {
  constructor(e, n, r, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (n === void 0 || n.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = jc(n, this.TimeBufferType)),
      (this.values = jc(r, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const n = e.constructor;
    let r;
    if (n.toJSON !== this.toJSON) r = n.toJSON(e);
    else {
      r = {
        name: e.name,
        times: jc(e.times, Array),
        values: jc(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return (r.type = e.ValueTypeName), r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new UD(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new EC(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new zD(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let n;
    switch (e) {
      case Pp:
        n = this.InterpolantFactoryMethodDiscrete;
        break;
      case Ip:
        n = this.InterpolantFactoryMethodLinear;
        break;
      case _0:
        n = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (n === void 0) {
      const r =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return (this.createInterpolant = n), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Pp;
      case this.InterpolantFactoryMethodLinear:
        return Ip;
      case this.InterpolantFactoryMethodSmooth:
        return _0;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const n = this.times;
      for (let r = 0, i = n.length; r !== i; ++r) n[r] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const n = this.times;
      for (let r = 0, i = n.length; r !== i; ++r) n[r] *= e;
    }
    return this;
  }
  trim(e, n) {
    const r = this.times,
      i = r.length;
    let o = 0,
      a = i - 1;
    for (; o !== i && r[o] < e; ) ++o;
    for (; a !== -1 && r[a] > n; ) --a;
    if ((++a, o !== 0 || a !== i)) {
      o >= a && ((a = Math.max(a, 1)), (o = a - 1));
      const s = this.getValueSize();
      (this.times = r.slice(o, a)),
        (this.values = this.values.slice(o * s, a * s));
    }
    return this;
  }
  validate() {
    let e = !0;
    const n = this.getValueSize();
    n - Math.floor(n) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const r = this.times,
      i = this.values,
      o = r.length;
    o === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let a = null;
    for (let s = 0; s !== o; s++) {
      const l = r[s];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          s,
          l
        ),
          (e = !1);
        break;
      }
      if (a !== null && a > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, s, l, a),
          (e = !1);
        break;
      }
      a = l;
    }
    if (i !== void 0 && FD(i))
      for (let s = 0, l = i.length; s !== l; ++s) {
        const c = i[s];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            s,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      n = this.values.slice(),
      r = this.getValueSize(),
      i = this.getInterpolation() === _0,
      o = e.length - 1;
    let a = 1;
    for (let s = 1; s < o; ++s) {
      let l = !1;
      const c = e[s],
        u = e[s + 1];
      if (c !== u && (s !== 1 || c !== e[0]))
        if (i) l = !0;
        else {
          const d = s * r,
            p = d - r,
            m = d + r;
          for (let v = 0; v !== r; ++v) {
            const S = n[d + v];
            if (S !== n[p + v] || S !== n[m + v]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (s !== a) {
          e[a] = e[s];
          const d = s * r,
            p = a * r;
          for (let m = 0; m !== r; ++m) n[p + m] = n[d + m];
        }
        ++a;
      }
    }
    if (o > 0) {
      e[a] = e[o];
      for (let s = o * r, l = a * r, c = 0; c !== r; ++c) n[l + c] = n[s + c];
      ++a;
    }
    return (
      a !== e.length
        ? ((this.times = e.slice(0, a)), (this.values = n.slice(0, a * r)))
        : ((this.times = e), (this.values = n)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      n = this.values.slice(),
      r = this.constructor,
      i = new r(this.name, e, n);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
Na.prototype.TimeBufferType = Float32Array;
Na.prototype.ValueBufferType = Float32Array;
Na.prototype.DefaultInterpolation = Ip;
class Su extends Na {}
Su.prototype.ValueTypeName = "bool";
Su.prototype.ValueBufferType = Array;
Su.prototype.DefaultInterpolation = Pp;
Su.prototype.InterpolantFactoryMethodLinear = void 0;
Su.prototype.InterpolantFactoryMethodSmooth = void 0;
class MC extends Na {}
MC.prototype.ValueTypeName = "color";
class Vp extends Na {}
Vp.prototype.ValueTypeName = "number";
class kD extends Sm {
  constructor(e, n, r, i) {
    super(e, n, r, i);
  }
  interpolate_(e, n, r, i) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      s = this.valueSize,
      l = (r - n) / (i - n);
    let c = e * s;
    for (let u = c + s; c !== u; c += 4) mi.slerpFlat(o, 0, a, c - s, a, c, l);
    return o;
  }
}
class Pf extends Na {
  InterpolantFactoryMethodLinear(e) {
    return new kD(this.times, this.values, this.getValueSize(), e);
  }
}
Pf.prototype.ValueTypeName = "quaternion";
Pf.prototype.DefaultInterpolation = Ip;
Pf.prototype.InterpolantFactoryMethodSmooth = void 0;
class _u extends Na {}
_u.prototype.ValueTypeName = "string";
_u.prototype.ValueBufferType = Array;
_u.prototype.DefaultInterpolation = Pp;
_u.prototype.InterpolantFactoryMethodLinear = void 0;
_u.prototype.InterpolantFactoryMethodSmooth = void 0;
class $p extends Na {}
$p.prototype.ValueTypeName = "vector";
class Gp {
  constructor(e, n = -1, r, i = e1) {
    (this.name = e),
      (this.tracks = r),
      (this.duration = n),
      (this.blendMode = i),
      (this.uuid = Ao()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const n = [],
      r = e.tracks,
      i = 1 / (e.fps || 1);
    for (let a = 0, s = r.length; a !== s; ++a) n.push(OW(r[a]).scale(i));
    const o = new this(e.name, e.duration, n, e.blendMode);
    return (o.uuid = e.uuid), o;
  }
  static toJSON(e) {
    const n = [],
      r = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: n,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let o = 0, a = r.length; o !== a; ++o) n.push(Na.toJSON(r[o]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, n, r, i) {
    const o = n.length,
      a = [];
    for (let s = 0; s < o; s++) {
      let l = [],
        c = [];
      l.push((s + o - 1) % o, s, (s + 1) % o), c.push(0, 1, 0);
      const u = DD(l);
      (l = zw(l, 1, u)),
        (c = zw(c, 1, u)),
        !i && l[0] === 0 && (l.push(o), c.push(c[0])),
        a.push(
          new Vp(".morphTargetInfluences[" + n[s].name + "]", l, c).scale(1 / r)
        );
    }
    return new this(e, -1, a);
  }
  static findByName(e, n) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < r.length; i++) if (r[i].name === n) return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, n, r) {
    const i = {},
      o = /^([\w-]*?)([\d]+)$/;
    for (let s = 0, l = e.length; s < l; s++) {
      const c = e[s],
        u = c.name.match(o);
      if (u && u.length > 1) {
        const d = u[1];
        let p = i[d];
        p || (i[d] = p = []), p.push(c);
      }
    }
    const a = [];
    for (const s in i)
      a.push(this.CreateFromMorphTargetSequence(s, i[s], n, r));
    return a;
  }
  static parseAnimation(e, n) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const r = function (d, p, m, v, S) {
        if (m.length !== 0) {
          const x = [],
            g = [];
          wC(m, x, g, v), x.length !== 0 && S.push(new d(p, x, g));
        }
      },
      i = [],
      o = e.name || "default",
      a = e.fps || 30,
      s = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let d = 0; d < c.length; d++) {
      const p = c[d].keys;
      if (!(!p || p.length === 0))
        if (p[0].morphTargets) {
          const m = {};
          let v;
          for (v = 0; v < p.length; v++)
            if (p[v].morphTargets)
              for (let S = 0; S < p[v].morphTargets.length; S++)
                m[p[v].morphTargets[S]] = -1;
          for (const S in m) {
            const x = [],
              g = [];
            for (let _ = 0; _ !== p[v].morphTargets.length; ++_) {
              const y = p[v];
              x.push(y.time), g.push(y.morphTarget === S ? 1 : 0);
            }
            i.push(new Vp(".morphTargetInfluence[" + S + "]", x, g));
          }
          l = m.length * a;
        } else {
          const m = ".bones[" + n[d].name + "]";
          r($p, m + ".position", p, "pos", i),
            r(Pf, m + ".quaternion", p, "rot", i),
            r($p, m + ".scale", p, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(o, l, i, s);
  }
  resetDuration() {
    const e = this.tracks;
    let n = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const o = this.tracks[r];
      n = Math.max(n, o.times[o.times.length - 1]);
    }
    return (this.duration = n), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let n = 0; n < this.tracks.length; n++)
      e = e && this.tracks[n].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let n = 0; n < this.tracks.length; n++) e.push(this.tracks[n].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function LW(t) {
  switch (t.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Vp;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return $p;
    case "color":
      return MC;
    case "quaternion":
      return Pf;
    case "bool":
    case "boolean":
      return Su;
    case "string":
      return _u;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
}
function OW(t) {
  if (t.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = LW(t.type);
  if (t.times === void 0) {
    const n = [],
      r = [];
    wC(t.keys, n, r, "value"), (t.times = n), (t.values = r);
  }
  return e.parse !== void 0
    ? e.parse(t)
    : new e(t.name, t.times, t.values, t.interpolation);
}
const Os = {
  enabled: !1,
  files: {},
  add: function (t, e) {
    this.enabled !== !1 && (this.files[t] = e);
  },
  get: function (t) {
    if (this.enabled !== !1) return this.files[t];
  },
  remove: function (t) {
    delete this.files[t];
  },
  clear: function () {
    this.files = {};
  },
};
class CC {
  constructor(e, n, r) {
    const i = this;
    let o = !1,
      a = 0,
      s = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = n),
      (this.onError = r),
      (this.itemStart = function (u) {
        s++, o === !1 && i.onStart !== void 0 && i.onStart(u, a, s), (o = !0);
      }),
      (this.itemEnd = function (u) {
        a++,
          i.onProgress !== void 0 && i.onProgress(u, a, s),
          a === s && ((o = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (u) {
        i.onError !== void 0 && i.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return (l = u), this;
      }),
      (this.addHandler = function (u, d) {
        return c.push(u, d), this;
      }),
      (this.removeHandler = function (u) {
        const d = c.indexOf(u);
        return d !== -1 && c.splice(d, 2), this;
      }),
      (this.getHandler = function (u) {
        for (let d = 0, p = c.length; d < p; d += 2) {
          const m = c[d],
            v = c[d + 1];
          if ((m.global && (m.lastIndex = 0), m.test(u))) return v;
        }
        return null;
      });
  }
}
const BD = new CC();
class no {
  constructor(e) {
    (this.manager = e !== void 0 ? e : BD),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, n) {
    const r = this;
    return new Promise(function (i, o) {
      r.load(e, i, n, o);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
no.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const bs = {};
class NW extends Error {
  constructor(e, n) {
    super(e), (this.response = n);
  }
}
class $s extends no {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = Os.get(e);
    if (o !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          n && n(o), this.manager.itemEnd(e);
        }, 0),
        o
      );
    if (bs[e] !== void 0) {
      bs[e].push({ onLoad: n, onProgress: r, onError: i });
      return;
    }
    (bs[e] = []), bs[e].push({ onLoad: n, onProgress: r, onError: i });
    const a = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      s = this.mimeType,
      l = this.responseType;
    fetch(a)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const u = bs[e],
            d = c.body.getReader(),
            p = c.headers.get("Content-Length") || c.headers.get("X-File-Size"),
            m = p ? parseInt(p) : 0,
            v = m !== 0;
          let S = 0;
          const x = new ReadableStream({
            start(g) {
              _();
              function _() {
                d.read().then(({ done: y, value: w }) => {
                  if (y) g.close();
                  else {
                    S += w.byteLength;
                    const A = new ProgressEvent("progress", {
                      lengthComputable: v,
                      loaded: S,
                      total: m,
                    });
                    for (let M = 0, T = u.length; M < T; M++) {
                      const I = u[M];
                      I.onProgress && I.onProgress(A);
                    }
                    g.enqueue(w), _();
                  }
                });
              }
            },
          });
          return new Response(x);
        } else
          throw new NW(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((u) => new DOMParser().parseFromString(u, s));
          case "json":
            return c.json();
          default:
            if (s === void 0) return c.text();
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(s),
                p = d && d[1] ? d[1].toLowerCase() : void 0,
                m = new TextDecoder(p);
              return c.arrayBuffer().then((v) => m.decode(v));
            }
        }
      })
      .then((c) => {
        Os.add(e, c);
        const u = bs[e];
        delete bs[e];
        for (let d = 0, p = u.length; d < p; d++) {
          const m = u[d];
          m.onLoad && m.onLoad(c);
        }
      })
      .catch((c) => {
        const u = bs[e];
        if (u === void 0) throw (this.manager.itemError(e), c);
        delete bs[e];
        for (let d = 0, p = u.length; d < p; d++) {
          const m = u[d];
          m.onError && m.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class FW extends no {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = this,
      a = new $s(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (s) {
          try {
            n(o.parse(JSON.parse(s)));
          } catch (l) {
            i ? i(l) : console.error(l), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const i = Gp.parse(e[r]);
      n.push(i);
    }
    return n;
  }
}
class DW extends no {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = this,
      a = [],
      s = new c1(),
      l = new $s(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(o.withCredentials);
    let c = 0;
    function u(d) {
      l.load(
        e[d],
        function (p) {
          const m = o.parse(p, !0);
          (a[d] = {
            width: m.width,
            height: m.height,
            format: m.format,
            mipmaps: m.mipmaps,
          }),
            (c += 1),
            c === 6 &&
              (m.mipmapCount === 1 && (s.minFilter = Yn),
              (s.image = a),
              (s.format = m.format),
              (s.needsUpdate = !0),
              n && n(s));
        },
        r,
        i
      );
    }
    if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d) u(d);
    else
      l.load(
        e,
        function (d) {
          const p = o.parse(d, !0);
          if (p.isCubemap) {
            const m = p.mipmaps.length / p.mipmapCount;
            for (let v = 0; v < m; v++) {
              a[v] = { mipmaps: [] };
              for (let S = 0; S < p.mipmapCount; S++)
                a[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + S]),
                  (a[v].format = p.format),
                  (a[v].width = p.width),
                  (a[v].height = p.height);
            }
            s.image = a;
          } else
            (s.image.width = p.width),
              (s.image.height = p.height),
              (s.mipmaps = p.mipmaps);
          p.mipmapCount === 1 && (s.minFilter = Yn),
            (s.format = p.format),
            (s.needsUpdate = !0),
            n && n(s);
        },
        r,
        i
      );
    return s;
  }
}
class Wp extends no {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      a = Os.get(e);
    if (a !== void 0)
      return (
        o.manager.itemStart(e),
        setTimeout(function () {
          n && n(a), o.manager.itemEnd(e);
        }, 0),
        a
      );
    const s = zp("img");
    function l() {
      u(), Os.add(e, this), n && n(this), o.manager.itemEnd(e);
    }
    function c(d) {
      u(), i && i(d), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function u() {
      s.removeEventListener("load", l, !1),
        s.removeEventListener("error", c, !1);
    }
    return (
      s.addEventListener("load", l, !1),
      s.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (s.crossOrigin = this.crossOrigin),
      o.manager.itemStart(e),
      (s.src = e),
      s
    );
  }
}
class zW extends no {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = new mm();
    o.colorSpace = Tr;
    const a = new Wp(this.manager);
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
    let s = 0;
    function l(c) {
      a.load(
        e[c],
        function (u) {
          (o.images[c] = u), s++, s === 6 && ((o.needsUpdate = !0), n && n(o));
        },
        void 0,
        i
      );
    }
    for (let c = 0; c < e.length; ++c) l(c);
    return o;
  }
}
class UW extends no {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = this,
      a = new Zc(),
      s = new $s(this.manager);
    return (
      s.setResponseType("arraybuffer"),
      s.setRequestHeader(this.requestHeader),
      s.setPath(this.path),
      s.setWithCredentials(o.withCredentials),
      s.load(
        e,
        function (l) {
          let c;
          try {
            c = o.parse(l);
          } catch (u) {
            if (i !== void 0) i(u);
            else {
              console.error(u);
              return;
            }
          }
          c.image !== void 0
            ? (a.image = c.image)
            : c.data !== void 0 &&
              ((a.image.width = c.width),
              (a.image.height = c.height),
              (a.image.data = c.data)),
            (a.wrapS = c.wrapS !== void 0 ? c.wrapS : pi),
            (a.wrapT = c.wrapT !== void 0 ? c.wrapT : pi),
            (a.magFilter = c.magFilter !== void 0 ? c.magFilter : Yn),
            (a.minFilter = c.minFilter !== void 0 ? c.minFilter : Yn),
            (a.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.colorSpace !== void 0
              ? (a.colorSpace = c.colorSpace)
              : c.encoding !== void 0 && (a.encoding = c.encoding),
            c.flipY !== void 0 && (a.flipY = c.flipY),
            c.format !== void 0 && (a.format = c.format),
            c.type !== void 0 && (a.type = c.type),
            c.mipmaps !== void 0 &&
              ((a.mipmaps = c.mipmaps), (a.minFilter = Hl)),
            c.mipmapCount === 1 && (a.minFilter = Yn),
            c.generateMipmaps !== void 0 &&
              (a.generateMipmaps = c.generateMipmaps),
            (a.needsUpdate = !0),
            n && n(a, c);
        },
        r,
        i
      ),
      a
    );
  }
}
class kW extends no {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = new sr(),
      a = new Wp(this.manager);
    return (
      a.setCrossOrigin(this.crossOrigin),
      a.setPath(this.path),
      a.load(
        e,
        function (s) {
          (o.image = s), (o.needsUpdate = !0), n !== void 0 && n(o);
        },
        r,
        i
      ),
      o
    );
  }
}
class Jl extends Sn {
  constructor(e, n = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new pt(e)),
      (this.intensity = n);
  }
  dispose() {}
  copy(e, n) {
    return (
      super.copy(e, n),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.color = this.color.getHex()),
      (n.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (n.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (n.object.distance = this.distance),
      this.angle !== void 0 && (n.object.angle = this.angle),
      this.decay !== void 0 && (n.object.decay = this.decay),
      this.penumbra !== void 0 && (n.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()),
      n
    );
  }
}
class HD extends Jl {
  constructor(e, n, r) {
    super(e, r),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Sn.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new pt(n));
  }
  copy(e, n) {
    return super.copy(e, n), this.groundColor.copy(e.groundColor), this;
  }
}
const i_ = new kt(),
  EP = new K(),
  MP = new K();
class TC {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Ge(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new kt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new gm()),
      (this._frameExtents = new Ge(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new rn(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const n = this.camera,
      r = this.matrix;
    EP.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(EP),
      MP.setFromMatrixPosition(e.target.matrixWorld),
      n.lookAt(MP),
      n.updateMatrixWorld(),
      i_.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(i_),
      r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      r.multiply(i_);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class BW extends TC {
  constructor() {
    super(new Zn(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const n = this.camera,
      r = hf * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      o = e.distance || n.far;
    (r !== n.fov || i !== n.aspect || o !== n.far) &&
      ((n.fov = r), (n.aspect = i), (n.far = o), n.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class jD extends Jl {
  constructor(e, n, r = 0, i = Math.PI / 3, o = 0, a = 2) {
    super(e, n),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Sn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Sn()),
      (this.distance = r),
      (this.angle = i),
      (this.penumbra = o),
      (this.decay = a),
      (this.map = null),
      (this.shadow = new BW());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const CP = new kt(),
  xh = new K(),
  o_ = new K();
class HW extends TC {
  constructor() {
    super(new Zn(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Ge(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new rn(2, 1, 1, 1),
        new rn(0, 1, 1, 1),
        new rn(3, 1, 1, 1),
        new rn(1, 1, 1, 1),
        new rn(3, 0, 1, 1),
        new rn(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new K(1, 0, 0),
        new K(-1, 0, 0),
        new K(0, 0, 1),
        new K(0, 0, -1),
        new K(0, 1, 0),
        new K(0, -1, 0),
      ]),
      (this._cubeUps = [
        new K(0, 1, 0),
        new K(0, 1, 0),
        new K(0, 1, 0),
        new K(0, 1, 0),
        new K(0, 0, 1),
        new K(0, 0, -1),
      ]);
  }
  updateMatrices(e, n = 0) {
    const r = this.camera,
      i = this.matrix,
      o = e.distance || r.far;
    o !== r.far && ((r.far = o), r.updateProjectionMatrix()),
      xh.setFromMatrixPosition(e.matrixWorld),
      r.position.copy(xh),
      o_.copy(r.position),
      o_.add(this._cubeDirections[n]),
      r.up.copy(this._cubeUps[n]),
      r.lookAt(o_),
      r.updateMatrixWorld(),
      i.makeTranslation(-xh.x, -xh.y, -xh.z),
      CP.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(CP);
  }
}
class VD extends Jl {
  constructor(e, n, r = 0, i = 2) {
    super(e, n),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = r),
      (this.decay = i),
      (this.shadow = new HW());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class jW extends TC {
  constructor() {
    super(new ts(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class $D extends Jl {
  constructor(e, n) {
    super(e, n),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Sn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Sn()),
      (this.shadow = new jW());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class GD extends Jl {
  constructor(e, n) {
    super(e, n), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class WD extends Jl {
  constructor(e, n, r = 10, i = 10) {
    super(e, n),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = r),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (n.object.width = this.width), (n.object.height = this.height), n;
  }
}
class XD {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new K());
  }
  set(e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].copy(e[n]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, n) {
    const r = e.x,
      i = e.y,
      o = e.z,
      a = this.coefficients;
    return (
      n.copy(a[0]).multiplyScalar(0.282095),
      n.addScaledVector(a[1], 0.488603 * i),
      n.addScaledVector(a[2], 0.488603 * o),
      n.addScaledVector(a[3], 0.488603 * r),
      n.addScaledVector(a[4], 1.092548 * (r * i)),
      n.addScaledVector(a[5], 1.092548 * (i * o)),
      n.addScaledVector(a[6], 0.315392 * (3 * o * o - 1)),
      n.addScaledVector(a[7], 1.092548 * (r * o)),
      n.addScaledVector(a[8], 0.546274 * (r * r - i * i)),
      n
    );
  }
  getIrradianceAt(e, n) {
    const r = e.x,
      i = e.y,
      o = e.z,
      a = this.coefficients;
    return (
      n.copy(a[0]).multiplyScalar(0.886227),
      n.addScaledVector(a[1], 2 * 0.511664 * i),
      n.addScaledVector(a[2], 2 * 0.511664 * o),
      n.addScaledVector(a[3], 2 * 0.511664 * r),
      n.addScaledVector(a[4], 2 * 0.429043 * r * i),
      n.addScaledVector(a[5], 2 * 0.429043 * i * o),
      n.addScaledVector(a[6], 0.743125 * o * o - 0.247708),
      n.addScaledVector(a[7], 2 * 0.429043 * r * o),
      n.addScaledVector(a[8], 0.429043 * (r * r - i * i)),
      n
    );
  }
  add(e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].add(e.coefficients[n]);
    return this;
  }
  addScaledSH(e, n) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], n);
    return this;
  }
  scale(e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].multiplyScalar(e);
    return this;
  }
  lerp(e, n) {
    for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], n);
    return this;
  }
  equals(e) {
    for (let n = 0; n < 9; n++)
      if (!this.coefficients[n].equals(e.coefficients[n])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, n = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].fromArray(e, n + i * 3);
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].toArray(e, n + i * 3);
    return e;
  }
  static getBasisAt(e, n) {
    const r = e.x,
      i = e.y,
      o = e.z;
    (n[0] = 0.282095),
      (n[1] = 0.488603 * i),
      (n[2] = 0.488603 * o),
      (n[3] = 0.488603 * r),
      (n[4] = 1.092548 * r * i),
      (n[5] = 1.092548 * i * o),
      (n[6] = 0.315392 * (3 * o * o - 1)),
      (n[7] = 1.092548 * r * o),
      (n[8] = 0.546274 * (r * r - i * i));
  }
}
class qD extends Jl {
  constructor(e = new XD(), n = 1) {
    super(void 0, n), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (n.object.sh = this.sh.toArray()), n;
  }
}
class E1 extends no {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, n, r, i) {
    const o = this,
      a = new $s(o.manager);
    a.setPath(o.path),
      a.setRequestHeader(o.requestHeader),
      a.setWithCredentials(o.withCredentials),
      a.load(
        e,
        function (s) {
          try {
            n(o.parse(JSON.parse(s)));
          } catch (l) {
            i ? i(l) : console.error(l), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const n = this.textures;
    function r(o) {
      return (
        n[o] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", o),
        n[o]
      );
    }
    const i = E1.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new pt().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        i.emissive !== void 0 &&
        i.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        i.specular !== void 0 &&
        i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = e.clearcoatRoughness),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (i.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (i.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        i.blendColor !== void 0 &&
        i.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== void 0 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const o in e.uniforms) {
        const a = e.uniforms[o];
        switch (((i.uniforms[o] = {}), a.type)) {
          case "t":
            i.uniforms[o].value = r(a.value);
            break;
          case "c":
            i.uniforms[o].value = new pt().setHex(a.value);
            break;
          case "v2":
            i.uniforms[o].value = new Ge().fromArray(a.value);
            break;
          case "v3":
            i.uniforms[o].value = new K().fromArray(a.value);
            break;
          case "v4":
            i.uniforms[o].value = new rn().fromArray(a.value);
            break;
          case "m3":
            i.uniforms[o].value = new Yt().fromArray(a.value);
            break;
          case "m4":
            i.uniforms[o].value = new kt().fromArray(a.value);
            break;
          default:
            i.uniforms[o].value = a.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const o in e.extensions) i.extensions[o] = e.extensions[o];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = r(e.map)),
      e.matcap !== void 0 && (i.matcap = r(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let o = e.normalScale;
      Array.isArray(o) === !1 && (o = [o, o]),
        (i.normalScale = new Ge().fromArray(o));
    }
    return (
      e.displacementMap !== void 0 &&
        (i.displacementMap = r(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = r(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (i.specularColorMap = r(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = r(e.envMap)),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = r(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new Ge().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (i.transmissionMap = r(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = r(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const n = {
      ShadowMaterial: CD,
      SpriteMaterial: fC,
      RawShaderMaterial: TD,
      ShaderMaterial: Ia,
      PointsMaterial: pC,
      MeshPhysicalMaterial: AD,
      MeshStandardMaterial: bC,
      MeshPhongMaterial: RD,
      MeshToonMaterial: PD,
      MeshNormalMaterial: ID,
      MeshLambertMaterial: LD,
      MeshDepthMaterial: i1,
      MeshDistanceMaterial: o1,
      MeshBasicMaterial: Ks,
      MeshMatcapMaterial: OD,
      LineDashedMaterial: ND,
      LineBasicMaterial: zi,
      Material: yi,
    };
    return new n[e]();
  }
}
class Uw {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let n = "";
    for (let r = 0, i = e.length; r < i; r++) n += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(n));
    } catch {
      return n;
    }
  }
  static extractUrlBase(e) {
    const n = e.lastIndexOf("/");
    return n === -1 ? "./" : e.slice(0, n + 1);
  }
  static resolveURL(e, n) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(n) &&
          /^\//.test(e) &&
          (n = n.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : n + e);
  }
}
class M1 extends Jt {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class KD extends no {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = this,
      a = new $s(o.manager);
    a.setPath(o.path),
      a.setRequestHeader(o.requestHeader),
      a.setWithCredentials(o.withCredentials),
      a.load(
        e,
        function (s) {
          try {
            n(o.parse(JSON.parse(s)));
          } catch (l) {
            i ? i(l) : console.error(l), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const n = {},
      r = {};
    function i(m, v) {
      if (n[v] !== void 0) return n[v];
      const x = m.interleavedBuffers[v],
        g = o(m, x.buffer),
        _ = Ud(x.type, g),
        y = new l1(_, x.stride);
      return (y.uuid = x.uuid), (n[v] = y), y;
    }
    function o(m, v) {
      if (r[v] !== void 0) return r[v];
      const x = m.arrayBuffers[v],
        g = new Uint32Array(x).buffer;
      return (r[v] = g), g;
    }
    const a = e.isInstancedBufferGeometry ? new M1() : new Jt(),
      s = e.data.index;
    if (s !== void 0) {
      const m = Ud(s.type, s.array);
      a.setIndex(new wn(m, 1));
    }
    const l = e.data.attributes;
    for (const m in l) {
      const v = l[m];
      let S;
      if (v.isInterleavedBufferAttribute) {
        const x = i(e.data, v.data);
        S = new wo(x, v.itemSize, v.offset, v.normalized);
      } else {
        const x = Ud(v.type, v.array),
          g = v.isInstancedBufferAttribute ? uu : wn;
        S = new g(x, v.itemSize, v.normalized);
      }
      v.name !== void 0 && (S.name = v.name),
        v.usage !== void 0 && S.setUsage(v.usage),
        a.setAttribute(m, S);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const m in c) {
        const v = c[m],
          S = [];
        for (let x = 0, g = v.length; x < g; x++) {
          const _ = v[x];
          let y;
          if (_.isInterleavedBufferAttribute) {
            const w = i(e.data, _.data);
            y = new wo(w, _.itemSize, _.offset, _.normalized);
          } else {
            const w = Ud(_.type, _.array);
            y = new wn(w, _.itemSize, _.normalized);
          }
          _.name !== void 0 && (y.name = _.name), S.push(y);
        }
        a.morphAttributes[m] = S;
      }
    e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0)
      for (let m = 0, v = d.length; m !== v; ++m) {
        const S = d[m];
        a.addGroup(S.start, S.count, S.materialIndex);
      }
    const p = e.data.boundingSphere;
    if (p !== void 0) {
      const m = new K();
      p.center !== void 0 && m.fromArray(p.center),
        (a.boundingSphere = new Rr(m, p.radius));
    }
    return (
      e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a
    );
  }
}
class VW extends no {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = this,
      a = this.path === "" ? Uw.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || a;
    const s = new $s(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        function (l) {
          let c = null;
          try {
            c = JSON.parse(l);
          } catch (d) {
            i !== void 0 && i(d),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                d.message
              );
            return;
          }
          const u = c.metadata;
          if (
            u === void 0 ||
            u.type === void 0 ||
            u.type.toLowerCase() === "geometry"
          ) {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          o.parse(c, n);
        },
        r,
        i
      );
  }
  async loadAsync(e, n) {
    const r = this,
      i = this.path === "" ? Uw.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const o = new $s(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials);
    const a = await o.loadAsync(e, n),
      s = JSON.parse(a),
      l = s.metadata;
    if (
      l === void 0 ||
      l.type === void 0 ||
      l.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(s);
  }
  parse(e, n) {
    const r = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      o = this.parseGeometries(e.geometries, i),
      a = this.parseImages(e.images, function () {
        n !== void 0 && n(c);
      }),
      s = this.parseTextures(e.textures, a),
      l = this.parseMaterials(e.materials, s),
      c = this.parseObject(e.object, o, l, s, r),
      u = this.parseSkeletons(e.skeletons, c);
    if ((this.bindSkeletons(c, u), n !== void 0)) {
      let d = !1;
      for (const p in a)
        if (a[p].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && n(c);
    }
    return c;
  }
  async parseAsync(e) {
    const n = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, r),
      o = await this.parseImagesAsync(e.images),
      a = this.parseTextures(e.textures, o),
      s = this.parseMaterials(e.materials, a),
      l = this.parseObject(e.object, i, s, a, n),
      c = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, c), l;
  }
  parseShapes(e) {
    const n = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const o = new zl().fromJSON(e[r]);
        n[o.uuid] = o;
      }
    return n;
  }
  parseSkeletons(e, n) {
    const r = {},
      i = {};
    if (
      (n.traverse(function (o) {
        o.isBone && (i[o.uuid] = o);
      }),
      e !== void 0)
    )
      for (let o = 0, a = e.length; o < a; o++) {
        const s = new dD().fromJSON(e[o], i);
        r[s.uuid] = s;
      }
    return r;
  }
  parseGeometries(e, n) {
    const r = {};
    if (e !== void 0) {
      const i = new KD();
      for (let o = 0, a = e.length; o < a; o++) {
        let s;
        const l = e[o];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            s = i.parse(l);
            break;
          default:
            l.type in wP
              ? (s = wP[l.type].fromJSON(l, n))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                );
        }
        (s.uuid = l.uuid),
          l.name !== void 0 && (s.name = l.name),
          l.userData !== void 0 && (s.userData = l.userData),
          (r[l.uuid] = s);
      }
    }
    return r;
  }
  parseMaterials(e, n) {
    const r = {},
      i = {};
    if (e !== void 0) {
      const o = new E1();
      o.setTextures(n);
      for (let a = 0, s = e.length; a < s; a++) {
        const l = e[a];
        r[l.uuid] === void 0 && (r[l.uuid] = o.parse(l)),
          (i[l.uuid] = r[l.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const n = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r],
          o = Gp.parse(i);
        n[o.uuid] = o;
      }
    return n;
  }
  parseImages(e, n) {
    const r = this,
      i = {};
    let o;
    function a(l) {
      return (
        r.manager.itemStart(l),
        o.load(
          l,
          function () {
            r.manager.itemEnd(l);
          },
          void 0,
          function () {
            r.manager.itemError(l), r.manager.itemEnd(l);
          }
        )
      );
    }
    function s(l) {
      if (typeof l == "string") {
        const c = l,
          u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : r.resourcePath + c;
        return a(u);
      } else
        return l.data
          ? { data: Ud(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new CC(n);
      (o = new Wp(l)), o.setCrossOrigin(this.crossOrigin);
      for (let c = 0, u = e.length; c < u; c++) {
        const d = e[c],
          p = d.url;
        if (Array.isArray(p)) {
          const m = [];
          for (let v = 0, S = p.length; v < S; v++) {
            const x = p[v],
              g = s(x);
            g !== null &&
              (g instanceof HTMLImageElement
                ? m.push(g)
                : m.push(new Zc(g.data, g.width, g.height)));
          }
          i[d.uuid] = new Hc(m);
        } else {
          const m = s(d.url);
          i[d.uuid] = new Hc(m);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const n = this,
      r = {};
    let i;
    async function o(a) {
      if (typeof a == "string") {
        const s = a,
          l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s) ? s : n.resourcePath + s;
        return await i.loadAsync(l);
      } else
        return a.data
          ? { data: Ud(a.type, a.data), width: a.width, height: a.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new Wp(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let a = 0, s = e.length; a < s; a++) {
        const l = e[a],
          c = l.url;
        if (Array.isArray(c)) {
          const u = [];
          for (let d = 0, p = c.length; d < p; d++) {
            const m = c[d],
              v = await o(m);
            v !== null &&
              (v instanceof HTMLImageElement
                ? u.push(v)
                : u.push(new Zc(v.data, v.width, v.height)));
          }
          r[l.uuid] = new Hc(u);
        } else {
          const u = await o(l.url);
          r[l.uuid] = new Hc(u);
        }
      }
    }
    return r;
  }
  parseTextures(e, n) {
    function r(o, a) {
      return typeof o == "number"
        ? o
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            o
          ),
          a[o]);
    }
    const i = {};
    if (e !== void 0)
      for (let o = 0, a = e.length; o < a; o++) {
        const s = e[o];
        s.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid),
          n[s.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", s.image);
        const l = n[s.image],
          c = l.data;
        let u;
        Array.isArray(c)
          ? ((u = new mm()), c.length === 6 && (u.needsUpdate = !0))
          : (c && c.data ? (u = new Zc()) : (u = new sr()),
            c && (u.needsUpdate = !0)),
          (u.source = l),
          (u.uuid = s.uuid),
          s.name !== void 0 && (u.name = s.name),
          s.mapping !== void 0 && (u.mapping = r(s.mapping, $W)),
          s.channel !== void 0 && (u.channel = s.channel),
          s.offset !== void 0 && u.offset.fromArray(s.offset),
          s.repeat !== void 0 && u.repeat.fromArray(s.repeat),
          s.center !== void 0 && u.center.fromArray(s.center),
          s.rotation !== void 0 && (u.rotation = s.rotation),
          s.wrap !== void 0 &&
            ((u.wrapS = r(s.wrap[0], TP)), (u.wrapT = r(s.wrap[1], TP))),
          s.format !== void 0 && (u.format = s.format),
          s.internalFormat !== void 0 && (u.internalFormat = s.internalFormat),
          s.type !== void 0 && (u.type = s.type),
          s.colorSpace !== void 0 && (u.colorSpace = s.colorSpace),
          s.encoding !== void 0 && (u.encoding = s.encoding),
          s.minFilter !== void 0 && (u.minFilter = r(s.minFilter, AP)),
          s.magFilter !== void 0 && (u.magFilter = r(s.magFilter, AP)),
          s.anisotropy !== void 0 && (u.anisotropy = s.anisotropy),
          s.flipY !== void 0 && (u.flipY = s.flipY),
          s.generateMipmaps !== void 0 &&
            (u.generateMipmaps = s.generateMipmaps),
          s.premultiplyAlpha !== void 0 &&
            (u.premultiplyAlpha = s.premultiplyAlpha),
          s.unpackAlignment !== void 0 &&
            (u.unpackAlignment = s.unpackAlignment),
          s.compareFunction !== void 0 &&
            (u.compareFunction = s.compareFunction),
          s.userData !== void 0 && (u.userData = s.userData),
          (i[s.uuid] = u);
      }
    return i;
  }
  parseObject(e, n, r, i, o) {
    let a;
    function s(p) {
      return (
        n[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", p),
        n[p]
      );
    }
    function l(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const m = [];
          for (let v = 0, S = p.length; v < S; v++) {
            const x = p[v];
            r[x] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", x),
              m.push(r[x]);
          }
          return m;
        }
        return (
          r[p] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", p),
          r[p]
        );
      }
    }
    function c(p) {
      return (
        i[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", p),
        i[p]
      );
    }
    let u, d;
    switch (e.type) {
      case "Scene":
        (a = new dC()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (a.background = new pt(e.background))
              : (a.background = c(e.background))),
          e.environment !== void 0 && (a.environment = c(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (a.fog = new s1(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (a.fog = new a1(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (a.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (a.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (a.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        (a = new Zn(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (a.focus = e.focus),
          e.zoom !== void 0 && (a.zoom = e.zoom),
          e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset),
          e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (a = new ts(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (a.zoom = e.zoom),
          e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        a = new GD(e.color, e.intensity);
        break;
      case "DirectionalLight":
        a = new $D(e.color, e.intensity);
        break;
      case "PointLight":
        a = new VD(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        a = new WD(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        a = new jD(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        );
        break;
      case "HemisphereLight":
        a = new HD(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        a = new qD().fromJSON(e);
        break;
      case "SkinnedMesh":
        (u = s(e.geometry)),
          (d = l(e.material)),
          (a = new uD(u, d)),
          e.bindMode !== void 0 && (a.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (a.skeleton = e.skeleton);
        break;
      case "Mesh":
        (u = s(e.geometry)), (d = l(e.material)), (a = new Jn(u, d));
        break;
      case "InstancedMesh":
        (u = s(e.geometry)), (d = l(e.material));
        const p = e.count,
          m = e.instanceMatrix,
          v = e.instanceColor;
        (a = new hD(u, d, p)),
          (a.instanceMatrix = new uu(new Float32Array(m.array), 16)),
          v !== void 0 &&
            (a.instanceColor = new uu(new Float32Array(v.array), v.itemSize));
        break;
      case "BatchedMesh":
        (u = s(e.geometry)),
          (d = l(e.material)),
          (a = new pD(
            e.maxGeometryCount,
            e.maxVertexCount,
            e.maxIndexCount,
            d
          )),
          (a.geometry = u),
          (a.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (a.sortObjects = e.sortObjects),
          (a._drawRanges = e.drawRanges),
          (a._reservedRanges = e.reservedRanges),
          (a._visibility = e.visibility),
          (a._active = e.active),
          (a._bounds = e.bounds.map((S) => {
            const x = new wr();
            x.min.fromArray(S.boxMin), x.max.fromArray(S.boxMax);
            const g = new Rr();
            return (
              (g.radius = S.sphereRadius),
              g.center.fromArray(S.sphereCenter),
              {
                boxInitialized: S.boxInitialized,
                box: x,
                sphereInitialized: S.sphereInitialized,
                sphere: g,
              }
            );
          })),
          (a._maxGeometryCount = e.maxGeometryCount),
          (a._maxVertexCount = e.maxVertexCount),
          (a._maxIndexCount = e.maxIndexCount),
          (a._geometryInitialized = e.geometryInitialized),
          (a._geometryCount = e.geometryCount),
          (a._matricesTexture = c(e.matricesTexture.uuid));
        break;
      case "LOD":
        a = new cD();
        break;
      case "Line":
        a = new jl(s(e.geometry), l(e.material));
        break;
      case "LineLoop":
        a = new mD(s(e.geometry), l(e.material));
        break;
      case "LineSegments":
        a = new as(s(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        a = new gD(s(e.geometry), l(e.material));
        break;
      case "Sprite":
        a = new lD(l(e.material));
        break;
      case "Group":
        a = new Hd();
        break;
      case "Bone":
        a = new hC();
        break;
      default:
        a = new Sn();
    }
    if (
      ((a.uuid = e.uuid),
      e.name !== void 0 && (a.name = e.name),
      e.matrix !== void 0
        ? (a.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (a.matrixAutoUpdate = e.matrixAutoUpdate),
          a.matrixAutoUpdate &&
            a.matrix.decompose(a.position, a.quaternion, a.scale))
        : (e.position !== void 0 && a.position.fromArray(e.position),
          e.rotation !== void 0 && a.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && a.scale.fromArray(e.scale)),
      e.up !== void 0 && a.up.fromArray(e.up),
      e.castShadow !== void 0 && (a.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (a.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          a.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (a.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (a.visible = e.visible),
      e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder),
      e.userData !== void 0 && (a.userData = e.userData),
      e.layers !== void 0 && (a.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const p = e.children;
      for (let m = 0; m < p.length; m++)
        a.add(this.parseObject(p[m], n, r, i, o));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let m = 0; m < p.length; m++) {
        const v = p[m];
        a.animations.push(o[v]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let m = 0; m < p.length; m++) {
        const v = p[m],
          S = a.getObjectByProperty("uuid", v.object);
        S !== void 0 && a.addLevel(S, v.distance, v.hysteresis);
      }
    }
    return a;
  }
  bindSkeletons(e, n) {
    Object.keys(n).length !== 0 &&
      e.traverse(function (r) {
        if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
          const i = n[r.skeleton];
          i === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                r.skeleton
              )
            : r.bind(i, r.bindMatrix);
        }
      });
  }
}
const $W = {
    UVMapping: Qy,
    CubeReflectionMapping: Vs,
    CubeRefractionMapping: Bl,
    EquirectangularReflectionMapping: Cp,
    EquirectangularRefractionMapping: Tp,
    CubeUVReflectionMapping: Tf,
  },
  TP = {
    RepeatWrapping: Ap,
    ClampToEdgeWrapping: pi,
    MirroredRepeatWrapping: Rp,
  },
  AP = {
    NearestFilter: pr,
    NearestMipmapNearestFilter: cy,
    NearestMipmapLinearFilter: Yh,
    LinearFilter: Yn,
    LinearMipmapNearestFilter: GM,
    LinearMipmapLinearFilter: Hl,
  };
class GW extends no {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, n, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      a = Os.get(e);
    if (a !== void 0) {
      if ((o.manager.itemStart(e), a.then)) {
        a.then((c) => {
          n && n(c), o.manager.itemEnd(e);
        }).catch((c) => {
          i && i(c);
        });
        return;
      }
      return (
        setTimeout(function () {
          n && n(a), o.manager.itemEnd(e);
        }, 0),
        a
      );
    }
    const s = {};
    (s.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (s.headers = this.requestHeader);
    const l = fetch(e, s)
      .then(function (c) {
        return c.blob();
      })
      .then(function (c) {
        return createImageBitmap(
          c,
          Object.assign(o.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (c) {
        return Os.add(e, c), n && n(c), o.manager.itemEnd(e), c;
      })
      .catch(function (c) {
        i && i(c), Os.remove(e), o.manager.itemError(e), o.manager.itemEnd(e);
      });
    Os.add(e, l), o.manager.itemStart(e);
  }
}
let Mv;
class AC {
  static getContext() {
    return (
      Mv === void 0 &&
        (Mv = new (window.AudioContext || window.webkitAudioContext)()),
      Mv
    );
  }
  static setContext(e) {
    Mv = e;
  }
}
class WW extends no {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = this,
      a = new $s(this.manager);
    a.setResponseType("arraybuffer"),
      a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          try {
            const c = l.slice(0);
            AC.getContext()
              .decodeAudioData(c, function (d) {
                n(d);
              })
              .catch(s);
          } catch (c) {
            s(c);
          }
        },
        r,
        i
      );
    function s(l) {
      i ? i(l) : console.error(l), o.manager.itemError(e);
    }
  }
}
const RP = new kt(),
  PP = new kt(),
  yc = new kt();
class XW {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Zn()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Zn()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const n = this._cache;
    if (
      n.focus !== e.focus ||
      n.fov !== e.fov ||
      n.aspect !== e.aspect * this.aspect ||
      n.near !== e.near ||
      n.far !== e.far ||
      n.zoom !== e.zoom ||
      n.eyeSep !== this.eyeSep
    ) {
      (n.focus = e.focus),
        (n.fov = e.fov),
        (n.aspect = e.aspect * this.aspect),
        (n.near = e.near),
        (n.far = e.far),
        (n.zoom = e.zoom),
        (n.eyeSep = this.eyeSep),
        yc.copy(e.projectionMatrix);
      const i = n.eyeSep / 2,
        o = (i * n.near) / n.focus,
        a = (n.near * Math.tan(Kc * n.fov * 0.5)) / n.zoom;
      let s, l;
      (PP.elements[12] = -i),
        (RP.elements[12] = i),
        (s = -a * n.aspect + o),
        (l = a * n.aspect + o),
        (yc.elements[0] = (2 * n.near) / (l - s)),
        (yc.elements[8] = (l + s) / (l - s)),
        this.cameraL.projectionMatrix.copy(yc),
        (s = -a * n.aspect - o),
        (l = a * n.aspect - o),
        (yc.elements[0] = (2 * n.near) / (l - s)),
        (yc.elements[8] = (l + s) / (l - s)),
        this.cameraR.projectionMatrix.copy(yc);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(PP),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(RP);
  }
}
class RC {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = IP()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const n = IP();
      (e = (n - this.oldTime) / 1e3),
        (this.oldTime = n),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function IP() {
  return (typeof performance > "u" ? Date : performance).now();
}
const xc = new K(),
  LP = new mi(),
  qW = new K(),
  Sc = new K();
class KW extends Sn {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = AC.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new RC());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const n = this.context.listener,
      r = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(xc, LP, qW),
      Sc.set(0, 0, -1).applyQuaternion(LP),
      n.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      n.positionX.linearRampToValueAtTime(xc.x, i),
        n.positionY.linearRampToValueAtTime(xc.y, i),
        n.positionZ.linearRampToValueAtTime(xc.z, i),
        n.forwardX.linearRampToValueAtTime(Sc.x, i),
        n.forwardY.linearRampToValueAtTime(Sc.y, i),
        n.forwardZ.linearRampToValueAtTime(Sc.z, i),
        n.upX.linearRampToValueAtTime(r.x, i),
        n.upY.linearRampToValueAtTime(r.y, i),
        n.upZ.linearRampToValueAtTime(r.z, i);
    } else
      n.setPosition(xc.x, xc.y, xc.z),
        n.setOrientation(Sc.x, Sc.y, Sc.z, r.x, r.y, r.z);
  }
}
let YD = class extends Sn {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const n = this.context.createBufferSource();
    return (
      (n.buffer = this.buffer),
      (n.loop = this.loop),
      (n.loopStart = this.loopStart),
      (n.loopEnd = this.loopEnd),
      (n.onended = this.onEnded.bind(this)),
      n.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = n),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, n = this.filters.length; e < n; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, n = this.filters.length; e < n; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    if (((this.detune = e), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
};
const _c = new K(),
  OP = new mi(),
  YW = new K(),
  bc = new K();
class ZW extends YD {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, n, r) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = n),
      (this.panner.coneOuterGain = r),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(_c, OP, YW), bc.set(0, 0, 1).applyQuaternion(OP);
    const n = this.panner;
    if (n.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      n.positionX.linearRampToValueAtTime(_c.x, r),
        n.positionY.linearRampToValueAtTime(_c.y, r),
        n.positionZ.linearRampToValueAtTime(_c.z, r),
        n.orientationX.linearRampToValueAtTime(bc.x, r),
        n.orientationY.linearRampToValueAtTime(bc.y, r),
        n.orientationZ.linearRampToValueAtTime(bc.z, r);
    } else n.setPosition(_c.x, _c.y, _c.z), n.setOrientation(bc.x, bc.y, bc.z);
  }
}
class QW {
  constructor(e, n = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = n),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const n = this.getFrequencyData();
    for (let r = 0; r < n.length; r++) e += n[r];
    return e / n.length;
  }
}
class ZD {
  constructor(e, n, r) {
    (this.binding = e), (this.valueSize = r);
    let i, o, a;
    switch (n) {
      case "quaternion":
        (i = this._slerp),
          (o = this._slerpAdditive),
          (a = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(r * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (o = this._select),
          (a = this._setAdditiveIdentityOther),
          (this.buffer = new Array(r * 5));
        break;
      default:
        (i = this._lerp),
          (o = this._lerpAdditive),
          (a = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(r * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = o),
      (this._setIdentity = a),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, n) {
    const r = this.buffer,
      i = this.valueSize,
      o = e * i + i;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let s = 0; s !== i; ++s) r[o + s] = r[s];
      a = n;
    } else {
      a += n;
      const s = n / a;
      this._mixBufferRegion(r, o, 0, s, i);
    }
    this.cumulativeWeight = a;
  }
  accumulateAdditive(e) {
    const n = this.buffer,
      r = this.valueSize,
      i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(n, i, 0, e, r),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const n = this.valueSize,
      r = this.buffer,
      i = e * n + n,
      o = this.cumulativeWeight,
      a = this.cumulativeWeightAdditive,
      s = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), o < 1)
    ) {
      const l = n * this._origIndex;
      this._mixBufferRegion(r, i, l, 1 - o, n);
    }
    a > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * n, 1, n);
    for (let l = n, c = n + n; l !== c; ++l)
      if (r[l] !== r[l + n]) {
        s.setValue(r, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      n = this.buffer,
      r = this.valueSize,
      i = r * this._origIndex;
    e.getValue(n, i);
    for (let o = r, a = i; o !== a; ++o) n[o] = n[i + (o % r)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      n = e + this.valueSize;
    for (let r = e; r < n; r++) this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      n = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[n + r] = this.buffer[e + r];
  }
  _select(e, n, r, i, o) {
    if (i >= 0.5) for (let a = 0; a !== o; ++a) e[n + a] = e[r + a];
  }
  _slerp(e, n, r, i) {
    mi.slerpFlat(e, n, e, n, e, r, i);
  }
  _slerpAdditive(e, n, r, i, o) {
    const a = this._workIndex * o;
    mi.multiplyQuaternionsFlat(e, a, e, n, e, r),
      mi.slerpFlat(e, n, e, n, e, a, i);
  }
  _lerp(e, n, r, i, o) {
    const a = 1 - i;
    for (let s = 0; s !== o; ++s) {
      const l = n + s;
      e[l] = e[l] * a + e[r + s] * i;
    }
  }
  _lerpAdditive(e, n, r, i, o) {
    for (let a = 0; a !== o; ++a) {
      const s = n + a;
      e[s] = e[s] + e[r + a] * i;
    }
  }
}
const PC = "\\[\\]\\.:\\/",
  JW = new RegExp("[" + PC + "]", "g"),
  IC = "[^" + PC + "]",
  e7 = "[^" + PC.replace("\\.", "") + "]",
  t7 = /((?:WC+[\/:])*)/.source.replace("WC", IC),
  n7 = /(WCOD+)?/.source.replace("WCOD", e7),
  r7 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", IC),
  i7 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", IC),
  o7 = new RegExp("^" + t7 + n7 + r7 + i7 + "$"),
  a7 = ["material", "materials", "bones", "map"];
class s7 {
  constructor(e, n, r) {
    const i = r || pn.parseTrackName(n);
    (this._targetGroup = e), (this._bindings = e.subscribe_(n, i));
  }
  getValue(e, n) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_,
      i = this._bindings[r];
    i !== void 0 && i.getValue(e, n);
  }
  setValue(e, n) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, o = r.length; i !== o; ++i)
      r[i].setValue(e, n);
  }
  bind() {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n)
      e[n].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n)
      e[n].unbind();
  }
}
class pn {
  constructor(e, n, r) {
    (this.path = n),
      (this.parsedPath = r || pn.parseTrackName(n)),
      (this.node = pn.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, n, r) {
    return e && e.isAnimationObjectGroup
      ? new pn.Composite(e, n, r)
      : new pn(e, n, r);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(JW, "");
  }
  static parseTrackName(e) {
    const n = o7.exec(e);
    if (n === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
        nodeName: n[2],
        objectName: n[3],
        objectIndex: n[4],
        propertyName: n[5],
        propertyIndex: n[6],
      },
      i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const o = r.nodeName.substring(i + 1);
      a7.indexOf(o) !== -1 &&
        ((r.nodeName = r.nodeName.substring(0, i)), (r.objectName = o));
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return r;
  }
  static findNode(e, n) {
    if (
      n === void 0 ||
      n === "" ||
      n === "." ||
      n === -1 ||
      n === e.name ||
      n === e.uuid
    )
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(n);
      if (r !== void 0) return r;
    }
    if (e.children) {
      const r = function (o) {
          for (let a = 0; a < o.length; a++) {
            const s = o[a];
            if (s.name === n || s.uuid === n) return s;
            const l = r(s.children);
            if (l) return l;
          }
          return null;
        },
        i = r(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, n) {
    e[n] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, n) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) e[n++] = r[i];
  }
  _getValue_arrayElement(e, n) {
    e[n] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, n) {
    this.resolvedProperty.toArray(e, n);
  }
  _setValue_direct(e, n) {
    this.targetObject[this.propertyName] = e[n];
  }
  _setValue_direct_setNeedsUpdate(e, n) {
    (this.targetObject[this.propertyName] = e[n]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, n) {
    (this.targetObject[this.propertyName] = e[n]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, n) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[n++];
  }
  _setValue_array_setNeedsUpdate(e, n) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[n++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, n) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[n++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, n) {
    this.resolvedProperty[this.propertyIndex] = e[n];
  }
  _setValue_arrayElement_setNeedsUpdate(e, n) {
    (this.resolvedProperty[this.propertyIndex] = e[n]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, n) {
    (this.resolvedProperty[this.propertyIndex] = e[n]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, n) {
    this.resolvedProperty.fromArray(e, n);
  }
  _setValue_fromArray_setNeedsUpdate(e, n) {
    this.resolvedProperty.fromArray(e, n), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, n) {
    this.resolvedProperty.fromArray(e, n),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, n) {
    this.bind(), this.getValue(e, n);
  }
  _setValue_unbound(e, n) {
    this.bind(), this.setValue(e, n);
  }
  bind() {
    let e = this.node;
    const n = this.parsedPath,
      r = n.objectName,
      i = n.propertyName;
    let o = n.propertyIndex;
    if (
      (e || ((e = pn.findNode(this.rootNode, n.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (r) {
      let c = n.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[r];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const a = e[i];
    if (a === void 0) {
      const c = n.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let s = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (s = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (s = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (o !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[o] !== void 0 &&
          (o = e.morphTargetDictionary[o]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = a),
        (this.propertyIndex = o);
    } else
      a.fromArray !== void 0 && a.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = a))
        : Array.isArray(a)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = a))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][s]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
pn.Composite = s7;
pn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
pn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
pn.prototype.GetterByBindingType = [
  pn.prototype._getValue_direct,
  pn.prototype._getValue_array,
  pn.prototype._getValue_arrayElement,
  pn.prototype._getValue_toArray,
];
pn.prototype.SetterByBindingTypeAndVersioning = [
  [
    pn.prototype._setValue_direct,
    pn.prototype._setValue_direct_setNeedsUpdate,
    pn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    pn.prototype._setValue_array,
    pn.prototype._setValue_array_setNeedsUpdate,
    pn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    pn.prototype._setValue_arrayElement,
    pn.prototype._setValue_arrayElement_setNeedsUpdate,
    pn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    pn.prototype._setValue_fromArray,
    pn.prototype._setValue_fromArray_setNeedsUpdate,
    pn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class l7 {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = Ao()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const n = this;
    this.stats = {
      objects: {
        get total() {
          return n._objects.length;
        },
        get inUse() {
          return this.total - n.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return n._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      n = this._indicesByUUID,
      r = this._paths,
      i = this._parsedPaths,
      o = this._bindings,
      a = o.length;
    let s,
      l = e.length,
      c = this.nCachedObjects_;
    for (let u = 0, d = arguments.length; u !== d; ++u) {
      const p = arguments[u],
        m = p.uuid;
      let v = n[m];
      if (v === void 0) {
        (v = l++), (n[m] = v), e.push(p);
        for (let S = 0, x = a; S !== x; ++S) o[S].push(new pn(p, r[S], i[S]));
      } else if (v < c) {
        s = e[v];
        const S = --c,
          x = e[S];
        (n[x.uuid] = v), (e[v] = x), (n[m] = S), (e[S] = p);
        for (let g = 0, _ = a; g !== _; ++g) {
          const y = o[g],
            w = y[S];
          let A = y[v];
          (y[v] = w), A === void 0 && (A = new pn(p, r[g], i[g])), (y[S] = A);
        }
      } else
        e[v] !== s &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects,
      n = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let o = this.nCachedObjects_;
    for (let a = 0, s = arguments.length; a !== s; ++a) {
      const l = arguments[a],
        c = l.uuid,
        u = n[c];
      if (u !== void 0 && u >= o) {
        const d = o++,
          p = e[d];
        (n[p.uuid] = u), (e[u] = p), (n[c] = d), (e[d] = l);
        for (let m = 0, v = i; m !== v; ++m) {
          const S = r[m],
            x = S[d],
            g = S[u];
          (S[u] = x), (S[d] = g);
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  uncache() {
    const e = this._objects,
      n = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let o = this.nCachedObjects_,
      a = e.length;
    for (let s = 0, l = arguments.length; s !== l; ++s) {
      const c = arguments[s],
        u = c.uuid,
        d = n[u];
      if (d !== void 0)
        if ((delete n[u], d < o)) {
          const p = --o,
            m = e[p],
            v = --a,
            S = e[v];
          (n[m.uuid] = d), (e[d] = m), (n[S.uuid] = p), (e[p] = S), e.pop();
          for (let x = 0, g = i; x !== g; ++x) {
            const _ = r[x],
              y = _[p],
              w = _[v];
            (_[d] = y), (_[p] = w), _.pop();
          }
        } else {
          const p = --a,
            m = e[p];
          p > 0 && (n[m.uuid] = d), (e[d] = m), e.pop();
          for (let v = 0, S = i; v !== S; ++v) {
            const x = r[v];
            (x[d] = x[p]), x.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  subscribe_(e, n) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const o = this._bindings;
    if (i !== void 0) return o[i];
    const a = this._paths,
      s = this._parsedPaths,
      l = this._objects,
      c = l.length,
      u = this.nCachedObjects_,
      d = new Array(c);
    (i = o.length), (r[e] = i), a.push(e), s.push(n), o.push(d);
    for (let p = u, m = l.length; p !== m; ++p) {
      const v = l[p];
      d[p] = new pn(v, e, n);
    }
    return d;
  }
  unsubscribe_(e) {
    const n = this._bindingsIndicesByPath,
      r = n[e];
    if (r !== void 0) {
      const i = this._paths,
        o = this._parsedPaths,
        a = this._bindings,
        s = a.length - 1,
        l = a[s],
        c = e[s];
      (n[c] = r),
        (a[r] = l),
        a.pop(),
        (o[r] = o[s]),
        o.pop(),
        (i[r] = i[s]),
        i.pop();
    }
  }
}
class QD {
  constructor(e, n, r = null, i = n.blendMode) {
    (this._mixer = e),
      (this._clip = n),
      (this._localRoot = r),
      (this.blendMode = i);
    const o = n.tracks,
      a = o.length,
      s = new Array(a),
      l = { endingStart: kc, endingEnd: kc };
    for (let c = 0; c !== a; ++c) {
      const u = o[c].createInterpolant(null);
      (s[c] = u), (u.settings = l);
    }
    (this._interpolantSettings = l),
      (this._interpolants = s),
      (this._propertyBindings = new Array(a)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = OF),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, n) {
    return (this.loop = e), (this.repetitions = n), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, n, r) {
    if ((e.fadeOut(n), this.fadeIn(n), r)) {
      const i = this._clip.duration,
        o = e._clip.duration,
        a = o / i,
        s = i / o;
      e.warp(1, a, n), this.warp(s, 1, n);
    }
    return this;
  }
  crossFadeTo(e, n, r) {
    return e.crossFadeFrom(this, n, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, n, r) {
    const i = this._mixer,
      o = i.time,
      a = this.timeScale;
    let s = this._timeScaleInterpolant;
    s === null &&
      ((s = i._lendControlInterpolant()), (this._timeScaleInterpolant = s));
    const l = s.parameterPositions,
      c = s.sampleValues;
    return (l[0] = o), (l[1] = o + r), (c[0] = e / a), (c[1] = n / a), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, n, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const l = (e - o) * r;
      l < 0 || r === 0 ? (n = 0) : ((this._startTime = null), (n = r * l));
    }
    n *= this._updateTimeScale(e);
    const a = this._updateTime(n),
      s = this._updateWeight(e);
    if (s > 0) {
      const l = this._interpolants,
        c = this._propertyBindings;
      switch (this.blendMode) {
        case JM:
          for (let u = 0, d = l.length; u !== d; ++u)
            l[u].evaluate(a), c[u].accumulateAdditive(s);
          break;
        case e1:
        default:
          for (let u = 0, d = l.length; u !== d; ++u)
            l[u].evaluate(a), c[u].accumulate(i, s);
      }
    }
  }
  _updateWeight(e) {
    let n = 0;
    if (this.enabled) {
      n = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (n *= i),
          e > r.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = n), n;
  }
  _updateTimeScale(e) {
    let n = 0;
    if (!this.paused) {
      n = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (n *= i),
          e > r.parameterPositions[1] &&
            (this.stopWarping(),
            n === 0 ? (this.paused = !0) : (this.timeScale = n));
      }
    }
    return (this._effectiveTimeScale = n), n;
  }
  _updateTime(e) {
    const n = this._clip.duration,
      r = this.loop;
    let i = this.time + e,
      o = this._loopCount;
    const a = r === NF;
    if (e === 0) return o === -1 ? i : a && (o & 1) === 1 ? n - i : i;
    if (r === LF) {
      o === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= n) i = n;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (o === -1 &&
          (e >= 0
            ? ((o = 0), this._setEndings(!0, this.repetitions === 0, a))
            : this._setEndings(this.repetitions === 0, !0, a)),
        i >= n || i < 0)
      ) {
        const s = Math.floor(i / n);
        (i -= n * s), (o += Math.abs(s));
        const l = this.repetitions - o;
        if (l <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? n : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, a);
          } else this._setEndings(!1, !1, a);
          (this._loopCount = o),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: s,
            });
        }
      } else this.time = i;
      if (a && (o & 1) === 1) return n - i;
    }
    return i;
  }
  _setEndings(e, n, r) {
    const i = this._interpolantSettings;
    r
      ? ((i.endingStart = Bc), (i.endingEnd = Bc))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? Bc : kc)
          : (i.endingStart = Lp),
        n ? (i.endingEnd = this.zeroSlopeAtEnd ? Bc : kc) : (i.endingEnd = Lp));
  }
  _scheduleFading(e, n, r) {
    const i = this._mixer,
      o = i.time;
    let a = this._weightInterpolant;
    a === null &&
      ((a = i._lendControlInterpolant()), (this._weightInterpolant = a));
    const s = a.parameterPositions,
      l = a.sampleValues;
    return (s[0] = o), (l[0] = n), (s[1] = o + e), (l[1] = r), this;
  }
}
const c7 = new Float32Array(1);
class u7 extends qs {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, n) {
    const r = e._localRoot || this._root,
      i = e._clip.tracks,
      o = i.length,
      a = e._propertyBindings,
      s = e._interpolants,
      l = r.uuid,
      c = this._bindingsByRootAndName;
    let u = c[l];
    u === void 0 && ((u = {}), (c[l] = u));
    for (let d = 0; d !== o; ++d) {
      const p = i[d],
        m = p.name;
      let v = u[m];
      if (v !== void 0) ++v.referenceCount, (a[d] = v);
      else {
        if (((v = a[d]), v !== void 0)) {
          v._cacheIndex === null &&
            (++v.referenceCount, this._addInactiveBinding(v, l, m));
          continue;
        }
        const S = n && n._propertyBindings[d].binding.parsedPath;
        (v = new ZD(pn.create(r, m, S), p.ValueTypeName, p.getValueSize())),
          ++v.referenceCount,
          this._addInactiveBinding(v, l, m),
          (a[d] = v);
      }
      s[d].resultBuffer = v.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          o = this._actionsByClip[i];
        this._bindAction(e, o && o.knownActions[0]),
          this._addInactiveAction(e, i, r);
      }
      const n = e._propertyBindings;
      for (let r = 0, i = n.length; r !== i; ++r) {
        const o = n[r];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const n = e._propertyBindings;
      for (let r = 0, i = n.length; r !== i; ++r) {
        const o = n[r];
        --o.useCount === 0 &&
          (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const n = e._cacheIndex;
    return n !== null && n < this._nActiveActions;
  }
  _addInactiveAction(e, n, r) {
    const i = this._actions,
      o = this._actionsByClip;
    let a = o[n];
    if (a === void 0)
      (a = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (o[n] = a);
    else {
      const s = a.knownActions;
      (e._byClipCacheIndex = s.length), s.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (a.actionByRoot[r] = e);
  }
  _removeInactiveAction(e) {
    const n = this._actions,
      r = n[n.length - 1],
      i = e._cacheIndex;
    (r._cacheIndex = i), (n[i] = r), n.pop(), (e._cacheIndex = null);
    const o = e._clip.uuid,
      a = this._actionsByClip,
      s = a[o],
      l = s.knownActions,
      c = l[l.length - 1],
      u = e._byClipCacheIndex;
    (c._byClipCacheIndex = u),
      (l[u] = c),
      l.pop(),
      (e._byClipCacheIndex = null);
    const d = s.actionByRoot,
      p = (e._localRoot || this._root).uuid;
    delete d[p],
      l.length === 0 && delete a[o],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const n = e._propertyBindings;
    for (let r = 0, i = n.length; r !== i; ++r) {
      const o = n[r];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const n = this._actions,
      r = e._cacheIndex,
      i = this._nActiveActions++,
      o = n[i];
    (e._cacheIndex = i), (n[i] = e), (o._cacheIndex = r), (n[r] = o);
  }
  _takeBackAction(e) {
    const n = this._actions,
      r = e._cacheIndex,
      i = --this._nActiveActions,
      o = n[i];
    (e._cacheIndex = i), (n[i] = e), (o._cacheIndex = r), (n[r] = o);
  }
  _addInactiveBinding(e, n, r) {
    const i = this._bindingsByRootAndName,
      o = this._bindings;
    let a = i[n];
    a === void 0 && ((a = {}), (i[n] = a)),
      (a[r] = e),
      (e._cacheIndex = o.length),
      o.push(e);
  }
  _removeInactiveBinding(e) {
    const n = this._bindings,
      r = e.binding,
      i = r.rootNode.uuid,
      o = r.path,
      a = this._bindingsByRootAndName,
      s = a[i],
      l = n[n.length - 1],
      c = e._cacheIndex;
    (l._cacheIndex = c),
      (n[c] = l),
      n.pop(),
      delete s[o],
      Object.keys(s).length === 0 && delete a[i];
  }
  _lendBinding(e) {
    const n = this._bindings,
      r = e._cacheIndex,
      i = this._nActiveBindings++,
      o = n[i];
    (e._cacheIndex = i), (n[i] = e), (o._cacheIndex = r), (n[r] = o);
  }
  _takeBackBinding(e) {
    const n = this._bindings,
      r = e._cacheIndex,
      i = --this._nActiveBindings,
      o = n[i];
    (e._cacheIndex = i), (n[i] = e), (o._cacheIndex = r), (n[r] = o);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      n = this._nActiveControlInterpolants++;
    let r = e[n];
    return (
      r === void 0 &&
        ((r = new EC(new Float32Array(2), new Float32Array(2), 1, c7)),
        (r.__cacheIndex = n),
        (e[n] = r)),
      r
    );
  }
  _takeBackControlInterpolant(e) {
    const n = this._controlInterpolants,
      r = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      o = n[i];
    (e.__cacheIndex = i), (n[i] = e), (o.__cacheIndex = r), (n[r] = o);
  }
  clipAction(e, n, r) {
    const i = n || this._root,
      o = i.uuid;
    let a = typeof e == "string" ? Gp.findByName(i, e) : e;
    const s = a !== null ? a.uuid : e,
      l = this._actionsByClip[s];
    let c = null;
    if (
      (r === void 0 && (a !== null ? (r = a.blendMode) : (r = e1)),
      l !== void 0)
    ) {
      const d = l.actionByRoot[o];
      if (d !== void 0 && d.blendMode === r) return d;
      (c = l.knownActions[0]), a === null && (a = c._clip);
    }
    if (a === null) return null;
    const u = new QD(this, a, n, r);
    return this._bindAction(u, c), this._addInactiveAction(u, s, o), u;
  }
  existingAction(e, n) {
    const r = n || this._root,
      i = r.uuid,
      o = typeof e == "string" ? Gp.findByName(r, e) : e,
      a = o ? o.uuid : e,
      s = this._actionsByClip[a];
    return (s !== void 0 && s.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      n = this._nActiveActions;
    for (let r = n - 1; r >= 0; --r) e[r].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const n = this._actions,
      r = this._nActiveActions,
      i = (this.time += e),
      o = Math.sign(e),
      a = (this._accuIndex ^= 1);
    for (let c = 0; c !== r; ++c) n[c]._update(i, e, o, a);
    const s = this._bindings,
      l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c) s[c].apply(a);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let n = 0; n < this._actions.length; n++) this._actions[n].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const n = this._actions,
      r = e.uuid,
      i = this._actionsByClip,
      o = i[r];
    if (o !== void 0) {
      const a = o.knownActions;
      for (let s = 0, l = a.length; s !== l; ++s) {
        const c = a[s];
        this._deactivateAction(c);
        const u = c._cacheIndex,
          d = n[n.length - 1];
        (c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (d._cacheIndex = u),
          (n[u] = d),
          n.pop(),
          this._removeInactiveBindingsForAction(c);
      }
      delete i[r];
    }
  }
  uncacheRoot(e) {
    const n = e.uuid,
      r = this._actionsByClip;
    for (const a in r) {
      const s = r[a].actionByRoot,
        l = s[n];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const i = this._bindingsByRootAndName,
      o = i[n];
    if (o !== void 0)
      for (const a in o) {
        const s = o[a];
        s.restoreOriginalState(), this._removeInactiveBinding(s);
      }
  }
  uncacheAction(e, n) {
    const r = this.existingAction(e, n);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class LC {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new LC(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let d7 = 0;
class f7 extends qs {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: d7++ }),
      (this.name = ""),
      (this.usage = Dp),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const n = this.uniforms.indexOf(e);
    return n !== -1 && this.uniforms.splice(n, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const n = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = n.length; r < i; r++) {
      const o = Array.isArray(n[r]) ? n[r] : [n[r]];
      for (let a = 0; a < o.length; a++) this.uniforms.push(o[a].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class hy extends l1 {
  constructor(e, n, r = 1) {
    super(e, n),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const n = super.clone(e);
    return (n.meshPerAttribute = this.meshPerAttribute), n;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.isInstancedInterleavedBuffer = !0),
      (n.meshPerAttribute = this.meshPerAttribute),
      n
    );
  }
}
class h7 {
  constructor(e, n, r, i, o) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = n),
      (this.itemSize = r),
      (this.elementSize = i),
      (this.count = o),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, n) {
    return (this.type = e), (this.elementSize = n), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
class JD {
  constructor(e, n, r = 0, i = 1 / 0) {
    (this.ray = new yu(e, n)),
      (this.near = r),
      (this.far = i),
      (this.camera = null),
      (this.layers = new Yc()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, n) {
    this.ray.set(e, n);
  }
  setFromCamera(e, n) {
    n.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(n)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = n))
      : n.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (n.near + n.far) / (n.near - n.far))
          .unproject(n),
        this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld),
        (this.camera = n))
      : console.error("THREE.Raycaster: Unsupported camera type: " + n.type);
  }
  intersectObject(e, n = !0, r = []) {
    return kw(e, this, r, n), r.sort(NP), r;
  }
  intersectObjects(e, n = !0, r = []) {
    for (let i = 0, o = e.length; i < o; i++) kw(e[i], this, r, n);
    return r.sort(NP), r;
  }
}
function NP(t, e) {
  return t.distance - e.distance;
}
function kw(t, e, n, r) {
  if ((t.layers.test(e.layers) && t.raycast(e, n), r === !0)) {
    const i = t.children;
    for (let o = 0, a = i.length; o < a; o++) kw(i[o], e, n, !0);
  }
}
class Bw {
  constructor(e = 1, n = 0, r = 0) {
    return (this.radius = e), (this.phi = n), (this.theta = r), this;
  }
  set(e, n, r) {
    return (this.radius = e), (this.phi = n), (this.theta = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, n, r) {
    return (
      (this.radius = Math.sqrt(e * e + n * n + r * r)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, r)),
          (this.phi = Math.acos(ar(n / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class p7 {
  constructor(e = 1, n = 0, r = 0) {
    return (this.radius = e), (this.theta = n), (this.y = r), this;
  }
  set(e, n, r) {
    return (this.radius = e), (this.theta = n), (this.y = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, n, r) {
    return (
      (this.radius = Math.sqrt(e * e + r * r)),
      (this.theta = Math.atan2(e, r)),
      (this.y = n),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const FP = new Ge();
class m7 {
  constructor(e = new Ge(1 / 0, 1 / 0), n = new Ge(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = n);
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n++) this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const r = FP.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, FP).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const DP = new K(),
  Cv = new K();
class ez {
  constructor(e = new K(), n = new K()) {
    (this.start = e), (this.end = n);
  }
  set(e, n) {
    return this.start.copy(e), this.end.copy(n), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, n) {
    return this.delta(n).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, n) {
    DP.subVectors(e, this.start), Cv.subVectors(this.end, this.start);
    const r = Cv.dot(Cv);
    let o = Cv.dot(DP) / r;
    return n && (o = ar(o, 0, 1)), o;
  }
  closestPointToPoint(e, n, r) {
    const i = this.closestPointToPointParameter(e, n);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const zP = new K();
class g7 extends Sn {
  constructor(e, n) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "SpotLightHelper");
    const r = new Jt(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let a = 0, s = 1, l = 32; a < l; a++, s++) {
      const c = (a / l) * Math.PI * 2,
        u = (s / l) * Math.PI * 2;
      i.push(Math.cos(c), Math.sin(c), 1, Math.cos(u), Math.sin(u), 1);
    }
    r.setAttribute("position", new wt(i, 3));
    const o = new zi({ fog: !1, toneMapped: !1 });
    (this.cone = new as(r, o)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3,
      n = e * Math.tan(this.light.angle);
    this.cone.scale.set(n, n, e),
      zP.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(zP),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const hl = new K(),
  Tv = new kt(),
  a_ = new kt();
class v7 extends as {
  constructor(e) {
    const n = tz(e),
      r = new Jt(),
      i = [],
      o = [],
      a = new pt(0, 0, 1),
      s = new pt(0, 1, 0);
    for (let c = 0; c < n.length; c++) {
      const u = n[c];
      u.parent &&
        u.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        o.push(a.r, a.g, a.b),
        o.push(s.r, s.g, s.b));
    }
    r.setAttribute("position", new wt(i, 3)),
      r.setAttribute("color", new wt(o, 3));
    const l = new zi({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(r, l),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = n),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const n = this.bones,
      r = this.geometry,
      i = r.getAttribute("position");
    a_.copy(this.root.matrixWorld).invert();
    for (let o = 0, a = 0; o < n.length; o++) {
      const s = n[o];
      s.parent &&
        s.parent.isBone &&
        (Tv.multiplyMatrices(a_, s.matrixWorld),
        hl.setFromMatrixPosition(Tv),
        i.setXYZ(a, hl.x, hl.y, hl.z),
        Tv.multiplyMatrices(a_, s.parent.matrixWorld),
        hl.setFromMatrixPosition(Tv),
        i.setXYZ(a + 1, hl.x, hl.y, hl.z),
        (a += 2));
    }
    (r.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function tz(t) {
  const e = [];
  t.isBone === !0 && e.push(t);
  for (let n = 0; n < t.children.length; n++)
    e.push.apply(e, tz(t.children[n]));
  return e;
}
class y7 extends Jn {
  constructor(e, n, r) {
    const i = new xm(n, 4, 2),
      o = new Ks({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, o),
      (this.light = e),
      (this.color = r),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const x7 = new K(),
  UP = new pt(),
  kP = new pt();
class S7 extends Sn {
  constructor(e, n, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "HemisphereLightHelper");
    const i = new ym(n);
    i.rotateY(Math.PI * 0.5),
      (this.material = new Ks({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const o = i.getAttribute("position"),
      a = new Float32Array(o.count * 3);
    i.setAttribute("color", new wn(a, 3)),
      this.add(new Jn(i, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const n = e.geometry.getAttribute("color");
      UP.copy(this.light.color), kP.copy(this.light.groundColor);
      for (let r = 0, i = n.count; r < i; r++) {
        const o = r < i / 2 ? UP : kP;
        n.setXYZ(r, o.r, o.g, o.b);
      }
      n.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(x7.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class _7 extends as {
  constructor(e = 10, n = 10, r = 4473924, i = 8947848) {
    (r = new pt(r)), (i = new pt(i));
    const o = n / 2,
      a = e / n,
      s = e / 2,
      l = [],
      c = [];
    for (let p = 0, m = 0, v = -s; p <= n; p++, v += a) {
      l.push(-s, 0, v, s, 0, v), l.push(v, 0, -s, v, 0, s);
      const S = p === o ? r : i;
      S.toArray(c, m),
        (m += 3),
        S.toArray(c, m),
        (m += 3),
        S.toArray(c, m),
        (m += 3),
        S.toArray(c, m),
        (m += 3);
    }
    const u = new Jt();
    u.setAttribute("position", new wt(l, 3)),
      u.setAttribute("color", new wt(c, 3));
    const d = new zi({ vertexColors: !0, toneMapped: !1 });
    super(u, d), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class b7 extends as {
  constructor(e = 10, n = 16, r = 8, i = 64, o = 4473924, a = 8947848) {
    (o = new pt(o)), (a = new pt(a));
    const s = [],
      l = [];
    if (n > 1)
      for (let d = 0; d < n; d++) {
        const p = (d / n) * (Math.PI * 2),
          m = Math.sin(p) * e,
          v = Math.cos(p) * e;
        s.push(0, 0, 0), s.push(m, 0, v);
        const S = d & 1 ? o : a;
        l.push(S.r, S.g, S.b), l.push(S.r, S.g, S.b);
      }
    for (let d = 0; d < r; d++) {
      const p = d & 1 ? o : a,
        m = e - (e / r) * d;
      for (let v = 0; v < i; v++) {
        let S = (v / i) * (Math.PI * 2),
          x = Math.sin(S) * m,
          g = Math.cos(S) * m;
        s.push(x, 0, g),
          l.push(p.r, p.g, p.b),
          (S = ((v + 1) / i) * (Math.PI * 2)),
          (x = Math.sin(S) * m),
          (g = Math.cos(S) * m),
          s.push(x, 0, g),
          l.push(p.r, p.g, p.b);
      }
    }
    const c = new Jt();
    c.setAttribute("position", new wt(s, 3)),
      c.setAttribute("color", new wt(l, 3));
    const u = new zi({ vertexColors: !0, toneMapped: !1 });
    super(c, u), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const BP = new K(),
  Av = new K(),
  HP = new K();
class w7 extends Sn {
  constructor(e, n, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "DirectionalLightHelper"),
      n === void 0 && (n = 1);
    let i = new Jt();
    i.setAttribute(
      "position",
      new wt([-n, n, 0, n, n, 0, n, -n, 0, -n, -n, 0, -n, n, 0], 3)
    );
    const o = new zi({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new jl(i, o)),
      this.add(this.lightPlane),
      (i = new Jt()),
      i.setAttribute("position", new wt([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new jl(i, o)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      BP.setFromMatrixPosition(this.light.matrixWorld),
      Av.setFromMatrixPosition(this.light.target.matrixWorld),
      HP.subVectors(Av, BP),
      this.lightPlane.lookAt(Av),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Av),
      (this.targetLine.scale.z = HP.length());
  }
}
const Rv = new K(),
  ir = new pm();
class E7 extends as {
  constructor(e) {
    const n = new Jt(),
      r = new zi({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      o = [],
      a = {};
    s("n1", "n2"),
      s("n2", "n4"),
      s("n4", "n3"),
      s("n3", "n1"),
      s("f1", "f2"),
      s("f2", "f4"),
      s("f4", "f3"),
      s("f3", "f1"),
      s("n1", "f1"),
      s("n2", "f2"),
      s("n3", "f3"),
      s("n4", "f4"),
      s("p", "n1"),
      s("p", "n2"),
      s("p", "n3"),
      s("p", "n4"),
      s("u1", "u2"),
      s("u2", "u3"),
      s("u3", "u1"),
      s("c", "t"),
      s("p", "c"),
      s("cn1", "cn2"),
      s("cn3", "cn4"),
      s("cf1", "cf2"),
      s("cf3", "cf4");
    function s(v, S) {
      l(v), l(S);
    }
    function l(v) {
      i.push(0, 0, 0),
        o.push(0, 0, 0),
        a[v] === void 0 && (a[v] = []),
        a[v].push(i.length / 3 - 1);
    }
    n.setAttribute("position", new wt(i, 3)),
      n.setAttribute("color", new wt(o, 3)),
      super(n, r),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = a),
      this.update();
    const c = new pt(16755200),
      u = new pt(16711680),
      d = new pt(43775),
      p = new pt(16777215),
      m = new pt(3355443);
    this.setColors(c, u, d, p, m);
  }
  setColors(e, n, r, i, o) {
    const s = this.geometry.getAttribute("color");
    s.setXYZ(0, e.r, e.g, e.b),
      s.setXYZ(1, e.r, e.g, e.b),
      s.setXYZ(2, e.r, e.g, e.b),
      s.setXYZ(3, e.r, e.g, e.b),
      s.setXYZ(4, e.r, e.g, e.b),
      s.setXYZ(5, e.r, e.g, e.b),
      s.setXYZ(6, e.r, e.g, e.b),
      s.setXYZ(7, e.r, e.g, e.b),
      s.setXYZ(8, e.r, e.g, e.b),
      s.setXYZ(9, e.r, e.g, e.b),
      s.setXYZ(10, e.r, e.g, e.b),
      s.setXYZ(11, e.r, e.g, e.b),
      s.setXYZ(12, e.r, e.g, e.b),
      s.setXYZ(13, e.r, e.g, e.b),
      s.setXYZ(14, e.r, e.g, e.b),
      s.setXYZ(15, e.r, e.g, e.b),
      s.setXYZ(16, e.r, e.g, e.b),
      s.setXYZ(17, e.r, e.g, e.b),
      s.setXYZ(18, e.r, e.g, e.b),
      s.setXYZ(19, e.r, e.g, e.b),
      s.setXYZ(20, e.r, e.g, e.b),
      s.setXYZ(21, e.r, e.g, e.b),
      s.setXYZ(22, e.r, e.g, e.b),
      s.setXYZ(23, e.r, e.g, e.b),
      s.setXYZ(24, n.r, n.g, n.b),
      s.setXYZ(25, n.r, n.g, n.b),
      s.setXYZ(26, n.r, n.g, n.b),
      s.setXYZ(27, n.r, n.g, n.b),
      s.setXYZ(28, n.r, n.g, n.b),
      s.setXYZ(29, n.r, n.g, n.b),
      s.setXYZ(30, n.r, n.g, n.b),
      s.setXYZ(31, n.r, n.g, n.b),
      s.setXYZ(32, r.r, r.g, r.b),
      s.setXYZ(33, r.r, r.g, r.b),
      s.setXYZ(34, r.r, r.g, r.b),
      s.setXYZ(35, r.r, r.g, r.b),
      s.setXYZ(36, r.r, r.g, r.b),
      s.setXYZ(37, r.r, r.g, r.b),
      s.setXYZ(38, i.r, i.g, i.b),
      s.setXYZ(39, i.r, i.g, i.b),
      s.setXYZ(40, o.r, o.g, o.b),
      s.setXYZ(41, o.r, o.g, o.b),
      s.setXYZ(42, o.r, o.g, o.b),
      s.setXYZ(43, o.r, o.g, o.b),
      s.setXYZ(44, o.r, o.g, o.b),
      s.setXYZ(45, o.r, o.g, o.b),
      s.setXYZ(46, o.r, o.g, o.b),
      s.setXYZ(47, o.r, o.g, o.b),
      s.setXYZ(48, o.r, o.g, o.b),
      s.setXYZ(49, o.r, o.g, o.b),
      (s.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      n = this.pointMap,
      r = 1,
      i = 1;
    ir.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      fr("c", n, e, ir, 0, 0, -1),
      fr("t", n, e, ir, 0, 0, 1),
      fr("n1", n, e, ir, -r, -i, -1),
      fr("n2", n, e, ir, r, -i, -1),
      fr("n3", n, e, ir, -r, i, -1),
      fr("n4", n, e, ir, r, i, -1),
      fr("f1", n, e, ir, -r, -i, 1),
      fr("f2", n, e, ir, r, -i, 1),
      fr("f3", n, e, ir, -r, i, 1),
      fr("f4", n, e, ir, r, i, 1),
      fr("u1", n, e, ir, r * 0.7, i * 1.1, -1),
      fr("u2", n, e, ir, -r * 0.7, i * 1.1, -1),
      fr("u3", n, e, ir, 0, i * 2, -1),
      fr("cf1", n, e, ir, -r, 0, 1),
      fr("cf2", n, e, ir, r, 0, 1),
      fr("cf3", n, e, ir, 0, -i, 1),
      fr("cf4", n, e, ir, 0, i, 1),
      fr("cn1", n, e, ir, -r, 0, -1),
      fr("cn2", n, e, ir, r, 0, -1),
      fr("cn3", n, e, ir, 0, -i, -1),
      fr("cn4", n, e, ir, 0, i, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function fr(t, e, n, r, i, o, a) {
  Rv.set(i, o, a).unproject(r);
  const s = e[t];
  if (s !== void 0) {
    const l = n.getAttribute("position");
    for (let c = 0, u = s.length; c < u; c++) l.setXYZ(s[c], Rv.x, Rv.y, Rv.z);
  }
}
const Pv = new wr();
class M7 extends as {
  constructor(e, n = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      o = new Jt();
    o.setIndex(new wn(r, 1)),
      o.setAttribute("position", new wn(i, 3)),
      super(o, new zi({ color: n, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && Pv.setFromObject(this.object),
      Pv.isEmpty())
    )
      return;
    const n = Pv.min,
      r = Pv.max,
      i = this.geometry.attributes.position,
      o = i.array;
    (o[0] = r.x),
      (o[1] = r.y),
      (o[2] = r.z),
      (o[3] = n.x),
      (o[4] = r.y),
      (o[5] = r.z),
      (o[6] = n.x),
      (o[7] = n.y),
      (o[8] = r.z),
      (o[9] = r.x),
      (o[10] = n.y),
      (o[11] = r.z),
      (o[12] = r.x),
      (o[13] = r.y),
      (o[14] = n.z),
      (o[15] = n.x),
      (o[16] = r.y),
      (o[17] = n.z),
      (o[18] = n.x),
      (o[19] = n.y),
      (o[20] = n.z),
      (o[21] = r.x),
      (o[22] = n.y),
      (o[23] = n.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, n) {
    return super.copy(e, n), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class C7 extends as {
  constructor(e, n = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      o = new Jt();
    o.setIndex(new wn(r, 1)),
      o.setAttribute("position", new wt(i, 3)),
      super(o, new zi({ color: n, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const n = this.box;
    n.isEmpty() ||
      (n.getCenter(this.position),
      n.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class T7 extends jl {
  constructor(e, n = 1, r = 16776960) {
    const i = r,
      o = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      a = new Jt();
    a.setAttribute("position", new wt(o, 3)),
      a.computeBoundingSphere(),
      super(a, new zi({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = n);
    const s = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      l = new Jt();
    l.setAttribute("position", new wt(s, 3)),
      l.computeBoundingSphere(),
      this.add(
        new Jn(
          l,
          new Ks({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const jP = new K();
let Iv, s_;
class A7 extends Sn {
  constructor(
    e = new K(0, 0, 1),
    n = new K(0, 0, 0),
    r = 1,
    i = 16776960,
    o = r * 0.2,
    a = o * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      Iv === void 0 &&
        ((Iv = new Jt()),
        Iv.setAttribute("position", new wt([0, 0, 0, 0, 1, 0], 3)),
        (s_ = new Rf(0, 0.5, 1, 5, 1)),
        s_.translate(0, -0.5, 0)),
      this.position.copy(n),
      (this.line = new jl(Iv, new zi({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Jn(s_, new Ks({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(r, o, a);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      jP.set(e.z, 0, -e.x).normalize();
      const n = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(jP, n);
    }
  }
  setLength(e, n = e * 0.2, r = n * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - n), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(r, n, r),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class R7 extends as {
  constructor(e = 1) {
    const n = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      r = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new Jt();
    i.setAttribute("position", new wt(n, 3)),
      i.setAttribute("color", new wt(r, 3));
    const o = new zi({ vertexColors: !0, toneMapped: !1 });
    super(i, o), (this.type = "AxesHelper");
  }
  setColors(e, n, r) {
    const i = new pt(),
      o = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(o, 0),
      i.toArray(o, 3),
      i.set(n),
      i.toArray(o, 6),
      i.toArray(o, 9),
      i.set(r),
      i.toArray(o, 12),
      i.toArray(o, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class P7 {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new pt()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, n) {
    return (
      (this.currentPath = new kp()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, n),
      this
    );
  }
  lineTo(e, n) {
    return this.currentPath.lineTo(e, n), this;
  }
  quadraticCurveTo(e, n, r, i) {
    return this.currentPath.quadraticCurveTo(e, n, r, i), this;
  }
  bezierCurveTo(e, n, r, i, o, a) {
    return this.currentPath.bezierCurveTo(e, n, r, i, o, a), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function n(g) {
      const _ = [];
      for (let y = 0, w = g.length; y < w; y++) {
        const A = g[y],
          M = new zl();
        (M.curves = A.curves), _.push(M);
      }
      return _;
    }
    function r(g, _) {
      const y = _.length;
      let w = !1;
      for (let A = y - 1, M = 0; M < y; A = M++) {
        let T = _[A],
          I = _[M],
          R = I.x - T.x,
          P = I.y - T.y;
        if (Math.abs(P) > Number.EPSILON) {
          if (
            (P < 0 && ((T = _[M]), (R = -R), (I = _[A]), (P = -P)),
            g.y < T.y || g.y > I.y)
          )
            continue;
          if (g.y === T.y) {
            if (g.x === T.x) return !0;
          } else {
            const F = P * (g.x - T.x) - R * (g.y - T.y);
            if (F === 0) return !0;
            if (F < 0) continue;
            w = !w;
          }
        } else {
          if (g.y !== T.y) continue;
          if ((I.x <= g.x && g.x <= T.x) || (T.x <= g.x && g.x <= I.x))
            return !0;
        }
      }
      return w;
    }
    const i = ns.isClockWise,
      o = this.subPaths;
    if (o.length === 0) return [];
    let a, s, l;
    const c = [];
    if (o.length === 1)
      return (s = o[0]), (l = new zl()), (l.curves = s.curves), c.push(l), c;
    let u = !i(o[0].getPoints());
    u = e ? !u : u;
    const d = [],
      p = [];
    let m = [],
      v = 0,
      S;
    (p[v] = void 0), (m[v] = []);
    for (let g = 0, _ = o.length; g < _; g++)
      (s = o[g]),
        (S = s.getPoints()),
        (a = i(S)),
        (a = e ? !a : a),
        a
          ? (!u && p[v] && v++,
            (p[v] = { s: new zl(), p: S }),
            (p[v].s.curves = s.curves),
            u && v++,
            (m[v] = []))
          : m[v].push({ h: s, p: S[0] });
    if (!p[0]) return n(o);
    if (p.length > 1) {
      let g = !1,
        _ = 0;
      for (let y = 0, w = p.length; y < w; y++) d[y] = [];
      for (let y = 0, w = p.length; y < w; y++) {
        const A = m[y];
        for (let M = 0; M < A.length; M++) {
          const T = A[M];
          let I = !0;
          for (let R = 0; R < p.length; R++)
            r(T.p, p[R].p) &&
              (y !== R && _++, I ? ((I = !1), d[R].push(T)) : (g = !0));
          I && d[y].push(T);
        }
      }
      _ > 0 && g === !1 && (m = d);
    }
    let x;
    for (let g = 0, _ = p.length; g < _; g++) {
      (l = p[g].s), c.push(l), (x = m[g]);
      for (let y = 0, w = x.length; y < w; y++) l.holes.push(x[y].h);
    }
    return c;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: um } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = um));
const I7 = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: $M,
      AddEquation: xl,
      AddOperation: vF,
      AdditiveAnimationBlendMode: JM,
      AdditiveBlending: Qb,
      AgXToneMapping: bF,
      AlphaFormat: CF,
      AlwaysCompare: VF,
      AlwaysDepth: uF,
      AlwaysStencilFunc: Rw,
      AmbientLight: GD,
      AnimationAction: QD,
      AnimationClip: Gp,
      AnimationLoader: FW,
      AnimationMixer: u7,
      AnimationObjectGroup: l7,
      AnimationUtils: IW,
      ArcCurve: vD,
      ArrayCamera: oD,
      ArrowHelper: A7,
      AttachedBindMode: rw,
      Audio: YD,
      AudioAnalyser: QW,
      AudioContext: AC,
      AudioListener: KW,
      AudioLoader: WW,
      AxesHelper: R7,
      BackSide: Oi,
      BasicDepthPacking: FF,
      BasicShadowMap: WN,
      BatchedMesh: pD,
      Bone: hC,
      BooleanKeyframeTrack: Su,
      Box2: m7,
      Box3: wr,
      Box3Helper: C7,
      BoxGeometry: xu,
      BoxHelper: M7,
      BufferAttribute: wn,
      BufferGeometry: Jt,
      BufferGeometryLoader: KD,
      ByteType: EF,
      Cache: Os,
      Camera: pm,
      CameraHelper: E7,
      CanvasTexture: tW,
      CapsuleGeometry: d1,
      CatmullRomCurve3: yD,
      CineonToneMapping: SF,
      CircleGeometry: f1,
      ClampToEdgeWrapping: pi,
      Clock: RC,
      Color: pt,
      ColorKeyframeTrack: MC,
      ColorManagement: Mn,
      CompressedArrayTexture: JG,
      CompressedCubeTexture: eW,
      CompressedTexture: c1,
      CompressedTextureLoader: DW,
      ConeGeometry: h1,
      ConstantAlphaFactor: sF,
      ConstantColorFactor: oF,
      CubeCamera: YF,
      CubeReflectionMapping: Vs,
      CubeRefractionMapping: Bl,
      CubeTexture: mm,
      CubeTextureLoader: zW,
      CubeUVReflectionMapping: Tf,
      CubicBezierCurve: gC,
      CubicBezierCurve3: xD,
      CubicInterpolant: zD,
      CullFaceBack: Zb,
      CullFaceFront: GN,
      CullFaceFrontBack: V6,
      CullFaceNone: $N,
      Curve: Oa,
      CurvePath: _D,
      CustomBlending: XN,
      CustomToneMapping: _F,
      CylinderGeometry: Rf,
      Cylindrical: p7,
      Data3DTexture: oC,
      DataArrayTexture: n1,
      DataTexture: Zc,
      DataTextureLoader: UW,
      DataUtils: QH,
      DecrementStencilOp: tH,
      DecrementWrapStencilOp: rH,
      DefaultLoadingManager: BD,
      DepthFormat: Fl,
      DepthStencilFormat: cu,
      DepthTexture: cC,
      DetachedBindMode: wF,
      DirectionalLight: $D,
      DirectionalLightHelper: w7,
      DiscreteInterpolant: UD,
      DisplayP3ColorSpace: t1,
      DodecahedronGeometry: p1,
      DoubleSide: Zo,
      DstAlphaFactor: eF,
      DstColorFactor: nF,
      DynamicCopyUsage: yH,
      DynamicDrawUsage: fH,
      DynamicReadUsage: mH,
      EdgesGeometry: bD,
      EllipseCurve: u1,
      EqualCompare: kF,
      EqualDepth: fF,
      EqualStencilFunc: sH,
      EquirectangularReflectionMapping: Cp,
      EquirectangularRefractionMapping: Tp,
      Euler: hm,
      EventDispatcher: qs,
      ExtrudeGeometry: g1,
      FileLoader: $s,
      Float16BufferAttribute: i8,
      Float32BufferAttribute: wt,
      Float64BufferAttribute: o8,
      FloatType: wa,
      Fog: s1,
      FogExp2: a1,
      FramebufferTexture: QG,
      FrontSide: js,
      Frustum: gm,
      GLBufferAttribute: h7,
      GLSL1: SH,
      GLSL3: Pw,
      GreaterCompare: BF,
      GreaterDepth: pF,
      GreaterEqualCompare: jF,
      GreaterEqualDepth: hF,
      GreaterEqualStencilFunc: dH,
      GreaterStencilFunc: cH,
      GridHelper: _7,
      Group: Hd,
      HalfFloatType: df,
      HemisphereLight: HD,
      HemisphereLightHelper: S7,
      IcosahedronGeometry: v1,
      ImageBitmapLoader: GW,
      ImageLoader: Wp,
      ImageUtils: iC,
      IncrementStencilOp: eH,
      IncrementWrapStencilOp: nH,
      InstancedBufferAttribute: uu,
      InstancedBufferGeometry: M1,
      InstancedInterleavedBuffer: hy,
      InstancedMesh: hD,
      Int16BufferAttribute: n8,
      Int32BufferAttribute: r8,
      Int8BufferAttribute: JH,
      IntType: WM,
      InterleavedBuffer: l1,
      InterleavedBufferAttribute: wo,
      Interpolant: Sm,
      InterpolateDiscrete: Pp,
      InterpolateLinear: Ip,
      InterpolateSmooth: _0,
      InvertStencilOp: iH,
      KeepStencilOp: Rc,
      KeyframeTrack: Na,
      LOD: cD,
      LatheGeometry: vm,
      Layers: Yc,
      LessCompare: UF,
      LessDepth: dF,
      LessEqualCompare: nC,
      LessEqualDepth: Mp,
      LessEqualStencilFunc: lH,
      LessStencilFunc: aH,
      Light: Jl,
      LightProbe: qD,
      Line: jl,
      Line3: ez,
      LineBasicMaterial: zi,
      LineCurve: vC,
      LineCurve3: SD,
      LineDashedMaterial: ND,
      LineLoop: mD,
      LineSegments: as,
      LinearDisplayP3ColorSpace: fm,
      LinearEncoding: eC,
      LinearFilter: Yn,
      LinearInterpolant: EC,
      LinearMipMapLinearFilter: q6,
      LinearMipMapNearestFilter: X6,
      LinearMipmapLinearFilter: Hl,
      LinearMipmapNearestFilter: GM,
      LinearSRGBColorSpace: rs,
      LinearToneMapping: yF,
      LinearTransfer: Op,
      Loader: no,
      LoaderUtils: Uw,
      LoadingManager: CC,
      LoopOnce: LF,
      LoopPingPong: NF,
      LoopRepeat: OF,
      LuminanceAlphaFormat: AF,
      LuminanceFormat: TF,
      MOUSE: Tc,
      Material: yi,
      MaterialLoader: E1,
      MathUtils: $F,
      Matrix3: Yt,
      Matrix4: kt,
      MaxEquation: nw,
      Mesh: Jn,
      MeshBasicMaterial: Ks,
      MeshDepthMaterial: i1,
      MeshDistanceMaterial: o1,
      MeshLambertMaterial: LD,
      MeshMatcapMaterial: OD,
      MeshNormalMaterial: ID,
      MeshPhongMaterial: RD,
      MeshPhysicalMaterial: AD,
      MeshStandardMaterial: bC,
      MeshToonMaterial: PD,
      MinEquation: tw,
      MirroredRepeatWrapping: Rp,
      MixOperation: gF,
      MultiplyBlending: ew,
      MultiplyOperation: dm,
      NearestFilter: pr,
      NearestMipMapLinearFilter: W6,
      NearestMipMapNearestFilter: G6,
      NearestMipmapLinearFilter: Yh,
      NearestMipmapNearestFilter: cy,
      NeverCompare: zF,
      NeverDepth: cF,
      NeverStencilFunc: oH,
      NoBlending: Fs,
      NoColorSpace: _o,
      NoToneMapping: Ja,
      NormalAnimationBlendMode: e1,
      NormalBlending: qc,
      NotEqualCompare: HF,
      NotEqualDepth: mF,
      NotEqualStencilFunc: uH,
      NumberKeyframeTrack: Vp,
      Object3D: Sn,
      ObjectLoader: VW,
      ObjectSpaceNormalMap: DF,
      OctahedronGeometry: ym,
      OneFactor: ZN,
      OneMinusConstantAlphaFactor: lF,
      OneMinusConstantColorFactor: aF,
      OneMinusDstAlphaFactor: tF,
      OneMinusDstColorFactor: rF,
      OneMinusSrcAlphaFactor: ly,
      OneMinusSrcColorFactor: JN,
      OrthographicCamera: ts,
      P3Primaries: Fp,
      PCFShadowMap: Zy,
      PCFSoftShadowMap: Kh,
      PMREMGenerator: Lw,
      Path: kp,
      PerspectiveCamera: Zn,
      Plane: Ts,
      PlaneGeometry: Zl,
      PlaneHelper: T7,
      PointLight: VD,
      PointLightHelper: y7,
      Points: gD,
      PointsMaterial: pC,
      PolarGridHelper: b7,
      PolyhedronGeometry: Ql,
      PositionalAudio: ZW,
      PropertyBinding: pn,
      PropertyMixer: ZD,
      QuadraticBezierCurve: yC,
      QuadraticBezierCurve3: xC,
      Quaternion: mi,
      QuaternionKeyframeTrack: Pf,
      QuaternionLinearInterpolant: kD,
      RED_GREEN_RGTC2_Format: Tw,
      RED_RGTC1_Format: IF,
      REVISION: um,
      RGBADepthPacking: tC,
      RGBAFormat: Ii,
      RGBAIntegerFormat: ZM,
      RGBA_ASTC_10x10_Format: _w,
      RGBA_ASTC_10x5_Format: yw,
      RGBA_ASTC_10x6_Format: xw,
      RGBA_ASTC_10x8_Format: Sw,
      RGBA_ASTC_12x10_Format: bw,
      RGBA_ASTC_12x12_Format: ww,
      RGBA_ASTC_4x4_Format: uw,
      RGBA_ASTC_5x4_Format: dw,
      RGBA_ASTC_5x5_Format: fw,
      RGBA_ASTC_6x5_Format: hw,
      RGBA_ASTC_6x6_Format: pw,
      RGBA_ASTC_8x5_Format: mw,
      RGBA_ASTC_8x6_Format: gw,
      RGBA_ASTC_8x8_Format: vw,
      RGBA_BPTC_Format: S0,
      RGBA_ETC2_EAC_Format: cw,
      RGBA_PVRTC_2BPPV1_Format: sw,
      RGBA_PVRTC_4BPPV1_Format: aw,
      RGBA_S3TC_DXT1_Format: v0,
      RGBA_S3TC_DXT3_Format: y0,
      RGBA_S3TC_DXT5_Format: x0,
      RGB_BPTC_SIGNED_Format: Ew,
      RGB_BPTC_UNSIGNED_Format: Mw,
      RGB_ETC1_Format: QM,
      RGB_ETC2_Format: lw,
      RGB_PVRTC_2BPPV1_Format: ow,
      RGB_PVRTC_4BPPV1_Format: iw,
      RGB_S3TC_DXT1_Format: g0,
      RGFormat: PF,
      RGIntegerFormat: YM,
      RawShaderMaterial: TD,
      Ray: yu,
      Raycaster: JD,
      Rec709Primaries: Np,
      RectAreaLight: WD,
      RedFormat: RF,
      RedIntegerFormat: KM,
      ReinhardToneMapping: xF,
      RenderTarget: XF,
      RepeatWrapping: Ap,
      ReplaceStencilOp: J6,
      ReverseSubtractEquation: KN,
      RingGeometry: y1,
      SIGNED_RED_GREEN_RGTC2_Format: Aw,
      SIGNED_RED_RGTC1_Format: Cw,
      SRGBColorSpace: Tr,
      SRGBTransfer: Un,
      Scene: dC,
      ShaderChunk: Xt,
      ShaderLib: _a,
      ShaderMaterial: Ia,
      ShadowMaterial: CD,
      Shape: zl,
      ShapeGeometry: x1,
      ShapePath: P7,
      ShapeUtils: ns,
      ShortType: MF,
      Skeleton: dD,
      SkeletonHelper: v7,
      SkinnedMesh: uD,
      Source: Hc,
      Sphere: Rr,
      SphereGeometry: xm,
      Spherical: Bw,
      SphericalHarmonics3: XD,
      SplineCurve: SC,
      SpotLight: jD,
      SpotLightHelper: g7,
      Sprite: lD,
      SpriteMaterial: fC,
      SrcAlphaFactor: sy,
      SrcAlphaSaturateFactor: iF,
      SrcColorFactor: QN,
      StaticCopyUsage: vH,
      StaticDrawUsage: Dp,
      StaticReadUsage: pH,
      StereoCamera: XW,
      StreamCopyUsage: xH,
      StreamDrawUsage: hH,
      StreamReadUsage: gH,
      StringKeyframeTrack: _u,
      SubtractEquation: qN,
      SubtractiveBlending: Jb,
      TOUCH: Ac,
      TangentSpaceNormalMap: Yl,
      TetrahedronGeometry: S1,
      Texture: sr,
      TextureLoader: kW,
      TorusGeometry: _1,
      TorusKnotGeometry: b1,
      Triangle: qi,
      TriangleFanDrawMode: Z6,
      TriangleStripDrawMode: Y6,
      TrianglesDrawMode: K6,
      TubeGeometry: w1,
      TwoPassDoubleSide: $6,
      UVMapping: Qy,
      Uint16BufferAttribute: aC,
      Uint32BufferAttribute: sC,
      Uint8BufferAttribute: e8,
      Uint8ClampedBufferAttribute: t8,
      Uniform: LC,
      UniformsGroup: f7,
      UniformsLib: lt,
      UniformsUtils: Up,
      UnsignedByteType: es,
      UnsignedInt248Type: Nl,
      UnsignedIntType: Ls,
      UnsignedShort4444Type: XM,
      UnsignedShort5551Type: qM,
      UnsignedShortType: Jy,
      VSMShadowMap: ma,
      Vector2: Ge,
      Vector3: K,
      Vector4: rn,
      VectorKeyframeTrack: $p,
      VideoTexture: ZG,
      WebGL1Renderer: aD,
      WebGL3DRenderTarget: BH,
      WebGLArrayRenderTarget: kH,
      WebGLCoordinateSystem: Ea,
      WebGLCubeRenderTarget: ZF,
      WebGLMultipleRenderTargets: HH,
      WebGLRenderTarget: Pa,
      WebGLRenderer: uC,
      WebGLUtils: iD,
      WebGPUCoordinateSystem: ff,
      WireframeGeometry: _C,
      WrapAroundEnding: Lp,
      ZeroCurvatureEnding: kc,
      ZeroFactor: YN,
      ZeroSlopeEnding: Bc,
      ZeroStencilOp: Q6,
      _SRGBAFormat: uy,
      createCanvasElement: WF,
      sRGBEncoding: Dl,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var nz = { exports: {} },
  bu = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ bu.ConcurrentRoot = 1;
bu.ContinuousEventPriority = 4;
bu.DefaultEventPriority = 16;
bu.DiscreteEventPriority = 1;
bu.IdleEventPriority = 536870912;
bu.LegacyRoot = 0;
nz.exports = bu;
var Vd = nz.exports;
function L7(t) {
  let e;
  const n = new Set(),
    r = (c, u) => {
      const d = typeof c == "function" ? c(e) : c;
      if (d !== e) {
        const p = e;
        (e = u ? d : Object.assign({}, e, d)), n.forEach((m) => m(e, p));
      }
    },
    i = () => e,
    o = (c, u = i, d = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let p = u(e);
      function m() {
        const v = u(e);
        if (!d(p, v)) {
          const S = p;
          c((p = v), S);
        }
      }
      return n.add(m), () => n.delete(m);
    },
    l = {
      setState: r,
      getState: i,
      subscribe: (c, u, d) =>
        u || d ? o(c, u, d) : (n.add(c), () => n.delete(c)),
      destroy: () => n.clear(),
    };
  return (e = t(r, i, l)), l;
}
const O7 =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  VP = O7 ? E.useEffect : E.useLayoutEffect;
function N7(t) {
  const e = typeof t == "function" ? L7(t) : t,
    n = (r = e.getState, i = Object.is) => {
      const [, o] = E.useReducer((x) => x + 1, 0),
        a = e.getState(),
        s = E.useRef(a),
        l = E.useRef(r),
        c = E.useRef(i),
        u = E.useRef(!1),
        d = E.useRef();
      d.current === void 0 && (d.current = r(a));
      let p,
        m = !1;
      (s.current !== a || l.current !== r || c.current !== i || u.current) &&
        ((p = r(a)), (m = !i(d.current, p))),
        VP(() => {
          m && (d.current = p),
            (s.current = a),
            (l.current = r),
            (c.current = i),
            (u.current = !1);
        });
      const v = E.useRef(a);
      VP(() => {
        const x = () => {
            try {
              const _ = e.getState(),
                y = l.current(_);
              c.current(d.current, y) ||
                ((s.current = _), (d.current = y), o());
            } catch {
              (u.current = !0), o();
            }
          },
          g = e.subscribe(x);
        return e.getState() !== v.current && x(), g;
      }, []);
      const S = m ? p : d.current;
      return E.useDebugValue(S), S;
    };
  return (
    Object.assign(n, e),
    (n[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const r = [n, e];
      return {
        next() {
          const i = r.length <= 0;
          return { value: r.shift(), done: i };
        },
      };
    }),
    n
  );
}
const F7 = (t) => typeof t == "object" && typeof t.then == "function",
  Lv = [];
function D7(t, e, n = (r, i) => r === i) {
  if (t === e) return !0;
  if (!t || !e) return !1;
  const r = t.length;
  if (e.length !== r) return !1;
  for (let i = 0; i < r; i++) if (!n(t[i], e[i])) return !1;
  return !0;
}
function z7(t, e = null, n = !1, r = {}) {
  e === null && (e = [t]);
  for (const o of Lv)
    if (D7(e, o.keys, o.equal)) {
      if (n) return;
      if (Object.prototype.hasOwnProperty.call(o, "error")) throw o.error;
      if (Object.prototype.hasOwnProperty.call(o, "response"))
        return (
          r.lifespan &&
            r.lifespan > 0 &&
            (o.timeout && clearTimeout(o.timeout),
            (o.timeout = setTimeout(o.remove, r.lifespan))),
          o.response
        );
      if (!n) throw o.promise;
    }
  const i = {
    keys: e,
    equal: r.equal,
    remove: () => {
      const o = Lv.indexOf(i);
      o !== -1 && Lv.splice(o, 1);
    },
    promise: (F7(t) ? t : t(...e))
      .then((o) => {
        (i.response = o),
          r.lifespan &&
            r.lifespan > 0 &&
            (i.timeout = setTimeout(i.remove, r.lifespan));
      })
      .catch((o) => (i.error = o)),
  };
  if ((Lv.push(i), !n)) throw i.promise;
}
const U7 = (t, e, n) => z7(t, e, !1, n);
var rz = { exports: {} },
  iz = { exports: {} },
  oz = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (t) {
  function e(B, $) {
    var G = B.length;
    B.push($);
    e: for (; 0 < G; ) {
      var k = (G - 1) >>> 1,
        q = B[k];
      if (0 < i(q, $)) (B[k] = $), (B[G] = q), (G = k);
      else break e;
    }
  }
  function n(B) {
    return B.length === 0 ? null : B[0];
  }
  function r(B) {
    if (B.length === 0) return null;
    var $ = B[0],
      G = B.pop();
    if (G !== $) {
      B[0] = G;
      e: for (var k = 0, q = B.length, X = q >>> 1; k < X; ) {
        var ee = 2 * (k + 1) - 1,
          J = B[ee],
          oe = ee + 1,
          ae = B[oe];
        if (0 > i(J, G))
          oe < q && 0 > i(ae, J)
            ? ((B[k] = ae), (B[oe] = G), (k = oe))
            : ((B[k] = J), (B[ee] = G), (k = ee));
        else if (oe < q && 0 > i(ae, G)) (B[k] = ae), (B[oe] = G), (k = oe);
        else break e;
      }
    }
    return $;
  }
  function i(B, $) {
    var G = B.sortIndex - $.sortIndex;
    return G !== 0 ? G : B.id - $.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var o = performance;
    t.unstable_now = function () {
      return o.now();
    };
  } else {
    var a = Date,
      s = a.now();
    t.unstable_now = function () {
      return a.now() - s;
    };
  }
  var l = [],
    c = [],
    u = 1,
    d = null,
    p = 3,
    m = !1,
    v = !1,
    S = !1,
    x = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    _ = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function y(B) {
    for (var $ = n(c); $ !== null; ) {
      if ($.callback === null) r(c);
      else if ($.startTime <= B)
        r(c), ($.sortIndex = $.expirationTime), e(l, $);
      else break;
      $ = n(c);
    }
  }
  function w(B) {
    if (((S = !1), y(B), !v))
      if (n(l) !== null) (v = !0), W(A);
      else {
        var $ = n(c);
        $ !== null && Q(w, $.startTime - B);
      }
  }
  function A(B, $) {
    (v = !1), S && ((S = !1), g(I), (I = -1)), (m = !0);
    var G = p;
    try {
      for (
        y($), d = n(l);
        d !== null && (!(d.expirationTime > $) || (B && !F()));

      ) {
        var k = d.callback;
        if (typeof k == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var q = k(d.expirationTime <= $);
          ($ = t.unstable_now()),
            typeof q == "function" ? (d.callback = q) : d === n(l) && r(l),
            y($);
        } else r(l);
        d = n(l);
      }
      if (d !== null) var X = !0;
      else {
        var ee = n(c);
        ee !== null && Q(w, ee.startTime - $), (X = !1);
      }
      return X;
    } finally {
      (d = null), (p = G), (m = !1);
    }
  }
  var M = !1,
    T = null,
    I = -1,
    R = 5,
    P = -1;
  function F() {
    return !(t.unstable_now() - P < R);
  }
  function D() {
    if (T !== null) {
      var B = t.unstable_now();
      P = B;
      var $ = !0;
      try {
        $ = T(!0, B);
      } finally {
        $ ? j() : ((M = !1), (T = null));
      }
    } else M = !1;
  }
  var j;
  if (typeof _ == "function")
    j = function () {
      _(D);
    };
  else if (typeof MessageChannel < "u") {
    var N = new MessageChannel(),
      V = N.port2;
    (N.port1.onmessage = D),
      (j = function () {
        V.postMessage(null);
      });
  } else
    j = function () {
      x(D, 0);
    };
  function W(B) {
    (T = B), M || ((M = !0), j());
  }
  function Q(B, $) {
    I = x(function () {
      B(t.unstable_now());
    }, $);
  }
  (t.unstable_IdlePriority = 5),
    (t.unstable_ImmediatePriority = 1),
    (t.unstable_LowPriority = 4),
    (t.unstable_NormalPriority = 3),
    (t.unstable_Profiling = null),
    (t.unstable_UserBlockingPriority = 2),
    (t.unstable_cancelCallback = function (B) {
      B.callback = null;
    }),
    (t.unstable_continueExecution = function () {
      v || m || ((v = !0), W(A));
    }),
    (t.unstable_forceFrameRate = function (B) {
      0 > B || 125 < B
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (R = 0 < B ? Math.floor(1e3 / B) : 5);
    }),
    (t.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (t.unstable_getFirstCallbackNode = function () {
      return n(l);
    }),
    (t.unstable_next = function (B) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var $ = 3;
          break;
        default:
          $ = p;
      }
      var G = p;
      p = $;
      try {
        return B();
      } finally {
        p = G;
      }
    }),
    (t.unstable_pauseExecution = function () {}),
    (t.unstable_requestPaint = function () {}),
    (t.unstable_runWithPriority = function (B, $) {
      switch (B) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          B = 3;
      }
      var G = p;
      p = B;
      try {
        return $();
      } finally {
        p = G;
      }
    }),
    (t.unstable_scheduleCallback = function (B, $, G) {
      var k = t.unstable_now();
      switch (
        (typeof G == "object" && G !== null
          ? ((G = G.delay), (G = typeof G == "number" && 0 < G ? k + G : k))
          : (G = k),
        B)
      ) {
        case 1:
          var q = -1;
          break;
        case 2:
          q = 250;
          break;
        case 5:
          q = 1073741823;
          break;
        case 4:
          q = 1e4;
          break;
        default:
          q = 5e3;
      }
      return (
        (q = G + q),
        (B = {
          id: u++,
          callback: $,
          priorityLevel: B,
          startTime: G,
          expirationTime: q,
          sortIndex: -1,
        }),
        G > k
          ? ((B.sortIndex = G),
            e(c, B),
            n(l) === null &&
              B === n(c) &&
              (S ? (g(I), (I = -1)) : (S = !0), Q(w, G - k)))
          : ((B.sortIndex = q), e(l, B), v || m || ((v = !0), W(A))),
        B
      );
    }),
    (t.unstable_shouldYield = F),
    (t.unstable_wrapCallback = function (B) {
      var $ = p;
      return function () {
        var G = p;
        p = $;
        try {
          return B.apply(this, arguments);
        } finally {
          p = G;
        }
      };
    });
})(oz);
iz.exports = oz;
var Hw = iz.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var k7 = function (e) {
  var n = {},
    r = E,
    i = Hw,
    o = Object.assign;
  function a(f) {
    for (
      var h = "https://reactjs.org/docs/error-decoder.html?invariant=" + f,
        b = 1;
      b < arguments.length;
      b++
    )
      h += "&args[]=" + encodeURIComponent(arguments[b]);
    return (
      "Minified React error #" +
      f +
      "; visit " +
      h +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    l = Symbol.for("react.element"),
    c = Symbol.for("react.portal"),
    u = Symbol.for("react.fragment"),
    d = Symbol.for("react.strict_mode"),
    p = Symbol.for("react.profiler"),
    m = Symbol.for("react.provider"),
    v = Symbol.for("react.context"),
    S = Symbol.for("react.forward_ref"),
    x = Symbol.for("react.suspense"),
    g = Symbol.for("react.suspense_list"),
    _ = Symbol.for("react.memo"),
    y = Symbol.for("react.lazy"),
    w = Symbol.for("react.offscreen"),
    A = Symbol.iterator;
  function M(f) {
    return f === null || typeof f != "object"
      ? null
      : ((f = (A && f[A]) || f["@@iterator"]),
        typeof f == "function" ? f : null);
  }
  function T(f) {
    if (f == null) return null;
    if (typeof f == "function") return f.displayName || f.name || null;
    if (typeof f == "string") return f;
    switch (f) {
      case u:
        return "Fragment";
      case c:
        return "Portal";
      case p:
        return "Profiler";
      case d:
        return "StrictMode";
      case x:
        return "Suspense";
      case g:
        return "SuspenseList";
    }
    if (typeof f == "object")
      switch (f.$$typeof) {
        case v:
          return (f.displayName || "Context") + ".Consumer";
        case m:
          return (f._context.displayName || "Context") + ".Provider";
        case S:
          var h = f.render;
          return (
            (f = f.displayName),
            f ||
              ((f = h.displayName || h.name || ""),
              (f = f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef")),
            f
          );
        case _:
          return (
            (h = f.displayName || null), h !== null ? h : T(f.type) || "Memo"
          );
        case y:
          (h = f._payload), (f = f._init);
          try {
            return T(f(h));
          } catch {}
      }
    return null;
  }
  function I(f) {
    var h = f.type;
    switch (f.tag) {
      case 24:
        return "Cache";
      case 9:
        return (h.displayName || "Context") + ".Consumer";
      case 10:
        return (h._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (f = h.render),
          (f = f.displayName || f.name || ""),
          h.displayName || (f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return h;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return T(h);
      case 8:
        return h === d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof h == "function") return h.displayName || h.name || null;
        if (typeof h == "string") return h;
    }
    return null;
  }
  function R(f) {
    var h = f,
      b = f;
    if (f.alternate) for (; h.return; ) h = h.return;
    else {
      f = h;
      do (h = f), h.flags & 4098 && (b = h.return), (f = h.return);
      while (f);
    }
    return h.tag === 3 ? b : null;
  }
  function P(f) {
    if (R(f) !== f) throw Error(a(188));
  }
  function F(f) {
    var h = f.alternate;
    if (!h) {
      if (((h = R(f)), h === null)) throw Error(a(188));
      return h !== f ? null : f;
    }
    for (var b = f, C = h; ; ) {
      var O = b.return;
      if (O === null) break;
      var U = O.alternate;
      if (U === null) {
        if (((C = O.return), C !== null)) {
          b = C;
          continue;
        }
        break;
      }
      if (O.child === U.child) {
        for (U = O.child; U; ) {
          if (U === b) return P(O), f;
          if (U === C) return P(O), h;
          U = U.sibling;
        }
        throw Error(a(188));
      }
      if (b.return !== C.return) (b = O), (C = U);
      else {
        for (var re = !1, xe = O.child; xe; ) {
          if (xe === b) {
            (re = !0), (b = O), (C = U);
            break;
          }
          if (xe === C) {
            (re = !0), (C = O), (b = U);
            break;
          }
          xe = xe.sibling;
        }
        if (!re) {
          for (xe = U.child; xe; ) {
            if (xe === b) {
              (re = !0), (b = U), (C = O);
              break;
            }
            if (xe === C) {
              (re = !0), (C = U), (b = O);
              break;
            }
            xe = xe.sibling;
          }
          if (!re) throw Error(a(189));
        }
      }
      if (b.alternate !== C) throw Error(a(190));
    }
    if (b.tag !== 3) throw Error(a(188));
    return b.stateNode.current === b ? f : h;
  }
  function D(f) {
    return (f = F(f)), f !== null ? j(f) : null;
  }
  function j(f) {
    if (f.tag === 5 || f.tag === 6) return f;
    for (f = f.child; f !== null; ) {
      var h = j(f);
      if (h !== null) return h;
      f = f.sibling;
    }
    return null;
  }
  function N(f) {
    if (f.tag === 5 || f.tag === 6) return f;
    for (f = f.child; f !== null; ) {
      if (f.tag !== 4) {
        var h = N(f);
        if (h !== null) return h;
      }
      f = f.sibling;
    }
    return null;
  }
  var V = Array.isArray,
    W = e.getPublicInstance,
    Q = e.getRootHostContext,
    B = e.getChildHostContext,
    $ = e.prepareForCommit,
    G = e.resetAfterCommit,
    k = e.createInstance,
    q = e.appendInitialChild,
    X = e.finalizeInitialChildren,
    ee = e.prepareUpdate,
    J = e.shouldSetTextContent,
    oe = e.createTextInstance,
    ae = e.scheduleTimeout,
    le = e.cancelTimeout,
    _e = e.noTimeout,
    me = e.isPrimaryRenderer,
    se = e.supportsMutation,
    Y = e.supportsPersistence,
    ve = e.supportsHydration,
    de = e.getInstanceFromNode,
    ue = e.preparePortalMount,
    fe = e.getCurrentEventPriority,
    Te = e.detachDeletedInstance,
    pe = e.supportsMicrotasks,
    H = e.scheduleMicrotask,
    z = e.supportsTestSelectors,
    Z = e.findFiberRoot,
    ge = e.getBoundingRect,
    ce = e.getTextContent,
    he = e.isHiddenSubtree,
    Me = e.matchAccessibilityRole,
    Re = e.setFocusIfFocusable,
    Le = e.setupIntersectionObserver,
    Oe = e.appendChild,
    Pe = e.appendChildToContainer,
    Se = e.commitTextUpdate,
    Je = e.commitMount,
    st = e.commitUpdate,
    Qe = e.insertBefore,
    Ke = e.insertInContainerBefore,
    Ne = e.removeChild,
    ne = e.removeChildFromContainer,
    Ie = e.resetTextContent,
    et = e.hideInstance,
    We = e.hideTextInstance,
    Ee = e.unhideInstance,
    ie = e.unhideTextInstance,
    $e = e.clearContainer,
    He = e.cloneInstance,
    Xe = e.createContainerChildSet,
    Ue = e.appendChildToContainerChildSet,
    Ye = e.finalizeContainerChildren,
    ke = e.replaceContainerChildren,
    tt = e.cloneHiddenInstance,
    ut = e.cloneHiddenTextInstance,
    dt = e.canHydrateInstance,
    Rt = e.canHydrateTextInstance,
    Bt = e.canHydrateSuspenseInstance,
    In = e.isSuspenseInstancePending,
    dn = e.isSuspenseInstanceFallback,
    _n = e.registerSuspenseInstanceRetry,
    gn = e.getNextHydratableSibling,
    Gt = e.getFirstHydratableChild,
    ln = e.getFirstHydratableChildWithinContainer,
    Ht = e.getFirstHydratableChildWithinSuspenseInstance,
    Dt = e.hydrateInstance,
    nn = e.hydrateTextInstance,
    Ln = e.hydrateSuspenseInstance,
    te = e.getNextHydratableInstanceAfterSuspenseInstance,
    ye = e.commitHydratedContainer,
    Ae = e.commitHydratedSuspenseInstance,
    ze = e.clearSuspenseBoundary,
    Ce = e.clearSuspenseBoundaryFromContainer,
    ot = e.shouldDeleteUnhydratedTailInstances,
    ht = e.didNotMatchHydratedContainerTextInstance,
    xt = e.didNotMatchHydratedTextInstance,
    qe;
  function bt(f) {
    if (qe === void 0)
      try {
        throw Error();
      } catch (b) {
        var h = b.stack.trim().match(/\n( *(at )?)/);
        qe = (h && h[1]) || "";
      }
    return (
      `
` +
      qe +
      f
    );
  }
  var Lt = !1;
  function Mt(f, h) {
    if (!f || Lt) return "";
    Lt = !0;
    var b = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (h)
        if (
          ((h = function () {
            throw Error();
          }),
          Object.defineProperty(h.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(h, []);
          } catch (it) {
            var C = it;
          }
          Reflect.construct(f, [], h);
        } else {
          try {
            h.call();
          } catch (it) {
            C = it;
          }
          f.call(h.prototype);
        }
      else {
        try {
          throw Error();
        } catch (it) {
          C = it;
        }
        f();
      }
    } catch (it) {
      if (it && C && typeof it.stack == "string") {
        for (
          var O = it.stack.split(`
`),
            U = C.stack.split(`
`),
            re = O.length - 1,
            xe = U.length - 1;
          1 <= re && 0 <= xe && O[re] !== U[xe];

        )
          xe--;
        for (; 1 <= re && 0 <= xe; re--, xe--)
          if (O[re] !== U[xe]) {
            if (re !== 1 || xe !== 1)
              do
                if ((re--, xe--, 0 > xe || O[re] !== U[xe])) {
                  var je =
                    `
` + O[re].replace(" at new ", " at ");
                  return (
                    f.displayName &&
                      je.includes("<anonymous>") &&
                      (je = je.replace("<anonymous>", f.displayName)),
                    je
                  );
                }
              while (1 <= re && 0 <= xe);
            break;
          }
      }
    } finally {
      (Lt = !1), (Error.prepareStackTrace = b);
    }
    return (f = f ? f.displayName || f.name : "") ? bt(f) : "";
  }
  var qt = Object.prototype.hasOwnProperty,
    On = [],
    tn = -1;
  function cn(f) {
    return { current: f };
  }
  function St(f) {
    0 > tn || ((f.current = On[tn]), (On[tn] = null), tn--);
  }
  function ct(f, h) {
    tn++, (On[tn] = f.current), (f.current = h);
  }
  var zn = {},
    Ot = cn(zn),
    fn = cn(!1),
    Xn = zn;
  function Ut(f, h) {
    var b = f.type.contextTypes;
    if (!b) return zn;
    var C = f.stateNode;
    if (C && C.__reactInternalMemoizedUnmaskedChildContext === h)
      return C.__reactInternalMemoizedMaskedChildContext;
    var O = {},
      U;
    for (U in b) O[U] = h[U];
    return (
      C &&
        ((f = f.stateNode),
        (f.__reactInternalMemoizedUnmaskedChildContext = h),
        (f.__reactInternalMemoizedMaskedChildContext = O)),
      O
    );
  }
  function Pt(f) {
    return (f = f.childContextTypes), f != null;
  }
  function Tt() {
    St(fn), St(Ot);
  }
  function vn(f, h, b) {
    if (Ot.current !== zn) throw Error(a(168));
    ct(Ot, h), ct(fn, b);
  }
  function En(f, h, b) {
    var C = f.stateNode;
    if (((h = h.childContextTypes), typeof C.getChildContext != "function"))
      return b;
    C = C.getChildContext();
    for (var O in C) if (!(O in h)) throw Error(a(108, I(f) || "Unknown", O));
    return o({}, b, C);
  }
  function bn(f) {
    return (
      (f =
        ((f = f.stateNode) && f.__reactInternalMemoizedMergedChildContext) ||
        zn),
      (Xn = Ot.current),
      ct(Ot, f),
      ct(fn, fn.current),
      !0
    );
  }
  function Bn(f, h, b) {
    var C = f.stateNode;
    if (!C) throw Error(a(169));
    b
      ? ((f = En(f, h, Xn)),
        (C.__reactInternalMemoizedMergedChildContext = f),
        St(fn),
        St(Ot),
        ct(Ot, f))
      : St(fn),
      ct(fn, b);
  }
  var lr = Math.clz32 ? Math.clz32 : ki,
    Vr = Math.log,
    Ui = Math.LN2;
  function ki(f) {
    return (f >>>= 0), f === 0 ? 32 : (31 - ((Vr(f) / Ui) | 0)) | 0;
  }
  var Or = 64,
    Si = 4194304;
  function nr(f) {
    switch (f & -f) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return f & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return f;
    }
  }
  function No(f, h) {
    var b = f.pendingLanes;
    if (b === 0) return 0;
    var C = 0,
      O = f.suspendedLanes,
      U = f.pingedLanes,
      re = b & 268435455;
    if (re !== 0) {
      var xe = re & ~O;
      xe !== 0 ? (C = nr(xe)) : ((U &= re), U !== 0 && (C = nr(U)));
    } else (re = b & ~O), re !== 0 ? (C = nr(re)) : U !== 0 && (C = nr(U));
    if (C === 0) return 0;
    if (
      h !== 0 &&
      h !== C &&
      !(h & O) &&
      ((O = C & -C), (U = h & -h), O >= U || (O === 16 && (U & 4194240) !== 0))
    )
      return h;
    if ((C & 4 && (C |= b & 16), (h = f.entangledLanes), h !== 0))
      for (f = f.entanglements, h &= C; 0 < h; )
        (b = 31 - lr(h)), (O = 1 << b), (C |= f[b]), (h &= ~O);
    return C;
  }
  function Bi(f, h) {
    switch (f) {
      case 1:
      case 2:
      case 4:
        return h + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return h + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function oo(f, h) {
    for (
      var b = f.suspendedLanes,
        C = f.pingedLanes,
        O = f.expirationTimes,
        U = f.pendingLanes;
      0 < U;

    ) {
      var re = 31 - lr(U),
        xe = 1 << re,
        je = O[re];
      je === -1
        ? (!(xe & b) || xe & C) && (O[re] = Bi(xe, h))
        : je <= h && (f.expiredLanes |= xe),
        (U &= ~xe);
    }
  }
  function ei(f) {
    return (
      (f = f.pendingLanes & -1073741825),
      f !== 0 ? f : f & 1073741824 ? 1073741824 : 0
    );
  }
  function ao(f) {
    for (var h = [], b = 0; 31 > b; b++) h.push(f);
    return h;
  }
  function ti(f, h, b) {
    (f.pendingLanes |= h),
      h !== 536870912 && ((f.suspendedLanes = 0), (f.pingedLanes = 0)),
      (f = f.eventTimes),
      (h = 31 - lr(h)),
      (f[h] = b);
  }
  function Hi(f, h) {
    var b = f.pendingLanes & ~h;
    (f.pendingLanes = h),
      (f.suspendedLanes = 0),
      (f.pingedLanes = 0),
      (f.expiredLanes &= h),
      (f.mutableReadLanes &= h),
      (f.entangledLanes &= h),
      (h = f.entanglements);
    var C = f.eventTimes;
    for (f = f.expirationTimes; 0 < b; ) {
      var O = 31 - lr(b),
        U = 1 << O;
      (h[O] = 0), (C[O] = -1), (f[O] = -1), (b &= ~U);
    }
  }
  function _i(f, h) {
    var b = (f.entangledLanes |= h);
    for (f = f.entanglements; b; ) {
      var C = 31 - lr(b),
        O = 1 << C;
      (O & h) | (f[C] & h) && (f[C] |= h), (b &= ~O);
    }
  }
  var Wt = 0;
  function us(f) {
    return (
      (f &= -f), 1 < f ? (4 < f ? (f & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var so = i.unstable_scheduleCallback,
    za = i.unstable_cancelCallback,
    vt = i.unstable_shouldYield,
    zt = i.unstable_requestPaint,
    jt = i.unstable_now,
    Nn = i.unstable_ImmediatePriority,
    Fn = i.unstable_UserBlockingPriority,
    vr = i.unstable_NormalPriority,
    ds = i.unstable_IdlePriority,
    Ua = null,
    Nr = null;
  function Ff(f) {
    if (Nr && typeof Nr.onCommitFiberRoot == "function")
      try {
        Nr.onCommitFiberRoot(Ua, f, void 0, (f.current.flags & 128) === 128);
      } catch {}
  }
  function zm(f, h) {
    return (f === h && (f !== 0 || 1 / f === 1 / h)) || (f !== f && h !== h);
  }
  var lo = typeof Object.is == "function" ? Object.is : zm,
    bi = null,
    ka = !1,
    Fo = !1;
  function Df(f) {
    bi === null ? (bi = [f]) : bi.push(f);
  }
  function zf(f) {
    (ka = !0), Df(f);
  }
  function ji() {
    if (!Fo && bi !== null) {
      Fo = !0;
      var f = 0,
        h = Wt;
      try {
        var b = bi;
        for (Wt = 1; f < b.length; f++) {
          var C = b[f];
          do C = C(!0);
          while (C !== null);
        }
        (bi = null), (ka = !1);
      } catch (O) {
        throw (bi !== null && (bi = bi.slice(f + 1)), so(Nn, ji), O);
      } finally {
        (Wt = h), (Fo = !1);
      }
    }
    return null;
  }
  var tc = s.ReactCurrentBatchConfig;
  function nc(f, h) {
    if (lo(f, h)) return !0;
    if (
      typeof f != "object" ||
      f === null ||
      typeof h != "object" ||
      h === null
    )
      return !1;
    var b = Object.keys(f),
      C = Object.keys(h);
    if (b.length !== C.length) return !1;
    for (C = 0; C < b.length; C++) {
      var O = b[C];
      if (!qt.call(h, O) || !lo(f[O], h[O])) return !1;
    }
    return !0;
  }
  function rc(f) {
    switch (f.tag) {
      case 5:
        return bt(f.type);
      case 16:
        return bt("Lazy");
      case 13:
        return bt("Suspense");
      case 19:
        return bt("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (f = Mt(f.type, !1)), f;
      case 11:
        return (f = Mt(f.type.render, !1)), f;
      case 1:
        return (f = Mt(f.type, !0)), f;
      default:
        return "";
    }
  }
  function wi(f, h) {
    if (f && f.defaultProps) {
      (h = o({}, h)), (f = f.defaultProps);
      for (var b in f) h[b] === void 0 && (h[b] = f[b]);
      return h;
    }
    return h;
  }
  var Fr = cn(null),
    Au = null,
    sa = null,
    Zs = null;
  function Ru() {
    Zs = sa = Au = null;
  }
  function Um(f, h, b) {
    me
      ? (ct(Fr, h._currentValue), (h._currentValue = b))
      : (ct(Fr, h._currentValue2), (h._currentValue2 = b));
  }
  function Dr(f) {
    var h = Fr.current;
    St(Fr), me ? (f._currentValue = h) : (f._currentValue2 = h);
  }
  function Ei(f, h, b) {
    for (; f !== null; ) {
      var C = f.alternate;
      if (
        ((f.childLanes & h) !== h
          ? ((f.childLanes |= h), C !== null && (C.childLanes |= h))
          : C !== null && (C.childLanes & h) !== h && (C.childLanes |= h),
        f === b)
      )
        break;
      f = f.return;
    }
  }
  function cr(f, h) {
    (Au = f),
      (Zs = sa = null),
      (f = f.dependencies),
      f !== null &&
        f.firstContext !== null &&
        (f.lanes & h && (ho = !0), (f.firstContext = null));
  }
  function ur(f) {
    var h = me ? f._currentValue : f._currentValue2;
    if (Zs !== f)
      if (((f = { context: f, memoizedValue: h, next: null }), sa === null)) {
        if (Au === null) throw Error(a(308));
        (sa = f), (Au.dependencies = { lanes: 0, firstContext: f });
      } else sa = sa.next = f;
    return h;
  }
  var co = null,
    Qs = !1;
  function ax(f) {
    f.updateQueue = {
      baseState: f.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function L2(f, h) {
    (f = f.updateQueue),
      h.updateQueue === f &&
        (h.updateQueue = {
          baseState: f.baseState,
          firstBaseUpdate: f.firstBaseUpdate,
          lastBaseUpdate: f.lastBaseUpdate,
          shared: f.shared,
          effects: f.effects,
        });
  }
  function fs(f, h) {
    return {
      eventTime: f,
      lane: h,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function Js(f, h) {
    var b = f.updateQueue;
    b !== null &&
      ((b = b.shared),
      yr !== null && f.mode & 1 && !(en & 2)
        ? ((f = b.interleaved),
          f === null
            ? ((h.next = h), co === null ? (co = [b]) : co.push(b))
            : ((h.next = f.next), (f.next = h)),
          (b.interleaved = h))
        : ((f = b.pending),
          f === null ? (h.next = h) : ((h.next = f.next), (f.next = h)),
          (b.pending = h)));
  }
  function km(f, h, b) {
    if (
      ((h = h.updateQueue), h !== null && ((h = h.shared), (b & 4194240) !== 0))
    ) {
      var C = h.lanes;
      (C &= f.pendingLanes), (b |= C), (h.lanes = b), _i(f, b);
    }
  }
  function O2(f, h) {
    var b = f.updateQueue,
      C = f.alternate;
    if (C !== null && ((C = C.updateQueue), b === C)) {
      var O = null,
        U = null;
      if (((b = b.firstBaseUpdate), b !== null)) {
        do {
          var re = {
            eventTime: b.eventTime,
            lane: b.lane,
            tag: b.tag,
            payload: b.payload,
            callback: b.callback,
            next: null,
          };
          U === null ? (O = U = re) : (U = U.next = re), (b = b.next);
        } while (b !== null);
        U === null ? (O = U = h) : (U = U.next = h);
      } else O = U = h;
      (b = {
        baseState: C.baseState,
        firstBaseUpdate: O,
        lastBaseUpdate: U,
        shared: C.shared,
        effects: C.effects,
      }),
        (f.updateQueue = b);
      return;
    }
    (f = b.lastBaseUpdate),
      f === null ? (b.firstBaseUpdate = h) : (f.next = h),
      (b.lastBaseUpdate = h);
  }
  function Bm(f, h, b, C) {
    var O = f.updateQueue;
    Qs = !1;
    var U = O.firstBaseUpdate,
      re = O.lastBaseUpdate,
      xe = O.shared.pending;
    if (xe !== null) {
      O.shared.pending = null;
      var je = xe,
        it = je.next;
      (je.next = null), re === null ? (U = it) : (re.next = it), (re = je);
      var _t = f.alternate;
      _t !== null &&
        ((_t = _t.updateQueue),
        (xe = _t.lastBaseUpdate),
        xe !== re &&
          (xe === null ? (_t.firstBaseUpdate = it) : (xe.next = it),
          (_t.lastBaseUpdate = je)));
    }
    if (U !== null) {
      var Vt = O.baseState;
      (re = 0), (_t = it = je = null), (xe = U);
      do {
        var Nt = xe.lane,
          Dn = xe.eventTime;
        if ((C & Nt) === Nt) {
          _t !== null &&
            (_t = _t.next =
              {
                eventTime: Dn,
                lane: 0,
                tag: xe.tag,
                payload: xe.payload,
                callback: xe.callback,
                next: null,
              });
          e: {
            var At = f,
              oi = xe;
            switch (((Nt = h), (Dn = b), oi.tag)) {
              case 1:
                if (((At = oi.payload), typeof At == "function")) {
                  Vt = At.call(Dn, Vt, Nt);
                  break e;
                }
                Vt = At;
                break e;
              case 3:
                At.flags = (At.flags & -65537) | 128;
              case 0:
                if (
                  ((At = oi.payload),
                  (Nt = typeof At == "function" ? At.call(Dn, Vt, Nt) : At),
                  Nt == null)
                )
                  break e;
                Vt = o({}, Vt, Nt);
                break e;
              case 2:
                Qs = !0;
            }
          }
          xe.callback !== null &&
            xe.lane !== 0 &&
            ((f.flags |= 64),
            (Nt = O.effects),
            Nt === null ? (O.effects = [xe]) : Nt.push(xe));
        } else
          (Dn = {
            eventTime: Dn,
            lane: Nt,
            tag: xe.tag,
            payload: xe.payload,
            callback: xe.callback,
            next: null,
          }),
            _t === null ? ((it = _t = Dn), (je = Vt)) : (_t = _t.next = Dn),
            (re |= Nt);
        if (((xe = xe.next), xe === null)) {
          if (((xe = O.shared.pending), xe === null)) break;
          (Nt = xe),
            (xe = Nt.next),
            (Nt.next = null),
            (O.lastBaseUpdate = Nt),
            (O.shared.pending = null);
        }
      } while (!0);
      if (
        (_t === null && (je = Vt),
        (O.baseState = je),
        (O.firstBaseUpdate = it),
        (O.lastBaseUpdate = _t),
        (h = O.shared.interleaved),
        h !== null)
      ) {
        O = h;
        do (re |= O.lane), (O = O.next);
        while (O !== h);
      } else U === null && (O.shared.lanes = 0);
      (Uu |= re), (f.lanes = re), (f.memoizedState = Vt);
    }
  }
  function N2(f, h, b) {
    if (((f = h.effects), (h.effects = null), f !== null))
      for (h = 0; h < f.length; h++) {
        var C = f[h],
          O = C.callback;
        if (O !== null) {
          if (((C.callback = null), (C = b), typeof O != "function"))
            throw Error(a(191, O));
          O.call(C);
        }
      }
  }
  var F2 = new r.Component().refs;
  function sx(f, h, b, C) {
    (h = f.memoizedState),
      (b = b(C, h)),
      (b = b == null ? h : o({}, h, b)),
      (f.memoizedState = b),
      f.lanes === 0 && (f.updateQueue.baseState = b);
  }
  var Hm = {
    isMounted: function (f) {
      return (f = f._reactInternals) ? R(f) === f : !1;
    },
    enqueueSetState: function (f, h, b) {
      f = f._reactInternals;
      var C = Ci(),
        O = nl(f),
        U = fs(C, O);
      (U.payload = h),
        b != null && (U.callback = b),
        Js(f, U),
        (h = Bo(f, O, C)),
        h !== null && km(h, f, O);
    },
    enqueueReplaceState: function (f, h, b) {
      f = f._reactInternals;
      var C = Ci(),
        O = nl(f),
        U = fs(C, O);
      (U.tag = 1),
        (U.payload = h),
        b != null && (U.callback = b),
        Js(f, U),
        (h = Bo(f, O, C)),
        h !== null && km(h, f, O);
    },
    enqueueForceUpdate: function (f, h) {
      f = f._reactInternals;
      var b = Ci(),
        C = nl(f),
        O = fs(b, C);
      (O.tag = 2),
        h != null && (O.callback = h),
        Js(f, O),
        (h = Bo(f, C, b)),
        h !== null && km(h, f, C);
    },
  };
  function D2(f, h, b, C, O, U, re) {
    return (
      (f = f.stateNode),
      typeof f.shouldComponentUpdate == "function"
        ? f.shouldComponentUpdate(C, U, re)
        : h.prototype && h.prototype.isPureReactComponent
        ? !nc(b, C) || !nc(O, U)
        : !0
    );
  }
  function z2(f, h, b) {
    var C = !1,
      O = zn,
      U = h.contextType;
    return (
      typeof U == "object" && U !== null
        ? (U = ur(U))
        : ((O = Pt(h) ? Xn : Ot.current),
          (C = h.contextTypes),
          (U = (C = C != null) ? Ut(f, O) : zn)),
      (h = new h(b, U)),
      (f.memoizedState =
        h.state !== null && h.state !== void 0 ? h.state : null),
      (h.updater = Hm),
      (f.stateNode = h),
      (h._reactInternals = f),
      C &&
        ((f = f.stateNode),
        (f.__reactInternalMemoizedUnmaskedChildContext = O),
        (f.__reactInternalMemoizedMaskedChildContext = U)),
      h
    );
  }
  function U2(f, h, b, C) {
    (f = h.state),
      typeof h.componentWillReceiveProps == "function" &&
        h.componentWillReceiveProps(b, C),
      typeof h.UNSAFE_componentWillReceiveProps == "function" &&
        h.UNSAFE_componentWillReceiveProps(b, C),
      h.state !== f && Hm.enqueueReplaceState(h, h.state, null);
  }
  function lx(f, h, b, C) {
    var O = f.stateNode;
    (O.props = b), (O.state = f.memoizedState), (O.refs = F2), ax(f);
    var U = h.contextType;
    typeof U == "object" && U !== null
      ? (O.context = ur(U))
      : ((U = Pt(h) ? Xn : Ot.current), (O.context = Ut(f, U))),
      (O.state = f.memoizedState),
      (U = h.getDerivedStateFromProps),
      typeof U == "function" && (sx(f, h, U, b), (O.state = f.memoizedState)),
      typeof h.getDerivedStateFromProps == "function" ||
        typeof O.getSnapshotBeforeUpdate == "function" ||
        (typeof O.UNSAFE_componentWillMount != "function" &&
          typeof O.componentWillMount != "function") ||
        ((h = O.state),
        typeof O.componentWillMount == "function" && O.componentWillMount(),
        typeof O.UNSAFE_componentWillMount == "function" &&
          O.UNSAFE_componentWillMount(),
        h !== O.state && Hm.enqueueReplaceState(O, O.state, null),
        Bm(f, b, O, C),
        (O.state = f.memoizedState)),
      typeof O.componentDidMount == "function" && (f.flags |= 4194308);
  }
  var Pu = [],
    Iu = 0,
    jm = null,
    Vm = 0,
    Do = [],
    zo = 0,
    ic = null,
    hs = 1,
    ps = "";
  function oc(f, h) {
    (Pu[Iu++] = Vm), (Pu[Iu++] = jm), (jm = f), (Vm = h);
  }
  function k2(f, h, b) {
    (Do[zo++] = hs), (Do[zo++] = ps), (Do[zo++] = ic), (ic = f);
    var C = hs;
    f = ps;
    var O = 32 - lr(C) - 1;
    (C &= ~(1 << O)), (b += 1);
    var U = 32 - lr(h) + O;
    if (30 < U) {
      var re = O - (O % 5);
      (U = (C & ((1 << re) - 1)).toString(32)),
        (C >>= re),
        (O -= re),
        (hs = (1 << (32 - lr(h) + O)) | (b << O) | C),
        (ps = U + f);
    } else (hs = (1 << U) | (b << O) | C), (ps = f);
  }
  function cx(f) {
    f.return !== null && (oc(f, 1), k2(f, 1, 0));
  }
  function ux(f) {
    for (; f === jm; )
      (jm = Pu[--Iu]), (Pu[Iu] = null), (Vm = Pu[--Iu]), (Pu[Iu] = null);
    for (; f === ic; )
      (ic = Do[--zo]),
        (Do[zo] = null),
        (ps = Do[--zo]),
        (Do[zo] = null),
        (hs = Do[--zo]),
        (Do[zo] = null);
  }
  var uo = null,
    fo = null,
    Gn = !1,
    Uf = !1,
    la = null;
  function B2(f, h) {
    var b = Ho(5, null, null, 0);
    (b.elementType = "DELETED"),
      (b.stateNode = h),
      (b.return = f),
      (h = f.deletions),
      h === null ? ((f.deletions = [b]), (f.flags |= 16)) : h.push(b);
  }
  function H2(f, h) {
    switch (f.tag) {
      case 5:
        return (
          (h = dt(h, f.type, f.pendingProps)),
          h !== null ? ((f.stateNode = h), (uo = f), (fo = Gt(h)), !0) : !1
        );
      case 6:
        return (
          (h = Rt(h, f.pendingProps)),
          h !== null ? ((f.stateNode = h), (uo = f), (fo = null), !0) : !1
        );
      case 13:
        if (((h = Bt(h)), h !== null)) {
          var b = ic !== null ? { id: hs, overflow: ps } : null;
          return (
            (f.memoizedState = {
              dehydrated: h,
              treeContext: b,
              retryLane: 1073741824,
            }),
            (b = Ho(18, null, null, 0)),
            (b.stateNode = h),
            (b.return = f),
            (f.child = b),
            (uo = f),
            (fo = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function dx(f) {
    return (f.mode & 1) !== 0 && (f.flags & 128) === 0;
  }
  function fx(f) {
    if (Gn) {
      var h = fo;
      if (h) {
        var b = h;
        if (!H2(f, h)) {
          if (dx(f)) throw Error(a(418));
          h = gn(b);
          var C = uo;
          h && H2(f, h)
            ? B2(C, b)
            : ((f.flags = (f.flags & -4097) | 2), (Gn = !1), (uo = f));
        }
      } else {
        if (dx(f)) throw Error(a(418));
        (f.flags = (f.flags & -4097) | 2), (Gn = !1), (uo = f);
      }
    }
  }
  function j2(f) {
    for (
      f = f.return;
      f !== null && f.tag !== 5 && f.tag !== 3 && f.tag !== 13;

    )
      f = f.return;
    uo = f;
  }
  function kf(f) {
    if (!ve || f !== uo) return !1;
    if (!Gn) return j2(f), (Gn = !0), !1;
    if (
      f.tag !== 3 &&
      (f.tag !== 5 || (ot(f.type) && !J(f.type, f.memoizedProps)))
    ) {
      var h = fo;
      if (h) {
        if (dx(f)) {
          for (f = fo; f; ) f = gn(f);
          throw Error(a(418));
        }
        for (; h; ) B2(f, h), (h = gn(h));
      }
    }
    if ((j2(f), f.tag === 13)) {
      if (!ve) throw Error(a(316));
      if (((f = f.memoizedState), (f = f !== null ? f.dehydrated : null), !f))
        throw Error(a(317));
      fo = te(f);
    } else fo = uo ? gn(f.stateNode) : null;
    return !0;
  }
  function Lu() {
    ve && ((fo = uo = null), (Uf = Gn = !1));
  }
  function hx(f) {
    la === null ? (la = [f]) : la.push(f);
  }
  function Bf(f, h, b) {
    if (
      ((f = b.ref),
      f !== null && typeof f != "function" && typeof f != "object")
    ) {
      if (b._owner) {
        if (((b = b._owner), b)) {
          if (b.tag !== 1) throw Error(a(309));
          var C = b.stateNode;
        }
        if (!C) throw Error(a(147, f));
        var O = C,
          U = "" + f;
        return h !== null &&
          h.ref !== null &&
          typeof h.ref == "function" &&
          h.ref._stringRef === U
          ? h.ref
          : ((h = function (re) {
              var xe = O.refs;
              xe === F2 && (xe = O.refs = {}),
                re === null ? delete xe[U] : (xe[U] = re);
            }),
            (h._stringRef = U),
            h);
      }
      if (typeof f != "string") throw Error(a(284));
      if (!b._owner) throw Error(a(290, f));
    }
    return f;
  }
  function $m(f, h) {
    throw (
      ((f = Object.prototype.toString.call(h)),
      Error(
        a(
          31,
          f === "[object Object]"
            ? "object with keys {" + Object.keys(h).join(", ") + "}"
            : f
        )
      ))
    );
  }
  function V2(f) {
    var h = f._init;
    return h(f._payload);
  }
  function $2(f) {
    function h(Fe, we) {
      if (f) {
        var Be = Fe.deletions;
        Be === null ? ((Fe.deletions = [we]), (Fe.flags |= 16)) : Be.push(we);
      }
    }
    function b(Fe, we) {
      if (!f) return null;
      for (; we !== null; ) h(Fe, we), (we = we.sibling);
      return null;
    }
    function C(Fe, we) {
      for (Fe = new Map(); we !== null; )
        we.key !== null ? Fe.set(we.key, we) : Fe.set(we.index, we),
          (we = we.sibling);
      return Fe;
    }
    function O(Fe, we) {
      return (Fe = il(Fe, we)), (Fe.index = 0), (Fe.sibling = null), Fe;
    }
    function U(Fe, we, Be) {
      return (
        (Fe.index = Be),
        f
          ? ((Be = Fe.alternate),
            Be !== null
              ? ((Be = Be.index), Be < we ? ((Fe.flags |= 2), we) : Be)
              : ((Fe.flags |= 2), we))
          : ((Fe.flags |= 1048576), we)
      );
    }
    function re(Fe) {
      return f && Fe.alternate === null && (Fe.flags |= 2), Fe;
    }
    function xe(Fe, we, Be, mt) {
      return we === null || we.tag !== 6
        ? ((we = Yx(Be, Fe.mode, mt)), (we.return = Fe), we)
        : ((we = O(we, Be)), (we.return = Fe), we);
    }
    function je(Fe, we, Be, mt) {
      var Ct = Be.type;
      return Ct === u
        ? _t(Fe, we, Be.props.children, mt, Be.key)
        : we !== null &&
          (we.elementType === Ct ||
            (typeof Ct == "object" &&
              Ct !== null &&
              Ct.$$typeof === y &&
              V2(Ct) === we.type))
        ? ((mt = O(we, Be.props)),
          (mt.ref = Bf(Fe, we, Be)),
          (mt.return = Fe),
          mt)
        : ((mt = _g(Be.type, Be.key, Be.props, null, Fe.mode, mt)),
          (mt.ref = Bf(Fe, we, Be)),
          (mt.return = Fe),
          mt);
    }
    function it(Fe, we, Be, mt) {
      return we === null ||
        we.tag !== 4 ||
        we.stateNode.containerInfo !== Be.containerInfo ||
        we.stateNode.implementation !== Be.implementation
        ? ((we = Zx(Be, Fe.mode, mt)), (we.return = Fe), we)
        : ((we = O(we, Be.children || [])), (we.return = Fe), we);
    }
    function _t(Fe, we, Be, mt, Ct) {
      return we === null || we.tag !== 7
        ? ((we = fc(Be, Fe.mode, mt, Ct)), (we.return = Fe), we)
        : ((we = O(we, Be)), (we.return = Fe), we);
    }
    function Vt(Fe, we, Be) {
      if ((typeof we == "string" && we !== "") || typeof we == "number")
        return (we = Yx("" + we, Fe.mode, Be)), (we.return = Fe), we;
      if (typeof we == "object" && we !== null) {
        switch (we.$$typeof) {
          case l:
            return (
              (Be = _g(we.type, we.key, we.props, null, Fe.mode, Be)),
              (Be.ref = Bf(Fe, null, we)),
              (Be.return = Fe),
              Be
            );
          case c:
            return (we = Zx(we, Fe.mode, Be)), (we.return = Fe), we;
          case y:
            var mt = we._init;
            return Vt(Fe, mt(we._payload), Be);
        }
        if (V(we) || M(we))
          return (we = fc(we, Fe.mode, Be, null)), (we.return = Fe), we;
        $m(Fe, we);
      }
      return null;
    }
    function Nt(Fe, we, Be, mt) {
      var Ct = we !== null ? we.key : null;
      if ((typeof Be == "string" && Be !== "") || typeof Be == "number")
        return Ct !== null ? null : xe(Fe, we, "" + Be, mt);
      if (typeof Be == "object" && Be !== null) {
        switch (Be.$$typeof) {
          case l:
            return Be.key === Ct ? je(Fe, we, Be, mt) : null;
          case c:
            return Be.key === Ct ? it(Fe, we, Be, mt) : null;
          case y:
            return (Ct = Be._init), Nt(Fe, we, Ct(Be._payload), mt);
        }
        if (V(Be) || M(Be))
          return Ct !== null ? null : _t(Fe, we, Be, mt, null);
        $m(Fe, Be);
      }
      return null;
    }
    function Dn(Fe, we, Be, mt, Ct) {
      if ((typeof mt == "string" && mt !== "") || typeof mt == "number")
        return (Fe = Fe.get(Be) || null), xe(we, Fe, "" + mt, Ct);
      if (typeof mt == "object" && mt !== null) {
        switch (mt.$$typeof) {
          case l:
            return (
              (Fe = Fe.get(mt.key === null ? Be : mt.key) || null),
              je(we, Fe, mt, Ct)
            );
          case c:
            return (
              (Fe = Fe.get(mt.key === null ? Be : mt.key) || null),
              it(we, Fe, mt, Ct)
            );
          case y:
            var Qt = mt._init;
            return Dn(Fe, we, Be, Qt(mt._payload), Ct);
        }
        if (V(mt) || M(mt))
          return (Fe = Fe.get(Be) || null), _t(we, Fe, mt, Ct, null);
        $m(we, mt);
      }
      return null;
    }
    function At(Fe, we, Be, mt) {
      for (
        var Ct = null, Qt = null, $t = we, yn = (we = 0), Ur = null;
        $t !== null && yn < Be.length;
        yn++
      ) {
        $t.index > yn ? ((Ur = $t), ($t = null)) : (Ur = $t.sibling);
        var xn = Nt(Fe, $t, Be[yn], mt);
        if (xn === null) {
          $t === null && ($t = Ur);
          break;
        }
        f && $t && xn.alternate === null && h(Fe, $t),
          (we = U(xn, we, yn)),
          Qt === null ? (Ct = xn) : (Qt.sibling = xn),
          (Qt = xn),
          ($t = Ur);
      }
      if (yn === Be.length) return b(Fe, $t), Gn && oc(Fe, yn), Ct;
      if ($t === null) {
        for (; yn < Be.length; yn++)
          ($t = Vt(Fe, Be[yn], mt)),
            $t !== null &&
              ((we = U($t, we, yn)),
              Qt === null ? (Ct = $t) : (Qt.sibling = $t),
              (Qt = $t));
        return Gn && oc(Fe, yn), Ct;
      }
      for ($t = C(Fe, $t); yn < Be.length; yn++)
        (Ur = Dn($t, Fe, yn, Be[yn], mt)),
          Ur !== null &&
            (f &&
              Ur.alternate !== null &&
              $t.delete(Ur.key === null ? yn : Ur.key),
            (we = U(Ur, we, yn)),
            Qt === null ? (Ct = Ur) : (Qt.sibling = Ur),
            (Qt = Ur));
      return (
        f &&
          $t.forEach(function (ol) {
            return h(Fe, ol);
          }),
        Gn && oc(Fe, yn),
        Ct
      );
    }
    function oi(Fe, we, Be, mt) {
      var Ct = M(Be);
      if (typeof Ct != "function") throw Error(a(150));
      if (((Be = Ct.call(Be)), Be == null)) throw Error(a(151));
      for (
        var Qt = (Ct = null), $t = we, yn = (we = 0), Ur = null, xn = Be.next();
        $t !== null && !xn.done;
        yn++, xn = Be.next()
      ) {
        $t.index > yn ? ((Ur = $t), ($t = null)) : (Ur = $t.sibling);
        var ol = Nt(Fe, $t, xn.value, mt);
        if (ol === null) {
          $t === null && ($t = Ur);
          break;
        }
        f && $t && ol.alternate === null && h(Fe, $t),
          (we = U(ol, we, yn)),
          Qt === null ? (Ct = ol) : (Qt.sibling = ol),
          (Qt = ol),
          ($t = Ur);
      }
      if (xn.done) return b(Fe, $t), Gn && oc(Fe, yn), Ct;
      if ($t === null) {
        for (; !xn.done; yn++, xn = Be.next())
          (xn = Vt(Fe, xn.value, mt)),
            xn !== null &&
              ((we = U(xn, we, yn)),
              Qt === null ? (Ct = xn) : (Qt.sibling = xn),
              (Qt = xn));
        return Gn && oc(Fe, yn), Ct;
      }
      for ($t = C(Fe, $t); !xn.done; yn++, xn = Be.next())
        (xn = Dn($t, Fe, yn, xn.value, mt)),
          xn !== null &&
            (f &&
              xn.alternate !== null &&
              $t.delete(xn.key === null ? yn : xn.key),
            (we = U(xn, we, yn)),
            Qt === null ? (Ct = xn) : (Qt.sibling = xn),
            (Qt = xn));
      return (
        f &&
          $t.forEach(function (v5) {
            return h(Fe, v5);
          }),
        Gn && oc(Fe, yn),
        Ct
      );
    }
    function jo(Fe, we, Be, mt) {
      if (
        (typeof Be == "object" &&
          Be !== null &&
          Be.type === u &&
          Be.key === null &&
          (Be = Be.props.children),
        typeof Be == "object" && Be !== null)
      ) {
        switch (Be.$$typeof) {
          case l:
            e: {
              for (var Ct = Be.key, Qt = we; Qt !== null; ) {
                if (Qt.key === Ct) {
                  if (((Ct = Be.type), Ct === u)) {
                    if (Qt.tag === 7) {
                      b(Fe, Qt.sibling),
                        (we = O(Qt, Be.props.children)),
                        (we.return = Fe),
                        (Fe = we);
                      break e;
                    }
                  } else if (
                    Qt.elementType === Ct ||
                    (typeof Ct == "object" &&
                      Ct !== null &&
                      Ct.$$typeof === y &&
                      V2(Ct) === Qt.type)
                  ) {
                    b(Fe, Qt.sibling),
                      (we = O(Qt, Be.props)),
                      (we.ref = Bf(Fe, Qt, Be)),
                      (we.return = Fe),
                      (Fe = we);
                    break e;
                  }
                  b(Fe, Qt);
                  break;
                } else h(Fe, Qt);
                Qt = Qt.sibling;
              }
              Be.type === u
                ? ((we = fc(Be.props.children, Fe.mode, mt, Be.key)),
                  (we.return = Fe),
                  (Fe = we))
                : ((mt = _g(Be.type, Be.key, Be.props, null, Fe.mode, mt)),
                  (mt.ref = Bf(Fe, we, Be)),
                  (mt.return = Fe),
                  (Fe = mt));
            }
            return re(Fe);
          case c:
            e: {
              for (Qt = Be.key; we !== null; ) {
                if (we.key === Qt)
                  if (
                    we.tag === 4 &&
                    we.stateNode.containerInfo === Be.containerInfo &&
                    we.stateNode.implementation === Be.implementation
                  ) {
                    b(Fe, we.sibling),
                      (we = O(we, Be.children || [])),
                      (we.return = Fe),
                      (Fe = we);
                    break e;
                  } else {
                    b(Fe, we);
                    break;
                  }
                else h(Fe, we);
                we = we.sibling;
              }
              (we = Zx(Be, Fe.mode, mt)), (we.return = Fe), (Fe = we);
            }
            return re(Fe);
          case y:
            return (Qt = Be._init), jo(Fe, we, Qt(Be._payload), mt);
        }
        if (V(Be)) return At(Fe, we, Be, mt);
        if (M(Be)) return oi(Fe, we, Be, mt);
        $m(Fe, Be);
      }
      return (typeof Be == "string" && Be !== "") || typeof Be == "number"
        ? ((Be = "" + Be),
          we !== null && we.tag === 6
            ? (b(Fe, we.sibling), (we = O(we, Be)), (we.return = Fe), (Fe = we))
            : (b(Fe, we),
              (we = Yx(Be, Fe.mode, mt)),
              (we.return = Fe),
              (Fe = we)),
          re(Fe))
        : b(Fe, we);
    }
    return jo;
  }
  var Ou = $2(!0),
    G2 = $2(!1),
    Hf = {},
    Uo = cn(Hf),
    jf = cn(Hf),
    Nu = cn(Hf);
  function Ba(f) {
    if (f === Hf) throw Error(a(174));
    return f;
  }
  function px(f, h) {
    ct(Nu, h), ct(jf, f), ct(Uo, Hf), (f = Q(h)), St(Uo), ct(Uo, f);
  }
  function Fu() {
    St(Uo), St(jf), St(Nu);
  }
  function W2(f) {
    var h = Ba(Nu.current),
      b = Ba(Uo.current);
    (h = B(b, f.type, h)), b !== h && (ct(jf, f), ct(Uo, h));
  }
  function mx(f) {
    jf.current === f && (St(Uo), St(jf));
  }
  var qn = cn(0);
  function Gm(f) {
    for (var h = f; h !== null; ) {
      if (h.tag === 13) {
        var b = h.memoizedState;
        if (b !== null && ((b = b.dehydrated), b === null || In(b) || dn(b)))
          return h;
      } else if (h.tag === 19 && h.memoizedProps.revealOrder !== void 0) {
        if (h.flags & 128) return h;
      } else if (h.child !== null) {
        (h.child.return = h), (h = h.child);
        continue;
      }
      if (h === f) break;
      for (; h.sibling === null; ) {
        if (h.return === null || h.return === f) return null;
        h = h.return;
      }
      (h.sibling.return = h.return), (h = h.sibling);
    }
    return null;
  }
  var gx = [];
  function vx() {
    for (var f = 0; f < gx.length; f++) {
      var h = gx[f];
      me
        ? (h._workInProgressVersionPrimary = null)
        : (h._workInProgressVersionSecondary = null);
    }
    gx.length = 0;
  }
  var Wm = s.ReactCurrentDispatcher,
    ko = s.ReactCurrentBatchConfig,
    Du = 0,
    rr = null,
    ni = null,
    zr = null,
    Xm = !1,
    Vf = !1,
    $f = 0,
    j4 = 0;
  function ri() {
    throw Error(a(321));
  }
  function yx(f, h) {
    if (h === null) return !1;
    for (var b = 0; b < h.length && b < f.length; b++)
      if (!lo(f[b], h[b])) return !1;
    return !0;
  }
  function xx(f, h, b, C, O, U) {
    if (
      ((Du = U),
      (rr = h),
      (h.memoizedState = null),
      (h.updateQueue = null),
      (h.lanes = 0),
      (Wm.current = f === null || f.memoizedState === null ? W4 : X4),
      (f = b(C, O)),
      Vf)
    ) {
      U = 0;
      do {
        if (((Vf = !1), ($f = 0), 25 <= U)) throw Error(a(301));
        (U += 1),
          (zr = ni = null),
          (h.updateQueue = null),
          (Wm.current = q4),
          (f = b(C, O));
      } while (Vf);
    }
    if (
      ((Wm.current = Qm),
      (h = ni !== null && ni.next !== null),
      (Du = 0),
      (zr = ni = rr = null),
      (Xm = !1),
      h)
    )
      throw Error(a(300));
    return f;
  }
  function Sx() {
    var f = $f !== 0;
    return ($f = 0), f;
  }
  function ms() {
    var f = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return zr === null ? (rr.memoizedState = zr = f) : (zr = zr.next = f), zr;
  }
  function Ha() {
    if (ni === null) {
      var f = rr.alternate;
      f = f !== null ? f.memoizedState : null;
    } else f = ni.next;
    var h = zr === null ? rr.memoizedState : zr.next;
    if (h !== null) (zr = h), (ni = f);
    else {
      if (f === null) throw Error(a(310));
      (ni = f),
        (f = {
          memoizedState: ni.memoizedState,
          baseState: ni.baseState,
          baseQueue: ni.baseQueue,
          queue: ni.queue,
          next: null,
        }),
        zr === null ? (rr.memoizedState = zr = f) : (zr = zr.next = f);
    }
    return zr;
  }
  function ac(f, h) {
    return typeof h == "function" ? h(f) : h;
  }
  function qm(f) {
    var h = Ha(),
      b = h.queue;
    if (b === null) throw Error(a(311));
    b.lastRenderedReducer = f;
    var C = ni,
      O = C.baseQueue,
      U = b.pending;
    if (U !== null) {
      if (O !== null) {
        var re = O.next;
        (O.next = U.next), (U.next = re);
      }
      (C.baseQueue = O = U), (b.pending = null);
    }
    if (O !== null) {
      (U = O.next), (C = C.baseState);
      var xe = (re = null),
        je = null,
        it = U;
      do {
        var _t = it.lane;
        if ((Du & _t) === _t)
          je !== null &&
            (je = je.next =
              {
                lane: 0,
                action: it.action,
                hasEagerState: it.hasEagerState,
                eagerState: it.eagerState,
                next: null,
              }),
            (C = it.hasEagerState ? it.eagerState : f(C, it.action));
        else {
          var Vt = {
            lane: _t,
            action: it.action,
            hasEagerState: it.hasEagerState,
            eagerState: it.eagerState,
            next: null,
          };
          je === null ? ((xe = je = Vt), (re = C)) : (je = je.next = Vt),
            (rr.lanes |= _t),
            (Uu |= _t);
        }
        it = it.next;
      } while (it !== null && it !== U);
      je === null ? (re = C) : (je.next = xe),
        lo(C, h.memoizedState) || (ho = !0),
        (h.memoizedState = C),
        (h.baseState = re),
        (h.baseQueue = je),
        (b.lastRenderedState = C);
    }
    if (((f = b.interleaved), f !== null)) {
      O = f;
      do (U = O.lane), (rr.lanes |= U), (Uu |= U), (O = O.next);
      while (O !== f);
    } else O === null && (b.lanes = 0);
    return [h.memoizedState, b.dispatch];
  }
  function Km(f) {
    var h = Ha(),
      b = h.queue;
    if (b === null) throw Error(a(311));
    b.lastRenderedReducer = f;
    var C = b.dispatch,
      O = b.pending,
      U = h.memoizedState;
    if (O !== null) {
      b.pending = null;
      var re = (O = O.next);
      do (U = f(U, re.action)), (re = re.next);
      while (re !== O);
      lo(U, h.memoizedState) || (ho = !0),
        (h.memoizedState = U),
        h.baseQueue === null && (h.baseState = U),
        (b.lastRenderedState = U);
    }
    return [U, C];
  }
  function X2() {}
  function q2(f, h) {
    var b = rr,
      C = Ha(),
      O = h(),
      U = !lo(C.memoizedState, O);
    if (
      (U && ((C.memoizedState = O), (ho = !0)),
      (C = C.queue),
      Wf(Z2.bind(null, b, C, f), [f]),
      C.getSnapshot !== h || U || (zr !== null && zr.memoizedState.tag & 1))
    ) {
      if (
        ((b.flags |= 2048),
        Gf(9, Y2.bind(null, b, C, O, h), void 0, null),
        yr === null)
      )
        throw Error(a(349));
      Du & 30 || K2(b, h, O);
    }
    return O;
  }
  function K2(f, h, b) {
    (f.flags |= 16384),
      (f = { getSnapshot: h, value: b }),
      (h = rr.updateQueue),
      h === null
        ? ((h = { lastEffect: null, stores: null }),
          (rr.updateQueue = h),
          (h.stores = [f]))
        : ((b = h.stores), b === null ? (h.stores = [f]) : b.push(f));
  }
  function Y2(f, h, b, C) {
    (h.value = b), (h.getSnapshot = C), Q2(h) && Bo(f, 1, -1);
  }
  function Z2(f, h, b) {
    return b(function () {
      Q2(h) && Bo(f, 1, -1);
    });
  }
  function Q2(f) {
    var h = f.getSnapshot;
    f = f.value;
    try {
      var b = h();
      return !lo(f, b);
    } catch {
      return !0;
    }
  }
  function _x(f) {
    var h = ms();
    return (
      typeof f == "function" && (f = f()),
      (h.memoizedState = h.baseState = f),
      (f = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ac,
        lastRenderedState: f,
      }),
      (h.queue = f),
      (f = f.dispatch = G4.bind(null, rr, f)),
      [h.memoizedState, f]
    );
  }
  function Gf(f, h, b, C) {
    return (
      (f = { tag: f, create: h, destroy: b, deps: C, next: null }),
      (h = rr.updateQueue),
      h === null
        ? ((h = { lastEffect: null, stores: null }),
          (rr.updateQueue = h),
          (h.lastEffect = f.next = f))
        : ((b = h.lastEffect),
          b === null
            ? (h.lastEffect = f.next = f)
            : ((C = b.next), (b.next = f), (f.next = C), (h.lastEffect = f))),
      f
    );
  }
  function J2() {
    return Ha().memoizedState;
  }
  function Ym(f, h, b, C) {
    var O = ms();
    (rr.flags |= f),
      (O.memoizedState = Gf(1 | h, b, void 0, C === void 0 ? null : C));
  }
  function Zm(f, h, b, C) {
    var O = Ha();
    C = C === void 0 ? null : C;
    var U = void 0;
    if (ni !== null) {
      var re = ni.memoizedState;
      if (((U = re.destroy), C !== null && yx(C, re.deps))) {
        O.memoizedState = Gf(h, b, U, C);
        return;
      }
    }
    (rr.flags |= f), (O.memoizedState = Gf(1 | h, b, U, C));
  }
  function bx(f, h) {
    return Ym(8390656, 8, f, h);
  }
  function Wf(f, h) {
    return Zm(2048, 8, f, h);
  }
  function eT(f, h) {
    return Zm(4, 2, f, h);
  }
  function tT(f, h) {
    return Zm(4, 4, f, h);
  }
  function nT(f, h) {
    if (typeof h == "function")
      return (
        (f = f()),
        h(f),
        function () {
          h(null);
        }
      );
    if (h != null)
      return (
        (f = f()),
        (h.current = f),
        function () {
          h.current = null;
        }
      );
  }
  function rT(f, h, b) {
    return (
      (b = b != null ? b.concat([f]) : null), Zm(4, 4, nT.bind(null, h, f), b)
    );
  }
  function wx() {}
  function iT(f, h) {
    var b = Ha();
    h = h === void 0 ? null : h;
    var C = b.memoizedState;
    return C !== null && h !== null && yx(h, C[1])
      ? C[0]
      : ((b.memoizedState = [f, h]), f);
  }
  function oT(f, h) {
    var b = Ha();
    h = h === void 0 ? null : h;
    var C = b.memoizedState;
    return C !== null && h !== null && yx(h, C[1])
      ? C[0]
      : ((f = f()), (b.memoizedState = [f, h]), f);
  }
  function V4(f, h) {
    var b = Wt;
    (Wt = b !== 0 && 4 > b ? b : 4), f(!0);
    var C = ko.transition;
    ko.transition = {};
    try {
      f(!1), h();
    } finally {
      (Wt = b), (ko.transition = C);
    }
  }
  function aT() {
    return Ha().memoizedState;
  }
  function $4(f, h, b) {
    var C = nl(f);
    (b = {
      lane: C,
      action: b,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      sT(f)
        ? lT(h, b)
        : (cT(f, h, b),
          (b = Ci()),
          (f = Bo(f, C, b)),
          f !== null && uT(f, h, C));
  }
  function G4(f, h, b) {
    var C = nl(f),
      O = {
        lane: C,
        action: b,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (sT(f)) lT(h, O);
    else {
      cT(f, h, O);
      var U = f.alternate;
      if (
        f.lanes === 0 &&
        (U === null || U.lanes === 0) &&
        ((U = h.lastRenderedReducer), U !== null)
      )
        try {
          var re = h.lastRenderedState,
            xe = U(re, b);
          if (((O.hasEagerState = !0), (O.eagerState = xe), lo(xe, re))) return;
        } catch {
        } finally {
        }
      (b = Ci()), (f = Bo(f, C, b)), f !== null && uT(f, h, C);
    }
  }
  function sT(f) {
    var h = f.alternate;
    return f === rr || (h !== null && h === rr);
  }
  function lT(f, h) {
    Vf = Xm = !0;
    var b = f.pending;
    b === null ? (h.next = h) : ((h.next = b.next), (b.next = h)),
      (f.pending = h);
  }
  function cT(f, h, b) {
    yr !== null && f.mode & 1 && !(en & 2)
      ? ((f = h.interleaved),
        f === null
          ? ((b.next = b), co === null ? (co = [h]) : co.push(h))
          : ((b.next = f.next), (f.next = b)),
        (h.interleaved = b))
      : ((f = h.pending),
        f === null ? (b.next = b) : ((b.next = f.next), (f.next = b)),
        (h.pending = b));
  }
  function uT(f, h, b) {
    if (b & 4194240) {
      var C = h.lanes;
      (C &= f.pendingLanes), (b |= C), (h.lanes = b), _i(f, b);
    }
  }
  var Qm = {
      readContext: ur,
      useCallback: ri,
      useContext: ri,
      useEffect: ri,
      useImperativeHandle: ri,
      useInsertionEffect: ri,
      useLayoutEffect: ri,
      useMemo: ri,
      useReducer: ri,
      useRef: ri,
      useState: ri,
      useDebugValue: ri,
      useDeferredValue: ri,
      useTransition: ri,
      useMutableSource: ri,
      useSyncExternalStore: ri,
      useId: ri,
      unstable_isNewReconciler: !1,
    },
    W4 = {
      readContext: ur,
      useCallback: function (f, h) {
        return (ms().memoizedState = [f, h === void 0 ? null : h]), f;
      },
      useContext: ur,
      useEffect: bx,
      useImperativeHandle: function (f, h, b) {
        return (
          (b = b != null ? b.concat([f]) : null),
          Ym(4194308, 4, nT.bind(null, h, f), b)
        );
      },
      useLayoutEffect: function (f, h) {
        return Ym(4194308, 4, f, h);
      },
      useInsertionEffect: function (f, h) {
        return Ym(4, 2, f, h);
      },
      useMemo: function (f, h) {
        var b = ms();
        return (
          (h = h === void 0 ? null : h),
          (f = f()),
          (b.memoizedState = [f, h]),
          f
        );
      },
      useReducer: function (f, h, b) {
        var C = ms();
        return (
          (h = b !== void 0 ? b(h) : h),
          (C.memoizedState = C.baseState = h),
          (f = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: f,
            lastRenderedState: h,
          }),
          (C.queue = f),
          (f = f.dispatch = $4.bind(null, rr, f)),
          [C.memoizedState, f]
        );
      },
      useRef: function (f) {
        var h = ms();
        return (f = { current: f }), (h.memoizedState = f);
      },
      useState: _x,
      useDebugValue: wx,
      useDeferredValue: function (f) {
        var h = _x(f),
          b = h[0],
          C = h[1];
        return (
          bx(
            function () {
              var O = ko.transition;
              ko.transition = {};
              try {
                C(f);
              } finally {
                ko.transition = O;
              }
            },
            [f]
          ),
          b
        );
      },
      useTransition: function () {
        var f = _x(!1),
          h = f[0];
        return (f = V4.bind(null, f[1])), (ms().memoizedState = f), [h, f];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (f, h, b) {
        var C = rr,
          O = ms();
        if (Gn) {
          if (b === void 0) throw Error(a(407));
          b = b();
        } else {
          if (((b = h()), yr === null)) throw Error(a(349));
          Du & 30 || K2(C, h, b);
        }
        O.memoizedState = b;
        var U = { value: b, getSnapshot: h };
        return (
          (O.queue = U),
          bx(Z2.bind(null, C, U, f), [f]),
          (C.flags |= 2048),
          Gf(9, Y2.bind(null, C, U, b, h), void 0, null),
          b
        );
      },
      useId: function () {
        var f = ms(),
          h = yr.identifierPrefix;
        if (Gn) {
          var b = ps,
            C = hs;
          (b = (C & ~(1 << (32 - lr(C) - 1))).toString(32) + b),
            (h = ":" + h + "R" + b),
            (b = $f++),
            0 < b && (h += "H" + b.toString(32)),
            (h += ":");
        } else (b = j4++), (h = ":" + h + "r" + b.toString(32) + ":");
        return (f.memoizedState = h);
      },
      unstable_isNewReconciler: !1,
    },
    X4 = {
      readContext: ur,
      useCallback: iT,
      useContext: ur,
      useEffect: Wf,
      useImperativeHandle: rT,
      useInsertionEffect: eT,
      useLayoutEffect: tT,
      useMemo: oT,
      useReducer: qm,
      useRef: J2,
      useState: function () {
        return qm(ac);
      },
      useDebugValue: wx,
      useDeferredValue: function (f) {
        var h = qm(ac),
          b = h[0],
          C = h[1];
        return (
          Wf(
            function () {
              var O = ko.transition;
              ko.transition = {};
              try {
                C(f);
              } finally {
                ko.transition = O;
              }
            },
            [f]
          ),
          b
        );
      },
      useTransition: function () {
        var f = qm(ac)[0],
          h = Ha().memoizedState;
        return [f, h];
      },
      useMutableSource: X2,
      useSyncExternalStore: q2,
      useId: aT,
      unstable_isNewReconciler: !1,
    },
    q4 = {
      readContext: ur,
      useCallback: iT,
      useContext: ur,
      useEffect: Wf,
      useImperativeHandle: rT,
      useInsertionEffect: eT,
      useLayoutEffect: tT,
      useMemo: oT,
      useReducer: Km,
      useRef: J2,
      useState: function () {
        return Km(ac);
      },
      useDebugValue: wx,
      useDeferredValue: function (f) {
        var h = Km(ac),
          b = h[0],
          C = h[1];
        return (
          Wf(
            function () {
              var O = ko.transition;
              ko.transition = {};
              try {
                C(f);
              } finally {
                ko.transition = O;
              }
            },
            [f]
          ),
          b
        );
      },
      useTransition: function () {
        var f = Km(ac)[0],
          h = Ha().memoizedState;
        return [f, h];
      },
      useMutableSource: X2,
      useSyncExternalStore: q2,
      useId: aT,
      unstable_isNewReconciler: !1,
    };
  function Ex(f, h) {
    try {
      var b = "",
        C = h;
      do (b += rc(C)), (C = C.return);
      while (C);
      var O = b;
    } catch (U) {
      O =
        `
Error generating stack: ` +
        U.message +
        `
` +
        U.stack;
    }
    return { value: f, source: h, stack: O };
  }
  function Mx(f, h) {
    try {
      console.error(h.value);
    } catch (b) {
      setTimeout(function () {
        throw b;
      });
    }
  }
  var K4 = typeof WeakMap == "function" ? WeakMap : Map;
  function dT(f, h, b) {
    (b = fs(-1, b)), (b.tag = 3), (b.payload = { element: null });
    var C = h.value;
    return (
      (b.callback = function () {
        pg || ((pg = !0), (Vx = C)), Mx(f, h);
      }),
      b
    );
  }
  function fT(f, h, b) {
    (b = fs(-1, b)), (b.tag = 3);
    var C = f.type.getDerivedStateFromError;
    if (typeof C == "function") {
      var O = h.value;
      (b.payload = function () {
        return C(O);
      }),
        (b.callback = function () {
          Mx(f, h);
        });
    }
    var U = f.stateNode;
    return (
      U !== null &&
        typeof U.componentDidCatch == "function" &&
        (b.callback = function () {
          Mx(f, h),
            typeof C != "function" &&
              (el === null ? (el = new Set([this])) : el.add(this));
          var re = h.stack;
          this.componentDidCatch(h.value, {
            componentStack: re !== null ? re : "",
          });
        }),
      b
    );
  }
  function hT(f, h, b) {
    var C = f.pingCache;
    if (C === null) {
      C = f.pingCache = new K4();
      var O = new Set();
      C.set(h, O);
    } else (O = C.get(h)), O === void 0 && ((O = new Set()), C.set(h, O));
    O.has(b) || (O.add(b), (f = c5.bind(null, f, h, b)), h.then(f, f));
  }
  function pT(f) {
    do {
      var h;
      if (
        ((h = f.tag === 13) &&
          ((h = f.memoizedState),
          (h = h !== null ? h.dehydrated !== null : !0)),
        h)
      )
        return f;
      f = f.return;
    } while (f !== null);
    return null;
  }
  function mT(f, h, b, C, O) {
    return f.mode & 1
      ? ((f.flags |= 65536), (f.lanes = O), f)
      : (f === h
          ? (f.flags |= 65536)
          : ((f.flags |= 128),
            (b.flags |= 131072),
            (b.flags &= -52805),
            b.tag === 1 &&
              (b.alternate === null
                ? (b.tag = 17)
                : ((h = fs(-1, 1)), (h.tag = 2), Js(b, h))),
            (b.lanes |= 1)),
        f);
  }
  function ja(f) {
    f.flags |= 4;
  }
  function gT(f, h) {
    if (f !== null && f.child === h.child) return !0;
    if (h.flags & 16) return !1;
    for (f = h.child; f !== null; ) {
      if (f.flags & 12854 || f.subtreeFlags & 12854) return !1;
      f = f.sibling;
    }
    return !0;
  }
  var Xf, qf, Jm, eg;
  if (se)
    (Xf = function (f, h) {
      for (var b = h.child; b !== null; ) {
        if (b.tag === 5 || b.tag === 6) q(f, b.stateNode);
        else if (b.tag !== 4 && b.child !== null) {
          (b.child.return = b), (b = b.child);
          continue;
        }
        if (b === h) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === h) return;
          b = b.return;
        }
        (b.sibling.return = b.return), (b = b.sibling);
      }
    }),
      (qf = function () {}),
      (Jm = function (f, h, b, C, O) {
        if (((f = f.memoizedProps), f !== C)) {
          var U = h.stateNode,
            re = Ba(Uo.current);
          (b = ee(U, b, f, C, O, re)), (h.updateQueue = b) && ja(h);
        }
      }),
      (eg = function (f, h, b, C) {
        b !== C && ja(h);
      });
  else if (Y) {
    Xf = function (f, h, b, C) {
      for (var O = h.child; O !== null; ) {
        if (O.tag === 5) {
          var U = O.stateNode;
          b && C && (U = tt(U, O.type, O.memoizedProps, O)), q(f, U);
        } else if (O.tag === 6)
          (U = O.stateNode), b && C && (U = ut(U, O.memoizedProps, O)), q(f, U);
        else if (O.tag !== 4) {
          if (O.tag === 22 && O.memoizedState !== null)
            (U = O.child), U !== null && (U.return = O), Xf(f, O, !0, !0);
          else if (O.child !== null) {
            (O.child.return = O), (O = O.child);
            continue;
          }
        }
        if (O === h) break;
        for (; O.sibling === null; ) {
          if (O.return === null || O.return === h) return;
          O = O.return;
        }
        (O.sibling.return = O.return), (O = O.sibling);
      }
    };
    var vT = function (f, h, b, C) {
      for (var O = h.child; O !== null; ) {
        if (O.tag === 5) {
          var U = O.stateNode;
          b && C && (U = tt(U, O.type, O.memoizedProps, O)), Ue(f, U);
        } else if (O.tag === 6)
          (U = O.stateNode),
            b && C && (U = ut(U, O.memoizedProps, O)),
            Ue(f, U);
        else if (O.tag !== 4) {
          if (O.tag === 22 && O.memoizedState !== null)
            (U = O.child), U !== null && (U.return = O), vT(f, O, !0, !0);
          else if (O.child !== null) {
            (O.child.return = O), (O = O.child);
            continue;
          }
        }
        if (O === h) break;
        for (; O.sibling === null; ) {
          if (O.return === null || O.return === h) return;
          O = O.return;
        }
        (O.sibling.return = O.return), (O = O.sibling);
      }
    };
    (qf = function (f, h) {
      var b = h.stateNode;
      if (!gT(f, h)) {
        f = b.containerInfo;
        var C = Xe(f);
        vT(C, h, !1, !1), (b.pendingChildren = C), ja(h), Ye(f, C);
      }
    }),
      (Jm = function (f, h, b, C, O) {
        var U = f.stateNode,
          re = f.memoizedProps;
        if ((f = gT(f, h)) && re === C) h.stateNode = U;
        else {
          var xe = h.stateNode,
            je = Ba(Uo.current),
            it = null;
          re !== C && (it = ee(xe, b, re, C, O, je)),
            f && it === null
              ? (h.stateNode = U)
              : ((U = He(U, it, b, re, C, h, f, xe)),
                X(U, b, C, O, je) && ja(h),
                (h.stateNode = U),
                f ? ja(h) : Xf(U, h, !1, !1));
        }
      }),
      (eg = function (f, h, b, C) {
        b !== C
          ? ((f = Ba(Nu.current)),
            (b = Ba(Uo.current)),
            (h.stateNode = oe(C, f, b, h)),
            ja(h))
          : (h.stateNode = f.stateNode);
      });
  } else (qf = function () {}), (Jm = function () {}), (eg = function () {});
  function Kf(f, h) {
    if (!Gn)
      switch (f.tailMode) {
        case "hidden":
          h = f.tail;
          for (var b = null; h !== null; )
            h.alternate !== null && (b = h), (h = h.sibling);
          b === null ? (f.tail = null) : (b.sibling = null);
          break;
        case "collapsed":
          b = f.tail;
          for (var C = null; b !== null; )
            b.alternate !== null && (C = b), (b = b.sibling);
          C === null
            ? h || f.tail === null
              ? (f.tail = null)
              : (f.tail.sibling = null)
            : (C.sibling = null);
      }
  }
  function ii(f) {
    var h = f.alternate !== null && f.alternate.child === f.child,
      b = 0,
      C = 0;
    if (h)
      for (var O = f.child; O !== null; )
        (b |= O.lanes | O.childLanes),
          (C |= O.subtreeFlags & 14680064),
          (C |= O.flags & 14680064),
          (O.return = f),
          (O = O.sibling);
    else
      for (O = f.child; O !== null; )
        (b |= O.lanes | O.childLanes),
          (C |= O.subtreeFlags),
          (C |= O.flags),
          (O.return = f),
          (O = O.sibling);
    return (f.subtreeFlags |= C), (f.childLanes = b), h;
  }
  function Y4(f, h, b) {
    var C = h.pendingProps;
    switch ((ux(h), h.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ii(h), null;
      case 1:
        return Pt(h.type) && Tt(), ii(h), null;
      case 3:
        return (
          (C = h.stateNode),
          Fu(),
          St(fn),
          St(Ot),
          vx(),
          C.pendingContext &&
            ((C.context = C.pendingContext), (C.pendingContext = null)),
          (f === null || f.child === null) &&
            (kf(h)
              ? ja(h)
              : f === null ||
                (f.memoizedState.isDehydrated && !(h.flags & 256)) ||
                ((h.flags |= 1024), la !== null && (Wx(la), (la = null)))),
          qf(f, h),
          ii(h),
          null
        );
      case 5:
        mx(h), (b = Ba(Nu.current));
        var O = h.type;
        if (f !== null && h.stateNode != null)
          Jm(f, h, O, C, b),
            f.ref !== h.ref && ((h.flags |= 512), (h.flags |= 2097152));
        else {
          if (!C) {
            if (h.stateNode === null) throw Error(a(166));
            return ii(h), null;
          }
          if (((f = Ba(Uo.current)), kf(h))) {
            if (!ve) throw Error(a(175));
            (f = Dt(h.stateNode, h.type, h.memoizedProps, b, f, h, !Uf)),
              (h.updateQueue = f),
              f !== null && ja(h);
          } else {
            var U = k(O, C, b, f, h);
            Xf(U, h, !1, !1), (h.stateNode = U), X(U, O, C, b, f) && ja(h);
          }
          h.ref !== null && ((h.flags |= 512), (h.flags |= 2097152));
        }
        return ii(h), null;
      case 6:
        if (f && h.stateNode != null) eg(f, h, f.memoizedProps, C);
        else {
          if (typeof C != "string" && h.stateNode === null) throw Error(a(166));
          if (((f = Ba(Nu.current)), (b = Ba(Uo.current)), kf(h))) {
            if (!ve) throw Error(a(176));
            if (
              ((f = h.stateNode),
              (C = h.memoizedProps),
              (b = nn(f, C, h, !Uf)) && ((O = uo), O !== null))
            )
              switch (((U = (O.mode & 1) !== 0), O.tag)) {
                case 3:
                  ht(O.stateNode.containerInfo, f, C, U);
                  break;
                case 5:
                  xt(O.type, O.memoizedProps, O.stateNode, f, C, U);
              }
            b && ja(h);
          } else h.stateNode = oe(C, f, b, h);
        }
        return ii(h), null;
      case 13:
        if (
          (St(qn),
          (C = h.memoizedState),
          Gn && fo !== null && h.mode & 1 && !(h.flags & 128))
        ) {
          for (f = fo; f; ) f = gn(f);
          return Lu(), (h.flags |= 98560), h;
        }
        if (C !== null && C.dehydrated !== null) {
          if (((C = kf(h)), f === null)) {
            if (!C) throw Error(a(318));
            if (!ve) throw Error(a(344));
            if (
              ((f = h.memoizedState),
              (f = f !== null ? f.dehydrated : null),
              !f)
            )
              throw Error(a(317));
            Ln(f, h);
          } else
            Lu(), !(h.flags & 128) && (h.memoizedState = null), (h.flags |= 4);
          return ii(h), null;
        }
        return (
          la !== null && (Wx(la), (la = null)),
          h.flags & 128
            ? ((h.lanes = b), h)
            : ((C = C !== null),
              (b = !1),
              f === null ? kf(h) : (b = f.memoizedState !== null),
              C &&
                !b &&
                ((h.child.flags |= 8192),
                h.mode & 1 &&
                  (f === null || qn.current & 1 ? Mr === 0 && (Mr = 3) : qx())),
              h.updateQueue !== null && (h.flags |= 4),
              ii(h),
              null)
        );
      case 4:
        return (
          Fu(),
          qf(f, h),
          f === null && ue(h.stateNode.containerInfo),
          ii(h),
          null
        );
      case 10:
        return Dr(h.type._context), ii(h), null;
      case 17:
        return Pt(h.type) && Tt(), ii(h), null;
      case 19:
        if ((St(qn), (O = h.memoizedState), O === null)) return ii(h), null;
        if (((C = (h.flags & 128) !== 0), (U = O.rendering), U === null))
          if (C) Kf(O, !1);
          else {
            if (Mr !== 0 || (f !== null && f.flags & 128))
              for (f = h.child; f !== null; ) {
                if (((U = Gm(f)), U !== null)) {
                  for (
                    h.flags |= 128,
                      Kf(O, !1),
                      f = U.updateQueue,
                      f !== null && ((h.updateQueue = f), (h.flags |= 4)),
                      h.subtreeFlags = 0,
                      f = b,
                      C = h.child;
                    C !== null;

                  )
                    (b = C),
                      (O = f),
                      (b.flags &= 14680066),
                      (U = b.alternate),
                      U === null
                        ? ((b.childLanes = 0),
                          (b.lanes = O),
                          (b.child = null),
                          (b.subtreeFlags = 0),
                          (b.memoizedProps = null),
                          (b.memoizedState = null),
                          (b.updateQueue = null),
                          (b.dependencies = null),
                          (b.stateNode = null))
                        : ((b.childLanes = U.childLanes),
                          (b.lanes = U.lanes),
                          (b.child = U.child),
                          (b.subtreeFlags = 0),
                          (b.deletions = null),
                          (b.memoizedProps = U.memoizedProps),
                          (b.memoizedState = U.memoizedState),
                          (b.updateQueue = U.updateQueue),
                          (b.type = U.type),
                          (O = U.dependencies),
                          (b.dependencies =
                            O === null
                              ? null
                              : {
                                  lanes: O.lanes,
                                  firstContext: O.firstContext,
                                })),
                      (C = C.sibling);
                  return ct(qn, (qn.current & 1) | 2), h.child;
                }
                f = f.sibling;
              }
            O.tail !== null &&
              jt() > jx &&
              ((h.flags |= 128), (C = !0), Kf(O, !1), (h.lanes = 4194304));
          }
        else {
          if (!C)
            if (((f = Gm(U)), f !== null)) {
              if (
                ((h.flags |= 128),
                (C = !0),
                (f = f.updateQueue),
                f !== null && ((h.updateQueue = f), (h.flags |= 4)),
                Kf(O, !0),
                O.tail === null &&
                  O.tailMode === "hidden" &&
                  !U.alternate &&
                  !Gn)
              )
                return ii(h), null;
            } else
              2 * jt() - O.renderingStartTime > jx &&
                b !== 1073741824 &&
                ((h.flags |= 128), (C = !0), Kf(O, !1), (h.lanes = 4194304));
          O.isBackwards
            ? ((U.sibling = h.child), (h.child = U))
            : ((f = O.last),
              f !== null ? (f.sibling = U) : (h.child = U),
              (O.last = U));
        }
        return O.tail !== null
          ? ((h = O.tail),
            (O.rendering = h),
            (O.tail = h.sibling),
            (O.renderingStartTime = jt()),
            (h.sibling = null),
            (f = qn.current),
            ct(qn, C ? (f & 1) | 2 : f & 1),
            h)
          : (ii(h), null);
      case 22:
      case 23:
        return (
          Xx(),
          (C = h.memoizedState !== null),
          f !== null && (f.memoizedState !== null) !== C && (h.flags |= 8192),
          C && h.mode & 1
            ? po & 1073741824 &&
              (ii(h), se && h.subtreeFlags & 6 && (h.flags |= 8192))
            : ii(h),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(a(156, h.tag));
  }
  var Z4 = s.ReactCurrentOwner,
    ho = !1;
  function Mi(f, h, b, C) {
    h.child = f === null ? G2(h, null, b, C) : Ou(h, f.child, b, C);
  }
  function yT(f, h, b, C, O) {
    b = b.render;
    var U = h.ref;
    return (
      cr(h, O),
      (C = xx(f, h, b, C, U, O)),
      (b = Sx()),
      f !== null && !ho
        ? ((h.updateQueue = f.updateQueue),
          (h.flags &= -2053),
          (f.lanes &= ~O),
          gs(f, h, O))
        : (Gn && b && cx(h), (h.flags |= 1), Mi(f, h, C, O), h.child)
    );
  }
  function xT(f, h, b, C, O) {
    if (f === null) {
      var U = b.type;
      return typeof U == "function" &&
        !Kx(U) &&
        U.defaultProps === void 0 &&
        b.compare === null &&
        b.defaultProps === void 0
        ? ((h.tag = 15), (h.type = U), ST(f, h, U, C, O))
        : ((f = _g(b.type, null, C, h, h.mode, O)),
          (f.ref = h.ref),
          (f.return = h),
          (h.child = f));
    }
    if (((U = f.child), !(f.lanes & O))) {
      var re = U.memoizedProps;
      if (
        ((b = b.compare),
        (b = b !== null ? b : nc),
        b(re, C) && f.ref === h.ref)
      )
        return gs(f, h, O);
    }
    return (
      (h.flags |= 1),
      (f = il(U, C)),
      (f.ref = h.ref),
      (f.return = h),
      (h.child = f)
    );
  }
  function ST(f, h, b, C, O) {
    if (f !== null && nc(f.memoizedProps, C) && f.ref === h.ref)
      if (((ho = !1), (f.lanes & O) !== 0)) f.flags & 131072 && (ho = !0);
      else return (h.lanes = f.lanes), gs(f, h, O);
    return Cx(f, h, b, C, O);
  }
  function _T(f, h, b) {
    var C = h.pendingProps,
      O = C.children,
      U = f !== null ? f.memoizedState : null;
    if (C.mode === "hidden")
      if (!(h.mode & 1))
        (h.memoizedState = { baseLanes: 0, cachePool: null }),
          ct(zu, po),
          (po |= b);
      else if (b & 1073741824)
        (h.memoizedState = { baseLanes: 0, cachePool: null }),
          (C = U !== null ? U.baseLanes : b),
          ct(zu, po),
          (po |= C);
      else
        return (
          (f = U !== null ? U.baseLanes | b : b),
          (h.lanes = h.childLanes = 1073741824),
          (h.memoizedState = { baseLanes: f, cachePool: null }),
          (h.updateQueue = null),
          ct(zu, po),
          (po |= f),
          null
        );
    else
      U !== null ? ((C = U.baseLanes | b), (h.memoizedState = null)) : (C = b),
        ct(zu, po),
        (po |= C);
    return Mi(f, h, O, b), h.child;
  }
  function bT(f, h) {
    var b = h.ref;
    ((f === null && b !== null) || (f !== null && f.ref !== b)) &&
      ((h.flags |= 512), (h.flags |= 2097152));
  }
  function Cx(f, h, b, C, O) {
    var U = Pt(b) ? Xn : Ot.current;
    return (
      (U = Ut(h, U)),
      cr(h, O),
      (b = xx(f, h, b, C, U, O)),
      (C = Sx()),
      f !== null && !ho
        ? ((h.updateQueue = f.updateQueue),
          (h.flags &= -2053),
          (f.lanes &= ~O),
          gs(f, h, O))
        : (Gn && C && cx(h), (h.flags |= 1), Mi(f, h, b, O), h.child)
    );
  }
  function wT(f, h, b, C, O) {
    if (Pt(b)) {
      var U = !0;
      bn(h);
    } else U = !1;
    if ((cr(h, O), h.stateNode === null))
      f !== null &&
        ((f.alternate = null), (h.alternate = null), (h.flags |= 2)),
        z2(h, b, C),
        lx(h, b, C, O),
        (C = !0);
    else if (f === null) {
      var re = h.stateNode,
        xe = h.memoizedProps;
      re.props = xe;
      var je = re.context,
        it = b.contextType;
      typeof it == "object" && it !== null
        ? (it = ur(it))
        : ((it = Pt(b) ? Xn : Ot.current), (it = Ut(h, it)));
      var _t = b.getDerivedStateFromProps,
        Vt =
          typeof _t == "function" ||
          typeof re.getSnapshotBeforeUpdate == "function";
      Vt ||
        (typeof re.UNSAFE_componentWillReceiveProps != "function" &&
          typeof re.componentWillReceiveProps != "function") ||
        ((xe !== C || je !== it) && U2(h, re, C, it)),
        (Qs = !1);
      var Nt = h.memoizedState;
      (re.state = Nt),
        Bm(h, C, re, O),
        (je = h.memoizedState),
        xe !== C || Nt !== je || fn.current || Qs
          ? (typeof _t == "function" &&
              (sx(h, b, _t, C), (je = h.memoizedState)),
            (xe = Qs || D2(h, b, xe, C, Nt, je, it))
              ? (Vt ||
                  (typeof re.UNSAFE_componentWillMount != "function" &&
                    typeof re.componentWillMount != "function") ||
                  (typeof re.componentWillMount == "function" &&
                    re.componentWillMount(),
                  typeof re.UNSAFE_componentWillMount == "function" &&
                    re.UNSAFE_componentWillMount()),
                typeof re.componentDidMount == "function" &&
                  (h.flags |= 4194308))
              : (typeof re.componentDidMount == "function" &&
                  (h.flags |= 4194308),
                (h.memoizedProps = C),
                (h.memoizedState = je)),
            (re.props = C),
            (re.state = je),
            (re.context = it),
            (C = xe))
          : (typeof re.componentDidMount == "function" && (h.flags |= 4194308),
            (C = !1));
    } else {
      (re = h.stateNode),
        L2(f, h),
        (xe = h.memoizedProps),
        (it = h.type === h.elementType ? xe : wi(h.type, xe)),
        (re.props = it),
        (Vt = h.pendingProps),
        (Nt = re.context),
        (je = b.contextType),
        typeof je == "object" && je !== null
          ? (je = ur(je))
          : ((je = Pt(b) ? Xn : Ot.current), (je = Ut(h, je)));
      var Dn = b.getDerivedStateFromProps;
      (_t =
        typeof Dn == "function" ||
        typeof re.getSnapshotBeforeUpdate == "function") ||
        (typeof re.UNSAFE_componentWillReceiveProps != "function" &&
          typeof re.componentWillReceiveProps != "function") ||
        ((xe !== Vt || Nt !== je) && U2(h, re, C, je)),
        (Qs = !1),
        (Nt = h.memoizedState),
        (re.state = Nt),
        Bm(h, C, re, O);
      var At = h.memoizedState;
      xe !== Vt || Nt !== At || fn.current || Qs
        ? (typeof Dn == "function" && (sx(h, b, Dn, C), (At = h.memoizedState)),
          (it = Qs || D2(h, b, it, C, Nt, At, je) || !1)
            ? (_t ||
                (typeof re.UNSAFE_componentWillUpdate != "function" &&
                  typeof re.componentWillUpdate != "function") ||
                (typeof re.componentWillUpdate == "function" &&
                  re.componentWillUpdate(C, At, je),
                typeof re.UNSAFE_componentWillUpdate == "function" &&
                  re.UNSAFE_componentWillUpdate(C, At, je)),
              typeof re.componentDidUpdate == "function" && (h.flags |= 4),
              typeof re.getSnapshotBeforeUpdate == "function" &&
                (h.flags |= 1024))
            : (typeof re.componentDidUpdate != "function" ||
                (xe === f.memoizedProps && Nt === f.memoizedState) ||
                (h.flags |= 4),
              typeof re.getSnapshotBeforeUpdate != "function" ||
                (xe === f.memoizedProps && Nt === f.memoizedState) ||
                (h.flags |= 1024),
              (h.memoizedProps = C),
              (h.memoizedState = At)),
          (re.props = C),
          (re.state = At),
          (re.context = je),
          (C = it))
        : (typeof re.componentDidUpdate != "function" ||
            (xe === f.memoizedProps && Nt === f.memoizedState) ||
            (h.flags |= 4),
          typeof re.getSnapshotBeforeUpdate != "function" ||
            (xe === f.memoizedProps && Nt === f.memoizedState) ||
            (h.flags |= 1024),
          (C = !1));
    }
    return Tx(f, h, b, C, U, O);
  }
  function Tx(f, h, b, C, O, U) {
    bT(f, h);
    var re = (h.flags & 128) !== 0;
    if (!C && !re) return O && Bn(h, b, !1), gs(f, h, U);
    (C = h.stateNode), (Z4.current = h);
    var xe =
      re && typeof b.getDerivedStateFromError != "function" ? null : C.render();
    return (
      (h.flags |= 1),
      f !== null && re
        ? ((h.child = Ou(h, f.child, null, U)), (h.child = Ou(h, null, xe, U)))
        : Mi(f, h, xe, U),
      (h.memoizedState = C.state),
      O && Bn(h, b, !0),
      h.child
    );
  }
  function ET(f) {
    var h = f.stateNode;
    h.pendingContext
      ? vn(f, h.pendingContext, h.pendingContext !== h.context)
      : h.context && vn(f, h.context, !1),
      px(f, h.containerInfo);
  }
  function MT(f, h, b, C, O) {
    return Lu(), hx(O), (h.flags |= 256), Mi(f, h, b, C), h.child;
  }
  var tg = { dehydrated: null, treeContext: null, retryLane: 0 };
  function ng(f) {
    return { baseLanes: f, cachePool: null };
  }
  function CT(f, h, b) {
    var C = h.pendingProps,
      O = qn.current,
      U = !1,
      re = (h.flags & 128) !== 0,
      xe;
    if (
      ((xe = re) ||
        (xe = f !== null && f.memoizedState === null ? !1 : (O & 2) !== 0),
      xe
        ? ((U = !0), (h.flags &= -129))
        : (f === null || f.memoizedState !== null) && (O |= 1),
      ct(qn, O & 1),
      f === null)
    )
      return (
        fx(h),
        (f = h.memoizedState),
        f !== null && ((f = f.dehydrated), f !== null)
          ? (h.mode & 1
              ? dn(f)
                ? (h.lanes = 8)
                : (h.lanes = 1073741824)
              : (h.lanes = 1),
            null)
          : ((O = C.children),
            (f = C.fallback),
            U
              ? ((C = h.mode),
                (U = h.child),
                (O = { mode: "hidden", children: O }),
                !(C & 1) && U !== null
                  ? ((U.childLanes = 0), (U.pendingProps = O))
                  : (U = bg(O, C, 0, null)),
                (f = fc(f, C, b, null)),
                (U.return = h),
                (f.return = h),
                (U.sibling = f),
                (h.child = U),
                (h.child.memoizedState = ng(b)),
                (h.memoizedState = tg),
                f)
              : Ax(h, O))
      );
    if (((O = f.memoizedState), O !== null)) {
      if (((xe = O.dehydrated), xe !== null)) {
        if (re)
          return h.flags & 256
            ? ((h.flags &= -257), rg(f, h, b, Error(a(422))))
            : h.memoizedState !== null
            ? ((h.child = f.child), (h.flags |= 128), null)
            : ((U = C.fallback),
              (O = h.mode),
              (C = bg({ mode: "visible", children: C.children }, O, 0, null)),
              (U = fc(U, O, b, null)),
              (U.flags |= 2),
              (C.return = h),
              (U.return = h),
              (C.sibling = U),
              (h.child = C),
              h.mode & 1 && Ou(h, f.child, null, b),
              (h.child.memoizedState = ng(b)),
              (h.memoizedState = tg),
              U);
        if (!(h.mode & 1)) h = rg(f, h, b, null);
        else if (dn(xe)) h = rg(f, h, b, Error(a(419)));
        else if (((C = (b & f.childLanes) !== 0), ho || C)) {
          if (((C = yr), C !== null)) {
            switch (b & -b) {
              case 4:
                U = 2;
                break;
              case 16:
                U = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                U = 32;
                break;
              case 536870912:
                U = 268435456;
                break;
              default:
                U = 0;
            }
            (C = U & (C.suspendedLanes | b) ? 0 : U),
              C !== 0 && C !== O.retryLane && ((O.retryLane = C), Bo(f, C, -1));
          }
          qx(), (h = rg(f, h, b, Error(a(421))));
        } else
          In(xe)
            ? ((h.flags |= 128),
              (h.child = f.child),
              (h = u5.bind(null, f)),
              _n(xe, h),
              (h = null))
            : ((b = O.treeContext),
              ve &&
                ((fo = Ht(xe)),
                (uo = h),
                (Gn = !0),
                (la = null),
                (Uf = !1),
                b !== null &&
                  ((Do[zo++] = hs),
                  (Do[zo++] = ps),
                  (Do[zo++] = ic),
                  (hs = b.id),
                  (ps = b.overflow),
                  (ic = h))),
              (h = Ax(h, h.pendingProps.children)),
              (h.flags |= 4096));
        return h;
      }
      return U
        ? ((C = AT(f, h, C.children, C.fallback, b)),
          (U = h.child),
          (O = f.child.memoizedState),
          (U.memoizedState =
            O === null
              ? ng(b)
              : { baseLanes: O.baseLanes | b, cachePool: null }),
          (U.childLanes = f.childLanes & ~b),
          (h.memoizedState = tg),
          C)
        : ((b = TT(f, h, C.children, b)), (h.memoizedState = null), b);
    }
    return U
      ? ((C = AT(f, h, C.children, C.fallback, b)),
        (U = h.child),
        (O = f.child.memoizedState),
        (U.memoizedState =
          O === null ? ng(b) : { baseLanes: O.baseLanes | b, cachePool: null }),
        (U.childLanes = f.childLanes & ~b),
        (h.memoizedState = tg),
        C)
      : ((b = TT(f, h, C.children, b)), (h.memoizedState = null), b);
  }
  function Ax(f, h) {
    return (
      (h = bg({ mode: "visible", children: h }, f.mode, 0, null)),
      (h.return = f),
      (f.child = h)
    );
  }
  function TT(f, h, b, C) {
    var O = f.child;
    return (
      (f = O.sibling),
      (b = il(O, { mode: "visible", children: b })),
      !(h.mode & 1) && (b.lanes = C),
      (b.return = h),
      (b.sibling = null),
      f !== null &&
        ((C = h.deletions),
        C === null ? ((h.deletions = [f]), (h.flags |= 16)) : C.push(f)),
      (h.child = b)
    );
  }
  function AT(f, h, b, C, O) {
    var U = h.mode;
    f = f.child;
    var re = f.sibling,
      xe = { mode: "hidden", children: b };
    return (
      !(U & 1) && h.child !== f
        ? ((b = h.child),
          (b.childLanes = 0),
          (b.pendingProps = xe),
          (h.deletions = null))
        : ((b = il(f, xe)), (b.subtreeFlags = f.subtreeFlags & 14680064)),
      re !== null ? (C = il(re, C)) : ((C = fc(C, U, O, null)), (C.flags |= 2)),
      (C.return = h),
      (b.return = h),
      (b.sibling = C),
      (h.child = b),
      C
    );
  }
  function rg(f, h, b, C) {
    return (
      C !== null && hx(C),
      Ou(h, f.child, null, b),
      (f = Ax(h, h.pendingProps.children)),
      (f.flags |= 2),
      (h.memoizedState = null),
      f
    );
  }
  function RT(f, h, b) {
    f.lanes |= h;
    var C = f.alternate;
    C !== null && (C.lanes |= h), Ei(f.return, h, b);
  }
  function Rx(f, h, b, C, O) {
    var U = f.memoizedState;
    U === null
      ? (f.memoizedState = {
          isBackwards: h,
          rendering: null,
          renderingStartTime: 0,
          last: C,
          tail: b,
          tailMode: O,
        })
      : ((U.isBackwards = h),
        (U.rendering = null),
        (U.renderingStartTime = 0),
        (U.last = C),
        (U.tail = b),
        (U.tailMode = O));
  }
  function PT(f, h, b) {
    var C = h.pendingProps,
      O = C.revealOrder,
      U = C.tail;
    if ((Mi(f, h, C.children, b), (C = qn.current), C & 2))
      (C = (C & 1) | 2), (h.flags |= 128);
    else {
      if (f !== null && f.flags & 128)
        e: for (f = h.child; f !== null; ) {
          if (f.tag === 13) f.memoizedState !== null && RT(f, b, h);
          else if (f.tag === 19) RT(f, b, h);
          else if (f.child !== null) {
            (f.child.return = f), (f = f.child);
            continue;
          }
          if (f === h) break e;
          for (; f.sibling === null; ) {
            if (f.return === null || f.return === h) break e;
            f = f.return;
          }
          (f.sibling.return = f.return), (f = f.sibling);
        }
      C &= 1;
    }
    if ((ct(qn, C), !(h.mode & 1))) h.memoizedState = null;
    else
      switch (O) {
        case "forwards":
          for (b = h.child, O = null; b !== null; )
            (f = b.alternate),
              f !== null && Gm(f) === null && (O = b),
              (b = b.sibling);
          (b = O),
            b === null
              ? ((O = h.child), (h.child = null))
              : ((O = b.sibling), (b.sibling = null)),
            Rx(h, !1, O, b, U);
          break;
        case "backwards":
          for (b = null, O = h.child, h.child = null; O !== null; ) {
            if (((f = O.alternate), f !== null && Gm(f) === null)) {
              h.child = O;
              break;
            }
            (f = O.sibling), (O.sibling = b), (b = O), (O = f);
          }
          Rx(h, !0, b, null, U);
          break;
        case "together":
          Rx(h, !1, null, null, void 0);
          break;
        default:
          h.memoizedState = null;
      }
    return h.child;
  }
  function gs(f, h, b) {
    if (
      (f !== null && (h.dependencies = f.dependencies),
      (Uu |= h.lanes),
      !(b & h.childLanes))
    )
      return null;
    if (f !== null && h.child !== f.child) throw Error(a(153));
    if (h.child !== null) {
      for (
        f = h.child, b = il(f, f.pendingProps), h.child = b, b.return = h;
        f.sibling !== null;

      )
        (f = f.sibling),
          (b = b.sibling = il(f, f.pendingProps)),
          (b.return = h);
      b.sibling = null;
    }
    return h.child;
  }
  function Q4(f, h, b) {
    switch (h.tag) {
      case 3:
        ET(h), Lu();
        break;
      case 5:
        W2(h);
        break;
      case 1:
        Pt(h.type) && bn(h);
        break;
      case 4:
        px(h, h.stateNode.containerInfo);
        break;
      case 10:
        Um(h, h.type._context, h.memoizedProps.value);
        break;
      case 13:
        var C = h.memoizedState;
        if (C !== null)
          return C.dehydrated !== null
            ? (ct(qn, qn.current & 1), (h.flags |= 128), null)
            : b & h.child.childLanes
            ? CT(f, h, b)
            : (ct(qn, qn.current & 1),
              (f = gs(f, h, b)),
              f !== null ? f.sibling : null);
        ct(qn, qn.current & 1);
        break;
      case 19:
        if (((C = (b & h.childLanes) !== 0), f.flags & 128)) {
          if (C) return PT(f, h, b);
          h.flags |= 128;
        }
        var O = h.memoizedState;
        if (
          (O !== null &&
            ((O.rendering = null), (O.tail = null), (O.lastEffect = null)),
          ct(qn, qn.current),
          C)
        )
          break;
        return null;
      case 22:
      case 23:
        return (h.lanes = 0), _T(f, h, b);
    }
    return gs(f, h, b);
  }
  function J4(f, h) {
    switch ((ux(h), h.tag)) {
      case 1:
        return (
          Pt(h.type) && Tt(),
          (f = h.flags),
          f & 65536 ? ((h.flags = (f & -65537) | 128), h) : null
        );
      case 3:
        return (
          Fu(),
          St(fn),
          St(Ot),
          vx(),
          (f = h.flags),
          f & 65536 && !(f & 128) ? ((h.flags = (f & -65537) | 128), h) : null
        );
      case 5:
        return mx(h), null;
      case 13:
        if (
          (St(qn), (f = h.memoizedState), f !== null && f.dehydrated !== null)
        ) {
          if (h.alternate === null) throw Error(a(340));
          Lu();
        }
        return (
          (f = h.flags), f & 65536 ? ((h.flags = (f & -65537) | 128), h) : null
        );
      case 19:
        return St(qn), null;
      case 4:
        return Fu(), null;
      case 10:
        return Dr(h.type._context), null;
      case 22:
      case 23:
        return Xx(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var ig = !1,
    sc = !1,
    e5 = typeof WeakSet == "function" ? WeakSet : Set,
    ft = null;
  function og(f, h) {
    var b = f.ref;
    if (b !== null)
      if (typeof b == "function")
        try {
          b(null);
        } catch (C) {
          Gi(f, h, C);
        }
      else b.current = null;
  }
  function Px(f, h, b) {
    try {
      b();
    } catch (C) {
      Gi(f, h, C);
    }
  }
  var IT = !1;
  function t5(f, h) {
    for ($(f.containerInfo), ft = h; ft !== null; )
      if (
        ((f = ft), (h = f.child), (f.subtreeFlags & 1028) !== 0 && h !== null)
      )
        (h.return = f), (ft = h);
      else
        for (; ft !== null; ) {
          f = ft;
          try {
            var b = f.alternate;
            if (f.flags & 1024)
              switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (b !== null) {
                    var C = b.memoizedProps,
                      O = b.memoizedState,
                      U = f.stateNode,
                      re = U.getSnapshotBeforeUpdate(
                        f.elementType === f.type ? C : wi(f.type, C),
                        O
                      );
                    U.__reactInternalSnapshotBeforeUpdate = re;
                  }
                  break;
                case 3:
                  se && $e(f.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(a(163));
              }
          } catch (xe) {
            Gi(f, f.return, xe);
          }
          if (((h = f.sibling), h !== null)) {
            (h.return = f.return), (ft = h);
            break;
          }
          ft = f.return;
        }
    return (b = IT), (IT = !1), b;
  }
  function lc(f, h, b) {
    var C = h.updateQueue;
    if (((C = C !== null ? C.lastEffect : null), C !== null)) {
      var O = (C = C.next);
      do {
        if ((O.tag & f) === f) {
          var U = O.destroy;
          (O.destroy = void 0), U !== void 0 && Px(h, b, U);
        }
        O = O.next;
      } while (O !== C);
    }
  }
  function Yf(f, h) {
    if (
      ((h = h.updateQueue), (h = h !== null ? h.lastEffect : null), h !== null)
    ) {
      var b = (h = h.next);
      do {
        if ((b.tag & f) === f) {
          var C = b.create;
          b.destroy = C();
        }
        b = b.next;
      } while (b !== h);
    }
  }
  function Ix(f) {
    var h = f.ref;
    if (h !== null) {
      var b = f.stateNode;
      switch (f.tag) {
        case 5:
          f = W(b);
          break;
        default:
          f = b;
      }
      typeof h == "function" ? h(f) : (h.current = f);
    }
  }
  function LT(f, h, b) {
    if (Nr && typeof Nr.onCommitFiberUnmount == "function")
      try {
        Nr.onCommitFiberUnmount(Ua, h);
      } catch {}
    switch (h.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((f = h.updateQueue), f !== null && ((f = f.lastEffect), f !== null))
        ) {
          var C = (f = f.next);
          do {
            var O = C,
              U = O.destroy;
            (O = O.tag),
              U !== void 0 && (O & 2 || O & 4) && Px(h, b, U),
              (C = C.next);
          } while (C !== f);
        }
        break;
      case 1:
        if (
          (og(h, b),
          (f = h.stateNode),
          typeof f.componentWillUnmount == "function")
        )
          try {
            (f.props = h.memoizedProps),
              (f.state = h.memoizedState),
              f.componentWillUnmount();
          } catch (re) {
            Gi(h, b, re);
          }
        break;
      case 5:
        og(h, b);
        break;
      case 4:
        se
          ? UT(f, h, b)
          : Y && Y && ((h = h.stateNode.containerInfo), (b = Xe(h)), ke(h, b));
    }
  }
  function OT(f, h, b) {
    for (var C = h; ; )
      if ((LT(f, C, b), C.child === null || (se && C.tag === 4))) {
        if (C === h) break;
        for (; C.sibling === null; ) {
          if (C.return === null || C.return === h) return;
          C = C.return;
        }
        (C.sibling.return = C.return), (C = C.sibling);
      } else (C.child.return = C), (C = C.child);
  }
  function NT(f) {
    var h = f.alternate;
    h !== null && ((f.alternate = null), NT(h)),
      (f.child = null),
      (f.deletions = null),
      (f.sibling = null),
      f.tag === 5 && ((h = f.stateNode), h !== null && Te(h)),
      (f.stateNode = null),
      (f.return = null),
      (f.dependencies = null),
      (f.memoizedProps = null),
      (f.memoizedState = null),
      (f.pendingProps = null),
      (f.stateNode = null),
      (f.updateQueue = null);
  }
  function FT(f) {
    return f.tag === 5 || f.tag === 3 || f.tag === 4;
  }
  function DT(f) {
    e: for (;;) {
      for (; f.sibling === null; ) {
        if (f.return === null || FT(f.return)) return null;
        f = f.return;
      }
      for (
        f.sibling.return = f.return, f = f.sibling;
        f.tag !== 5 && f.tag !== 6 && f.tag !== 18;

      ) {
        if (f.flags & 2 || f.child === null || f.tag === 4) continue e;
        (f.child.return = f), (f = f.child);
      }
      if (!(f.flags & 2)) return f.stateNode;
    }
  }
  function zT(f) {
    if (se) {
      e: {
        for (var h = f.return; h !== null; ) {
          if (FT(h)) break e;
          h = h.return;
        }
        throw Error(a(160));
      }
      var b = h;
      switch (b.tag) {
        case 5:
          (h = b.stateNode),
            b.flags & 32 && (Ie(h), (b.flags &= -33)),
            (b = DT(f)),
            Ox(f, b, h);
          break;
        case 3:
        case 4:
          (h = b.stateNode.containerInfo), (b = DT(f)), Lx(f, b, h);
          break;
        default:
          throw Error(a(161));
      }
    }
  }
  function Lx(f, h, b) {
    var C = f.tag;
    if (C === 5 || C === 6) (f = f.stateNode), h ? Ke(b, f, h) : Pe(b, f);
    else if (C !== 4 && ((f = f.child), f !== null))
      for (Lx(f, h, b), f = f.sibling; f !== null; )
        Lx(f, h, b), (f = f.sibling);
  }
  function Ox(f, h, b) {
    var C = f.tag;
    if (C === 5 || C === 6) (f = f.stateNode), h ? Qe(b, f, h) : Oe(b, f);
    else if (C !== 4 && ((f = f.child), f !== null))
      for (Ox(f, h, b), f = f.sibling; f !== null; )
        Ox(f, h, b), (f = f.sibling);
  }
  function UT(f, h, b) {
    for (var C = h, O = !1, U, re; ; ) {
      if (!O) {
        O = C.return;
        e: for (;;) {
          if (O === null) throw Error(a(160));
          switch (((U = O.stateNode), O.tag)) {
            case 5:
              re = !1;
              break e;
            case 3:
              (U = U.containerInfo), (re = !0);
              break e;
            case 4:
              (U = U.containerInfo), (re = !0);
              break e;
          }
          O = O.return;
        }
        O = !0;
      }
      if (C.tag === 5 || C.tag === 6)
        OT(f, C, b), re ? ne(U, C.stateNode) : Ne(U, C.stateNode);
      else if (C.tag === 18) re ? Ce(U, C.stateNode) : ze(U, C.stateNode);
      else if (C.tag === 4) {
        if (C.child !== null) {
          (U = C.stateNode.containerInfo),
            (re = !0),
            (C.child.return = C),
            (C = C.child);
          continue;
        }
      } else if ((LT(f, C, b), C.child !== null)) {
        (C.child.return = C), (C = C.child);
        continue;
      }
      if (C === h) break;
      for (; C.sibling === null; ) {
        if (C.return === null || C.return === h) return;
        (C = C.return), C.tag === 4 && (O = !1);
      }
      (C.sibling.return = C.return), (C = C.sibling);
    }
  }
  function Nx(f, h) {
    if (se) {
      switch (h.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          lc(3, h, h.return), Yf(3, h), lc(5, h, h.return);
          return;
        case 1:
          return;
        case 5:
          var b = h.stateNode;
          if (b != null) {
            var C = h.memoizedProps;
            f = f !== null ? f.memoizedProps : C;
            var O = h.type,
              U = h.updateQueue;
            (h.updateQueue = null), U !== null && st(b, U, O, f, C, h);
          }
          return;
        case 6:
          if (h.stateNode === null) throw Error(a(162));
          (b = h.memoizedProps),
            Se(h.stateNode, f !== null ? f.memoizedProps : b, b);
          return;
        case 3:
          ve &&
            f !== null &&
            f.memoizedState.isDehydrated &&
            ye(h.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          ag(h);
          return;
        case 19:
          ag(h);
          return;
        case 17:
          return;
      }
      throw Error(a(163));
    }
    switch (h.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        lc(3, h, h.return), Yf(3, h), lc(5, h, h.return);
        return;
      case 12:
        return;
      case 13:
        ag(h);
        return;
      case 19:
        ag(h);
        return;
      case 3:
        ve &&
          f !== null &&
          f.memoizedState.isDehydrated &&
          ye(h.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (Y) {
      switch (h.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (h = h.stateNode), ke(h.containerInfo, h.pendingChildren);
          break e;
      }
      throw Error(a(163));
    }
  }
  function ag(f) {
    var h = f.updateQueue;
    if (h !== null) {
      f.updateQueue = null;
      var b = f.stateNode;
      b === null && (b = f.stateNode = new e5()),
        h.forEach(function (C) {
          var O = d5.bind(null, f, C);
          b.has(C) || (b.add(C), C.then(O, O));
        });
    }
  }
  function n5(f, h) {
    for (ft = h; ft !== null; ) {
      h = ft;
      var b = h.deletions;
      if (b !== null)
        for (var C = 0; C < b.length; C++) {
          var O = b[C];
          try {
            var U = f;
            se ? UT(U, O, h) : OT(U, O, h);
            var re = O.alternate;
            re !== null && (re.return = null), (O.return = null);
          } catch (Ct) {
            Gi(O, h, Ct);
          }
        }
      if (((b = h.child), h.subtreeFlags & 12854 && b !== null))
        (b.return = h), (ft = b);
      else
        for (; ft !== null; ) {
          h = ft;
          try {
            var xe = h.flags;
            if ((xe & 32 && se && Ie(h.stateNode), xe & 512)) {
              var je = h.alternate;
              if (je !== null) {
                var it = je.ref;
                it !== null &&
                  (typeof it == "function" ? it(null) : (it.current = null));
              }
            }
            if (xe & 8192)
              switch (h.tag) {
                case 13:
                  if (h.memoizedState !== null) {
                    var _t = h.alternate;
                    (_t === null || _t.memoizedState === null) && (Hx = jt());
                  }
                  break;
                case 22:
                  var Vt = h.memoizedState !== null,
                    Nt = h.alternate,
                    Dn = Nt !== null && Nt.memoizedState !== null;
                  if (((b = h), se)) {
                    e: if (((C = b), (O = Vt), (U = null), se))
                      for (var At = C; ; ) {
                        if (At.tag === 5) {
                          if (U === null) {
                            U = At;
                            var oi = At.stateNode;
                            O ? et(oi) : Ee(At.stateNode, At.memoizedProps);
                          }
                        } else if (At.tag === 6) {
                          if (U === null) {
                            var jo = At.stateNode;
                            O ? We(jo) : ie(jo, At.memoizedProps);
                          }
                        } else if (
                          ((At.tag !== 22 && At.tag !== 23) ||
                            At.memoizedState === null ||
                            At === C) &&
                          At.child !== null
                        ) {
                          (At.child.return = At), (At = At.child);
                          continue;
                        }
                        if (At === C) break;
                        for (; At.sibling === null; ) {
                          if (At.return === null || At.return === C) break e;
                          U === At && (U = null), (At = At.return);
                        }
                        U === At && (U = null),
                          (At.sibling.return = At.return),
                          (At = At.sibling);
                      }
                  }
                  if (Vt && !Dn && b.mode & 1) {
                    ft = b;
                    for (var Fe = b.child; Fe !== null; ) {
                      for (b = ft = Fe; ft !== null; ) {
                        C = ft;
                        var we = C.child;
                        switch (C.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            lc(4, C, C.return);
                            break;
                          case 1:
                            og(C, C.return);
                            var Be = C.stateNode;
                            if (typeof Be.componentWillUnmount == "function") {
                              var mt = C.return;
                              try {
                                (Be.props = C.memoizedProps),
                                  (Be.state = C.memoizedState),
                                  Be.componentWillUnmount();
                              } catch (Ct) {
                                Gi(C, mt, Ct);
                              }
                            }
                            break;
                          case 5:
                            og(C, C.return);
                            break;
                          case 22:
                            if (C.memoizedState !== null) {
                              HT(b);
                              continue;
                            }
                        }
                        we !== null ? ((we.return = C), (ft = we)) : HT(b);
                      }
                      Fe = Fe.sibling;
                    }
                  }
              }
            switch (xe & 4102) {
              case 2:
                zT(h), (h.flags &= -3);
                break;
              case 6:
                zT(h), (h.flags &= -3), Nx(h.alternate, h);
                break;
              case 4096:
                h.flags &= -4097;
                break;
              case 4100:
                (h.flags &= -4097), Nx(h.alternate, h);
                break;
              case 4:
                Nx(h.alternate, h);
            }
          } catch (Ct) {
            Gi(h, h.return, Ct);
          }
          if (((b = h.sibling), b !== null)) {
            (b.return = h.return), (ft = b);
            break;
          }
          ft = h.return;
        }
    }
  }
  function r5(f, h, b) {
    (ft = f), kT(f);
  }
  function kT(f, h, b) {
    for (var C = (f.mode & 1) !== 0; ft !== null; ) {
      var O = ft,
        U = O.child;
      if (O.tag === 22 && C) {
        var re = O.memoizedState !== null || ig;
        if (!re) {
          var xe = O.alternate,
            je = (xe !== null && xe.memoizedState !== null) || sc;
          xe = ig;
          var it = sc;
          if (((ig = re), (sc = je) && !it))
            for (ft = O; ft !== null; )
              (re = ft),
                (je = re.child),
                re.tag === 22 && re.memoizedState !== null
                  ? jT(O)
                  : je !== null
                  ? ((je.return = re), (ft = je))
                  : jT(O);
          for (; U !== null; ) (ft = U), kT(U), (U = U.sibling);
          (ft = O), (ig = xe), (sc = it);
        }
        BT(f);
      } else
        O.subtreeFlags & 8772 && U !== null
          ? ((U.return = O), (ft = U))
          : BT(f);
    }
  }
  function BT(f) {
    for (; ft !== null; ) {
      var h = ft;
      if (h.flags & 8772) {
        var b = h.alternate;
        try {
          if (h.flags & 8772)
            switch (h.tag) {
              case 0:
              case 11:
              case 15:
                sc || Yf(5, h);
                break;
              case 1:
                var C = h.stateNode;
                if (h.flags & 4 && !sc)
                  if (b === null) C.componentDidMount();
                  else {
                    var O =
                      h.elementType === h.type
                        ? b.memoizedProps
                        : wi(h.type, b.memoizedProps);
                    C.componentDidUpdate(
                      O,
                      b.memoizedState,
                      C.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var U = h.updateQueue;
                U !== null && N2(h, U, C);
                break;
              case 3:
                var re = h.updateQueue;
                if (re !== null) {
                  if (((b = null), h.child !== null))
                    switch (h.child.tag) {
                      case 5:
                        b = W(h.child.stateNode);
                        break;
                      case 1:
                        b = h.child.stateNode;
                    }
                  N2(h, re, b);
                }
                break;
              case 5:
                var xe = h.stateNode;
                b === null && h.flags & 4 && Je(xe, h.type, h.memoizedProps, h);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (ve && h.memoizedState === null) {
                  var je = h.alternate;
                  if (je !== null) {
                    var it = je.memoizedState;
                    if (it !== null) {
                      var _t = it.dehydrated;
                      _t !== null && Ae(_t);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(a(163));
            }
          sc || (h.flags & 512 && Ix(h));
        } catch (Vt) {
          Gi(h, h.return, Vt);
        }
      }
      if (h === f) {
        ft = null;
        break;
      }
      if (((b = h.sibling), b !== null)) {
        (b.return = h.return), (ft = b);
        break;
      }
      ft = h.return;
    }
  }
  function HT(f) {
    for (; ft !== null; ) {
      var h = ft;
      if (h === f) {
        ft = null;
        break;
      }
      var b = h.sibling;
      if (b !== null) {
        (b.return = h.return), (ft = b);
        break;
      }
      ft = h.return;
    }
  }
  function jT(f) {
    for (; ft !== null; ) {
      var h = ft;
      try {
        switch (h.tag) {
          case 0:
          case 11:
          case 15:
            var b = h.return;
            try {
              Yf(4, h);
            } catch (je) {
              Gi(h, b, je);
            }
            break;
          case 1:
            var C = h.stateNode;
            if (typeof C.componentDidMount == "function") {
              var O = h.return;
              try {
                C.componentDidMount();
              } catch (je) {
                Gi(h, O, je);
              }
            }
            var U = h.return;
            try {
              Ix(h);
            } catch (je) {
              Gi(h, U, je);
            }
            break;
          case 5:
            var re = h.return;
            try {
              Ix(h);
            } catch (je) {
              Gi(h, re, je);
            }
        }
      } catch (je) {
        Gi(h, h.return, je);
      }
      if (h === f) {
        ft = null;
        break;
      }
      var xe = h.sibling;
      if (xe !== null) {
        (xe.return = h.return), (ft = xe);
        break;
      }
      ft = h.return;
    }
  }
  var sg = 0,
    lg = 1,
    cg = 2,
    ug = 3,
    dg = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var Zf = Symbol.for;
    (sg = Zf("selector.component")),
      (lg = Zf("selector.has_pseudo_class")),
      (cg = Zf("selector.role")),
      (ug = Zf("selector.test_id")),
      (dg = Zf("selector.text"));
  }
  function Fx(f) {
    var h = de(f);
    if (h != null) {
      if (typeof h.memoizedProps["data-testname"] != "string")
        throw Error(a(364));
      return h;
    }
    if (((f = Z(f)), f === null)) throw Error(a(362));
    return f.stateNode.current;
  }
  function Dx(f, h) {
    switch (h.$$typeof) {
      case sg:
        if (f.type === h.value) return !0;
        break;
      case lg:
        e: {
          (h = h.value), (f = [f, 0]);
          for (var b = 0; b < f.length; ) {
            var C = f[b++],
              O = f[b++],
              U = h[O];
            if (C.tag !== 5 || !he(C)) {
              for (; U != null && Dx(C, U); ) O++, (U = h[O]);
              if (O === h.length) {
                h = !0;
                break e;
              } else
                for (C = C.child; C !== null; ) f.push(C, O), (C = C.sibling);
            }
          }
          h = !1;
        }
        return h;
      case cg:
        if (f.tag === 5 && Me(f.stateNode, h.value)) return !0;
        break;
      case dg:
        if (
          (f.tag === 5 || f.tag === 6) &&
          ((f = ce(f)), f !== null && 0 <= f.indexOf(h.value))
        )
          return !0;
        break;
      case ug:
        if (
          f.tag === 5 &&
          ((f = f.memoizedProps["data-testname"]),
          typeof f == "string" && f.toLowerCase() === h.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(a(365));
    }
    return !1;
  }
  function zx(f) {
    switch (f.$$typeof) {
      case sg:
        return "<" + (T(f.value) || "Unknown") + ">";
      case lg:
        return ":has(" + (zx(f) || "") + ")";
      case cg:
        return '[role="' + f.value + '"]';
      case dg:
        return '"' + f.value + '"';
      case ug:
        return '[data-testname="' + f.value + '"]';
      default:
        throw Error(a(365));
    }
  }
  function VT(f, h) {
    var b = [];
    f = [f, 0];
    for (var C = 0; C < f.length; ) {
      var O = f[C++],
        U = f[C++],
        re = h[U];
      if (O.tag !== 5 || !he(O)) {
        for (; re != null && Dx(O, re); ) U++, (re = h[U]);
        if (U === h.length) b.push(O);
        else for (O = O.child; O !== null; ) f.push(O, U), (O = O.sibling);
      }
    }
    return b;
  }
  function Ux(f, h) {
    if (!z) throw Error(a(363));
    (f = Fx(f)), (f = VT(f, h)), (h = []), (f = Array.from(f));
    for (var b = 0; b < f.length; ) {
      var C = f[b++];
      if (C.tag === 5) he(C) || h.push(C.stateNode);
      else for (C = C.child; C !== null; ) f.push(C), (C = C.sibling);
    }
    return h;
  }
  var i5 = Math.ceil,
    fg = s.ReactCurrentDispatcher,
    kx = s.ReactCurrentOwner,
    dr = s.ReactCurrentBatchConfig,
    en = 0,
    yr = null,
    xr = null,
    $r = 0,
    po = 0,
    zu = cn(0),
    Mr = 0,
    Qf = null,
    Uu = 0,
    hg = 0,
    Bx = 0,
    Jf = null,
    Vi = null,
    Hx = 0,
    jx = 1 / 0;
  function ku() {
    jx = jt() + 500;
  }
  var pg = !1,
    Vx = null,
    el = null,
    mg = !1,
    tl = null,
    gg = 0,
    eh = 0,
    $x = null,
    vg = -1,
    yg = 0;
  function Ci() {
    return en & 6 ? jt() : vg !== -1 ? vg : (vg = jt());
  }
  function nl(f) {
    return f.mode & 1
      ? en & 2 && $r !== 0
        ? $r & -$r
        : tc.transition !== null
        ? (yg === 0 &&
            ((f = Or), (Or <<= 1), !(Or & 4194240) && (Or = 64), (yg = f)),
          yg)
        : ((f = Wt), f !== 0 ? f : fe())
      : 1;
  }
  function Bo(f, h, b) {
    if (50 < eh) throw ((eh = 0), ($x = null), Error(a(185)));
    var C = xg(f, h);
    return C === null
      ? null
      : (ti(C, h, b),
        (!(en & 2) || C !== yr) &&
          (C === yr && (!(en & 2) && (hg |= h), Mr === 4 && rl(C, $r)),
          $i(C, b),
          h === 1 && en === 0 && !(f.mode & 1) && (ku(), ka && ji())),
        C);
  }
  function xg(f, h) {
    f.lanes |= h;
    var b = f.alternate;
    for (b !== null && (b.lanes |= h), b = f, f = f.return; f !== null; )
      (f.childLanes |= h),
        (b = f.alternate),
        b !== null && (b.childLanes |= h),
        (b = f),
        (f = f.return);
    return b.tag === 3 ? b.stateNode : null;
  }
  function $i(f, h) {
    var b = f.callbackNode;
    oo(f, h);
    var C = No(f, f === yr ? $r : 0);
    if (C === 0)
      b !== null && za(b), (f.callbackNode = null), (f.callbackPriority = 0);
    else if (((h = C & -C), f.callbackPriority !== h)) {
      if ((b != null && za(b), h === 1))
        f.tag === 0 ? zf(GT.bind(null, f)) : Df(GT.bind(null, f)),
          pe
            ? H(function () {
                en === 0 && ji();
              })
            : so(Nn, ji),
          (b = null);
      else {
        switch (us(C)) {
          case 1:
            b = Nn;
            break;
          case 4:
            b = Fn;
            break;
          case 16:
            b = vr;
            break;
          case 536870912:
            b = ds;
            break;
          default:
            b = vr;
        }
        b = eA(b, $T.bind(null, f));
      }
      (f.callbackPriority = h), (f.callbackNode = b);
    }
  }
  function $T(f, h) {
    if (((vg = -1), (yg = 0), en & 6)) throw Error(a(327));
    var b = f.callbackNode;
    if (dc() && f.callbackNode !== b) return null;
    var C = No(f, f === yr ? $r : 0);
    if (C === 0) return null;
    if (C & 30 || C & f.expiredLanes || h) h = Sg(f, C);
    else {
      h = C;
      var O = en;
      en |= 2;
      var U = qT();
      (yr !== f || $r !== h) && (ku(), cc(f, h));
      do
        try {
          s5();
          break;
        } catch (xe) {
          XT(f, xe);
        }
      while (!0);
      Ru(),
        (fg.current = U),
        (en = O),
        xr !== null ? (h = 0) : ((yr = null), ($r = 0), (h = Mr));
    }
    if (h !== 0) {
      if (
        (h === 2 && ((O = ei(f)), O !== 0 && ((C = O), (h = Gx(f, O)))),
        h === 1)
      )
        throw ((b = Qf), cc(f, 0), rl(f, C), $i(f, jt()), b);
      if (h === 6) rl(f, C);
      else {
        if (
          ((O = f.current.alternate),
          !(C & 30) &&
            !o5(O) &&
            ((h = Sg(f, C)),
            h === 2 && ((U = ei(f)), U !== 0 && ((C = U), (h = Gx(f, U)))),
            h === 1))
        )
          throw ((b = Qf), cc(f, 0), rl(f, C), $i(f, jt()), b);
        switch (((f.finishedWork = O), (f.finishedLanes = C), h)) {
          case 0:
          case 1:
            throw Error(a(345));
          case 2:
            uc(f, Vi);
            break;
          case 3:
            if (
              (rl(f, C),
              (C & 130023424) === C && ((h = Hx + 500 - jt()), 10 < h))
            ) {
              if (No(f, 0) !== 0) break;
              if (((O = f.suspendedLanes), (O & C) !== C)) {
                Ci(), (f.pingedLanes |= f.suspendedLanes & O);
                break;
              }
              f.timeoutHandle = ae(uc.bind(null, f, Vi), h);
              break;
            }
            uc(f, Vi);
            break;
          case 4:
            if ((rl(f, C), (C & 4194240) === C)) break;
            for (h = f.eventTimes, O = -1; 0 < C; ) {
              var re = 31 - lr(C);
              (U = 1 << re), (re = h[re]), re > O && (O = re), (C &= ~U);
            }
            if (
              ((C = O),
              (C = jt() - C),
              (C =
                (120 > C
                  ? 120
                  : 480 > C
                  ? 480
                  : 1080 > C
                  ? 1080
                  : 1920 > C
                  ? 1920
                  : 3e3 > C
                  ? 3e3
                  : 4320 > C
                  ? 4320
                  : 1960 * i5(C / 1960)) - C),
              10 < C)
            ) {
              f.timeoutHandle = ae(uc.bind(null, f, Vi), C);
              break;
            }
            uc(f, Vi);
            break;
          case 5:
            uc(f, Vi);
            break;
          default:
            throw Error(a(329));
        }
      }
    }
    return $i(f, jt()), f.callbackNode === b ? $T.bind(null, f) : null;
  }
  function Gx(f, h) {
    var b = Jf;
    return (
      f.current.memoizedState.isDehydrated && (cc(f, h).flags |= 256),
      (f = Sg(f, h)),
      f !== 2 && ((h = Vi), (Vi = b), h !== null && Wx(h)),
      f
    );
  }
  function Wx(f) {
    Vi === null ? (Vi = f) : Vi.push.apply(Vi, f);
  }
  function o5(f) {
    for (var h = f; ; ) {
      if (h.flags & 16384) {
        var b = h.updateQueue;
        if (b !== null && ((b = b.stores), b !== null))
          for (var C = 0; C < b.length; C++) {
            var O = b[C],
              U = O.getSnapshot;
            O = O.value;
            try {
              if (!lo(U(), O)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((b = h.child), h.subtreeFlags & 16384 && b !== null))
        (b.return = h), (h = b);
      else {
        if (h === f) break;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === f) return !0;
          h = h.return;
        }
        (h.sibling.return = h.return), (h = h.sibling);
      }
    }
    return !0;
  }
  function rl(f, h) {
    for (
      h &= ~Bx,
        h &= ~hg,
        f.suspendedLanes |= h,
        f.pingedLanes &= ~h,
        f = f.expirationTimes;
      0 < h;

    ) {
      var b = 31 - lr(h),
        C = 1 << b;
      (f[b] = -1), (h &= ~C);
    }
  }
  function GT(f) {
    if (en & 6) throw Error(a(327));
    dc();
    var h = No(f, 0);
    if (!(h & 1)) return $i(f, jt()), null;
    var b = Sg(f, h);
    if (f.tag !== 0 && b === 2) {
      var C = ei(f);
      C !== 0 && ((h = C), (b = Gx(f, C)));
    }
    if (b === 1) throw ((b = Qf), cc(f, 0), rl(f, h), $i(f, jt()), b);
    if (b === 6) throw Error(a(345));
    return (
      (f.finishedWork = f.current.alternate),
      (f.finishedLanes = h),
      uc(f, Vi),
      $i(f, jt()),
      null
    );
  }
  function WT(f) {
    tl !== null && tl.tag === 0 && !(en & 6) && dc();
    var h = en;
    en |= 1;
    var b = dr.transition,
      C = Wt;
    try {
      if (((dr.transition = null), (Wt = 1), f)) return f();
    } finally {
      (Wt = C), (dr.transition = b), (en = h), !(en & 6) && ji();
    }
  }
  function Xx() {
    (po = zu.current), St(zu);
  }
  function cc(f, h) {
    (f.finishedWork = null), (f.finishedLanes = 0);
    var b = f.timeoutHandle;
    if ((b !== _e && ((f.timeoutHandle = _e), le(b)), xr !== null))
      for (b = xr.return; b !== null; ) {
        var C = b;
        switch ((ux(C), C.tag)) {
          case 1:
            (C = C.type.childContextTypes), C != null && Tt();
            break;
          case 3:
            Fu(), St(fn), St(Ot), vx();
            break;
          case 5:
            mx(C);
            break;
          case 4:
            Fu();
            break;
          case 13:
            St(qn);
            break;
          case 19:
            St(qn);
            break;
          case 10:
            Dr(C.type._context);
            break;
          case 22:
          case 23:
            Xx();
        }
        b = b.return;
      }
    if (
      ((yr = f),
      (xr = f = il(f.current, null)),
      ($r = po = h),
      (Mr = 0),
      (Qf = null),
      (Bx = hg = Uu = 0),
      (Vi = Jf = null),
      co !== null)
    ) {
      for (h = 0; h < co.length; h++)
        if (((b = co[h]), (C = b.interleaved), C !== null)) {
          b.interleaved = null;
          var O = C.next,
            U = b.pending;
          if (U !== null) {
            var re = U.next;
            (U.next = O), (C.next = re);
          }
          b.pending = C;
        }
      co = null;
    }
    return f;
  }
  function XT(f, h) {
    do {
      var b = xr;
      try {
        if ((Ru(), (Wm.current = Qm), Xm)) {
          for (var C = rr.memoizedState; C !== null; ) {
            var O = C.queue;
            O !== null && (O.pending = null), (C = C.next);
          }
          Xm = !1;
        }
        if (
          ((Du = 0),
          (zr = ni = rr = null),
          (Vf = !1),
          ($f = 0),
          (kx.current = null),
          b === null || b.return === null)
        ) {
          (Mr = 1), (Qf = h), (xr = null);
          break;
        }
        e: {
          var U = f,
            re = b.return,
            xe = b,
            je = h;
          if (
            ((h = $r),
            (xe.flags |= 32768),
            je !== null &&
              typeof je == "object" &&
              typeof je.then == "function")
          ) {
            var it = je,
              _t = xe,
              Vt = _t.tag;
            if (!(_t.mode & 1) && (Vt === 0 || Vt === 11 || Vt === 15)) {
              var Nt = _t.alternate;
              Nt
                ? ((_t.updateQueue = Nt.updateQueue),
                  (_t.memoizedState = Nt.memoizedState),
                  (_t.lanes = Nt.lanes))
                : ((_t.updateQueue = null), (_t.memoizedState = null));
            }
            var Dn = pT(re);
            if (Dn !== null) {
              (Dn.flags &= -257),
                mT(Dn, re, xe, U, h),
                Dn.mode & 1 && hT(U, it, h),
                (h = Dn),
                (je = it);
              var At = h.updateQueue;
              if (At === null) {
                var oi = new Set();
                oi.add(je), (h.updateQueue = oi);
              } else At.add(je);
              break e;
            } else {
              if (!(h & 1)) {
                hT(U, it, h), qx();
                break e;
              }
              je = Error(a(426));
            }
          } else if (Gn && xe.mode & 1) {
            var jo = pT(re);
            if (jo !== null) {
              !(jo.flags & 65536) && (jo.flags |= 256),
                mT(jo, re, xe, U, h),
                hx(je);
              break e;
            }
          }
          (U = je),
            Mr !== 4 && (Mr = 2),
            Jf === null ? (Jf = [U]) : Jf.push(U),
            (je = Ex(je, xe)),
            (xe = re);
          do {
            switch (xe.tag) {
              case 3:
                (xe.flags |= 65536), (h &= -h), (xe.lanes |= h);
                var Fe = dT(xe, je, h);
                O2(xe, Fe);
                break e;
              case 1:
                U = je;
                var we = xe.type,
                  Be = xe.stateNode;
                if (
                  !(xe.flags & 128) &&
                  (typeof we.getDerivedStateFromError == "function" ||
                    (Be !== null &&
                      typeof Be.componentDidCatch == "function" &&
                      (el === null || !el.has(Be))))
                ) {
                  (xe.flags |= 65536), (h &= -h), (xe.lanes |= h);
                  var mt = fT(xe, U, h);
                  O2(xe, mt);
                  break e;
                }
            }
            xe = xe.return;
          } while (xe !== null);
        }
        YT(b);
      } catch (Ct) {
        (h = Ct), xr === b && b !== null && (xr = b = b.return);
        continue;
      }
      break;
    } while (!0);
  }
  function qT() {
    var f = fg.current;
    return (fg.current = Qm), f === null ? Qm : f;
  }
  function qx() {
    (Mr === 0 || Mr === 3 || Mr === 2) && (Mr = 4),
      yr === null || (!(Uu & 268435455) && !(hg & 268435455)) || rl(yr, $r);
  }
  function Sg(f, h) {
    var b = en;
    en |= 2;
    var C = qT();
    (yr === f && $r === h) || cc(f, h);
    do
      try {
        a5();
        break;
      } catch (O) {
        XT(f, O);
      }
    while (!0);
    if ((Ru(), (en = b), (fg.current = C), xr !== null)) throw Error(a(261));
    return (yr = null), ($r = 0), Mr;
  }
  function a5() {
    for (; xr !== null; ) KT(xr);
  }
  function s5() {
    for (; xr !== null && !vt(); ) KT(xr);
  }
  function KT(f) {
    var h = JT(f.alternate, f, po);
    (f.memoizedProps = f.pendingProps),
      h === null ? YT(f) : (xr = h),
      (kx.current = null);
  }
  function YT(f) {
    var h = f;
    do {
      var b = h.alternate;
      if (((f = h.return), h.flags & 32768)) {
        if (((b = J4(b, h)), b !== null)) {
          (b.flags &= 32767), (xr = b);
          return;
        }
        if (f !== null)
          (f.flags |= 32768), (f.subtreeFlags = 0), (f.deletions = null);
        else {
          (Mr = 6), (xr = null);
          return;
        }
      } else if (((b = Y4(b, h, po)), b !== null)) {
        xr = b;
        return;
      }
      if (((h = h.sibling), h !== null)) {
        xr = h;
        return;
      }
      xr = h = f;
    } while (h !== null);
    Mr === 0 && (Mr = 5);
  }
  function uc(f, h) {
    var b = Wt,
      C = dr.transition;
    try {
      (dr.transition = null), (Wt = 1), l5(f, h, b);
    } finally {
      (dr.transition = C), (Wt = b);
    }
    return null;
  }
  function l5(f, h, b) {
    do dc();
    while (tl !== null);
    if (en & 6) throw Error(a(327));
    var C = f.finishedWork,
      O = f.finishedLanes;
    if (C === null) return null;
    if (((f.finishedWork = null), (f.finishedLanes = 0), C === f.current))
      throw Error(a(177));
    (f.callbackNode = null), (f.callbackPriority = 0);
    var U = C.lanes | C.childLanes;
    if (
      (Hi(f, U),
      f === yr && ((xr = yr = null), ($r = 0)),
      (!(C.subtreeFlags & 2064) && !(C.flags & 2064)) ||
        mg ||
        ((mg = !0),
        eA(vr, function () {
          return dc(), null;
        })),
      (U = (C.flags & 15990) !== 0),
      C.subtreeFlags & 15990 || U)
    ) {
      (U = dr.transition), (dr.transition = null);
      var re = Wt;
      Wt = 1;
      var xe = en;
      (en |= 4),
        (kx.current = null),
        t5(f, C),
        n5(f, C),
        G(f.containerInfo),
        (f.current = C),
        r5(C),
        zt(),
        (en = xe),
        (Wt = re),
        (dr.transition = U);
    } else f.current = C;
    if (
      (mg && ((mg = !1), (tl = f), (gg = O)),
      (U = f.pendingLanes),
      U === 0 && (el = null),
      Ff(C.stateNode),
      $i(f, jt()),
      h !== null)
    )
      for (b = f.onRecoverableError, C = 0; C < h.length; C++) b(h[C]);
    if (pg) throw ((pg = !1), (f = Vx), (Vx = null), f);
    return (
      gg & 1 && f.tag !== 0 && dc(),
      (U = f.pendingLanes),
      U & 1 ? (f === $x ? eh++ : ((eh = 0), ($x = f))) : (eh = 0),
      ji(),
      null
    );
  }
  function dc() {
    if (tl !== null) {
      var f = us(gg),
        h = dr.transition,
        b = Wt;
      try {
        if (((dr.transition = null), (Wt = 16 > f ? 16 : f), tl === null))
          var C = !1;
        else {
          if (((f = tl), (tl = null), (gg = 0), en & 6)) throw Error(a(331));
          var O = en;
          for (en |= 4, ft = f.current; ft !== null; ) {
            var U = ft,
              re = U.child;
            if (ft.flags & 16) {
              var xe = U.deletions;
              if (xe !== null) {
                for (var je = 0; je < xe.length; je++) {
                  var it = xe[je];
                  for (ft = it; ft !== null; ) {
                    var _t = ft;
                    switch (_t.tag) {
                      case 0:
                      case 11:
                      case 15:
                        lc(8, _t, U);
                    }
                    var Vt = _t.child;
                    if (Vt !== null) (Vt.return = _t), (ft = Vt);
                    else
                      for (; ft !== null; ) {
                        _t = ft;
                        var Nt = _t.sibling,
                          Dn = _t.return;
                        if ((NT(_t), _t === it)) {
                          ft = null;
                          break;
                        }
                        if (Nt !== null) {
                          (Nt.return = Dn), (ft = Nt);
                          break;
                        }
                        ft = Dn;
                      }
                  }
                }
                var At = U.alternate;
                if (At !== null) {
                  var oi = At.child;
                  if (oi !== null) {
                    At.child = null;
                    do {
                      var jo = oi.sibling;
                      (oi.sibling = null), (oi = jo);
                    } while (oi !== null);
                  }
                }
                ft = U;
              }
            }
            if (U.subtreeFlags & 2064 && re !== null)
              (re.return = U), (ft = re);
            else
              e: for (; ft !== null; ) {
                if (((U = ft), U.flags & 2048))
                  switch (U.tag) {
                    case 0:
                    case 11:
                    case 15:
                      lc(9, U, U.return);
                  }
                var Fe = U.sibling;
                if (Fe !== null) {
                  (Fe.return = U.return), (ft = Fe);
                  break e;
                }
                ft = U.return;
              }
          }
          var we = f.current;
          for (ft = we; ft !== null; ) {
            re = ft;
            var Be = re.child;
            if (re.subtreeFlags & 2064 && Be !== null)
              (Be.return = re), (ft = Be);
            else
              e: for (re = we; ft !== null; ) {
                if (((xe = ft), xe.flags & 2048))
                  try {
                    switch (xe.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Yf(9, xe);
                    }
                  } catch (Ct) {
                    Gi(xe, xe.return, Ct);
                  }
                if (xe === re) {
                  ft = null;
                  break e;
                }
                var mt = xe.sibling;
                if (mt !== null) {
                  (mt.return = xe.return), (ft = mt);
                  break e;
                }
                ft = xe.return;
              }
          }
          if (
            ((en = O),
            ji(),
            Nr && typeof Nr.onPostCommitFiberRoot == "function")
          )
            try {
              Nr.onPostCommitFiberRoot(Ua, f);
            } catch {}
          C = !0;
        }
        return C;
      } finally {
        (Wt = b), (dr.transition = h);
      }
    }
    return !1;
  }
  function ZT(f, h, b) {
    (h = Ex(b, h)),
      (h = dT(f, h, 1)),
      Js(f, h),
      (h = Ci()),
      (f = xg(f, 1)),
      f !== null && (ti(f, 1, h), $i(f, h));
  }
  function Gi(f, h, b) {
    if (f.tag === 3) ZT(f, f, b);
    else
      for (; h !== null; ) {
        if (h.tag === 3) {
          ZT(h, f, b);
          break;
        } else if (h.tag === 1) {
          var C = h.stateNode;
          if (
            typeof h.type.getDerivedStateFromError == "function" ||
            (typeof C.componentDidCatch == "function" &&
              (el === null || !el.has(C)))
          ) {
            (f = Ex(b, f)),
              (f = fT(h, f, 1)),
              Js(h, f),
              (f = Ci()),
              (h = xg(h, 1)),
              h !== null && (ti(h, 1, f), $i(h, f));
            break;
          }
        }
        h = h.return;
      }
  }
  function c5(f, h, b) {
    var C = f.pingCache;
    C !== null && C.delete(h),
      (h = Ci()),
      (f.pingedLanes |= f.suspendedLanes & b),
      yr === f &&
        ($r & b) === b &&
        (Mr === 4 || (Mr === 3 && ($r & 130023424) === $r && 500 > jt() - Hx)
          ? cc(f, 0)
          : (Bx |= b)),
      $i(f, h);
  }
  function QT(f, h) {
    h === 0 &&
      (f.mode & 1
        ? ((h = Si), (Si <<= 1), !(Si & 130023424) && (Si = 4194304))
        : (h = 1));
    var b = Ci();
    (f = xg(f, h)), f !== null && (ti(f, h, b), $i(f, b));
  }
  function u5(f) {
    var h = f.memoizedState,
      b = 0;
    h !== null && (b = h.retryLane), QT(f, b);
  }
  function d5(f, h) {
    var b = 0;
    switch (f.tag) {
      case 13:
        var C = f.stateNode,
          O = f.memoizedState;
        O !== null && (b = O.retryLane);
        break;
      case 19:
        C = f.stateNode;
        break;
      default:
        throw Error(a(314));
    }
    C !== null && C.delete(h), QT(f, b);
  }
  var JT;
  JT = function (f, h, b) {
    if (f !== null)
      if (f.memoizedProps !== h.pendingProps || fn.current) ho = !0;
      else {
        if (!(f.lanes & b) && !(h.flags & 128)) return (ho = !1), Q4(f, h, b);
        ho = !!(f.flags & 131072);
      }
    else (ho = !1), Gn && h.flags & 1048576 && k2(h, Vm, h.index);
    switch (((h.lanes = 0), h.tag)) {
      case 2:
        var C = h.type;
        f !== null &&
          ((f.alternate = null), (h.alternate = null), (h.flags |= 2)),
          (f = h.pendingProps);
        var O = Ut(h, Ot.current);
        cr(h, b), (O = xx(null, h, C, f, O, b));
        var U = Sx();
        return (
          (h.flags |= 1),
          typeof O == "object" &&
          O !== null &&
          typeof O.render == "function" &&
          O.$$typeof === void 0
            ? ((h.tag = 1),
              (h.memoizedState = null),
              (h.updateQueue = null),
              Pt(C) ? ((U = !0), bn(h)) : (U = !1),
              (h.memoizedState =
                O.state !== null && O.state !== void 0 ? O.state : null),
              ax(h),
              (O.updater = Hm),
              (h.stateNode = O),
              (O._reactInternals = h),
              lx(h, C, f, b),
              (h = Tx(null, h, C, !0, U, b)))
            : ((h.tag = 0), Gn && U && cx(h), Mi(null, h, O, b), (h = h.child)),
          h
        );
      case 16:
        C = h.elementType;
        e: {
          switch (
            (f !== null &&
              ((f.alternate = null), (h.alternate = null), (h.flags |= 2)),
            (f = h.pendingProps),
            (O = C._init),
            (C = O(C._payload)),
            (h.type = C),
            (O = h.tag = h5(C)),
            (f = wi(C, f)),
            O)
          ) {
            case 0:
              h = Cx(null, h, C, f, b);
              break e;
            case 1:
              h = wT(null, h, C, f, b);
              break e;
            case 11:
              h = yT(null, h, C, f, b);
              break e;
            case 14:
              h = xT(null, h, C, wi(C.type, f), b);
              break e;
          }
          throw Error(a(306, C, ""));
        }
        return h;
      case 0:
        return (
          (C = h.type),
          (O = h.pendingProps),
          (O = h.elementType === C ? O : wi(C, O)),
          Cx(f, h, C, O, b)
        );
      case 1:
        return (
          (C = h.type),
          (O = h.pendingProps),
          (O = h.elementType === C ? O : wi(C, O)),
          wT(f, h, C, O, b)
        );
      case 3:
        e: {
          if ((ET(h), f === null)) throw Error(a(387));
          (C = h.pendingProps),
            (U = h.memoizedState),
            (O = U.element),
            L2(f, h),
            Bm(h, C, null, b);
          var re = h.memoizedState;
          if (((C = re.element), ve && U.isDehydrated))
            if (
              ((U = {
                element: C,
                isDehydrated: !1,
                cache: re.cache,
                transitions: re.transitions,
              }),
              (h.updateQueue.baseState = U),
              (h.memoizedState = U),
              h.flags & 256)
            ) {
              (O = Error(a(423))), (h = MT(f, h, C, b, O));
              break e;
            } else if (C !== O) {
              (O = Error(a(424))), (h = MT(f, h, C, b, O));
              break e;
            } else
              for (
                ve &&
                  ((fo = ln(h.stateNode.containerInfo)),
                  (uo = h),
                  (Gn = !0),
                  (la = null),
                  (Uf = !1)),
                  b = G2(h, null, C, b),
                  h.child = b;
                b;

              )
                (b.flags = (b.flags & -3) | 4096), (b = b.sibling);
          else {
            if ((Lu(), C === O)) {
              h = gs(f, h, b);
              break e;
            }
            Mi(f, h, C, b);
          }
          h = h.child;
        }
        return h;
      case 5:
        return (
          W2(h),
          f === null && fx(h),
          (C = h.type),
          (O = h.pendingProps),
          (U = f !== null ? f.memoizedProps : null),
          (re = O.children),
          J(C, O) ? (re = null) : U !== null && J(C, U) && (h.flags |= 32),
          bT(f, h),
          Mi(f, h, re, b),
          h.child
        );
      case 6:
        return f === null && fx(h), null;
      case 13:
        return CT(f, h, b);
      case 4:
        return (
          px(h, h.stateNode.containerInfo),
          (C = h.pendingProps),
          f === null ? (h.child = Ou(h, null, C, b)) : Mi(f, h, C, b),
          h.child
        );
      case 11:
        return (
          (C = h.type),
          (O = h.pendingProps),
          (O = h.elementType === C ? O : wi(C, O)),
          yT(f, h, C, O, b)
        );
      case 7:
        return Mi(f, h, h.pendingProps, b), h.child;
      case 8:
        return Mi(f, h, h.pendingProps.children, b), h.child;
      case 12:
        return Mi(f, h, h.pendingProps.children, b), h.child;
      case 10:
        e: {
          if (
            ((C = h.type._context),
            (O = h.pendingProps),
            (U = h.memoizedProps),
            (re = O.value),
            Um(h, C, re),
            U !== null)
          )
            if (lo(U.value, re)) {
              if (U.children === O.children && !fn.current) {
                h = gs(f, h, b);
                break e;
              }
            } else
              for (U = h.child, U !== null && (U.return = h); U !== null; ) {
                var xe = U.dependencies;
                if (xe !== null) {
                  re = U.child;
                  for (var je = xe.firstContext; je !== null; ) {
                    if (je.context === C) {
                      if (U.tag === 1) {
                        (je = fs(-1, b & -b)), (je.tag = 2);
                        var it = U.updateQueue;
                        if (it !== null) {
                          it = it.shared;
                          var _t = it.pending;
                          _t === null
                            ? (je.next = je)
                            : ((je.next = _t.next), (_t.next = je)),
                            (it.pending = je);
                        }
                      }
                      (U.lanes |= b),
                        (je = U.alternate),
                        je !== null && (je.lanes |= b),
                        Ei(U.return, b, h),
                        (xe.lanes |= b);
                      break;
                    }
                    je = je.next;
                  }
                } else if (U.tag === 10)
                  re = U.type === h.type ? null : U.child;
                else if (U.tag === 18) {
                  if (((re = U.return), re === null)) throw Error(a(341));
                  (re.lanes |= b),
                    (xe = re.alternate),
                    xe !== null && (xe.lanes |= b),
                    Ei(re, b, h),
                    (re = U.sibling);
                } else re = U.child;
                if (re !== null) re.return = U;
                else
                  for (re = U; re !== null; ) {
                    if (re === h) {
                      re = null;
                      break;
                    }
                    if (((U = re.sibling), U !== null)) {
                      (U.return = re.return), (re = U);
                      break;
                    }
                    re = re.return;
                  }
                U = re;
              }
          Mi(f, h, O.children, b), (h = h.child);
        }
        return h;
      case 9:
        return (
          (O = h.type),
          (C = h.pendingProps.children),
          cr(h, b),
          (O = ur(O)),
          (C = C(O)),
          (h.flags |= 1),
          Mi(f, h, C, b),
          h.child
        );
      case 14:
        return (
          (C = h.type),
          (O = wi(C, h.pendingProps)),
          (O = wi(C.type, O)),
          xT(f, h, C, O, b)
        );
      case 15:
        return ST(f, h, h.type, h.pendingProps, b);
      case 17:
        return (
          (C = h.type),
          (O = h.pendingProps),
          (O = h.elementType === C ? O : wi(C, O)),
          f !== null &&
            ((f.alternate = null), (h.alternate = null), (h.flags |= 2)),
          (h.tag = 1),
          Pt(C) ? ((f = !0), bn(h)) : (f = !1),
          cr(h, b),
          z2(h, C, O),
          lx(h, C, O, b),
          Tx(null, h, C, !0, f, b)
        );
      case 19:
        return PT(f, h, b);
      case 22:
        return _T(f, h, b);
    }
    throw Error(a(156, h.tag));
  };
  function eA(f, h) {
    return so(f, h);
  }
  function f5(f, h, b, C) {
    (this.tag = f),
      (this.key = b),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = h),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = C),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function Ho(f, h, b, C) {
    return new f5(f, h, b, C);
  }
  function Kx(f) {
    return (f = f.prototype), !(!f || !f.isReactComponent);
  }
  function h5(f) {
    if (typeof f == "function") return Kx(f) ? 1 : 0;
    if (f != null) {
      if (((f = f.$$typeof), f === S)) return 11;
      if (f === _) return 14;
    }
    return 2;
  }
  function il(f, h) {
    var b = f.alternate;
    return (
      b === null
        ? ((b = Ho(f.tag, h, f.key, f.mode)),
          (b.elementType = f.elementType),
          (b.type = f.type),
          (b.stateNode = f.stateNode),
          (b.alternate = f),
          (f.alternate = b))
        : ((b.pendingProps = h),
          (b.type = f.type),
          (b.flags = 0),
          (b.subtreeFlags = 0),
          (b.deletions = null)),
      (b.flags = f.flags & 14680064),
      (b.childLanes = f.childLanes),
      (b.lanes = f.lanes),
      (b.child = f.child),
      (b.memoizedProps = f.memoizedProps),
      (b.memoizedState = f.memoizedState),
      (b.updateQueue = f.updateQueue),
      (h = f.dependencies),
      (b.dependencies =
        h === null ? null : { lanes: h.lanes, firstContext: h.firstContext }),
      (b.sibling = f.sibling),
      (b.index = f.index),
      (b.ref = f.ref),
      b
    );
  }
  function _g(f, h, b, C, O, U) {
    var re = 2;
    if (((C = f), typeof f == "function")) Kx(f) && (re = 1);
    else if (typeof f == "string") re = 5;
    else
      e: switch (f) {
        case u:
          return fc(b.children, O, U, h);
        case d:
          (re = 8), (O |= 8);
          break;
        case p:
          return (
            (f = Ho(12, b, h, O | 2)), (f.elementType = p), (f.lanes = U), f
          );
        case x:
          return (f = Ho(13, b, h, O)), (f.elementType = x), (f.lanes = U), f;
        case g:
          return (f = Ho(19, b, h, O)), (f.elementType = g), (f.lanes = U), f;
        case w:
          return bg(b, O, U, h);
        default:
          if (typeof f == "object" && f !== null)
            switch (f.$$typeof) {
              case m:
                re = 10;
                break e;
              case v:
                re = 9;
                break e;
              case S:
                re = 11;
                break e;
              case _:
                re = 14;
                break e;
              case y:
                (re = 16), (C = null);
                break e;
            }
          throw Error(a(130, f == null ? f : typeof f, ""));
      }
    return (
      (h = Ho(re, b, h, O)), (h.elementType = f), (h.type = C), (h.lanes = U), h
    );
  }
  function fc(f, h, b, C) {
    return (f = Ho(7, f, C, h)), (f.lanes = b), f;
  }
  function bg(f, h, b, C) {
    return (
      (f = Ho(22, f, C, h)),
      (f.elementType = w),
      (f.lanes = b),
      (f.stateNode = {}),
      f
    );
  }
  function Yx(f, h, b) {
    return (f = Ho(6, f, null, h)), (f.lanes = b), f;
  }
  function Zx(f, h, b) {
    return (
      (h = Ho(4, f.children !== null ? f.children : [], f.key, h)),
      (h.lanes = b),
      (h.stateNode = {
        containerInfo: f.containerInfo,
        pendingChildren: null,
        implementation: f.implementation,
      }),
      h
    );
  }
  function p5(f, h, b, C, O) {
    (this.tag = h),
      (this.containerInfo = f),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = _e),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = ao(0)),
      (this.expirationTimes = ao(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = ao(0)),
      (this.identifierPrefix = C),
      (this.onRecoverableError = O),
      ve && (this.mutableSourceEagerHydrationData = null);
  }
  function tA(f, h, b, C, O, U, re, xe, je) {
    return (
      (f = new p5(f, h, b, xe, je)),
      h === 1 ? ((h = 1), U === !0 && (h |= 8)) : (h = 0),
      (U = Ho(3, null, null, h)),
      (f.current = U),
      (U.stateNode = f),
      (U.memoizedState = {
        element: C,
        isDehydrated: b,
        cache: null,
        transitions: null,
      }),
      ax(U),
      f
    );
  }
  function nA(f) {
    if (!f) return zn;
    f = f._reactInternals;
    e: {
      if (R(f) !== f || f.tag !== 1) throw Error(a(170));
      var h = f;
      do {
        switch (h.tag) {
          case 3:
            h = h.stateNode.context;
            break e;
          case 1:
            if (Pt(h.type)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        h = h.return;
      } while (h !== null);
      throw Error(a(171));
    }
    if (f.tag === 1) {
      var b = f.type;
      if (Pt(b)) return En(f, b, h);
    }
    return h;
  }
  function rA(f) {
    var h = f._reactInternals;
    if (h === void 0)
      throw typeof f.render == "function"
        ? Error(a(188))
        : ((f = Object.keys(f).join(",")), Error(a(268, f)));
    return (f = D(h)), f === null ? null : f.stateNode;
  }
  function iA(f, h) {
    if (((f = f.memoizedState), f !== null && f.dehydrated !== null)) {
      var b = f.retryLane;
      f.retryLane = b !== 0 && b < h ? b : h;
    }
  }
  function Qx(f, h) {
    iA(f, h), (f = f.alternate) && iA(f, h);
  }
  function m5(f) {
    return (f = D(f)), f === null ? null : f.stateNode;
  }
  function g5() {
    return null;
  }
  return (
    (n.attemptContinuousHydration = function (f) {
      if (f.tag === 13) {
        var h = Ci();
        Bo(f, 134217728, h), Qx(f, 134217728);
      }
    }),
    (n.attemptHydrationAtCurrentPriority = function (f) {
      if (f.tag === 13) {
        var h = Ci(),
          b = nl(f);
        Bo(f, b, h), Qx(f, b);
      }
    }),
    (n.attemptSynchronousHydration = function (f) {
      switch (f.tag) {
        case 3:
          var h = f.stateNode;
          if (h.current.memoizedState.isDehydrated) {
            var b = nr(h.pendingLanes);
            b !== 0 && (_i(h, b | 1), $i(h, jt()), !(en & 6) && (ku(), ji()));
          }
          break;
        case 13:
          var C = Ci();
          WT(function () {
            return Bo(f, 1, C);
          }),
            Qx(f, 1);
      }
    }),
    (n.batchedUpdates = function (f, h) {
      var b = en;
      en |= 1;
      try {
        return f(h);
      } finally {
        (en = b), en === 0 && (ku(), ka && ji());
      }
    }),
    (n.createComponentSelector = function (f) {
      return { $$typeof: sg, value: f };
    }),
    (n.createContainer = function (f, h, b, C, O, U, re) {
      return tA(f, h, !1, null, b, C, O, U, re);
    }),
    (n.createHasPseudoClassSelector = function (f) {
      return { $$typeof: lg, value: f };
    }),
    (n.createHydrationContainer = function (f, h, b, C, O, U, re, xe, je) {
      return (
        (f = tA(b, C, !0, f, O, U, re, xe, je)),
        (f.context = nA(null)),
        (b = f.current),
        (C = Ci()),
        (O = nl(b)),
        (U = fs(C, O)),
        (U.callback = h ?? null),
        Js(b, U),
        (f.current.lanes = O),
        ti(f, O, C),
        $i(f, C),
        f
      );
    }),
    (n.createPortal = function (f, h, b) {
      var C =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: c,
        key: C == null ? null : "" + C,
        children: f,
        containerInfo: h,
        implementation: b,
      };
    }),
    (n.createRoleSelector = function (f) {
      return { $$typeof: cg, value: f };
    }),
    (n.createTestNameSelector = function (f) {
      return { $$typeof: ug, value: f };
    }),
    (n.createTextSelector = function (f) {
      return { $$typeof: dg, value: f };
    }),
    (n.deferredUpdates = function (f) {
      var h = Wt,
        b = dr.transition;
      try {
        return (dr.transition = null), (Wt = 16), f();
      } finally {
        (Wt = h), (dr.transition = b);
      }
    }),
    (n.discreteUpdates = function (f, h, b, C, O) {
      var U = Wt,
        re = dr.transition;
      try {
        return (dr.transition = null), (Wt = 1), f(h, b, C, O);
      } finally {
        (Wt = U), (dr.transition = re), en === 0 && ku();
      }
    }),
    (n.findAllNodes = Ux),
    (n.findBoundingRects = function (f, h) {
      if (!z) throw Error(a(363));
      (h = Ux(f, h)), (f = []);
      for (var b = 0; b < h.length; b++) f.push(ge(h[b]));
      for (h = f.length - 1; 0 < h; h--) {
        b = f[h];
        for (
          var C = b.x, O = C + b.width, U = b.y, re = U + b.height, xe = h - 1;
          0 <= xe;
          xe--
        )
          if (h !== xe) {
            var je = f[xe],
              it = je.x,
              _t = it + je.width,
              Vt = je.y,
              Nt = Vt + je.height;
            if (C >= it && U >= Vt && O <= _t && re <= Nt) {
              f.splice(h, 1);
              break;
            } else if (C !== it || b.width !== je.width || Nt < U || Vt > re) {
              if (!(U !== Vt || b.height !== je.height || _t < C || it > O)) {
                it > C && ((je.width += it - C), (je.x = C)),
                  _t < O && (je.width = O - it),
                  f.splice(h, 1);
                break;
              }
            } else {
              Vt > U && ((je.height += Vt - U), (je.y = U)),
                Nt < re && (je.height = re - Vt),
                f.splice(h, 1);
              break;
            }
          }
      }
      return f;
    }),
    (n.findHostInstance = rA),
    (n.findHostInstanceWithNoPortals = function (f) {
      return (
        (f = F(f)),
        (f = f !== null ? N(f) : null),
        f === null ? null : f.stateNode
      );
    }),
    (n.findHostInstanceWithWarning = function (f) {
      return rA(f);
    }),
    (n.flushControlled = function (f) {
      var h = en;
      en |= 1;
      var b = dr.transition,
        C = Wt;
      try {
        (dr.transition = null), (Wt = 1), f();
      } finally {
        (Wt = C), (dr.transition = b), (en = h), en === 0 && (ku(), ji());
      }
    }),
    (n.flushPassiveEffects = dc),
    (n.flushSync = WT),
    (n.focusWithin = function (f, h) {
      if (!z) throw Error(a(363));
      for (f = Fx(f), h = VT(f, h), h = Array.from(h), f = 0; f < h.length; ) {
        var b = h[f++];
        if (!he(b)) {
          if (b.tag === 5 && Re(b.stateNode)) return !0;
          for (b = b.child; b !== null; ) h.push(b), (b = b.sibling);
        }
      }
      return !1;
    }),
    (n.getCurrentUpdatePriority = function () {
      return Wt;
    }),
    (n.getFindAllNodesFailureDescription = function (f, h) {
      if (!z) throw Error(a(363));
      var b = 0,
        C = [];
      f = [Fx(f), 0];
      for (var O = 0; O < f.length; ) {
        var U = f[O++],
          re = f[O++],
          xe = h[re];
        if (
          (U.tag !== 5 || !he(U)) &&
          (Dx(U, xe) && (C.push(zx(xe)), re++, re > b && (b = re)),
          re < h.length)
        )
          for (U = U.child; U !== null; ) f.push(U, re), (U = U.sibling);
      }
      if (b < h.length) {
        for (f = []; b < h.length; b++) f.push(zx(h[b]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (C.join(" > ") +
            `

No matching component was found for:
  `) +
          f.join(" > ")
        );
      }
      return null;
    }),
    (n.getPublicRootInstance = function (f) {
      if (((f = f.current), !f.child)) return null;
      switch (f.child.tag) {
        case 5:
          return W(f.child.stateNode);
        default:
          return f.child.stateNode;
      }
    }),
    (n.injectIntoDevTools = function (f) {
      if (
        ((f = {
          bundleType: f.bundleType,
          version: f.version,
          rendererPackageName: f.rendererPackageName,
          rendererConfig: f.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: s.ReactCurrentDispatcher,
          findHostInstanceByFiber: m5,
          findFiberByHostInstance: f.findFiberByHostInstance || g5,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        f = !1;
      else {
        var h = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (h.isDisabled || !h.supportsFiber) f = !0;
        else {
          try {
            (Ua = h.inject(f)), (Nr = h);
          } catch {}
          f = !!h.checkDCE;
        }
      }
      return f;
    }),
    (n.isAlreadyRendering = function () {
      return !1;
    }),
    (n.observeVisibleRects = function (f, h, b, C) {
      if (!z) throw Error(a(363));
      f = Ux(f, h);
      var O = Le(f, b, C).disconnect;
      return {
        disconnect: function () {
          O();
        },
      };
    }),
    (n.registerMutableSourceForHydration = function (f, h) {
      var b = h._getVersion;
      (b = b(h._source)),
        f.mutableSourceEagerHydrationData == null
          ? (f.mutableSourceEagerHydrationData = [h, b])
          : f.mutableSourceEagerHydrationData.push(h, b);
    }),
    (n.runWithPriority = function (f, h) {
      var b = Wt;
      try {
        return (Wt = f), h();
      } finally {
        Wt = b;
      }
    }),
    (n.shouldError = function () {
      return null;
    }),
    (n.shouldSuspend = function () {
      return !1;
    }),
    (n.updateContainer = function (f, h, b, C) {
      var O = h.current,
        U = Ci(),
        re = nl(O);
      return (
        (b = nA(b)),
        h.context === null ? (h.context = b) : (h.pendingContext = b),
        (h = fs(U, re)),
        (h.payload = { element: f }),
        (C = C === void 0 ? null : C),
        C !== null && (h.callback = C),
        Js(O, h),
        (f = Bo(O, re, U)),
        f !== null && km(f, O, re),
        re
      );
    }),
    n
  );
};
rz.exports = k7;
var B7 = rz.exports;
const H7 = Ny(B7),
  OC = {},
  j7 = (t) => void Object.assign(OC, t);
function V7(t, e) {
  function n(u, { args: d = [], attach: p, ...m }, v) {
    let S = `${u[0].toUpperCase()}${u.slice(1)}`,
      x;
    if (u === "primitive") {
      if (m.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const g = m.object;
      x = bd(g, { type: u, root: v, attach: p, primitive: !0 });
    } else {
      const g = OC[S];
      if (!g)
        throw new Error(
          `R3F: ${S} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(d))
        throw new Error("R3F: The args prop must be an array!");
      x = bd(new g(...d), {
        type: u,
        root: v,
        attach: p,
        memoizedProps: { args: d },
      });
    }
    return (
      x.__r3f.attach === void 0 &&
        (x.isBufferGeometry
          ? (x.__r3f.attach = "geometry")
          : x.isMaterial && (x.__r3f.attach = "material")),
      S !== "inject" && u_(x, m),
      x
    );
  }
  function r(u, d) {
    let p = !1;
    if (d) {
      var m, v;
      (m = d.__r3f) != null && m.attach
        ? c_(u, d, d.__r3f.attach)
        : d.isObject3D && u.isObject3D && (u.add(d), (p = !0)),
        p || (v = u.__r3f) == null || v.objects.push(d),
        d.__r3f || bd(d, {}),
        (d.__r3f.parent = u),
        Vw(d),
        wd(d);
    }
  }
  function i(u, d, p) {
    let m = !1;
    if (d) {
      var v, S;
      if ((v = d.__r3f) != null && v.attach) c_(u, d, d.__r3f.attach);
      else if (d.isObject3D && u.isObject3D) {
        (d.parent = u),
          d.dispatchEvent({ type: "added" }),
          u.dispatchEvent({ type: "childadded", child: d });
        const x = u.children.filter((_) => _ !== d),
          g = x.indexOf(p);
        (u.children = [...x.slice(0, g), d, ...x.slice(g)]), (m = !0);
      }
      m || (S = u.__r3f) == null || S.objects.push(d),
        d.__r3f || bd(d, {}),
        (d.__r3f.parent = u),
        Vw(d),
        wd(d);
    }
  }
  function o(u, d, p = !1) {
    u && [...u].forEach((m) => a(d, m, p));
  }
  function a(u, d, p) {
    if (d) {
      var m, v, S;
      if (
        (d.__r3f && (d.__r3f.parent = null),
        (m = u.__r3f) != null &&
          m.objects &&
          (u.__r3f.objects = u.__r3f.objects.filter((w) => w !== d)),
        (v = d.__r3f) != null && v.attach)
      )
        qP(u, d, d.__r3f.attach);
      else if (d.isObject3D && u.isObject3D) {
        var x;
        u.remove(d), (x = d.__r3f) != null && x.root && Z7(w0(d), d);
      }
      const _ = (S = d.__r3f) == null ? void 0 : S.primitive,
        y = !_ && (p === void 0 ? d.dispose !== null : p);
      if (!_) {
        var g;
        o((g = d.__r3f) == null ? void 0 : g.objects, d, y),
          o(d.children, d, y);
      }
      if ((delete d.__r3f, y && d.dispose && d.type !== "Scene")) {
        const w = () => {
          try {
            d.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? Hw.unstable_scheduleCallback(Hw.unstable_IdlePriority, w)
          : w();
      }
      wd(u);
    }
  }
  function s(u, d, p, m) {
    var v;
    const S = (v = u.__r3f) == null ? void 0 : v.parent;
    if (!S) return;
    const x = n(d, p, u.__r3f.root);
    if (u.children) {
      for (const g of u.children) g.__r3f && r(x, g);
      u.children = u.children.filter((g) => !g.__r3f);
    }
    u.__r3f.objects.forEach((g) => r(x, g)),
      (u.__r3f.objects = []),
      u.__r3f.autoRemovedBeforeAppend || a(S, u),
      x.parent && (x.__r3f.autoRemovedBeforeAppend = !0),
      r(S, x),
      x.raycast &&
        x.__r3f.eventCount &&
        w0(x).getState().internal.interaction.push(x),
      [m, m.alternate].forEach((g) => {
        g !== null &&
          ((g.stateNode = x),
          g.ref &&
            (typeof g.ref == "function" ? g.ref(x) : (g.ref.current = x)));
      });
  }
  const l = () => {};
  return {
    reconciler: H7({
      createInstance: n,
      removeChild: a,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (u, d) => {
        if (!d) return;
        const p = u.getState().scene;
        p.__r3f && ((p.__r3f.root = u), r(p, d));
      },
      removeChildFromContainer: (u, d) => {
        d && a(u.getState().scene, d);
      },
      insertInContainerBefore: (u, d, p) => {
        if (!d || !p) return;
        const m = u.getState().scene;
        m.__r3f && i(m, d, p);
      },
      getRootHostContext: () => null,
      getChildHostContext: (u) => u,
      finalizeInitialChildren(u) {
        var d;
        return !!((d = u == null ? void 0 : u.__r3f) != null ? d : {}).handlers;
      },
      prepareUpdate(u, d, p, m) {
        var v;
        if (
          ((v = u == null ? void 0 : u.__r3f) != null ? v : {}).primitive &&
          m.object &&
          m.object !== u
        )
          return [!0];
        {
          const { args: x = [], children: g, ..._ } = m,
            { args: y = [], children: w, ...A } = p;
          if (!Array.isArray(x))
            throw new Error("R3F: the args prop must be an array!");
          if (x.some((T, I) => T !== y[I])) return [!0];
          const M = fz(u, _, A, !0);
          return M.changes.length ? [!1, M] : null;
        }
      },
      commitUpdate(u, [d, p], m, v, S, x) {
        d ? s(u, m, S, x) : u_(u, p);
      },
      commitMount(u, d, p, m) {
        var v;
        const S = (v = u.__r3f) != null ? v : {};
        u.raycast &&
          S.handlers &&
          S.eventCount &&
          w0(u).getState().internal.interaction.push(u);
      },
      getPublicInstance: (u) => u,
      prepareForCommit: () => null,
      preparePortalMount: (u) => bd(u.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(u) {
        var d;
        const { attach: p, parent: m } = (d = u.__r3f) != null ? d : {};
        p && m && qP(m, u, p), u.isObject3D && (u.visible = !1), wd(u);
      },
      unhideInstance(u, d) {
        var p;
        const { attach: m, parent: v } = (p = u.__r3f) != null ? p : {};
        m && v && c_(v, u, m),
          ((u.isObject3D && d.visible == null) || d.visible) &&
            (u.visible = !0),
          wd(u);
      },
      createTextInstance: l,
      hideTextInstance: l,
      unhideTextInstance: l,
      getCurrentEventPriority: () => (e ? e() : Vd.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && jn.fun(performance.now)
          ? performance.now
          : jn.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: jn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: jn.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: u_,
  };
}
var $P, GP;
const l_ = (t) => "colorSpace" in t || "outputColorSpace" in t,
  az = () => {
    var t;
    return (t = OC.ColorManagement) != null ? t : null;
  },
  sz = (t) => t && t.isOrthographicCamera,
  $7 = (t) => t && t.hasOwnProperty("current"),
  _m =
    typeof window < "u" &&
    ((($P = window.document) != null && $P.createElement) ||
      ((GP = window.navigator) == null ? void 0 : GP.product) === "ReactNative")
      ? E.useLayoutEffect
      : E.useEffect;
function lz(t) {
  const e = E.useRef(t);
  return _m(() => void (e.current = t), [t]), e;
}
function G7({ set: t }) {
  return _m(() => (t(new Promise(() => null)), () => t(!1)), [t]), null;
}
class cz extends E.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
cz.getDerivedStateFromError = () => ({ error: !0 });
const uz = "__default",
  WP = new Map(),
  W7 = (t) => t && !!t.memoized && !!t.changes;
function dz(t) {
  var e;
  const n =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(t) ? Math.min(Math.max(t[0], n), t[1]) : t;
}
const Sh = (t) => {
  var e;
  return (e = t.__r3f) == null ? void 0 : e.root.getState();
};
function w0(t) {
  let e = t.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const jn = {
  obj: (t) => t === Object(t) && !jn.arr(t) && typeof t != "function",
  fun: (t) => typeof t == "function",
  str: (t) => typeof t == "string",
  num: (t) => typeof t == "number",
  boo: (t) => typeof t == "boolean",
  und: (t) => t === void 0,
  arr: (t) => Array.isArray(t),
  equ(
    t,
    e,
    { arrays: n = "shallow", objects: r = "reference", strict: i = !0 } = {}
  ) {
    if (typeof t != typeof e || !!t != !!e) return !1;
    if (jn.str(t) || jn.num(t) || jn.boo(t)) return t === e;
    const o = jn.obj(t);
    if (o && r === "reference") return t === e;
    const a = jn.arr(t);
    if (a && n === "reference") return t === e;
    if ((a || o) && t === e) return !0;
    let s;
    for (s in t) if (!(s in e)) return !1;
    if (o && n === "shallow" && r === "shallow") {
      for (s in i ? e : t)
        if (!jn.equ(t[s], e[s], { strict: i, objects: "reference" })) return !1;
    } else for (s in i ? e : t) if (t[s] !== e[s]) return !1;
    if (jn.und(s)) {
      if (
        (a && t.length === 0 && e.length === 0) ||
        (o && Object.keys(t).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (t !== e) return !1;
    }
    return !0;
  },
};
function X7(t) {
  t.dispose && t.type !== "Scene" && t.dispose();
  for (const e in t) e.dispose == null || e.dispose(), delete t[e];
}
function bd(t, e) {
  const n = t;
  return (
    (n.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    t
  );
}
function jw(t, e) {
  let n = t;
  if (e.includes("-")) {
    const r = e.split("-"),
      i = r.pop();
    return (n = r.reduce((o, a) => o[a], t)), { target: n, key: i };
  } else return { target: n, key: e };
}
const XP = /-\d+$/;
function c_(t, e, n) {
  if (jn.str(n)) {
    if (XP.test(n)) {
      const o = n.replace(XP, ""),
        { target: a, key: s } = jw(t, o);
      Array.isArray(a[s]) || (a[s] = []);
    }
    const { target: r, key: i } = jw(t, n);
    (e.__r3f.previousAttach = r[i]), (r[i] = e);
  } else e.__r3f.previousAttach = n(t, e);
}
function qP(t, e, n) {
  var r, i;
  if (jn.str(n)) {
    const { target: o, key: a } = jw(t, n),
      s = e.__r3f.previousAttach;
    s === void 0 ? delete o[a] : (o[a] = s);
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(t, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function fz(
  t,
  { children: e, key: n, ref: r, ...i },
  { children: o, key: a, ref: s, ...l } = {},
  c = !1
) {
  const u = t.__r3f,
    d = Object.entries(i),
    p = [];
  if (c) {
    const v = Object.keys(l);
    for (let S = 0; S < v.length; S++)
      i.hasOwnProperty(v[S]) || d.unshift([v[S], uz + "remove"]);
  }
  d.forEach(([v, S]) => {
    var x;
    if (
      ((x = t.__r3f) != null && x.primitive && v === "object") ||
      jn.equ(S, l[v])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(v))
      return p.push([v, S, !0, []]);
    let g = [];
    v.includes("-") && (g = v.split("-")), p.push([v, S, !1, g]);
    for (const _ in i) {
      const y = i[_];
      _.startsWith(`${v}-`) && p.push([_, y, !1, _.split("-")]);
    }
  });
  const m = { ...i };
  return (
    u != null &&
      u.memoizedProps &&
      u != null &&
      u.memoizedProps.args &&
      (m.args = u.memoizedProps.args),
    u != null &&
      u.memoizedProps &&
      u != null &&
      u.memoizedProps.attach &&
      (m.attach = u.memoizedProps.attach),
    { memoized: m, changes: p }
  );
}
const q7 = typeof process < "u" && !1;
function u_(t, e) {
  var n;
  const r = t.__r3f,
    i = r == null ? void 0 : r.root,
    o = i == null || i.getState == null ? void 0 : i.getState(),
    { memoized: a, changes: s } = W7(e) ? e : fz(t, e),
    l = r == null ? void 0 : r.eventCount;
  t.__r3f && (t.__r3f.memoizedProps = a);
  for (let p = 0; p < s.length; p++) {
    let [m, v, S, x] = s[p];
    if (l_(t)) {
      const w = "srgb",
        A = "srgb-linear";
      m === "encoding"
        ? ((m = "colorSpace"), (v = v === 3001 ? w : A))
        : m === "outputEncoding" &&
          ((m = "outputColorSpace"), (v = v === 3001 ? w : A));
    }
    let g = t,
      _ = g[m];
    if (x.length && ((_ = x.reduce((y, w) => y[w], t)), !(_ && _.set))) {
      const [y, ...w] = x.reverse();
      (g = w.reverse().reduce((A, M) => A[M], t)), (m = y);
    }
    if (v === uz + "remove")
      if (g.constructor) {
        let y = WP.get(g.constructor);
        y || ((y = new g.constructor()), WP.set(g.constructor, y)), (v = y[m]);
      } else v = 0;
    if (S && r)
      v ? (r.handlers[m] = v) : delete r.handlers[m],
        (r.eventCount = Object.keys(r.handlers).length);
    else if (_ && _.set && (_.copy || _ instanceof Yc)) {
      if (Array.isArray(v)) _.fromArray ? _.fromArray(v) : _.set(...v);
      else if (
        _.copy &&
        v &&
        v.constructor &&
        (q7
          ? _.constructor.name === v.constructor.name
          : _.constructor === v.constructor)
      )
        _.copy(v);
      else if (v !== void 0) {
        var c;
        const y = (c = _) == null ? void 0 : c.isColor;
        !y && _.setScalar
          ? _.setScalar(v)
          : _ instanceof Yc && v instanceof Yc
          ? (_.mask = v.mask)
          : _.set(v),
          !az() && o && !o.linear && y && _.convertSRGBToLinear();
      }
    } else {
      var u;
      if (
        ((g[m] = v),
        (u = g[m]) != null &&
          u.isTexture &&
          g[m].format === Ii &&
          g[m].type === es &&
          o)
      ) {
        const y = g[m];
        l_(y) && l_(o.gl)
          ? (y.colorSpace = o.gl.outputColorSpace)
          : (y.encoding = o.gl.outputEncoding);
      }
    }
    wd(t);
  }
  if (r && r.parent && t.raycast && l !== r.eventCount) {
    const p = w0(t).getState().internal,
      m = p.interaction.indexOf(t);
    m > -1 && p.interaction.splice(m, 1), r.eventCount && p.interaction.push(t);
  }
  return (
    !(s.length === 1 && s[0][0] === "onUpdate") &&
      s.length &&
      (n = t.__r3f) != null &&
      n.parent &&
      Vw(t),
    t
  );
}
function wd(t) {
  var e, n;
  const r =
    (e = t.__r3f) == null || (n = e.root) == null || n.getState == null
      ? void 0
      : n.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function Vw(t) {
  t.onUpdate == null || t.onUpdate(t);
}
function K7(t, e) {
  t.manual ||
    (sz(t)
      ? ((t.left = e.width / -2),
        (t.right = e.width / 2),
        (t.top = e.height / 2),
        (t.bottom = e.height / -2))
      : (t.aspect = e.width / e.height),
    t.updateProjectionMatrix(),
    t.updateMatrixWorld());
}
function Ov(t) {
  return (t.eventObject || t.object).uuid + "/" + t.index + t.instanceId;
}
function Y7() {
  var t;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return Vd.DefaultEventPriority;
  switch ((t = e.event) == null ? void 0 : t.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Vd.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Vd.ContinuousEventPriority;
    default:
      return Vd.DefaultEventPriority;
  }
}
function hz(t, e, n, r) {
  const i = n.get(e);
  i &&
    (n.delete(e),
    n.size === 0 && (t.delete(r), i.target.releasePointerCapture(r)));
}
function Z7(t, e) {
  const { internal: n } = t.getState();
  (n.interaction = n.interaction.filter((r) => r !== e)),
    (n.initialHits = n.initialHits.filter((r) => r !== e)),
    n.hovered.forEach((r, i) => {
      (r.eventObject === e || r.object === e) && n.hovered.delete(i);
    }),
    n.capturedMap.forEach((r, i) => {
      hz(n.capturedMap, e, r, i);
    });
}
function Q7(t) {
  function e(l) {
    const { internal: c } = t.getState(),
      u = l.offsetX - c.initialClick[0],
      d = l.offsetY - c.initialClick[1];
    return Math.round(Math.sqrt(u * u + d * d));
  }
  function n(l) {
    return l.filter((c) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((u) => {
        var d;
        return (d = c.__r3f) == null ? void 0 : d.handlers["onPointer" + u];
      })
    );
  }
  function r(l, c) {
    const u = t.getState(),
      d = new Set(),
      p = [],
      m = c ? c(u.internal.interaction) : u.internal.interaction;
    for (let g = 0; g < m.length; g++) {
      const _ = Sh(m[g]);
      _ && (_.raycaster.camera = void 0);
    }
    u.previousRoot || u.events.compute == null || u.events.compute(l, u);
    function v(g) {
      const _ = Sh(g);
      if (!_ || !_.events.enabled || _.raycaster.camera === null) return [];
      if (_.raycaster.camera === void 0) {
        var y;
        _.events.compute == null ||
          _.events.compute(
            l,
            _,
            (y = _.previousRoot) == null ? void 0 : y.getState()
          ),
          _.raycaster.camera === void 0 && (_.raycaster.camera = null);
      }
      return _.raycaster.camera ? _.raycaster.intersectObject(g, !0) : [];
    }
    let S = m
      .flatMap(v)
      .sort((g, _) => {
        const y = Sh(g.object),
          w = Sh(_.object);
        return !y || !w
          ? g.distance - _.distance
          : w.events.priority - y.events.priority || g.distance - _.distance;
      })
      .filter((g) => {
        const _ = Ov(g);
        return d.has(_) ? !1 : (d.add(_), !0);
      });
    u.events.filter && (S = u.events.filter(S, u));
    for (const g of S) {
      let _ = g.object;
      for (; _; ) {
        var x;
        (x = _.__r3f) != null &&
          x.eventCount &&
          p.push({ ...g, eventObject: _ }),
          (_ = _.parent);
      }
    }
    if ("pointerId" in l && u.internal.capturedMap.has(l.pointerId))
      for (let g of u.internal.capturedMap.get(l.pointerId).values())
        d.has(Ov(g.intersection)) || p.push(g.intersection);
    return p;
  }
  function i(l, c, u, d) {
    const p = t.getState();
    if (l.length) {
      const m = { stopped: !1 };
      for (const v of l) {
        const S = Sh(v.object) || p,
          { raycaster: x, pointer: g, camera: _, internal: y } = S,
          w = new K(g.x, g.y, 0).unproject(_),
          A = (P) => {
            var F, D;
            return (F =
              (D = y.capturedMap.get(P)) == null
                ? void 0
                : D.has(v.eventObject)) != null
              ? F
              : !1;
          },
          M = (P) => {
            const F = { intersection: v, target: c.target };
            y.capturedMap.has(P)
              ? y.capturedMap.get(P).set(v.eventObject, F)
              : y.capturedMap.set(P, new Map([[v.eventObject, F]])),
              c.target.setPointerCapture(P);
          },
          T = (P) => {
            const F = y.capturedMap.get(P);
            F && hz(y.capturedMap, v.eventObject, F, P);
          };
        let I = {};
        for (let P in c) {
          let F = c[P];
          typeof F != "function" && (I[P] = F);
        }
        let R = {
          ...v,
          ...I,
          pointer: g,
          intersections: l,
          stopped: m.stopped,
          delta: u,
          unprojectedPoint: w,
          ray: x.ray,
          camera: _,
          stopPropagation() {
            const P = "pointerId" in c && y.capturedMap.get(c.pointerId);
            if (
              (!P || P.has(v.eventObject)) &&
              ((R.stopped = m.stopped = !0),
              y.hovered.size &&
                Array.from(y.hovered.values()).find(
                  (F) => F.eventObject === v.eventObject
                ))
            ) {
              const F = l.slice(0, l.indexOf(v));
              o([...F, v]);
            }
          },
          target: {
            hasPointerCapture: A,
            setPointerCapture: M,
            releasePointerCapture: T,
          },
          currentTarget: {
            hasPointerCapture: A,
            setPointerCapture: M,
            releasePointerCapture: T,
          },
          nativeEvent: c,
        };
        if ((d(R), m.stopped === !0)) break;
      }
    }
    return l;
  }
  function o(l) {
    const { internal: c } = t.getState();
    for (const u of c.hovered.values())
      if (
        !l.length ||
        !l.find(
          (d) =>
            d.object === u.object &&
            d.index === u.index &&
            d.instanceId === u.instanceId
        )
      ) {
        const p = u.eventObject.__r3f,
          m = p == null ? void 0 : p.handlers;
        if ((c.hovered.delete(Ov(u)), p != null && p.eventCount)) {
          const v = { ...u, intersections: l };
          m.onPointerOut == null || m.onPointerOut(v),
            m.onPointerLeave == null || m.onPointerLeave(v);
        }
      }
  }
  function a(l, c) {
    for (let u = 0; u < c.length; u++) {
      const d = c[u].__r3f;
      d == null ||
        d.handlers.onPointerMissed == null ||
        d.handlers.onPointerMissed(l);
    }
  }
  function s(l) {
    switch (l) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => o([]);
      case "onLostPointerCapture":
        return (c) => {
          const { internal: u } = t.getState();
          "pointerId" in c &&
            u.capturedMap.has(c.pointerId) &&
            requestAnimationFrame(() => {
              u.capturedMap.has(c.pointerId) &&
                (u.capturedMap.delete(c.pointerId), o([]));
            });
        };
    }
    return function (u) {
      const { onPointerMissed: d, internal: p } = t.getState();
      p.lastEvent.current = u;
      const m = l === "onPointerMove",
        v = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
        x = r(u, m ? n : void 0),
        g = v ? e(u) : 0;
      l === "onPointerDown" &&
        ((p.initialClick = [u.offsetX, u.offsetY]),
        (p.initialHits = x.map((y) => y.eventObject))),
        v && !x.length && g <= 2 && (a(u, p.interaction), d && d(u)),
        m && o(x);
      function _(y) {
        const w = y.eventObject,
          A = w.__r3f,
          M = A == null ? void 0 : A.handlers;
        if (A != null && A.eventCount)
          if (m) {
            if (
              M.onPointerOver ||
              M.onPointerEnter ||
              M.onPointerOut ||
              M.onPointerLeave
            ) {
              const T = Ov(y),
                I = p.hovered.get(T);
              I
                ? I.stopped && y.stopPropagation()
                : (p.hovered.set(T, y),
                  M.onPointerOver == null || M.onPointerOver(y),
                  M.onPointerEnter == null || M.onPointerEnter(y));
            }
            M.onPointerMove == null || M.onPointerMove(y);
          } else {
            const T = M[l];
            T
              ? (!v || p.initialHits.includes(w)) &&
                (a(
                  u,
                  p.interaction.filter((I) => !p.initialHits.includes(I))
                ),
                T(y))
              : v &&
                p.initialHits.includes(w) &&
                a(
                  u,
                  p.interaction.filter((I) => !p.initialHits.includes(I))
                );
          }
      }
      i(x, u, g, _);
    };
  }
  return { handlePointer: s };
}
const pz = (t) => !!(t != null && t.render),
  mz = E.createContext(null),
  J7 = (t, e) => {
    const n = N7((s, l) => {
        const c = new K(),
          u = new K(),
          d = new K();
        function p(g = l().camera, _ = u, y = l().size) {
          const { width: w, height: A, top: M, left: T } = y,
            I = w / A;
          _.isVector3 ? d.copy(_) : d.set(..._);
          const R = g.getWorldPosition(c).distanceTo(d);
          if (sz(g))
            return {
              width: w / g.zoom,
              height: A / g.zoom,
              top: M,
              left: T,
              factor: 1,
              distance: R,
              aspect: I,
            };
          {
            const P = (g.fov * Math.PI) / 180,
              F = 2 * Math.tan(P / 2) * R,
              D = F * (w / A);
            return {
              width: D,
              height: F,
              top: M,
              left: T,
              factor: w / D,
              distance: R,
              aspect: I,
            };
          }
        }
        let m;
        const v = (g) =>
            s((_) => ({ performance: { ..._.performance, current: g } })),
          S = new Ge();
        return {
          set: s,
          get: l,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (g = 1) => t(l(), g),
          advance: (g, _) => e(g, _, l()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new RC(),
          pointer: S,
          mouse: S,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const g = l();
              m && clearTimeout(m),
                g.performance.current !== g.performance.min &&
                  v(g.performance.min),
                (m = setTimeout(
                  () => v(l().performance.max),
                  g.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: p,
          },
          setEvents: (g) => s((_) => ({ ..._, events: { ..._.events, ...g } })),
          setSize: (g, _, y, w, A) => {
            const M = l().camera,
              T = {
                width: g,
                height: _,
                top: w || 0,
                left: A || 0,
                updateStyle: y,
              };
            s((I) => ({ size: T, viewport: { ...I.viewport, ...p(M, u, T) } }));
          },
          setDpr: (g) =>
            s((_) => {
              const y = dz(g);
              return {
                viewport: {
                  ..._.viewport,
                  dpr: y,
                  initialDpr: _.viewport.initialDpr || y,
                },
              };
            }),
          setFrameloop: (g = "always") => {
            const _ = l().clock;
            _.stop(),
              (_.elapsedTime = 0),
              g !== "never" && (_.start(), (_.elapsedTime = 0)),
              s(() => ({ frameloop: g }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: E.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (g, _, y) => {
              const w = l().internal;
              return (
                (w.priority = w.priority + (_ > 0 ? 1 : 0)),
                w.subscribers.push({ ref: g, priority: _, store: y }),
                (w.subscribers = w.subscribers.sort(
                  (A, M) => A.priority - M.priority
                )),
                () => {
                  const A = l().internal;
                  A != null &&
                    A.subscribers &&
                    ((A.priority = A.priority - (_ > 0 ? 1 : 0)),
                    (A.subscribers = A.subscribers.filter((M) => M.ref !== g)));
                }
              );
            },
          },
        };
      }),
      r = n.getState();
    let i = r.size,
      o = r.viewport.dpr,
      a = r.camera;
    return (
      n.subscribe(() => {
        const { camera: s, size: l, viewport: c, gl: u, set: d } = n.getState();
        if (l.width !== i.width || l.height !== i.height || c.dpr !== o) {
          var p;
          (i = l), (o = c.dpr), K7(s, l), u.setPixelRatio(c.dpr);
          const m =
            (p = l.updateStyle) != null
              ? p
              : typeof HTMLCanvasElement < "u" &&
                u.domElement instanceof HTMLCanvasElement;
          u.setSize(l.width, l.height, m);
        }
        s !== a &&
          ((a = s),
          d((m) => ({
            viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(s) },
          })));
      }),
      n.subscribe((s) => t(s)),
      n
    );
  };
let Nv,
  e9 = new Set(),
  t9 = new Set(),
  n9 = new Set();
function d_(t, e) {
  if (t.size) for (const { callback: n } of t.values()) n(e);
}
function _h(t, e) {
  switch (t) {
    case "before":
      return d_(e9, e);
    case "after":
      return d_(t9, e);
    case "tail":
      return d_(n9, e);
  }
}
let f_, h_;
function p_(t, e, n) {
  let r = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof t == "number" &&
      ((r = t - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = t)),
      f_ = e.internal.subscribers,
      Nv = 0;
    Nv < f_.length;
    Nv++
  )
    (h_ = f_[Nv]), h_.ref.current(h_.store.getState(), r, n);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function r9(t) {
  let e = !1,
    n = !1,
    r,
    i,
    o;
  function a(c) {
    (i = requestAnimationFrame(a)),
      (e = !0),
      (r = 0),
      _h("before", c),
      (n = !0);
    for (const d of t.values()) {
      var u;
      (o = d.store.getState()),
        o.internal.active &&
          (o.frameloop === "always" || o.internal.frames > 0) &&
          !((u = o.gl.xr) != null && u.isPresenting) &&
          (r += p_(c, o));
    }
    if (((n = !1), _h("after", c), r === 0))
      return _h("tail", c), (e = !1), cancelAnimationFrame(i);
  }
  function s(c, u = 1) {
    var d;
    if (!c) return t.forEach((p) => s(p.store.getState(), u));
    ((d = c.gl.xr) != null && d.isPresenting) ||
      !c.internal.active ||
      c.frameloop === "never" ||
      (u > 1
        ? (c.internal.frames = Math.min(60, c.internal.frames + u))
        : n
        ? (c.internal.frames = 2)
        : (c.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(a)));
  }
  function l(c, u = !0, d, p) {
    if ((u && _h("before", c), d)) p_(c, d, p);
    else for (const m of t.values()) p_(c, m.store.getState());
    u && _h("after", c);
  }
  return { loop: a, invalidate: s, advance: l };
}
function gz() {
  const t = E.useContext(mz);
  if (!t)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return t;
}
function ga(t = (n) => n, e) {
  return gz()(t, e);
}
function NC(t, e = 0) {
  const n = gz(),
    r = n.getState().internal.subscribe,
    i = lz(t);
  return _m(() => r(i, e, n), [e, r, n]), null;
}
const mf = new Map(),
  { invalidate: KP, advance: YP } = r9(mf),
  { reconciler: py, applyProps: ld } = V7(mf, Y7),
  cd = { objects: "shallow", strict: !1 },
  i9 = (t, e) => {
    const n = typeof t == "function" ? t(e) : t;
    return pz(n)
      ? n
      : new uC({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...t,
        });
  };
function o9(t, e) {
  const n = typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement;
  if (e) {
    const { width: r, height: i, top: o, left: a, updateStyle: s = n } = e;
    return { width: r, height: i, top: o, left: a, updateStyle: s };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    t instanceof HTMLCanvasElement &&
    t.parentElement
  ) {
    const {
      width: r,
      height: i,
      top: o,
      left: a,
    } = t.parentElement.getBoundingClientRect();
    return { width: r, height: i, top: o, left: a, updateStyle: n };
  } else if (typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas)
    return {
      width: t.width,
      height: t.height,
      top: 0,
      left: 0,
      updateStyle: n,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function a9(t) {
  const e = mf.get(t),
    n = e == null ? void 0 : e.fiber,
    r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error,
    o = r || J7(KP, YP),
    a =
      n ||
      py.createContainer(o, Vd.ConcurrentRoot, null, !1, null, "", i, null);
  e || mf.set(t, { fiber: a, store: o });
  let s,
    l = !1,
    c;
  return {
    configure(u = {}) {
      let {
          gl: d,
          size: p,
          scene: m,
          events: v,
          onCreated: S,
          shadows: x = !1,
          linear: g = !1,
          flat: _ = !1,
          legacy: y = !1,
          orthographic: w = !1,
          frameloop: A = "always",
          dpr: M = [1, 2],
          performance: T,
          raycaster: I,
          camera: R,
          onPointerMissed: P,
        } = u,
        F = o.getState(),
        D = F.gl;
      F.gl || F.set({ gl: (D = i9(d, t)) });
      let j = F.raycaster;
      j || F.set({ raycaster: (j = new JD()) });
      const { params: N, ...V } = I || {};
      if (
        (jn.equ(V, j, cd) || ld(j, { ...V }),
        jn.equ(N, j.params, cd) || ld(j, { params: { ...j.params, ...N } }),
        !F.camera || (F.camera === c && !jn.equ(c, R, cd)))
      ) {
        c = R;
        const G = R instanceof pm,
          k = G
            ? R
            : w
            ? new ts(0, 0, 0, 0, 0.1, 1e3)
            : new Zn(75, 0, 0.1, 1e3);
        G ||
          ((k.position.z = 5),
          R &&
            (ld(k, R),
            ("aspect" in R ||
              "left" in R ||
              "right" in R ||
              "bottom" in R ||
              "top" in R) &&
              ((k.manual = !0), k.updateProjectionMatrix())),
          !F.camera && !(R != null && R.rotation) && k.lookAt(0, 0, 0)),
          F.set({ camera: k }),
          (j.camera = k);
      }
      if (!F.scene) {
        let G;
        m != null && m.isScene ? (G = m) : ((G = new dC()), m && ld(G, m)),
          F.set({ scene: bd(G) });
      }
      if (!F.xr) {
        var W;
        const G = (X, ee) => {
            const J = o.getState();
            J.frameloop !== "never" && YP(X, !0, J, ee);
          },
          k = () => {
            const X = o.getState();
            (X.gl.xr.enabled = X.gl.xr.isPresenting),
              X.gl.xr.setAnimationLoop(X.gl.xr.isPresenting ? G : null),
              X.gl.xr.isPresenting || KP(X);
          },
          q = {
            connect() {
              const X = o.getState().gl;
              X.xr.addEventListener("sessionstart", k),
                X.xr.addEventListener("sessionend", k);
            },
            disconnect() {
              const X = o.getState().gl;
              X.xr.removeEventListener("sessionstart", k),
                X.xr.removeEventListener("sessionend", k);
            },
          };
        typeof ((W = D.xr) == null ? void 0 : W.addEventListener) ==
          "function" && q.connect(),
          F.set({ xr: q });
      }
      if (D.shadowMap) {
        const G = D.shadowMap.enabled,
          k = D.shadowMap.type;
        if (((D.shadowMap.enabled = !!x), jn.boo(x))) D.shadowMap.type = Kh;
        else if (jn.str(x)) {
          var Q;
          const q = { basic: WN, percentage: Zy, soft: Kh, variance: ma };
          D.shadowMap.type = (Q = q[x]) != null ? Q : Kh;
        } else jn.obj(x) && Object.assign(D.shadowMap, x);
        (G !== D.shadowMap.enabled || k !== D.shadowMap.type) &&
          (D.shadowMap.needsUpdate = !0);
      }
      const B = az();
      B &&
        ("enabled" in B
          ? (B.enabled = !y)
          : "legacyMode" in B && (B.legacyMode = y)),
        l ||
          ld(D, { outputEncoding: g ? 3e3 : 3001, toneMapping: _ ? Ja : $M }),
        F.legacy !== y && F.set(() => ({ legacy: y })),
        F.linear !== g && F.set(() => ({ linear: g })),
        F.flat !== _ && F.set(() => ({ flat: _ })),
        d && !jn.fun(d) && !pz(d) && !jn.equ(d, D, cd) && ld(D, d),
        v && !F.events.handlers && F.set({ events: v(o) });
      const $ = o9(t, p);
      return (
        jn.equ($, F.size, cd) ||
          F.setSize($.width, $.height, $.updateStyle, $.top, $.left),
        M && F.viewport.dpr !== dz(M) && F.setDpr(M),
        F.frameloop !== A && F.setFrameloop(A),
        F.onPointerMissed || F.set({ onPointerMissed: P }),
        T &&
          !jn.equ(T, F.performance, cd) &&
          F.set((G) => ({ performance: { ...G.performance, ...T } })),
        (s = S),
        (l = !0),
        this
      );
    },
    render(u) {
      return (
        l || this.configure(),
        py.updateContainer(
          L.jsx(s9, { store: o, children: u, onCreated: s, rootElement: t }),
          a,
          null,
          () => {}
        ),
        o
      );
    },
    unmount() {
      vz(t);
    },
  };
}
function s9({ store: t, children: e, onCreated: n, rootElement: r }) {
  return (
    _m(() => {
      const i = t.getState();
      i.set((o) => ({ internal: { ...o.internal, active: !0 } })),
        n && n(i),
        t.getState().events.connected ||
          i.events.connect == null ||
          i.events.connect(r);
    }, []),
    L.jsx(mz.Provider, { value: t, children: e })
  );
}
function vz(t, e) {
  const n = mf.get(t),
    r = n == null ? void 0 : n.fiber;
  if (r) {
    const i = n == null ? void 0 : n.store.getState();
    i && (i.internal.active = !1),
      py.updateContainer(null, r, null, () => {
        i &&
          setTimeout(() => {
            try {
              var o, a, s, l;
              i.events.disconnect == null || i.events.disconnect(),
                (o = i.gl) == null ||
                  (a = o.renderLists) == null ||
                  a.dispose == null ||
                  a.dispose(),
                (s = i.gl) == null ||
                  s.forceContextLoss == null ||
                  s.forceContextLoss(),
                (l = i.gl) != null && l.xr && i.xr.disconnect(),
                X7(i),
                mf.delete(t),
                e && e(t);
            } catch {}
          }, 500);
      });
  }
}
py.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: E.version,
});
const m_ = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function l9(t) {
  const { handlePointer: e } = Q7(t);
  return {
    priority: 1,
    enabled: !0,
    compute(n, r, i) {
      r.pointer.set(
        (n.offsetX / r.size.width) * 2 - 1,
        -(n.offsetY / r.size.height) * 2 + 1
      ),
        r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(m_).reduce((n, r) => ({ ...n, [r]: e(r) }), {}),
    update: () => {
      var n;
      const { events: r, internal: i } = t.getState();
      (n = i.lastEvent) != null &&
        n.current &&
        r.handlers &&
        r.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (n) => {
      var r;
      const { set: i, events: o } = t.getState();
      o.disconnect == null || o.disconnect(),
        i((a) => ({ events: { ...a.events, connected: n } })),
        Object.entries((r = o.handlers) != null ? r : []).forEach(([a, s]) => {
          const [l, c] = m_[a];
          n.addEventListener(l, s, { passive: c });
        });
    },
    disconnect: () => {
      const { set: n, events: r } = t.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([o, a]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [s] = m_[o];
            r.connected.removeEventListener(s, a);
          }
        }),
          n((o) => ({ events: { ...o.events, connected: void 0 } }));
      }
    },
  };
}
function ZP(t, e) {
  let n;
  return (...r) => {
    window.clearTimeout(n), (n = window.setTimeout(() => t(...r), e));
  };
}
function c9(
  { debounce: t, scroll: e, polyfill: n, offsetSize: r } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  }
) {
  const i = n || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!i)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [o, a] = E.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    s = E.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
      orientationHandler: null,
    }),
    l = t ? (typeof t == "number" ? t : t.scroll) : null,
    c = t ? (typeof t == "number" ? t : t.resize) : null,
    u = E.useRef(!1);
  E.useEffect(() => ((u.current = !0), () => void (u.current = !1)));
  const [d, p, m] = E.useMemo(() => {
    const g = () => {
      if (!s.current.element) return;
      const {
          left: _,
          top: y,
          width: w,
          height: A,
          bottom: M,
          right: T,
          x: I,
          y: R,
        } = s.current.element.getBoundingClientRect(),
        P = {
          left: _,
          top: y,
          width: w,
          height: A,
          bottom: M,
          right: T,
          x: I,
          y: R,
        };
      s.current.element instanceof HTMLElement &&
        r &&
        ((P.height = s.current.element.offsetHeight),
        (P.width = s.current.element.offsetWidth)),
        Object.freeze(P),
        u.current &&
          !h9(s.current.lastBounds, P) &&
          a((s.current.lastBounds = P));
    };
    return [g, c ? ZP(g, c) : g, l ? ZP(g, l) : g];
  }, [a, r, l, c]);
  function v() {
    s.current.scrollContainers &&
      (s.current.scrollContainers.forEach((g) =>
        g.removeEventListener("scroll", m, !0)
      ),
      (s.current.scrollContainers = null)),
      s.current.resizeObserver &&
        (s.current.resizeObserver.disconnect(),
        (s.current.resizeObserver = null)),
      s.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              s.current.orientationHandler
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              s.current.orientationHandler
            ));
  }
  function S() {
    s.current.element &&
      ((s.current.resizeObserver = new i(m)),
      s.current.resizeObserver.observe(s.current.element),
      e &&
        s.current.scrollContainers &&
        s.current.scrollContainers.forEach((g) =>
          g.addEventListener("scroll", m, { capture: !0, passive: !0 })
        ),
      (s.current.orientationHandler = () => {
        m();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            s.current.orientationHandler
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            s.current.orientationHandler
          ));
  }
  const x = (g) => {
    !g ||
      g === s.current.element ||
      (v(), (s.current.element = g), (s.current.scrollContainers = yz(g)), S());
  };
  return (
    d9(m, !!e),
    u9(p),
    E.useEffect(() => {
      v(), S();
    }, [e, m, p]),
    E.useEffect(() => v, []),
    [x, o, d]
  );
}
function u9(t) {
  E.useEffect(() => {
    const e = t;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [t]);
}
function d9(t, e) {
  E.useEffect(() => {
    if (e) {
      const n = t;
      return (
        window.addEventListener("scroll", n, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", n, !0)
      );
    }
  }, [t, e]);
}
function yz(t) {
  const e = [];
  if (!t || t === document.body) return e;
  const {
    overflow: n,
    overflowX: r,
    overflowY: i,
  } = window.getComputedStyle(t);
  return (
    [n, r, i].some((o) => o === "auto" || o === "scroll") && e.push(t),
    [...e, ...yz(t.parentElement)]
  );
}
const f9 = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  h9 = (t, e) => f9.every((n) => t[n] === e[n]);
var p9 = Object.defineProperty,
  m9 = Object.defineProperties,
  g9 = Object.getOwnPropertyDescriptors,
  QP = Object.getOwnPropertySymbols,
  v9 = Object.prototype.hasOwnProperty,
  y9 = Object.prototype.propertyIsEnumerable,
  JP = (t, e, n) =>
    e in t
      ? p9(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  e3 = (t, e) => {
    for (var n in e || (e = {})) v9.call(e, n) && JP(t, n, e[n]);
    if (QP) for (var n of QP(e)) y9.call(e, n) && JP(t, n, e[n]);
    return t;
  },
  x9 = (t, e) => m9(t, g9(e));
function xz(t, e, n) {
  if (!t) return;
  if (n(t) === !0) return t;
  let r = e ? t.return : t.child;
  for (; r; ) {
    const i = xz(r, e, n);
    if (i) return i;
    r = e ? null : r.sibling;
  }
}
function Sz(t) {
  try {
    return Object.defineProperties(t, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return t;
  }
}
const FC = Sz(E.createContext(null));
class _z extends E.Component {
  render() {
    return E.createElement(
      FC.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
const { ReactCurrentOwner: t3, ReactCurrentDispatcher: n3 } =
  E.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function S9() {
  const t = E.useContext(FC);
  if (t === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = E.useId();
  return E.useMemo(() => {
    for (const r of [
      t3 == null ? void 0 : t3.current,
      t,
      t == null ? void 0 : t.alternate,
    ]) {
      if (!r) continue;
      const i = xz(r, !1, (o) => {
        let a = o.memoizedState;
        for (; a; ) {
          if (a.memoizedState === e) return !0;
          a = a.next;
        }
      });
      if (i) return i;
    }
  }, [t, e]);
}
function _9() {
  var t, e;
  const n = S9(),
    [r] = E.useState(() => new Map());
  r.clear();
  let i = n;
  for (; i; ) {
    const o = (t = i.type) == null ? void 0 : t._context;
    o &&
      o !== FC &&
      !r.has(o) &&
      r.set(
        o,
        (e = n3 == null ? void 0 : n3.current) == null
          ? void 0
          : e.readContext(Sz(o))
      ),
      (i = i.return);
  }
  return r;
}
function b9() {
  const t = _9();
  return E.useMemo(
    () =>
      Array.from(t.keys()).reduce(
        (e, n) => (r) =>
          E.createElement(
            e,
            null,
            E.createElement(n.Provider, x9(e3({}, r), { value: t.get(n) }))
          ),
        (e) => E.createElement(_z, e3({}, e))
      ),
    [t]
  );
}
const w9 = E.forwardRef(function (
    {
      children: e,
      fallback: n,
      resize: r,
      style: i,
      gl: o,
      events: a = l9,
      eventSource: s,
      eventPrefix: l,
      shadows: c,
      linear: u,
      flat: d,
      legacy: p,
      orthographic: m,
      frameloop: v,
      dpr: S,
      performance: x,
      raycaster: g,
      camera: _,
      scene: y,
      onPointerMissed: w,
      onCreated: A,
      ...M
    },
    T
  ) {
    E.useMemo(() => j7(I7), []);
    const I = b9(),
      [R, P] = c9({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }),
      F = E.useRef(null),
      D = E.useRef(null);
    E.useImperativeHandle(T, () => F.current);
    const j = lz(w),
      [N, V] = E.useState(!1),
      [W, Q] = E.useState(!1);
    if (N) throw N;
    if (W) throw W;
    const B = E.useRef(null);
    _m(() => {
      const G = F.current;
      P.width > 0 &&
        P.height > 0 &&
        G &&
        (B.current || (B.current = a9(G)),
        B.current.configure({
          gl: o,
          events: a,
          shadows: c,
          linear: u,
          flat: d,
          legacy: p,
          orthographic: m,
          frameloop: v,
          dpr: S,
          performance: x,
          raycaster: g,
          camera: _,
          scene: y,
          size: P,
          onPointerMissed: (...k) =>
            j.current == null ? void 0 : j.current(...k),
          onCreated: (k) => {
            k.events.connect == null ||
              k.events.connect(s ? ($7(s) ? s.current : s) : D.current),
              l &&
                k.setEvents({
                  compute: (q, X) => {
                    const ee = q[l + "X"],
                      J = q[l + "Y"];
                    X.pointer.set(
                      (ee / X.size.width) * 2 - 1,
                      -(J / X.size.height) * 2 + 1
                    ),
                      X.raycaster.setFromCamera(X.pointer, X.camera);
                  },
                }),
              A == null || A(k);
          },
        }),
        B.current.render(
          L.jsx(I, {
            children: L.jsx(cz, {
              set: Q,
              children: L.jsx(E.Suspense, {
                fallback: L.jsx(G7, { set: V }),
                children: e ?? null,
              }),
            }),
          })
        ));
    }),
      E.useEffect(() => {
        const G = F.current;
        if (G) return () => vz(G);
      }, []);
    const $ = s ? "none" : "auto";
    return L.jsx("div", {
      ref: D,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        pointerEvents: $,
        ...i,
      },
      ...M,
      children: L.jsx("div", {
        ref: R,
        style: { width: "100%", height: "100%" },
        children: L.jsx("canvas", {
          ref: F,
          style: { display: "block" },
          children: n,
        }),
      }),
    });
  }),
  E9 = E.forwardRef(function (e, n) {
    return L.jsx(_z, { children: L.jsx(w9, { ...e, ref: n }) });
  });
var bz = { exports: {} },
  wz = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var bm = E;
function M9(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var C9 = typeof Object.is == "function" ? Object.is : M9,
  T9 = bm.useSyncExternalStore,
  A9 = bm.useRef,
  R9 = bm.useEffect,
  P9 = bm.useMemo,
  I9 = bm.useDebugValue;
wz.useSyncExternalStoreWithSelector = function (t, e, n, r, i) {
  var o = A9(null);
  if (o.current === null) {
    var a = { hasValue: !1, value: null };
    o.current = a;
  } else a = o.current;
  o = P9(
    function () {
      function l(m) {
        if (!c) {
          if (((c = !0), (u = m), (m = r(m)), i !== void 0 && a.hasValue)) {
            var v = a.value;
            if (i(v, m)) return (d = v);
          }
          return (d = m);
        }
        if (((v = d), C9(u, m))) return v;
        var S = r(m);
        return i !== void 0 && i(v, S) ? v : ((u = m), (d = S));
      }
      var c = !1,
        u,
        d,
        p = n === void 0 ? null : n;
      return [
        function () {
          return l(e());
        },
        p === null
          ? void 0
          : function () {
              return l(p());
            },
      ];
    },
    [e, n, r, i]
  );
  var s = T9(t, o[0], o[1]);
  return (
    R9(
      function () {
        (a.hasValue = !0), (a.value = s);
      },
      [s]
    ),
    I9(s),
    s
  );
};
bz.exports = wz;
var L9 = bz.exports,
  Eo = "default" in ru ? at : ru,
  r3 = Symbol.for("react-redux-context"),
  i3 = typeof globalThis < "u" ? globalThis : {};
function O9() {
  if (!Eo.createContext) return {};
  const t = i3[r3] ?? (i3[r3] = new Map());
  let e = t.get(Eo.createContext);
  return e || ((e = Eo.createContext(null)), t.set(Eo.createContext, e)), e;
}
var Vl = O9(),
  N9 = () => {
    throw new Error("uSES not initialized!");
  };
function DC(t = Vl) {
  return function () {
    return Eo.useContext(t);
  };
}
var Ez = DC(),
  Mz = N9,
  F9 = (t) => {
    Mz = t;
  },
  D9 = (t, e) => t === e;
function z9(t = Vl) {
  const e = t === Vl ? Ez : DC(t),
    n = (r, i = {}) => {
      const { equalityFn: o = D9, devModeChecks: a = {} } =
          typeof i == "function" ? { equalityFn: i } : i,
        {
          store: s,
          subscription: l,
          getServerState: c,
          stabilityCheck: u,
          identityFunctionCheck: d,
        } = e();
      Eo.useRef(!0);
      const p = Eo.useCallback(
          {
            [r.name](v) {
              return r(v);
            },
          }[r.name],
          [r, u, a.stabilityCheck]
        ),
        m = Mz(l.addNestedSub, s.getState, c || s.getState, p, o);
      return Eo.useDebugValue(m), m;
    };
  return Object.assign(n, { withTypes: () => n }), n;
}
var oa = z9();
function U9(t) {
  t();
}
function k9() {
  let t = null,
    e = null;
  return {
    clear() {
      (t = null), (e = null);
    },
    notify() {
      U9(() => {
        let n = t;
        for (; n; ) n.callback(), (n = n.next);
      });
    },
    get() {
      const n = [];
      let r = t;
      for (; r; ) n.push(r), (r = r.next);
      return n;
    },
    subscribe(n) {
      let r = !0;
      const i = (e = { callback: n, next: null, prev: e });
      return (
        i.prev ? (i.prev.next = i) : (t = i),
        function () {
          !r ||
            t === null ||
            ((r = !1),
            i.next ? (i.next.prev = i.prev) : (e = i.prev),
            i.prev ? (i.prev.next = i.next) : (t = i.next));
        }
      );
    },
  };
}
var o3 = { notify() {}, get: () => [] };
function B9(t, e) {
  let n,
    r = o3,
    i = 0,
    o = !1;
  function a(S) {
    u();
    const x = r.subscribe(S);
    let g = !1;
    return () => {
      g || ((g = !0), x(), d());
    };
  }
  function s() {
    r.notify();
  }
  function l() {
    v.onStateChange && v.onStateChange();
  }
  function c() {
    return o;
  }
  function u() {
    i++, n || ((n = e ? e.addNestedSub(l) : t.subscribe(l)), (r = k9()));
  }
  function d() {
    i--, n && i === 0 && (n(), (n = void 0), r.clear(), (r = o3));
  }
  function p() {
    o || ((o = !0), u());
  }
  function m() {
    o && ((o = !1), d());
  }
  const v = {
    addNestedSub: a,
    notifyNestedSubs: s,
    handleChangeWrapper: l,
    isSubscribed: c,
    trySubscribe: p,
    tryUnsubscribe: m,
    getListeners: () => r,
  };
  return v;
}
var H9 =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  j9 = H9 ? Eo.useLayoutEffect : Eo.useEffect;
function V9({
  store: t,
  context: e,
  children: n,
  serverState: r,
  stabilityCheck: i = "once",
  identityFunctionCheck: o = "once",
}) {
  const a = Eo.useMemo(() => {
      const c = B9(t);
      return {
        store: t,
        subscription: c,
        getServerState: r ? () => r : void 0,
        stabilityCheck: i,
        identityFunctionCheck: o,
      };
    }, [t, r, i, o]),
    s = Eo.useMemo(() => t.getState(), [t]);
  j9(() => {
    const { subscription: c } = a;
    return (
      (c.onStateChange = c.notifyNestedSubs),
      c.trySubscribe(),
      s !== t.getState() && c.notifyNestedSubs(),
      () => {
        c.tryUnsubscribe(), (c.onStateChange = void 0);
      }
    );
  }, [a, s]);
  const l = e || Vl;
  return Eo.createElement(l.Provider, { value: a }, n);
}
var $9 = V9;
function Cz(t = Vl) {
  const e = t === Vl ? Ez : DC(t),
    n = () => {
      const { store: r } = e();
      return r;
    };
  return Object.assign(n, { withTypes: () => n }), n;
}
var G9 = Cz();
function W9(t = Vl) {
  const e = t === Vl ? G9 : Cz(t),
    n = () => e().dispatch;
  return Object.assign(n, { withTypes: () => n }), n;
}
var Fa = W9();
F9(L9.useSyncExternalStoreWithSelector);
function Et() {
  return (
    (Et = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Et.apply(null, arguments)
  );
}
const wm = new K(),
  zC = new K(),
  X9 = new K(),
  a3 = new Ge();
function q9(t, e, n) {
  const r = wm.setFromMatrixPosition(t.matrixWorld);
  r.project(e);
  const i = n.width / 2,
    o = n.height / 2;
  return [r.x * i + i, -(r.y * o) + o];
}
function K9(t, e) {
  const n = wm.setFromMatrixPosition(t.matrixWorld),
    r = zC.setFromMatrixPosition(e.matrixWorld),
    i = n.sub(r),
    o = e.getWorldDirection(X9);
  return i.angleTo(o) > Math.PI / 2;
}
function Y9(t, e, n, r) {
  const i = wm.setFromMatrixPosition(t.matrixWorld),
    o = i.clone();
  o.project(e), a3.set(o.x, o.y), n.setFromCamera(a3, e);
  const a = n.intersectObjects(r, !0);
  if (a.length) {
    const s = a[0].distance;
    return i.distanceTo(n.ray.origin) < s;
  }
  return !0;
}
function Z9(t, e) {
  if (e instanceof ts) return e.zoom;
  if (e instanceof Zn) {
    const n = wm.setFromMatrixPosition(t.matrixWorld),
      r = zC.setFromMatrixPosition(e.matrixWorld),
      i = (e.fov * Math.PI) / 180,
      o = n.distanceTo(r);
    return 1 / (2 * Math.tan(i / 2) * o);
  } else return 1;
}
function Q9(t, e, n) {
  if (e instanceof Zn || e instanceof ts) {
    const r = wm.setFromMatrixPosition(t.matrixWorld),
      i = zC.setFromMatrixPosition(e.matrixWorld),
      o = r.distanceTo(i),
      a = (n[1] - n[0]) / (e.far - e.near),
      s = n[1] - a * e.far;
    return Math.round(a * o + s);
  }
}
const $w = (t) => (Math.abs(t) < 1e-10 ? 0 : t);
function Tz(t, e, n = "") {
  let r = "matrix3d(";
  for (let i = 0; i !== 16; i++)
    r += $w(e[i] * t.elements[i]) + (i !== 15 ? "," : ")");
  return n + r;
}
const J9 = (
    (t) => (e) =>
      Tz(e, t)
  )([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
  eX = (
    (t) => (e, n) =>
      Tz(e, t(n), "translate(-50%,-50%)")
  )((t) => [
    1 / t,
    1 / t,
    1 / t,
    1,
    -1 / t,
    -1 / t,
    -1 / t,
    -1,
    1 / t,
    1 / t,
    1 / t,
    1,
    1,
    1,
    1,
    1,
  ]);
function tX(t) {
  return t && typeof t == "object" && "current" in t;
}
const bl = E.forwardRef(
    (
      {
        children: t,
        eps: e = 0.001,
        style: n,
        className: r,
        prepend: i,
        center: o,
        fullscreen: a,
        portal: s,
        distanceFactor: l,
        sprite: c = !1,
        transform: u = !1,
        occlude: d,
        onOcclude: p,
        castShadow: m,
        receiveShadow: v,
        material: S,
        geometry: x,
        zIndexRange: g = [16777271, 0],
        calculatePosition: _ = q9,
        as: y = "div",
        wrapperClass: w,
        pointerEvents: A = "auto",
        ...M
      },
      T
    ) => {
      const {
          gl: I,
          camera: R,
          scene: P,
          size: F,
          raycaster: D,
          events: j,
          viewport: N,
        } = ga(),
        [V] = E.useState(() => document.createElement(y)),
        W = E.useRef(),
        Q = E.useRef(null),
        B = E.useRef(0),
        $ = E.useRef([0, 0]),
        G = E.useRef(null),
        k = E.useRef(null),
        q =
          (s == null ? void 0 : s.current) ||
          j.connected ||
          I.domElement.parentNode,
        X = E.useRef(null),
        ee = E.useRef(!1),
        J = E.useMemo(
          () =>
            (d && d !== "blending") ||
            (Array.isArray(d) && d.length && tX(d[0])),
          [d]
        );
      E.useLayoutEffect(() => {
        const me = I.domElement;
        d && d === "blending"
          ? ((me.style.zIndex = `${Math.floor(g[0] / 2)}`),
            (me.style.position = "absolute"),
            (me.style.pointerEvents = "none"))
          : ((me.style.zIndex = null),
            (me.style.position = null),
            (me.style.pointerEvents = null));
      }, [d]),
        E.useLayoutEffect(() => {
          if (Q.current) {
            const me = (W.current = VN(V));
            if ((P.updateMatrixWorld(), u))
              V.style.cssText =
                "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
            else {
              const se = _(Q.current, R, F);
              V.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${se[0]}px,${se[1]}px,0);transform-origin:0 0;`;
            }
            return (
              q && (i ? q.prepend(V) : q.appendChild(V)),
              () => {
                q && q.removeChild(V), me.unmount();
              }
            );
          }
        }, [q, u]),
        E.useLayoutEffect(() => {
          w && (V.className = w);
        }, [w]);
      const oe = E.useMemo(
          () =>
            u
              ? {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: F.width,
                  height: F.height,
                  transformStyle: "preserve-3d",
                  pointerEvents: "none",
                }
              : {
                  position: "absolute",
                  transform: o ? "translate3d(-50%,-50%,0)" : "none",
                  ...(a && {
                    top: -F.height / 2,
                    left: -F.width / 2,
                    width: F.width,
                    height: F.height,
                  }),
                  ...n,
                },
          [n, o, a, F, u]
        ),
        ae = E.useMemo(() => ({ position: "absolute", pointerEvents: A }), [A]);
      E.useLayoutEffect(() => {
        if (((ee.current = !1), u)) {
          var me;
          (me = W.current) == null ||
            me.render(
              E.createElement(
                "div",
                { ref: G, style: oe },
                E.createElement(
                  "div",
                  { ref: k, style: ae },
                  E.createElement("div", {
                    ref: T,
                    className: r,
                    style: n,
                    children: t,
                  })
                )
              )
            );
        } else {
          var se;
          (se = W.current) == null ||
            se.render(
              E.createElement("div", {
                ref: T,
                style: oe,
                className: r,
                children: t,
              })
            );
        }
      });
      const le = E.useRef(!0);
      NC((me) => {
        if (Q.current) {
          R.updateMatrixWorld(), Q.current.updateWorldMatrix(!0, !1);
          const se = u ? $.current : _(Q.current, R, F);
          if (
            u ||
            Math.abs(B.current - R.zoom) > e ||
            Math.abs($.current[0] - se[0]) > e ||
            Math.abs($.current[1] - se[1]) > e
          ) {
            const Y = K9(Q.current, R);
            let ve = !1;
            J &&
              (Array.isArray(d)
                ? (ve = d.map((Te) => Te.current))
                : d !== "blending" && (ve = [P]));
            const de = le.current;
            if (ve) {
              const Te = Y9(Q.current, R, D, ve);
              le.current = Te && !Y;
            } else le.current = !Y;
            de !== le.current &&
              (p
                ? p(!le.current)
                : (V.style.display = le.current ? "block" : "none"));
            const ue = Math.floor(g[0] / 2),
              fe = d ? (J ? [g[0], ue] : [ue - 1, 0]) : g;
            if (((V.style.zIndex = `${Q9(Q.current, R, fe)}`), u)) {
              const [Te, pe] = [F.width / 2, F.height / 2],
                H = R.projectionMatrix.elements[5] * pe,
                {
                  isOrthographicCamera: z,
                  top: Z,
                  left: ge,
                  bottom: ce,
                  right: he,
                } = R,
                Me = J9(R.matrixWorldInverse),
                Re = z
                  ? `scale(${H})translate(${$w(-(he + ge) / 2)}px,${$w(
                      (Z + ce) / 2
                    )}px)`
                  : `translateZ(${H}px)`;
              let Le = Q.current.matrixWorld;
              c &&
                ((Le = R.matrixWorldInverse
                  .clone()
                  .transpose()
                  .copyPosition(Le)
                  .scale(Q.current.scale)),
                (Le.elements[3] = Le.elements[7] = Le.elements[11] = 0),
                (Le.elements[15] = 1)),
                (V.style.width = F.width + "px"),
                (V.style.height = F.height + "px"),
                (V.style.perspective = z ? "" : `${H}px`),
                G.current &&
                  k.current &&
                  ((G.current.style.transform = `${Re}${Me}translate(${Te}px,${pe}px)`),
                  (k.current.style.transform = eX(Le, 1 / ((l || 10) / 400))));
            } else {
              const Te = l === void 0 ? 1 : Z9(Q.current, R) * l;
              V.style.transform = `translate3d(${se[0]}px,${se[1]}px,0) scale(${Te})`;
            }
            ($.current = se), (B.current = R.zoom);
          }
        }
        if (!J && X.current && !ee.current)
          if (u) {
            if (G.current) {
              const se = G.current.children[0];
              if (
                se != null &&
                se.clientWidth &&
                se != null &&
                se.clientHeight
              ) {
                const { isOrthographicCamera: Y } = R;
                if (Y || x)
                  M.scale &&
                    (Array.isArray(M.scale)
                      ? M.scale instanceof K
                        ? X.current.scale.copy(M.scale.clone().divideScalar(1))
                        : X.current.scale.set(
                            1 / M.scale[0],
                            1 / M.scale[1],
                            1 / M.scale[2]
                          )
                      : X.current.scale.setScalar(1 / M.scale));
                else {
                  const ve = (l || 10) / 400,
                    de = se.clientWidth * ve,
                    ue = se.clientHeight * ve;
                  X.current.scale.set(de, ue, 1);
                }
                ee.current = !0;
              }
            }
          } else {
            const se = V.children[0];
            if (se != null && se.clientWidth && se != null && se.clientHeight) {
              const Y = 1 / N.factor,
                ve = se.clientWidth * Y,
                de = se.clientHeight * Y;
              X.current.scale.set(ve, de, 1), (ee.current = !0);
            }
            X.current.lookAt(me.camera.position);
          }
      });
      const _e = E.useMemo(
        () => ({
          vertexShader: u
            ? void 0
            : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
          fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `,
        }),
        [u]
      );
      return E.createElement(
        "group",
        Et({}, M, { ref: Q }),
        d &&
          !J &&
          E.createElement(
            "mesh",
            { castShadow: m, receiveShadow: v, ref: X },
            x || E.createElement("planeGeometry", null),
            S ||
              E.createElement("shaderMaterial", {
                side: Zo,
                vertexShader: _e.vertexShader,
                fragmentShader: _e.fragmentShader,
              })
          )
      );
    }
  ),
  Az = parseInt(um.replace(/\D+/g, "")),
  Rz = Az >= 125 ? "uv1" : "uv2";
function nX(t, e = Math.PI / 3) {
  const n = Math.cos(e),
    r = (1 + 1e-10) * 100,
    i = [new K(), new K(), new K()],
    o = new K(),
    a = new K(),
    s = new K(),
    l = new K();
  function c(S) {
    const x = ~~(S.x * r),
      g = ~~(S.y * r),
      _ = ~~(S.z * r);
    return `${x},${g},${_}`;
  }
  const u = t.index ? t.toNonIndexed() : t,
    d = u.attributes.position,
    p = {};
  for (let S = 0, x = d.count / 3; S < x; S++) {
    const g = 3 * S,
      _ = i[0].fromBufferAttribute(d, g + 0),
      y = i[1].fromBufferAttribute(d, g + 1),
      w = i[2].fromBufferAttribute(d, g + 2);
    o.subVectors(w, y), a.subVectors(_, y);
    const A = new K().crossVectors(o, a).normalize();
    for (let M = 0; M < 3; M++) {
      const T = i[M],
        I = c(T);
      I in p || (p[I] = []), p[I].push(A);
    }
  }
  const m = new Float32Array(d.count * 3),
    v = new wn(m, 3, !1);
  for (let S = 0, x = d.count / 3; S < x; S++) {
    const g = 3 * S,
      _ = i[0].fromBufferAttribute(d, g + 0),
      y = i[1].fromBufferAttribute(d, g + 1),
      w = i[2].fromBufferAttribute(d, g + 2);
    o.subVectors(w, y), a.subVectors(_, y), s.crossVectors(o, a).normalize();
    for (let A = 0; A < 3; A++) {
      const M = i[A],
        T = c(M),
        I = p[T];
      l.set(0, 0, 0);
      for (let R = 0, P = I.length; R < P; R++) {
        const F = I[R];
        s.dot(F) > n && l.add(F);
      }
      l.normalize(), v.setXYZ(g + A, l.x, l.y, l.z);
    }
  }
  return u.setAttribute("normal", v), u;
}
var rX = Object.defineProperty,
  iX = (t, e, n) =>
    e in t
      ? rX(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  oX = (t, e, n) => (iX(t, typeof e != "symbol" ? e + "" : e, n), n);
class aX {
  constructor() {
    oX(this, "_listeners");
  }
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(n);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, a = i.length; o < a; o++) i[o].call(this, e);
      e.target = null;
    }
  }
}
var sX = Object.defineProperty,
  lX = (t, e, n) =>
    e in t
      ? sX(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Ft = (t, e, n) => (lX(t, typeof e != "symbol" ? e + "" : e, n), n);
const Fv = new yu(),
  s3 = new Ts(),
  cX = Math.cos(70 * (Math.PI / 180)),
  l3 = (t, e) => ((t % e) + e) % e;
let uX = class extends aX {
  constructor(e, n) {
    super(),
      Ft(this, "object"),
      Ft(this, "domElement"),
      Ft(this, "enabled", !0),
      Ft(this, "target", new K()),
      Ft(this, "minDistance", 0),
      Ft(this, "maxDistance", 1 / 0),
      Ft(this, "minZoom", 0),
      Ft(this, "maxZoom", 1 / 0),
      Ft(this, "minPolarAngle", 0),
      Ft(this, "maxPolarAngle", Math.PI),
      Ft(this, "minAzimuthAngle", -1 / 0),
      Ft(this, "maxAzimuthAngle", 1 / 0),
      Ft(this, "enableDamping", !1),
      Ft(this, "dampingFactor", 0.05),
      Ft(this, "enableZoom", !0),
      Ft(this, "zoomSpeed", 1),
      Ft(this, "enableRotate", !0),
      Ft(this, "rotateSpeed", 1),
      Ft(this, "enablePan", !0),
      Ft(this, "panSpeed", 1),
      Ft(this, "screenSpacePanning", !0),
      Ft(this, "keyPanSpeed", 7),
      Ft(this, "zoomToCursor", !1),
      Ft(this, "autoRotate", !1),
      Ft(this, "autoRotateSpeed", 2),
      Ft(this, "reverseOrbit", !1),
      Ft(this, "reverseHorizontalOrbit", !1),
      Ft(this, "reverseVerticalOrbit", !1),
      Ft(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      Ft(this, "mouseButtons", {
        LEFT: Tc.ROTATE,
        MIDDLE: Tc.DOLLY,
        RIGHT: Tc.PAN,
      }),
      Ft(this, "touches", { ONE: Ac.ROTATE, TWO: Ac.DOLLY_PAN }),
      Ft(this, "target0"),
      Ft(this, "position0"),
      Ft(this, "zoom0"),
      Ft(this, "_domElementKeyEvents", null),
      Ft(this, "getPolarAngle"),
      Ft(this, "getAzimuthalAngle"),
      Ft(this, "setPolarAngle"),
      Ft(this, "setAzimuthalAngle"),
      Ft(this, "getDistance"),
      Ft(this, "getZoomScale"),
      Ft(this, "listenToKeyEvents"),
      Ft(this, "stopListenToKeyEvents"),
      Ft(this, "saveState"),
      Ft(this, "reset"),
      Ft(this, "update"),
      Ft(this, "connect"),
      Ft(this, "dispose"),
      Ft(this, "dollyIn"),
      Ft(this, "dollyOut"),
      Ft(this, "getScale"),
      Ft(this, "setScale"),
      (this.object = e),
      (this.domElement = n),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => u.phi),
      (this.getAzimuthalAngle = () => u.theta),
      (this.setPolarAngle = (ne) => {
        let Ie = l3(ne, 2 * Math.PI),
          et = u.phi;
        et < 0 && (et += 2 * Math.PI), Ie < 0 && (Ie += 2 * Math.PI);
        let We = Math.abs(Ie - et);
        2 * Math.PI - We < We &&
          (Ie < et ? (Ie += 2 * Math.PI) : (et += 2 * Math.PI)),
          (d.phi = Ie - et),
          r.update();
      }),
      (this.setAzimuthalAngle = (ne) => {
        let Ie = l3(ne, 2 * Math.PI),
          et = u.theta;
        et < 0 && (et += 2 * Math.PI), Ie < 0 && (Ie += 2 * Math.PI);
        let We = Math.abs(Ie - et);
        2 * Math.PI - We < We &&
          (Ie < et ? (Ie += 2 * Math.PI) : (et += 2 * Math.PI)),
          (d.theta = Ie - et),
          r.update();
      }),
      (this.getDistance = () => r.object.position.distanceTo(r.target)),
      (this.listenToKeyEvents = (ne) => {
        ne.addEventListener("keydown", Oe), (this._domElementKeyEvents = ne);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", Oe),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        r.target0.copy(r.target),
          r.position0.copy(r.object.position),
          (r.zoom0 = r.object.zoom);
      }),
      (this.reset = () => {
        r.target.copy(r.target0),
          r.object.position.copy(r.position0),
          (r.object.zoom = r.zoom0),
          r.object.updateProjectionMatrix(),
          r.dispatchEvent(i),
          r.update(),
          (l = s.NONE);
      }),
      (this.update = (() => {
        const ne = new K(),
          Ie = new K(0, 1, 0),
          et = new mi().setFromUnitVectors(e.up, Ie),
          We = et.clone().invert(),
          Ee = new K(),
          ie = new mi(),
          $e = 2 * Math.PI;
        return function () {
          const Xe = r.object.position;
          et.setFromUnitVectors(e.up, Ie),
            We.copy(et).invert(),
            ne.copy(Xe).sub(r.target),
            ne.applyQuaternion(et),
            u.setFromVector3(ne),
            r.autoRotate && l === s.NONE && N(D()),
            r.enableDamping
              ? ((u.theta += d.theta * r.dampingFactor),
                (u.phi += d.phi * r.dampingFactor))
              : ((u.theta += d.theta), (u.phi += d.phi));
          let Ue = r.minAzimuthAngle,
            Ye = r.maxAzimuthAngle;
          isFinite(Ue) &&
            isFinite(Ye) &&
            (Ue < -Math.PI ? (Ue += $e) : Ue > Math.PI && (Ue -= $e),
            Ye < -Math.PI ? (Ye += $e) : Ye > Math.PI && (Ye -= $e),
            Ue <= Ye
              ? (u.theta = Math.max(Ue, Math.min(Ye, u.theta)))
              : (u.theta =
                  u.theta > (Ue + Ye) / 2
                    ? Math.max(Ue, u.theta)
                    : Math.min(Ye, u.theta))),
            (u.phi = Math.max(
              r.minPolarAngle,
              Math.min(r.maxPolarAngle, u.phi)
            )),
            u.makeSafe(),
            r.enableDamping === !0
              ? r.target.addScaledVector(m, r.dampingFactor)
              : r.target.add(m),
            (r.zoomToCursor && R) || r.object.isOrthographicCamera
              ? (u.radius = X(u.radius))
              : (u.radius = X(u.radius * p)),
            ne.setFromSpherical(u),
            ne.applyQuaternion(We),
            Xe.copy(r.target).add(ne),
            r.object.matrixAutoUpdate || r.object.updateMatrix(),
            r.object.lookAt(r.target),
            r.enableDamping === !0
              ? ((d.theta *= 1 - r.dampingFactor),
                (d.phi *= 1 - r.dampingFactor),
                m.multiplyScalar(1 - r.dampingFactor))
              : (d.set(0, 0, 0), m.set(0, 0, 0));
          let ke = !1;
          if (r.zoomToCursor && R) {
            let tt = null;
            if (r.object instanceof Zn && r.object.isPerspectiveCamera) {
              const ut = ne.length();
              tt = X(ut * p);
              const dt = ut - tt;
              r.object.position.addScaledVector(T, dt),
                r.object.updateMatrixWorld();
            } else if (r.object.isOrthographicCamera) {
              const ut = new K(I.x, I.y, 0);
              ut.unproject(r.object),
                (r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / p)
                )),
                r.object.updateProjectionMatrix(),
                (ke = !0);
              const dt = new K(I.x, I.y, 0);
              dt.unproject(r.object),
                r.object.position.sub(dt).add(ut),
                r.object.updateMatrixWorld(),
                (tt = ne.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (r.zoomToCursor = !1);
            tt !== null &&
              (r.screenSpacePanning
                ? r.target
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix)
                    .multiplyScalar(tt)
                    .add(r.object.position)
                : (Fv.origin.copy(r.object.position),
                  Fv.direction
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix),
                  Math.abs(r.object.up.dot(Fv.direction)) < cX
                    ? e.lookAt(r.target)
                    : (s3.setFromNormalAndCoplanarPoint(r.object.up, r.target),
                      Fv.intersectPlane(s3, r.target))));
          } else
            r.object instanceof ts &&
              r.object.isOrthographicCamera &&
              ((ke = p !== 1),
              ke &&
                ((r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / p)
                )),
                r.object.updateProjectionMatrix()));
          return (
            (p = 1),
            (R = !1),
            ke ||
            Ee.distanceToSquared(r.object.position) > c ||
            8 * (1 - ie.dot(r.object.quaternion)) > c
              ? (r.dispatchEvent(i),
                Ee.copy(r.object.position),
                ie.copy(r.object.quaternion),
                (ke = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (ne) => {
        (r.domElement = ne),
          (r.domElement.style.touchAction = "none"),
          r.domElement.addEventListener("contextmenu", Je),
          r.domElement.addEventListener("pointerdown", ge),
          r.domElement.addEventListener("pointercancel", he),
          r.domElement.addEventListener("wheel", Le);
      }),
      (this.dispose = () => {
        var ne, Ie, et, We, Ee, ie;
        r.domElement && (r.domElement.style.touchAction = "auto"),
          (ne = r.domElement) == null ||
            ne.removeEventListener("contextmenu", Je),
          (Ie = r.domElement) == null ||
            Ie.removeEventListener("pointerdown", ge),
          (et = r.domElement) == null ||
            et.removeEventListener("pointercancel", he),
          (We = r.domElement) == null || We.removeEventListener("wheel", Le),
          (Ee = r.domElement) == null ||
            Ee.ownerDocument.removeEventListener("pointermove", ce),
          (ie = r.domElement) == null ||
            ie.ownerDocument.removeEventListener("pointerup", he),
          r._domElementKeyEvents !== null &&
            r._domElementKeyEvents.removeEventListener("keydown", Oe);
      });
    const r = this,
      i = { type: "change" },
      o = { type: "start" },
      a = { type: "end" },
      s = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let l = s.NONE;
    const c = 1e-6,
      u = new Bw(),
      d = new Bw();
    let p = 1;
    const m = new K(),
      v = new Ge(),
      S = new Ge(),
      x = new Ge(),
      g = new Ge(),
      _ = new Ge(),
      y = new Ge(),
      w = new Ge(),
      A = new Ge(),
      M = new Ge(),
      T = new K(),
      I = new Ge();
    let R = !1;
    const P = [],
      F = {};
    function D() {
      return ((2 * Math.PI) / 60 / 60) * r.autoRotateSpeed;
    }
    function j() {
      return Math.pow(0.95, r.zoomSpeed);
    }
    function N(ne) {
      r.reverseOrbit || r.reverseHorizontalOrbit
        ? (d.theta += ne)
        : (d.theta -= ne);
    }
    function V(ne) {
      r.reverseOrbit || r.reverseVerticalOrbit ? (d.phi += ne) : (d.phi -= ne);
    }
    const W = (() => {
        const ne = new K();
        return function (et, We) {
          ne.setFromMatrixColumn(We, 0), ne.multiplyScalar(-et), m.add(ne);
        };
      })(),
      Q = (() => {
        const ne = new K();
        return function (et, We) {
          r.screenSpacePanning === !0
            ? ne.setFromMatrixColumn(We, 1)
            : (ne.setFromMatrixColumn(We, 0), ne.crossVectors(r.object.up, ne)),
            ne.multiplyScalar(et),
            m.add(ne);
        };
      })(),
      B = (() => {
        const ne = new K();
        return function (et, We) {
          const Ee = r.domElement;
          if (Ee && r.object instanceof Zn && r.object.isPerspectiveCamera) {
            const ie = r.object.position;
            ne.copy(ie).sub(r.target);
            let $e = ne.length();
            ($e *= Math.tan(((r.object.fov / 2) * Math.PI) / 180)),
              W((2 * et * $e) / Ee.clientHeight, r.object.matrix),
              Q((2 * We * $e) / Ee.clientHeight, r.object.matrix);
          } else
            Ee && r.object instanceof ts && r.object.isOrthographicCamera
              ? (W(
                  (et * (r.object.right - r.object.left)) /
                    r.object.zoom /
                    Ee.clientWidth,
                  r.object.matrix
                ),
                Q(
                  (We * (r.object.top - r.object.bottom)) /
                    r.object.zoom /
                    Ee.clientHeight,
                  r.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (r.enablePan = !1));
        };
      })();
    function $(ne) {
      (r.object instanceof Zn && r.object.isPerspectiveCamera) ||
      (r.object instanceof ts && r.object.isOrthographicCamera)
        ? (p = ne)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (r.enableZoom = !1));
    }
    function G(ne) {
      $(p / ne);
    }
    function k(ne) {
      $(p * ne);
    }
    function q(ne) {
      if (!r.zoomToCursor || !r.domElement) return;
      R = !0;
      const Ie = r.domElement.getBoundingClientRect(),
        et = ne.clientX - Ie.left,
        We = ne.clientY - Ie.top,
        Ee = Ie.width,
        ie = Ie.height;
      (I.x = (et / Ee) * 2 - 1),
        (I.y = -(We / ie) * 2 + 1),
        T.set(I.x, I.y, 1)
          .unproject(r.object)
          .sub(r.object.position)
          .normalize();
    }
    function X(ne) {
      return Math.max(r.minDistance, Math.min(r.maxDistance, ne));
    }
    function ee(ne) {
      v.set(ne.clientX, ne.clientY);
    }
    function J(ne) {
      q(ne), w.set(ne.clientX, ne.clientY);
    }
    function oe(ne) {
      g.set(ne.clientX, ne.clientY);
    }
    function ae(ne) {
      S.set(ne.clientX, ne.clientY),
        x.subVectors(S, v).multiplyScalar(r.rotateSpeed);
      const Ie = r.domElement;
      Ie &&
        (N((2 * Math.PI * x.x) / Ie.clientHeight),
        V((2 * Math.PI * x.y) / Ie.clientHeight)),
        v.copy(S),
        r.update();
    }
    function le(ne) {
      A.set(ne.clientX, ne.clientY),
        M.subVectors(A, w),
        M.y > 0 ? G(j()) : M.y < 0 && k(j()),
        w.copy(A),
        r.update();
    }
    function _e(ne) {
      _.set(ne.clientX, ne.clientY),
        y.subVectors(_, g).multiplyScalar(r.panSpeed),
        B(y.x, y.y),
        g.copy(_),
        r.update();
    }
    function me(ne) {
      q(ne), ne.deltaY < 0 ? k(j()) : ne.deltaY > 0 && G(j()), r.update();
    }
    function se(ne) {
      let Ie = !1;
      switch (ne.code) {
        case r.keys.UP:
          B(0, r.keyPanSpeed), (Ie = !0);
          break;
        case r.keys.BOTTOM:
          B(0, -r.keyPanSpeed), (Ie = !0);
          break;
        case r.keys.LEFT:
          B(r.keyPanSpeed, 0), (Ie = !0);
          break;
        case r.keys.RIGHT:
          B(-r.keyPanSpeed, 0), (Ie = !0);
          break;
      }
      Ie && (ne.preventDefault(), r.update());
    }
    function Y() {
      if (P.length == 1) v.set(P[0].pageX, P[0].pageY);
      else {
        const ne = 0.5 * (P[0].pageX + P[1].pageX),
          Ie = 0.5 * (P[0].pageY + P[1].pageY);
        v.set(ne, Ie);
      }
    }
    function ve() {
      if (P.length == 1) g.set(P[0].pageX, P[0].pageY);
      else {
        const ne = 0.5 * (P[0].pageX + P[1].pageX),
          Ie = 0.5 * (P[0].pageY + P[1].pageY);
        g.set(ne, Ie);
      }
    }
    function de() {
      const ne = P[0].pageX - P[1].pageX,
        Ie = P[0].pageY - P[1].pageY,
        et = Math.sqrt(ne * ne + Ie * Ie);
      w.set(0, et);
    }
    function ue() {
      r.enableZoom && de(), r.enablePan && ve();
    }
    function fe() {
      r.enableZoom && de(), r.enableRotate && Y();
    }
    function Te(ne) {
      if (P.length == 1) S.set(ne.pageX, ne.pageY);
      else {
        const et = Ne(ne),
          We = 0.5 * (ne.pageX + et.x),
          Ee = 0.5 * (ne.pageY + et.y);
        S.set(We, Ee);
      }
      x.subVectors(S, v).multiplyScalar(r.rotateSpeed);
      const Ie = r.domElement;
      Ie &&
        (N((2 * Math.PI * x.x) / Ie.clientHeight),
        V((2 * Math.PI * x.y) / Ie.clientHeight)),
        v.copy(S);
    }
    function pe(ne) {
      if (P.length == 1) _.set(ne.pageX, ne.pageY);
      else {
        const Ie = Ne(ne),
          et = 0.5 * (ne.pageX + Ie.x),
          We = 0.5 * (ne.pageY + Ie.y);
        _.set(et, We);
      }
      y.subVectors(_, g).multiplyScalar(r.panSpeed), B(y.x, y.y), g.copy(_);
    }
    function H(ne) {
      const Ie = Ne(ne),
        et = ne.pageX - Ie.x,
        We = ne.pageY - Ie.y,
        Ee = Math.sqrt(et * et + We * We);
      A.set(0, Ee),
        M.set(0, Math.pow(A.y / w.y, r.zoomSpeed)),
        G(M.y),
        w.copy(A);
    }
    function z(ne) {
      r.enableZoom && H(ne), r.enablePan && pe(ne);
    }
    function Z(ne) {
      r.enableZoom && H(ne), r.enableRotate && Te(ne);
    }
    function ge(ne) {
      var Ie, et;
      r.enabled !== !1 &&
        (P.length === 0 &&
          ((Ie = r.domElement) == null ||
            Ie.ownerDocument.addEventListener("pointermove", ce),
          (et = r.domElement) == null ||
            et.ownerDocument.addEventListener("pointerup", he)),
        st(ne),
        ne.pointerType === "touch" ? Pe(ne) : Me(ne));
    }
    function ce(ne) {
      r.enabled !== !1 && (ne.pointerType === "touch" ? Se(ne) : Re(ne));
    }
    function he(ne) {
      var Ie, et, We;
      Qe(ne),
        P.length === 0 &&
          ((Ie = r.domElement) == null ||
            Ie.releasePointerCapture(ne.pointerId),
          (et = r.domElement) == null ||
            et.ownerDocument.removeEventListener("pointermove", ce),
          (We = r.domElement) == null ||
            We.ownerDocument.removeEventListener("pointerup", he)),
        r.dispatchEvent(a),
        (l = s.NONE);
    }
    function Me(ne) {
      let Ie;
      switch (ne.button) {
        case 0:
          Ie = r.mouseButtons.LEFT;
          break;
        case 1:
          Ie = r.mouseButtons.MIDDLE;
          break;
        case 2:
          Ie = r.mouseButtons.RIGHT;
          break;
        default:
          Ie = -1;
      }
      switch (Ie) {
        case Tc.DOLLY:
          if (r.enableZoom === !1) return;
          J(ne), (l = s.DOLLY);
          break;
        case Tc.ROTATE:
          if (ne.ctrlKey || ne.metaKey || ne.shiftKey) {
            if (r.enablePan === !1) return;
            oe(ne), (l = s.PAN);
          } else {
            if (r.enableRotate === !1) return;
            ee(ne), (l = s.ROTATE);
          }
          break;
        case Tc.PAN:
          if (ne.ctrlKey || ne.metaKey || ne.shiftKey) {
            if (r.enableRotate === !1) return;
            ee(ne), (l = s.ROTATE);
          } else {
            if (r.enablePan === !1) return;
            oe(ne), (l = s.PAN);
          }
          break;
        default:
          l = s.NONE;
      }
      l !== s.NONE && r.dispatchEvent(o);
    }
    function Re(ne) {
      if (r.enabled !== !1)
        switch (l) {
          case s.ROTATE:
            if (r.enableRotate === !1) return;
            ae(ne);
            break;
          case s.DOLLY:
            if (r.enableZoom === !1) return;
            le(ne);
            break;
          case s.PAN:
            if (r.enablePan === !1) return;
            _e(ne);
            break;
        }
    }
    function Le(ne) {
      r.enabled === !1 ||
        r.enableZoom === !1 ||
        (l !== s.NONE && l !== s.ROTATE) ||
        (ne.preventDefault(), r.dispatchEvent(o), me(ne), r.dispatchEvent(a));
    }
    function Oe(ne) {
      r.enabled === !1 || r.enablePan === !1 || se(ne);
    }
    function Pe(ne) {
      switch ((Ke(ne), P.length)) {
        case 1:
          switch (r.touches.ONE) {
            case Ac.ROTATE:
              if (r.enableRotate === !1) return;
              Y(), (l = s.TOUCH_ROTATE);
              break;
            case Ac.PAN:
              if (r.enablePan === !1) return;
              ve(), (l = s.TOUCH_PAN);
              break;
            default:
              l = s.NONE;
          }
          break;
        case 2:
          switch (r.touches.TWO) {
            case Ac.DOLLY_PAN:
              if (r.enableZoom === !1 && r.enablePan === !1) return;
              ue(), (l = s.TOUCH_DOLLY_PAN);
              break;
            case Ac.DOLLY_ROTATE:
              if (r.enableZoom === !1 && r.enableRotate === !1) return;
              fe(), (l = s.TOUCH_DOLLY_ROTATE);
              break;
            default:
              l = s.NONE;
          }
          break;
        default:
          l = s.NONE;
      }
      l !== s.NONE && r.dispatchEvent(o);
    }
    function Se(ne) {
      switch ((Ke(ne), l)) {
        case s.TOUCH_ROTATE:
          if (r.enableRotate === !1) return;
          Te(ne), r.update();
          break;
        case s.TOUCH_PAN:
          if (r.enablePan === !1) return;
          pe(ne), r.update();
          break;
        case s.TOUCH_DOLLY_PAN:
          if (r.enableZoom === !1 && r.enablePan === !1) return;
          z(ne), r.update();
          break;
        case s.TOUCH_DOLLY_ROTATE:
          if (r.enableZoom === !1 && r.enableRotate === !1) return;
          Z(ne), r.update();
          break;
        default:
          l = s.NONE;
      }
    }
    function Je(ne) {
      r.enabled !== !1 && ne.preventDefault();
    }
    function st(ne) {
      P.push(ne);
    }
    function Qe(ne) {
      delete F[ne.pointerId];
      for (let Ie = 0; Ie < P.length; Ie++)
        if (P[Ie].pointerId == ne.pointerId) {
          P.splice(Ie, 1);
          return;
        }
    }
    function Ke(ne) {
      let Ie = F[ne.pointerId];
      Ie === void 0 && ((Ie = new Ge()), (F[ne.pointerId] = Ie)),
        Ie.set(ne.pageX, ne.pageY);
    }
    function Ne(ne) {
      const Ie = ne.pointerId === P[0].pointerId ? P[1] : P[0];
      return F[Ie.pointerId];
    }
    (this.dollyIn = (ne = j()) => {
      k(ne), r.update();
    }),
      (this.dollyOut = (ne = j()) => {
        G(ne), r.update();
      }),
      (this.getScale = () => p),
      (this.setScale = (ne) => {
        $(ne), r.update();
      }),
      (this.getZoomScale = () => j()),
      n !== void 0 && this.connect(n),
      this.update();
  }
};
const c3 = new wr(),
  Dv = new K();
class UC extends M1 {
  constructor() {
    super(),
      (this.isLineSegmentsGeometry = !0),
      (this.type = "LineSegmentsGeometry");
    const e = [
        -1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1,
        -1, 0,
      ],
      n = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],
      r = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(r),
      this.setAttribute("position", new wt(e, 3)),
      this.setAttribute("uv", new wt(n, 2));
  }
  applyMatrix4(e) {
    const n = this.attributes.instanceStart,
      r = this.attributes.instanceEnd;
    return (
      n !== void 0 &&
        (n.applyMatrix4(e), r.applyMatrix4(e), (n.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  setPositions(e) {
    let n;
    e instanceof Float32Array
      ? (n = e)
      : Array.isArray(e) && (n = new Float32Array(e));
    const r = new hy(n, 6, 1);
    return (
      this.setAttribute("instanceStart", new wo(r, 3, 0)),
      this.setAttribute("instanceEnd", new wo(r, 3, 3)),
      this.computeBoundingBox(),
      this.computeBoundingSphere(),
      this
    );
  }
  setColors(e, n = 3) {
    let r;
    e instanceof Float32Array
      ? (r = e)
      : Array.isArray(e) && (r = new Float32Array(e));
    const i = new hy(r, n * 2, 1);
    return (
      this.setAttribute("instanceColorStart", new wo(i, n, 0)),
      this.setAttribute("instanceColorEnd", new wo(i, n, n)),
      this
    );
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new _C(e.geometry)), this;
  }
  fromLineSegments(e) {
    const n = e.geometry;
    return this.setPositions(n.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new wr());
    const e = this.attributes.instanceStart,
      n = this.attributes.instanceEnd;
    e !== void 0 &&
      n !== void 0 &&
      (this.boundingBox.setFromBufferAttribute(e),
      c3.setFromBufferAttribute(n),
      this.boundingBox.union(c3));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Rr()),
      this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart,
      n = this.attributes.instanceEnd;
    if (e !== void 0 && n !== void 0) {
      const r = this.boundingSphere.center;
      this.boundingBox.getCenter(r);
      let i = 0;
      for (let o = 0, a = e.count; o < a; o++)
        Dv.fromBufferAttribute(e, o),
          (i = Math.max(i, r.distanceToSquared(Dv))),
          Dv.fromBufferAttribute(n, o),
          (i = Math.max(i, r.distanceToSquared(Dv)));
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            "THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",
            this
          );
    }
  }
  toJSON() {}
  applyMatrix(e) {
    return (
      console.warn(
        "THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."
      ),
      this.applyMatrix4(e)
    );
  }
}
class Pz extends UC {
  constructor() {
    super(), (this.isLineGeometry = !0), (this.type = "LineGeometry");
  }
  setPositions(e) {
    const n = e.length - 3,
      r = new Float32Array(2 * n);
    for (let i = 0; i < n; i += 3)
      (r[2 * i] = e[i]),
        (r[2 * i + 1] = e[i + 1]),
        (r[2 * i + 2] = e[i + 2]),
        (r[2 * i + 3] = e[i + 3]),
        (r[2 * i + 4] = e[i + 4]),
        (r[2 * i + 5] = e[i + 5]);
    return super.setPositions(r), this;
  }
  setColors(e, n = 3) {
    const r = e.length - n,
      i = new Float32Array(2 * r);
    if (n === 3)
      for (let o = 0; o < r; o += n)
        (i[2 * o] = e[o]),
          (i[2 * o + 1] = e[o + 1]),
          (i[2 * o + 2] = e[o + 2]),
          (i[2 * o + 3] = e[o + 3]),
          (i[2 * o + 4] = e[o + 4]),
          (i[2 * o + 5] = e[o + 5]);
    else
      for (let o = 0; o < r; o += n)
        (i[2 * o] = e[o]),
          (i[2 * o + 1] = e[o + 1]),
          (i[2 * o + 2] = e[o + 2]),
          (i[2 * o + 3] = e[o + 3]),
          (i[2 * o + 4] = e[o + 4]),
          (i[2 * o + 5] = e[o + 5]),
          (i[2 * o + 6] = e[o + 6]),
          (i[2 * o + 7] = e[o + 7]);
    return super.setColors(i, n), this;
  }
  fromLine(e) {
    const n = e.geometry;
    return this.setPositions(n.attributes.position.array), this;
  }
}
class kC extends Ia {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: Up.clone(
        Up.merge([
          lt.common,
          lt.fog,
          {
            worldUnits: { value: 1 },
            linewidth: { value: 1 },
            resolution: { value: new Ge(1, 1) },
            dashOffset: { value: 0 },
            dashScale: { value: 1 },
            dashSize: { value: 1 },
            gapSize: { value: 1 },
          },
        ])
      ),
      vertexShader: `
				#include <common>
				#include <fog_pars_vertex>
				#include <logdepthbuf_pars_vertex>
				#include <clipping_planes_pars_vertex>

				uniform float linewidth;
				uniform vec2 resolution;

				attribute vec3 instanceStart;
				attribute vec3 instanceEnd;

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
						attribute vec4 instanceColorStart;
						attribute vec4 instanceColorEnd;
					#else
						varying vec3 vLineColor;
						attribute vec3 instanceColorStart;
						attribute vec3 instanceColorEnd;
					#endif
				#endif

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#ifdef USE_DASH

					uniform float dashScale;
					attribute float instanceDistanceStart;
					attribute float instanceDistanceEnd;
					varying float vLineDistance;

				#endif

				void trimSegment( const in vec4 start, inout vec4 end ) {

					// trim end segment so it terminates between the camera plane and the near plane

					// conservative estimate of the near plane
					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
					float nearEstimate = - 0.5 * b / a;

					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

					end.xyz = mix( start.xyz, end.xyz, alpha );

				}

				void main() {

					#ifdef USE_COLOR

						vLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

					#endif

					#ifdef USE_DASH

						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
						vUv = uv;

					#endif

					float aspect = resolution.x / resolution.y;

					// camera space
					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

					#ifdef WORLD_UNITS

						worldStart = start.xyz;
						worldEnd = end.xyz;

					#else

						vUv = uv;

					#endif

					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
					// perhaps there is a more elegant solution -- WestLangley

					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

					if ( perspective ) {

						if ( start.z < 0.0 && end.z >= 0.0 ) {

							trimSegment( start, end );

						} else if ( end.z < 0.0 && start.z >= 0.0 ) {

							trimSegment( end, start );

						}

					}

					// clip space
					vec4 clipStart = projectionMatrix * start;
					vec4 clipEnd = projectionMatrix * end;

					// ndc space
					vec3 ndcStart = clipStart.xyz / clipStart.w;
					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

					// direction
					vec2 dir = ndcEnd.xy - ndcStart.xy;

					// account for clip-space aspect ratio
					dir.x *= aspect;
					dir = normalize( dir );

					#ifdef WORLD_UNITS

						// get the offset direction as perpendicular to the view vector
						vec3 worldDir = normalize( end.xyz - start.xyz );
						vec3 offset;
						if ( position.y < 0.5 ) {

							offset = normalize( cross( start.xyz, worldDir ) );

						} else {

							offset = normalize( cross( end.xyz, worldDir ) );

						}

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

						// don't extend the line if we're rendering dashes because we
						// won't be rendering the endcaps
						#ifndef USE_DASH

							// extend the line bounds to encompass  endcaps
							start.xyz += - worldDir * linewidth * 0.5;
							end.xyz += worldDir * linewidth * 0.5;

							// shift the position of the quad so it hugs the forward edge of the line
							offset.xy -= dir * forwardOffset;
							offset.z += 0.5;

						#endif

						// endcaps
						if ( position.y > 1.0 || position.y < 0.0 ) {

							offset.xy += dir * 2.0 * forwardOffset;

						}

						// adjust for linewidth
						offset *= linewidth * 0.5;

						// set the world position
						worldPos = ( position.y < 0.5 ) ? start : end;
						worldPos.xyz += offset;

						// project the worldpos
						vec4 clip = projectionMatrix * worldPos;

						// shift the depth of the projected points so the line
						// segments overlap neatly
						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
						clip.z = clipPose.z * clip.w;

					#else

						vec2 offset = vec2( dir.y, - dir.x );
						// undo aspect ratio adjustment
						dir.x /= aspect;
						offset.x /= aspect;

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						// endcaps
						if ( position.y < 0.0 ) {

							offset += - dir;

						} else if ( position.y > 1.0 ) {

							offset += dir;

						}

						// adjust for linewidth
						offset *= linewidth;

						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
						offset /= resolution.y;

						// select end
						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

						// back to clip space
						offset *= clip.w;

						clip.xy += offset;

					#endif

					gl_Position = clip;

					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

					#include <logdepthbuf_vertex>
					#include <clipping_planes_vertex>
					#include <fog_vertex>

				}
			`,
      fragmentShader: `
				uniform vec3 diffuse;
				uniform float opacity;
				uniform float linewidth;

				#ifdef USE_DASH

					uniform float dashOffset;
					uniform float dashSize;
					uniform float gapSize;

				#endif

				varying float vLineDistance;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#include <common>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <clipping_planes_pars_fragment>

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
					#else
						varying vec3 vLineColor;
					#endif
				#endif

				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

					float mua;
					float mub;

					vec3 p13 = p1 - p3;
					vec3 p43 = p4 - p3;

					vec3 p21 = p2 - p1;

					float d1343 = dot( p13, p43 );
					float d4321 = dot( p43, p21 );
					float d1321 = dot( p13, p21 );
					float d4343 = dot( p43, p43 );
					float d2121 = dot( p21, p21 );

					float denom = d2121 * d4343 - d4321 * d4321;

					float numer = d1343 * d4321 - d1321 * d4343;

					mua = numer / denom;
					mua = clamp( mua, 0.0, 1.0 );
					mub = ( d1343 + d4321 * ( mua ) ) / d4343;
					mub = clamp( mub, 0.0, 1.0 );

					return vec2( mua, mub );

				}

				void main() {

					#include <clipping_planes_fragment>

					#ifdef USE_DASH

						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

					#endif

					float alpha = opacity;

					#ifdef WORLD_UNITS

						// Find the closest points on the view ray and the line segment
						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
						vec3 lineDir = worldEnd - worldStart;
						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

						vec3 p1 = worldStart + lineDir * params.x;
						vec3 p2 = rayEnd * params.y;
						vec3 delta = p1 - p2;
						float len = length( delta );
						float norm = len / linewidth;

						#ifndef USE_DASH

							#ifdef USE_ALPHA_TO_COVERAGE

								float dnorm = fwidth( norm );
								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

							#else

								if ( norm > 0.5 ) {

									discard;

								}

							#endif

						#endif

					#else

						#ifdef USE_ALPHA_TO_COVERAGE

							// artifacts appear on some hardware if a derivative is taken within a conditional
							float a = vUv.x;
							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
							float len2 = a * a + b * b;
							float dlen = fwidth( len2 );

							if ( abs( vUv.y ) > 1.0 ) {

								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

							}

						#else

							if ( abs( vUv.y ) > 1.0 ) {

								float a = vUv.x;
								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
								float len2 = a * a + b * b;

								if ( len2 > 1.0 ) discard;

							}

						#endif

					#endif

					vec4 diffuseColor = vec4( diffuse, alpha );
					#ifdef USE_COLOR
						#ifdef USE_LINE_COLOR_ALPHA
							diffuseColor *= vLineColor;
						#else
							diffuseColor.rgb *= vLineColor;
						#endif
					#endif

					#include <logdepthbuf_fragment>

					gl_FragColor = diffuseColor;

					#include <tonemapping_fragment>
					#include <${Az >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
					#include <fog_fragment>
					#include <premultiplied_alpha_fragment>

				}
			`,
      clipping: !0,
    }),
      (this.isLineMaterial = !0),
      (this.onBeforeCompile = function () {
        this.transparent
          ? (this.defines.USE_LINE_COLOR_ALPHA = "1")
          : delete this.defines.USE_LINE_COLOR_ALPHA;
      }),
      Object.defineProperties(this, {
        color: {
          enumerable: !0,
          get: function () {
            return this.uniforms.diffuse.value;
          },
          set: function (n) {
            this.uniforms.diffuse.value = n;
          },
        },
        worldUnits: {
          enumerable: !0,
          get: function () {
            return "WORLD_UNITS" in this.defines;
          },
          set: function (n) {
            n === !0
              ? (this.defines.WORLD_UNITS = "")
              : delete this.defines.WORLD_UNITS;
          },
        },
        linewidth: {
          enumerable: !0,
          get: function () {
            return this.uniforms.linewidth.value;
          },
          set: function (n) {
            this.uniforms.linewidth.value = n;
          },
        },
        dashed: {
          enumerable: !0,
          get: function () {
            return "USE_DASH" in this.defines;
          },
          set(n) {
            !!n != "USE_DASH" in this.defines && (this.needsUpdate = !0),
              n === !0
                ? (this.defines.USE_DASH = "")
                : delete this.defines.USE_DASH;
          },
        },
        dashScale: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashScale.value;
          },
          set: function (n) {
            this.uniforms.dashScale.value = n;
          },
        },
        dashSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashSize.value;
          },
          set: function (n) {
            this.uniforms.dashSize.value = n;
          },
        },
        dashOffset: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashOffset.value;
          },
          set: function (n) {
            this.uniforms.dashOffset.value = n;
          },
        },
        gapSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.gapSize.value;
          },
          set: function (n) {
            this.uniforms.gapSize.value = n;
          },
        },
        opacity: {
          enumerable: !0,
          get: function () {
            return this.uniforms.opacity.value;
          },
          set: function (n) {
            this.uniforms.opacity.value = n;
          },
        },
        resolution: {
          enumerable: !0,
          get: function () {
            return this.uniforms.resolution.value;
          },
          set: function (n) {
            this.uniforms.resolution.value.copy(n);
          },
        },
        alphaToCoverage: {
          enumerable: !0,
          get: function () {
            return "USE_ALPHA_TO_COVERAGE" in this.defines;
          },
          set: function (n) {
            !!n != "USE_ALPHA_TO_COVERAGE" in this.defines &&
              (this.needsUpdate = !0),
              n === !0
                ? ((this.defines.USE_ALPHA_TO_COVERAGE = ""),
                  (this.extensions.derivatives = !0))
                : (delete this.defines.USE_ALPHA_TO_COVERAGE,
                  (this.extensions.derivatives = !1));
          },
        },
      }),
      this.setValues(e);
  }
}
const g_ = new rn(),
  u3 = new K(),
  d3 = new K(),
  Gr = new rn(),
  Wr = new rn(),
  $a = new rn(),
  v_ = new K(),
  y_ = new kt(),
  Yr = new ez(),
  f3 = new K(),
  zv = new wr(),
  Uv = new Rr(),
  Ga = new rn();
let Ka, Qc;
function h3(t, e, n) {
  return (
    Ga.set(0, 0, -e, 1).applyMatrix4(t.projectionMatrix),
    Ga.multiplyScalar(1 / Ga.w),
    (Ga.x = Qc / n.width),
    (Ga.y = Qc / n.height),
    Ga.applyMatrix4(t.projectionMatrixInverse),
    Ga.multiplyScalar(1 / Ga.w),
    Math.abs(Math.max(Ga.x, Ga.y))
  );
}
function dX(t, e) {
  const n = t.matrixWorld,
    r = t.geometry,
    i = r.attributes.instanceStart,
    o = r.attributes.instanceEnd,
    a = Math.min(r.instanceCount, i.count);
  for (let s = 0, l = a; s < l; s++) {
    Yr.start.fromBufferAttribute(i, s),
      Yr.end.fromBufferAttribute(o, s),
      Yr.applyMatrix4(n);
    const c = new K(),
      u = new K();
    Ka.distanceSqToSegment(Yr.start, Yr.end, u, c),
      u.distanceTo(c) < Qc * 0.5 &&
        e.push({
          point: u,
          pointOnLine: c,
          distance: Ka.origin.distanceTo(u),
          object: t,
          face: null,
          faceIndex: s,
          uv: null,
          [Rz]: null,
        });
  }
}
function fX(t, e, n) {
  const r = e.projectionMatrix,
    o = t.material.resolution,
    a = t.matrixWorld,
    s = t.geometry,
    l = s.attributes.instanceStart,
    c = s.attributes.instanceEnd,
    u = Math.min(s.instanceCount, l.count),
    d = -e.near;
  Ka.at(1, $a),
    ($a.w = 1),
    $a.applyMatrix4(e.matrixWorldInverse),
    $a.applyMatrix4(r),
    $a.multiplyScalar(1 / $a.w),
    ($a.x *= o.x / 2),
    ($a.y *= o.y / 2),
    ($a.z = 0),
    v_.copy($a),
    y_.multiplyMatrices(e.matrixWorldInverse, a);
  for (let p = 0, m = u; p < m; p++) {
    if (
      (Gr.fromBufferAttribute(l, p),
      Wr.fromBufferAttribute(c, p),
      (Gr.w = 1),
      (Wr.w = 1),
      Gr.applyMatrix4(y_),
      Wr.applyMatrix4(y_),
      Gr.z > d && Wr.z > d)
    )
      continue;
    if (Gr.z > d) {
      const y = Gr.z - Wr.z,
        w = (Gr.z - d) / y;
      Gr.lerp(Wr, w);
    } else if (Wr.z > d) {
      const y = Wr.z - Gr.z,
        w = (Wr.z - d) / y;
      Wr.lerp(Gr, w);
    }
    Gr.applyMatrix4(r),
      Wr.applyMatrix4(r),
      Gr.multiplyScalar(1 / Gr.w),
      Wr.multiplyScalar(1 / Wr.w),
      (Gr.x *= o.x / 2),
      (Gr.y *= o.y / 2),
      (Wr.x *= o.x / 2),
      (Wr.y *= o.y / 2),
      Yr.start.copy(Gr),
      (Yr.start.z = 0),
      Yr.end.copy(Wr),
      (Yr.end.z = 0);
    const S = Yr.closestPointToPointParameter(v_, !0);
    Yr.at(S, f3);
    const x = $F.lerp(Gr.z, Wr.z, S),
      g = x >= -1 && x <= 1,
      _ = v_.distanceTo(f3) < Qc * 0.5;
    if (g && _) {
      Yr.start.fromBufferAttribute(l, p),
        Yr.end.fromBufferAttribute(c, p),
        Yr.start.applyMatrix4(a),
        Yr.end.applyMatrix4(a);
      const y = new K(),
        w = new K();
      Ka.distanceSqToSegment(Yr.start, Yr.end, w, y),
        n.push({
          point: w,
          pointOnLine: y,
          distance: Ka.origin.distanceTo(w),
          object: t,
          face: null,
          faceIndex: p,
          uv: null,
          [Rz]: null,
        });
    }
  }
}
class Iz extends Jn {
  constructor(e = new UC(), n = new kC({ color: Math.random() * 16777215 })) {
    super(e, n), (this.isLineSegments2 = !0), (this.type = "LineSegments2");
  }
  computeLineDistances() {
    const e = this.geometry,
      n = e.attributes.instanceStart,
      r = e.attributes.instanceEnd,
      i = new Float32Array(2 * n.count);
    for (let a = 0, s = 0, l = n.count; a < l; a++, s += 2)
      u3.fromBufferAttribute(n, a),
        d3.fromBufferAttribute(r, a),
        (i[s] = s === 0 ? 0 : i[s - 1]),
        (i[s + 1] = i[s] + u3.distanceTo(d3));
    const o = new hy(i, 2, 1);
    return (
      e.setAttribute("instanceDistanceStart", new wo(o, 1, 0)),
      e.setAttribute("instanceDistanceEnd", new wo(o, 1, 1)),
      this
    );
  }
  raycast(e, n) {
    const r = this.material.worldUnits,
      i = e.camera;
    i === null &&
      !r &&
      console.error(
        'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'
      );
    const o = (e.params.Line2 !== void 0 && e.params.Line2.threshold) || 0;
    Ka = e.ray;
    const a = this.matrixWorld,
      s = this.geometry,
      l = this.material;
    (Qc = l.linewidth + o),
      s.boundingSphere === null && s.computeBoundingSphere(),
      Uv.copy(s.boundingSphere).applyMatrix4(a);
    let c;
    if (r) c = Qc * 0.5;
    else {
      const d = Math.max(i.near, Uv.distanceToPoint(Ka.origin));
      c = h3(i, d, l.resolution);
    }
    if (((Uv.radius += c), Ka.intersectsSphere(Uv) === !1)) return;
    s.boundingBox === null && s.computeBoundingBox(),
      zv.copy(s.boundingBox).applyMatrix4(a);
    let u;
    if (r) u = Qc * 0.5;
    else {
      const d = Math.max(i.near, zv.distanceToPoint(Ka.origin));
      u = h3(i, d, l.resolution);
    }
    zv.expandByScalar(u),
      Ka.intersectsBox(zv) !== !1 && (r ? dX(this, n) : fX(this, i, n));
  }
  onBeforeRender(e) {
    const n = this.material.uniforms;
    n &&
      n.resolution &&
      (e.getViewport(g_),
      this.material.uniforms.resolution.value.set(g_.z, g_.w));
  }
}
class hX extends Iz {
  constructor(e = new Pz(), n = new kC({ color: Math.random() * 16777215 })) {
    super(e, n), (this.isLine2 = !0), (this.type = "Line2");
  }
}
const Jo = E.forwardRef(function (
  {
    points: e,
    color: n = 16777215,
    vertexColors: r,
    linewidth: i,
    lineWidth: o,
    segments: a,
    dashed: s,
    ...l
  },
  c
) {
  var u, d;
  const p = ga((g) => g.size),
    m = E.useMemo(() => (a ? new Iz() : new hX()), [a]),
    [v] = E.useState(() => new kC()),
    S = (r == null || (u = r[0]) == null ? void 0 : u.length) === 4 ? 4 : 3,
    x = E.useMemo(() => {
      const g = a ? new UC() : new Pz(),
        _ = e.map((y) => {
          const w = Array.isArray(y);
          return y instanceof K || y instanceof rn
            ? [y.x, y.y, y.z]
            : y instanceof Ge
            ? [y.x, y.y, 0]
            : w && y.length === 3
            ? [y[0], y[1], y[2]]
            : w && y.length === 2
            ? [y[0], y[1], 0]
            : y;
        });
      if ((g.setPositions(_.flat()), r)) {
        n = 16777215;
        const y = r.map((w) => (w instanceof pt ? w.toArray() : w));
        g.setColors(y.flat(), S);
      }
      return g;
    }, [e, a, r, S]);
  return (
    E.useLayoutEffect(() => {
      m.computeLineDistances();
    }, [e, m]),
    E.useLayoutEffect(() => {
      s ? (v.defines.USE_DASH = "") : delete v.defines.USE_DASH,
        (v.needsUpdate = !0);
    }, [s, v]),
    E.useEffect(
      () => () => {
        x.dispose(), v.dispose();
      },
      [x]
    ),
    E.createElement(
      "primitive",
      Et({ object: m, ref: c }, l),
      E.createElement("primitive", { object: x, attach: "geometry" }),
      E.createElement(
        "primitive",
        Et(
          {
            object: v,
            attach: "material",
            color: n,
            vertexColors: !!r,
            resolution: [p.width, p.height],
            linewidth: (d = i ?? o) !== null && d !== void 0 ? d : 1,
            dashed: s,
            transparent: S === 4,
          },
          l
        )
      )
    )
  );
});
function pX() {
  var t = Object.create(null);
  function e(i, o) {
    var a = i.id,
      s = i.name,
      l = i.dependencies;
    l === void 0 && (l = []);
    var c = i.init;
    c === void 0 && (c = function () {});
    var u = i.getTransferables;
    if ((u === void 0 && (u = null), !t[a]))
      try {
        (l = l.map(function (p) {
          return (
            p &&
              p.isWorkerModule &&
              (e(p, function (m) {
                if (m instanceof Error) throw m;
              }),
              (p = t[p.id].value)),
            p
          );
        })),
          (c = r("<" + s + ">.init", c)),
          u && (u = r("<" + s + ">.getTransferables", u));
        var d = null;
        typeof c == "function"
          ? (d = c.apply(void 0, l))
          : console.error("worker module init function failed to rehydrate"),
          (t[a] = { id: a, value: d, getTransferables: u }),
          o(d);
      } catch (p) {
        (p && p.noLog) || console.error(p), o(p);
      }
  }
  function n(i, o) {
    var a,
      s = i.id,
      l = i.args;
    (!t[s] || typeof t[s].value != "function") &&
      o(
        new Error(
          "Worker module " +
            s +
            ": not found or its 'init' did not return a function"
        )
      );
    try {
      var c = (a = t[s]).value.apply(a, l);
      c && typeof c.then == "function"
        ? c.then(u, function (d) {
            return o(d instanceof Error ? d : new Error("" + d));
          })
        : u(c);
    } catch (d) {
      o(d);
    }
    function u(d) {
      try {
        var p = t[s].getTransferables && t[s].getTransferables(d);
        (!p || !Array.isArray(p) || !p.length) && (p = void 0), o(d, p);
      } catch (m) {
        console.error(m), o(m);
      }
    }
  }
  function r(i, o) {
    var a = void 0;
    self.troikaDefine = function (l) {
      return (a = l);
    };
    var s = URL.createObjectURL(
      new Blob(
        [
          "/** " +
            i.replace(/\*/g, "") +
            ` **/

troikaDefine(
` +
            o +
            `
)`,
        ],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(s);
    } catch (l) {
      console.error(l);
    }
    return URL.revokeObjectURL(s), delete self.troikaDefine, a;
  }
  self.addEventListener("message", function (i) {
    var o = i.data,
      a = o.messageId,
      s = o.action,
      l = o.data;
    try {
      s === "registerModule" &&
        e(l, function (c) {
          c instanceof Error
            ? postMessage({ messageId: a, success: !1, error: c.message })
            : postMessage({
                messageId: a,
                success: !0,
                result: { isCallable: typeof c == "function" },
              });
        }),
        s === "callModule" &&
          n(l, function (c, u) {
            c instanceof Error
              ? postMessage({ messageId: a, success: !1, error: c.message })
              : postMessage(
                  { messageId: a, success: !0, result: c },
                  u || void 0
                );
          });
    } catch (c) {
      postMessage({ messageId: a, success: !1, error: c.stack });
    }
  });
}
function mX(t) {
  var e = function () {
    for (var n = [], r = arguments.length; r--; ) n[r] = arguments[r];
    return e._getInitResult().then(function (i) {
      if (typeof i == "function") return i.apply(void 0, n);
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  };
  return (
    (e._getInitResult = function () {
      var n = t.dependencies,
        r = t.init;
      n = Array.isArray(n)
        ? n.map(function (o) {
            return (
              o &&
                ((o = o.onMainThread || o),
                o._getInitResult && (o = o._getInitResult())),
              o
            );
          })
        : [];
      var i = Promise.all(n).then(function (o) {
        return r.apply(null, o);
      });
      return (
        (e._getInitResult = function () {
          return i;
        }),
        i
      );
    }),
    e
  );
}
var Lz = function () {
    var t = !1;
    if (typeof window < "u" && typeof window.document < "u")
      try {
        var e = new Worker(
          URL.createObjectURL(
            new Blob([""], { type: "application/javascript" })
          )
        );
        e.terminate(), (t = !0);
      } catch (n) {
        typeof process < "u",
          console.log(
            "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" +
              n.message +
              "]"
          );
      }
    return (
      (Lz = function () {
        return t;
      }),
      t
    );
  },
  gX = 0,
  vX = 0,
  x_ = !1,
  tp = Object.create(null),
  np = Object.create(null),
  Gw = Object.create(null);
function If(t) {
  if ((!t || typeof t.init != "function") && !x_)
    throw new Error("requires `options.init` function");
  var e = t.dependencies,
    n = t.init,
    r = t.getTransferables,
    i = t.workerId,
    o = mX(t);
  i == null && (i = "#default");
  var a = "workerModule" + ++gX,
    s = t.name || a,
    l = null;
  e =
    e &&
    e.map(function (u) {
      return (
        typeof u == "function" &&
          !u.workerModuleData &&
          ((x_ = !0),
          (u = If({
            workerId: i,
            name: "<" + s + "> function dependency: " + u.name,
            init:
              `function(){return (
` +
              E0(u) +
              `
)}`,
          })),
          (x_ = !1)),
        u && u.workerModuleData && (u = u.workerModuleData),
        u
      );
    });
  function c() {
    for (var u = [], d = arguments.length; d--; ) u[d] = arguments[d];
    if (!Lz()) return o.apply(void 0, u);
    if (!l) {
      l = p3(i, "registerModule", c.workerModuleData);
      var p = function () {
        (l = null), np[i].delete(p);
      };
      (np[i] || (np[i] = new Set())).add(p);
    }
    return l.then(function (m) {
      var v = m.isCallable;
      if (v) return p3(i, "callModule", { id: a, args: u });
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  }
  return (
    (c.workerModuleData = {
      isWorkerModule: !0,
      id: a,
      name: s,
      dependencies: e,
      init: E0(n),
      getTransferables: r && E0(r),
    }),
    (c.onMainThread = o),
    c
  );
}
function yX(t) {
  np[t] &&
    np[t].forEach(function (e) {
      e();
    }),
    tp[t] && (tp[t].terminate(), delete tp[t]);
}
function E0(t) {
  var e = t.toString();
  return (
    !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e
  );
}
function xX(t) {
  var e = tp[t];
  if (!e) {
    var n = E0(pX);
    (e = tp[t] =
      new Worker(
        URL.createObjectURL(
          new Blob(
            [
              "/** Worker Module Bootstrap: " +
                t.replace(/\*/g, "") +
                ` **/

;(` +
                n +
                ")()",
            ],
            { type: "application/javascript" }
          )
        )
      )),
      (e.onmessage = function (r) {
        var i = r.data,
          o = i.messageId,
          a = Gw[o];
        if (!a)
          throw new Error(
            "WorkerModule response with empty or unknown messageId"
          );
        delete Gw[o], a(i);
      });
  }
  return e;
}
function p3(t, e, n) {
  return new Promise(function (r, i) {
    var o = ++vX;
    (Gw[o] = function (a) {
      a.success
        ? r(a.result)
        : i(new Error("Error in worker " + e + " call: " + a.error));
    }),
      xX(t).postMessage({ messageId: o, action: e, data: n });
  });
}
function Oz() {
  var t = (function (e) {
    function n($, G, k, q, X, ee, J, oe) {
      var ae = 1 - J;
      (oe.x = ae * ae * $ + 2 * ae * J * k + J * J * X),
        (oe.y = ae * ae * G + 2 * ae * J * q + J * J * ee);
    }
    function r($, G, k, q, X, ee, J, oe, ae, le) {
      var _e = 1 - ae;
      (le.x =
        _e * _e * _e * $ +
        3 * _e * _e * ae * k +
        3 * _e * ae * ae * X +
        ae * ae * ae * J),
        (le.y =
          _e * _e * _e * G +
          3 * _e * _e * ae * q +
          3 * _e * ae * ae * ee +
          ae * ae * ae * oe);
    }
    function i($, G) {
      for (
        var k = /([MLQCZ])([^MLQCZ]*)/g, q, X, ee, J, oe;
        (q = k.exec($));

      ) {
        var ae = q[2]
          .replace(/^\s*|\s*$/g, "")
          .split(/[,\s]+/)
          .map(function (le) {
            return parseFloat(le);
          });
        switch (q[1]) {
          case "M":
            (J = X = ae[0]), (oe = ee = ae[1]);
            break;
          case "L":
            (ae[0] !== J || ae[1] !== oe) &&
              G("L", J, oe, (J = ae[0]), (oe = ae[1]));
            break;
          case "Q": {
            G("Q", J, oe, (J = ae[2]), (oe = ae[3]), ae[0], ae[1]);
            break;
          }
          case "C": {
            G(
              "C",
              J,
              oe,
              (J = ae[4]),
              (oe = ae[5]),
              ae[0],
              ae[1],
              ae[2],
              ae[3]
            );
            break;
          }
          case "Z":
            (J !== X || oe !== ee) && G("L", J, oe, X, ee);
            break;
        }
      }
    }
    function o($, G, k) {
      k === void 0 && (k = 16);
      var q = { x: 0, y: 0 };
      i($, function (X, ee, J, oe, ae, le, _e, me, se) {
        switch (X) {
          case "L":
            G(ee, J, oe, ae);
            break;
          case "Q": {
            for (var Y = ee, ve = J, de = 1; de < k; de++)
              n(ee, J, le, _e, oe, ae, de / (k - 1), q),
                G(Y, ve, q.x, q.y),
                (Y = q.x),
                (ve = q.y);
            break;
          }
          case "C": {
            for (var ue = ee, fe = J, Te = 1; Te < k; Te++)
              r(ee, J, le, _e, me, se, oe, ae, Te / (k - 1), q),
                G(ue, fe, q.x, q.y),
                (ue = q.x),
                (fe = q.y);
            break;
          }
        }
      });
    }
    var a =
        "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      s =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}",
      l = new WeakMap(),
      c = {
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !0,
        antialias: !1,
        depth: !1,
      };
    function u($, G) {
      var k = $.getContext ? $.getContext("webgl", c) : $,
        q = l.get(k);
      if (!q) {
        let _e = function (ue) {
            var fe = ee[ue];
            if (!fe && ((fe = ee[ue] = k.getExtension(ue)), !fe))
              throw new Error(ue + " not supported");
            return fe;
          },
          me = function (ue, fe) {
            var Te = k.createShader(fe);
            return k.shaderSource(Te, ue), k.compileShader(Te), Te;
          },
          se = function (ue, fe, Te, pe) {
            if (!J[ue]) {
              var H = {},
                z = {},
                Z = k.createProgram();
              k.attachShader(Z, me(fe, k.VERTEX_SHADER)),
                k.attachShader(Z, me(Te, k.FRAGMENT_SHADER)),
                k.linkProgram(Z),
                (J[ue] = {
                  program: Z,
                  transaction: function (ce) {
                    k.useProgram(Z),
                      ce({
                        setUniform: function (Me, Re) {
                          for (
                            var Le = [], Oe = arguments.length - 2;
                            Oe-- > 0;

                          )
                            Le[Oe] = arguments[Oe + 2];
                          var Pe =
                            z[Re] || (z[Re] = k.getUniformLocation(Z, Re));
                          k["uniform" + Me].apply(k, [Pe].concat(Le));
                        },
                        setAttribute: function (Me, Re, Le, Oe, Pe) {
                          var Se = H[Me];
                          Se ||
                            (Se = H[Me] =
                              {
                                buf: k.createBuffer(),
                                loc: k.getAttribLocation(Z, Me),
                                data: null,
                              }),
                            k.bindBuffer(k.ARRAY_BUFFER, Se.buf),
                            k.vertexAttribPointer(
                              Se.loc,
                              Re,
                              k.FLOAT,
                              !1,
                              0,
                              0
                            ),
                            k.enableVertexAttribArray(Se.loc),
                            X
                              ? k.vertexAttribDivisor(Se.loc, Oe)
                              : _e(
                                  "ANGLE_instanced_arrays"
                                ).vertexAttribDivisorANGLE(Se.loc, Oe),
                            Pe !== Se.data &&
                              (k.bufferData(k.ARRAY_BUFFER, Pe, Le),
                              (Se.data = Pe));
                        },
                      });
                  },
                });
            }
            J[ue].transaction(pe);
          },
          Y = function (ue, fe) {
            ae++;
            try {
              k.activeTexture(k.TEXTURE0 + ae);
              var Te = oe[ue];
              Te ||
                ((Te = oe[ue] = k.createTexture()),
                k.bindTexture(k.TEXTURE_2D, Te),
                k.texParameteri(k.TEXTURE_2D, k.TEXTURE_MIN_FILTER, k.NEAREST),
                k.texParameteri(k.TEXTURE_2D, k.TEXTURE_MAG_FILTER, k.NEAREST)),
                k.bindTexture(k.TEXTURE_2D, Te),
                fe(Te, ae);
            } finally {
              ae--;
            }
          },
          ve = function (ue, fe, Te) {
            var pe = k.createFramebuffer();
            le.push(pe),
              k.bindFramebuffer(k.FRAMEBUFFER, pe),
              k.activeTexture(k.TEXTURE0 + fe),
              k.bindTexture(k.TEXTURE_2D, ue),
              k.framebufferTexture2D(
                k.FRAMEBUFFER,
                k.COLOR_ATTACHMENT0,
                k.TEXTURE_2D,
                ue,
                0
              );
            try {
              Te(pe);
            } finally {
              k.deleteFramebuffer(pe),
                k.bindFramebuffer(k.FRAMEBUFFER, le[--le.length - 1] || null);
            }
          },
          de = function () {
            (ee = {}), (J = {}), (oe = {}), (ae = -1), (le.length = 0);
          };
        var X =
            typeof WebGL2RenderingContext < "u" &&
            k instanceof WebGL2RenderingContext,
          ee = {},
          J = {},
          oe = {},
          ae = -1,
          le = [];
        k.canvas.addEventListener(
          "webglcontextlost",
          function (ue) {
            de(), ue.preventDefault();
          },
          !1
        ),
          l.set(
            k,
            (q = {
              gl: k,
              isWebGL2: X,
              getExtension: _e,
              withProgram: se,
              withTexture: Y,
              withTextureFramebuffer: ve,
              handleContextLoss: de,
            })
          );
      }
      G(q);
    }
    function d($, G, k, q, X, ee, J, oe) {
      J === void 0 && (J = 15),
        oe === void 0 && (oe = null),
        u($, function (ae) {
          var le = ae.gl,
            _e = ae.withProgram,
            me = ae.withTexture;
          me("copy", function (se, Y) {
            le.texImage2D(
              le.TEXTURE_2D,
              0,
              le.RGBA,
              X,
              ee,
              0,
              le.RGBA,
              le.UNSIGNED_BYTE,
              G
            ),
              _e("copy", a, s, function (ve) {
                var de = ve.setUniform,
                  ue = ve.setAttribute;
                ue(
                  "aUV",
                  2,
                  le.STATIC_DRAW,
                  0,
                  new Float32Array([0, 0, 2, 0, 0, 2])
                ),
                  de("1i", "image", Y),
                  le.bindFramebuffer(le.FRAMEBUFFER, oe || null),
                  le.disable(le.BLEND),
                  le.colorMask(J & 8, J & 4, J & 2, J & 1),
                  le.viewport(k, q, X, ee),
                  le.scissor(k, q, X, ee),
                  le.drawArrays(le.TRIANGLES, 0, 3);
              });
          });
        });
    }
    function p($, G, k) {
      var q = $.width,
        X = $.height;
      u($, function (ee) {
        var J = ee.gl,
          oe = new Uint8Array(q * X * 4);
        J.readPixels(0, 0, q, X, J.RGBA, J.UNSIGNED_BYTE, oe),
          ($.width = G),
          ($.height = k),
          d(J, oe, 0, 0, q, X);
      });
    }
    var m = Object.freeze({
      __proto__: null,
      withWebGLContext: u,
      renderImageData: d,
      resizeWebGLCanvasWithoutClearing: p,
    });
    function v($, G, k, q, X, ee) {
      ee === void 0 && (ee = 1);
      var J = new Uint8Array($ * G),
        oe = q[2] - q[0],
        ae = q[3] - q[1],
        le = [];
      o(k, function (ue, fe, Te, pe) {
        le.push({
          x1: ue,
          y1: fe,
          x2: Te,
          y2: pe,
          minX: Math.min(ue, Te),
          minY: Math.min(fe, pe),
          maxX: Math.max(ue, Te),
          maxY: Math.max(fe, pe),
        });
      }),
        le.sort(function (ue, fe) {
          return ue.maxX - fe.maxX;
        });
      for (var _e = 0; _e < $; _e++)
        for (var me = 0; me < G; me++) {
          var se = ve(
              q[0] + (oe * (_e + 0.5)) / $,
              q[1] + (ae * (me + 0.5)) / G
            ),
            Y = Math.pow(1 - Math.abs(se) / X, ee) / 2;
          se < 0 && (Y = 1 - Y),
            (Y = Math.max(0, Math.min(255, Math.round(Y * 255)))),
            (J[me * $ + _e] = Y);
        }
      return J;
      function ve(ue, fe) {
        for (var Te = 1 / 0, pe = 1 / 0, H = le.length; H--; ) {
          var z = le[H];
          if (z.maxX + pe <= ue) break;
          if (ue + pe > z.minX && fe - pe < z.maxY && fe + pe > z.minY) {
            var Z = g(ue, fe, z.x1, z.y1, z.x2, z.y2);
            Z < Te && ((Te = Z), (pe = Math.sqrt(Te)));
          }
        }
        return de(ue, fe) && (pe = -pe), pe;
      }
      function de(ue, fe) {
        for (var Te = 0, pe = le.length; pe--; ) {
          var H = le[pe];
          if (H.maxX <= ue) break;
          var z =
            H.y1 > fe != H.y2 > fe &&
            ue < ((H.x2 - H.x1) * (fe - H.y1)) / (H.y2 - H.y1) + H.x1;
          z && (Te += H.y1 < H.y2 ? 1 : -1);
        }
        return Te !== 0;
      }
    }
    function S($, G, k, q, X, ee, J, oe, ae, le) {
      ee === void 0 && (ee = 1),
        oe === void 0 && (oe = 0),
        ae === void 0 && (ae = 0),
        le === void 0 && (le = 0),
        x($, G, k, q, X, ee, J, null, oe, ae, le);
    }
    function x($, G, k, q, X, ee, J, oe, ae, le, _e) {
      ee === void 0 && (ee = 1),
        ae === void 0 && (ae = 0),
        le === void 0 && (le = 0),
        _e === void 0 && (_e = 0);
      for (
        var me = v($, G, k, q, X, ee),
          se = new Uint8Array(me.length * 4),
          Y = 0;
        Y < me.length;
        Y++
      )
        se[Y * 4 + _e] = me[Y];
      d(J, se, ae, le, $, G, 1 << (3 - _e), oe);
    }
    function g($, G, k, q, X, ee) {
      var J = X - k,
        oe = ee - q,
        ae = J * J + oe * oe,
        le = ae
          ? Math.max(0, Math.min(1, (($ - k) * J + (G - q) * oe) / ae))
          : 0,
        _e = $ - (k + le * J),
        me = G - (q + le * oe);
      return _e * _e + me * me;
    }
    var _ = Object.freeze({
        __proto__: null,
        generate: v,
        generateIntoCanvas: S,
        generateIntoFramebuffer: x,
      }),
      y =
        "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      w =
        "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}",
      A =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}",
      M = new Float32Array([0, 0, 2, 0, 0, 2]),
      T = null,
      I = !1,
      R = {},
      P = new WeakMap();
    function F($) {
      if (!I && !V($)) throw new Error("WebGL generation not supported");
    }
    function D($, G, k, q, X, ee, J) {
      if (
        (ee === void 0 && (ee = 1),
        J === void 0 && (J = null),
        !J && ((J = T), !J))
      ) {
        var oe =
          typeof OffscreenCanvas == "function"
            ? new OffscreenCanvas(1, 1)
            : typeof document < "u"
            ? document.createElement("canvas")
            : null;
        if (!oe) throw new Error("OffscreenCanvas or DOM canvas not supported");
        J = T = oe.getContext("webgl", { depth: !1 });
      }
      F(J);
      var ae = new Uint8Array($ * G * 4);
      u(J, function (se) {
        var Y = se.gl,
          ve = se.withTexture,
          de = se.withTextureFramebuffer;
        ve("readable", function (ue, fe) {
          Y.texImage2D(
            Y.TEXTURE_2D,
            0,
            Y.RGBA,
            $,
            G,
            0,
            Y.RGBA,
            Y.UNSIGNED_BYTE,
            null
          ),
            de(ue, fe, function (Te) {
              N($, G, k, q, X, ee, Y, Te, 0, 0, 0),
                Y.readPixels(0, 0, $, G, Y.RGBA, Y.UNSIGNED_BYTE, ae);
            });
        });
      });
      for (
        var le = new Uint8Array($ * G), _e = 0, me = 0;
        _e < ae.length;
        _e += 4
      )
        le[me++] = ae[_e];
      return le;
    }
    function j($, G, k, q, X, ee, J, oe, ae, le) {
      ee === void 0 && (ee = 1),
        oe === void 0 && (oe = 0),
        ae === void 0 && (ae = 0),
        le === void 0 && (le = 0),
        N($, G, k, q, X, ee, J, null, oe, ae, le);
    }
    function N($, G, k, q, X, ee, J, oe, ae, le, _e) {
      ee === void 0 && (ee = 1),
        ae === void 0 && (ae = 0),
        le === void 0 && (le = 0),
        _e === void 0 && (_e = 0),
        F(J);
      var me = [];
      o(k, function (se, Y, ve, de) {
        me.push(se, Y, ve, de);
      }),
        (me = new Float32Array(me)),
        u(J, function (se) {
          var Y = se.gl,
            ve = se.isWebGL2,
            de = se.getExtension,
            ue = se.withProgram,
            fe = se.withTexture,
            Te = se.withTextureFramebuffer,
            pe = se.handleContextLoss;
          if (
            (fe("rawDistances", function (H, z) {
              ($ !== H._lastWidth || G !== H._lastHeight) &&
                Y.texImage2D(
                  Y.TEXTURE_2D,
                  0,
                  Y.RGBA,
                  (H._lastWidth = $),
                  (H._lastHeight = G),
                  0,
                  Y.RGBA,
                  Y.UNSIGNED_BYTE,
                  null
                ),
                ue("main", y, w, function (Z) {
                  var ge = Z.setAttribute,
                    ce = Z.setUniform,
                    he = !ve && de("ANGLE_instanced_arrays"),
                    Me = !ve && de("EXT_blend_minmax");
                  ge("aUV", 2, Y.STATIC_DRAW, 0, M),
                    ge("aLineSegment", 4, Y.DYNAMIC_DRAW, 1, me),
                    ce.apply(void 0, ["4f", "uGlyphBounds"].concat(q)),
                    ce("1f", "uMaxDistance", X),
                    ce("1f", "uExponent", ee),
                    Te(H, z, function (Re) {
                      Y.enable(Y.BLEND),
                        Y.colorMask(!0, !0, !0, !0),
                        Y.viewport(0, 0, $, G),
                        Y.scissor(0, 0, $, G),
                        Y.blendFunc(Y.ONE, Y.ONE),
                        Y.blendEquationSeparate(
                          Y.FUNC_ADD,
                          ve ? Y.MAX : Me.MAX_EXT
                        ),
                        Y.clear(Y.COLOR_BUFFER_BIT),
                        ve
                          ? Y.drawArraysInstanced(
                              Y.TRIANGLES,
                              0,
                              3,
                              me.length / 4
                            )
                          : he.drawArraysInstancedANGLE(
                              Y.TRIANGLES,
                              0,
                              3,
                              me.length / 4
                            );
                    });
                }),
                ue("post", a, A, function (Z) {
                  Z.setAttribute("aUV", 2, Y.STATIC_DRAW, 0, M),
                    Z.setUniform("1i", "tex", z),
                    Y.bindFramebuffer(Y.FRAMEBUFFER, oe),
                    Y.disable(Y.BLEND),
                    Y.colorMask(_e === 0, _e === 1, _e === 2, _e === 3),
                    Y.viewport(ae, le, $, G),
                    Y.scissor(ae, le, $, G),
                    Y.drawArrays(Y.TRIANGLES, 0, 3);
                });
            }),
            Y.isContextLost())
          )
            throw (pe(), new Error("webgl context lost"));
        });
    }
    function V($) {
      var G = !$ || $ === T ? R : $.canvas || $,
        k = P.get(G);
      if (k === void 0) {
        I = !0;
        var q = null;
        try {
          var X = [
              97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106,
              97,
            ],
            ee = D(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, $);
          (k =
            ee &&
            X.length === ee.length &&
            ee.every(function (J, oe) {
              return J === X[oe];
            })),
            k || ((q = "bad trial run results"), console.info(X, ee));
        } catch (J) {
          (k = !1), (q = J.message);
        }
        q && console.warn("WebGL SDF generation not supported:", q),
          (I = !1),
          P.set(G, k);
      }
      return k;
    }
    var W = Object.freeze({
      __proto__: null,
      generate: D,
      generateIntoCanvas: j,
      generateIntoFramebuffer: N,
      isSupported: V,
    });
    function Q($, G, k, q, X, ee) {
      X === void 0 && (X = Math.max(q[2] - q[0], q[3] - q[1]) / 2),
        ee === void 0 && (ee = 1);
      try {
        return D.apply(W, arguments);
      } catch (J) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", J),
          v.apply(_, arguments)
        );
      }
    }
    function B($, G, k, q, X, ee, J, oe, ae, le) {
      X === void 0 && (X = Math.max(q[2] - q[0], q[3] - q[1]) / 2),
        ee === void 0 && (ee = 1),
        oe === void 0 && (oe = 0),
        ae === void 0 && (ae = 0),
        le === void 0 && (le = 0);
      try {
        return j.apply(W, arguments);
      } catch (_e) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", _e),
          S.apply(_, arguments)
        );
      }
    }
    return (
      (e.forEachPathCommand = i),
      (e.generate = Q),
      (e.generateIntoCanvas = B),
      (e.javascript = _),
      (e.pathToLineSegments = o),
      (e.webgl = W),
      (e.webglUtils = m),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return t;
}
function SX() {
  var t = (function (e) {
    var n = {
        R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
        EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
        ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
        ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
        AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
        CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
        B: "a,3,f+2,2v,690",
        S: "9,2,k",
        WS: "c,k,4f4,1vk+a,u,1j,335",
        ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
        BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
        NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
        AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
        LRO: "6ct",
        RLO: "6cu",
        LRE: "6cq",
        RLE: "6cr",
        PDF: "6cs",
        LRI: "6ee",
        RLI: "6ef",
        FSI: "6eg",
        PDI: "6eh",
      },
      r = {},
      i = {};
    (r.L = 1),
      (i[1] = "L"),
      Object.keys(n).forEach(function (pe, H) {
        (r[pe] = 1 << (H + 1)), (i[r[pe]] = pe);
      }),
      Object.freeze(r);
    var o = r.LRI | r.RLI | r.FSI,
      a = r.L | r.R | r.AL,
      s = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI,
      l = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF,
      c = r.S | r.WS | r.B | o | r.PDI | l,
      u = null;
    function d() {
      if (!u) {
        u = new Map();
        var pe = function (z) {
          if (n.hasOwnProperty(z)) {
            var Z = 0;
            n[z].split(",").forEach(function (ge) {
              var ce = ge.split("+"),
                he = ce[0],
                Me = ce[1];
              (he = parseInt(he, 36)),
                (Me = Me ? parseInt(Me, 36) : 0),
                u.set((Z += he), r[z]);
              for (var Re = 0; Re < Me; Re++) u.set(++Z, r[z]);
            });
          }
        };
        for (var H in n) pe(H);
      }
    }
    function p(pe) {
      return d(), u.get(pe.codePointAt(0)) || r.L;
    }
    function m(pe) {
      return i[p(pe)];
    }
    var v = {
      pairs:
        "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical:
        "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye",
    };
    function S(pe, H) {
      var z = 36,
        Z = 0,
        ge = new Map(),
        ce = H && new Map(),
        he;
      return (
        pe.split(",").forEach(function Me(Re) {
          if (Re.indexOf("+") !== -1) for (var Le = +Re; Le--; ) Me(he);
          else {
            he = Re;
            var Oe = Re.split(">"),
              Pe = Oe[0],
              Se = Oe[1];
            (Pe = String.fromCodePoint((Z += parseInt(Pe, z)))),
              (Se = String.fromCodePoint((Z += parseInt(Se, z)))),
              ge.set(Pe, Se),
              H && ce.set(Se, Pe);
          }
        }),
        { map: ge, reverseMap: ce }
      );
    }
    var x, g, _;
    function y() {
      if (!x) {
        var pe = S(v.pairs, !0),
          H = pe.map,
          z = pe.reverseMap;
        (x = H), (g = z), (_ = S(v.canonical, !1).map);
      }
    }
    function w(pe) {
      return y(), x.get(pe) || null;
    }
    function A(pe) {
      return y(), g.get(pe) || null;
    }
    function M(pe) {
      return y(), _.get(pe) || null;
    }
    var T = r.L,
      I = r.R,
      R = r.EN,
      P = r.ES,
      F = r.ET,
      D = r.AN,
      j = r.CS,
      N = r.B,
      V = r.S,
      W = r.ON,
      Q = r.BN,
      B = r.NSM,
      $ = r.AL,
      G = r.LRO,
      k = r.RLO,
      q = r.LRE,
      X = r.RLE,
      ee = r.PDF,
      J = r.LRI,
      oe = r.RLI,
      ae = r.FSI,
      le = r.PDI;
    function _e(pe, H) {
      for (
        var z = 125, Z = new Uint32Array(pe.length), ge = 0;
        ge < pe.length;
        ge++
      )
        Z[ge] = p(pe[ge]);
      var ce = new Map();
      function he(Dr, Ei) {
        var cr = Z[Dr];
        (Z[Dr] = Ei),
          ce.set(cr, ce.get(cr) - 1),
          cr & s && ce.set(s, ce.get(s) - 1),
          ce.set(Ei, (ce.get(Ei) || 0) + 1),
          Ei & s && ce.set(s, (ce.get(s) || 0) + 1);
      }
      for (
        var Me = new Uint8Array(pe.length),
          Re = new Map(),
          Le = [],
          Oe = null,
          Pe = 0;
        Pe < pe.length;
        Pe++
      )
        Oe ||
          Le.push(
            (Oe = {
              start: Pe,
              end: pe.length - 1,
              level: H === "rtl" ? 1 : H === "ltr" ? 0 : Ru(Pe, !1),
            })
          ),
          Z[Pe] & N && ((Oe.end = Pe), (Oe = null));
      for (
        var Se = X | q | k | G | o | le | ee | N,
          Je = function (Dr) {
            return Dr + (Dr & 1 ? 1 : 2);
          },
          st = function (Dr) {
            return Dr + (Dr & 1 ? 2 : 1);
          },
          Qe = 0;
        Qe < Le.length;
        Qe++
      ) {
        Oe = Le[Qe];
        var Ke = [{ _level: Oe.level, _override: 0, _isolate: 0 }],
          Ne = void 0,
          ne = 0,
          Ie = 0,
          et = 0;
        ce.clear();
        for (var We = Oe.start; We <= Oe.end; We++) {
          var Ee = Z[We];
          if (
            ((Ne = Ke[Ke.length - 1]),
            ce.set(Ee, (ce.get(Ee) || 0) + 1),
            Ee & s && ce.set(s, (ce.get(s) || 0) + 1),
            Ee & Se)
          )
            if (Ee & (X | q)) {
              Me[We] = Ne._level;
              var ie = (Ee === X ? st : Je)(Ne._level);
              ie <= z && !ne && !Ie
                ? Ke.push({ _level: ie, _override: 0, _isolate: 0 })
                : ne || Ie++;
            } else if (Ee & (k | G)) {
              Me[We] = Ne._level;
              var $e = (Ee === k ? st : Je)(Ne._level);
              $e <= z && !ne && !Ie
                ? Ke.push({
                    _level: $e,
                    _override: Ee & k ? I : T,
                    _isolate: 0,
                  })
                : ne || Ie++;
            } else if (Ee & o) {
              Ee & ae && (Ee = Ru(We + 1, !0) === 1 ? oe : J),
                (Me[We] = Ne._level),
                Ne._override && he(We, Ne._override);
              var He = (Ee === oe ? st : Je)(Ne._level);
              He <= z && ne === 0 && Ie === 0
                ? (et++,
                  Ke.push({
                    _level: He,
                    _override: 0,
                    _isolate: 1,
                    _isolInitIndex: We,
                  }))
                : ne++;
            } else if (Ee & le) {
              if (ne > 0) ne--;
              else if (et > 0) {
                for (Ie = 0; !Ke[Ke.length - 1]._isolate; ) Ke.pop();
                var Xe = Ke[Ke.length - 1]._isolInitIndex;
                Xe != null && (Re.set(Xe, We), Re.set(We, Xe)), Ke.pop(), et--;
              }
              (Ne = Ke[Ke.length - 1]),
                (Me[We] = Ne._level),
                Ne._override && he(We, Ne._override);
            } else
              Ee & ee
                ? (ne === 0 &&
                    (Ie > 0
                      ? Ie--
                      : !Ne._isolate &&
                        Ke.length > 1 &&
                        (Ke.pop(), (Ne = Ke[Ke.length - 1]))),
                  (Me[We] = Ne._level))
                : Ee & N && (Me[We] = Oe.level);
          else
            (Me[We] = Ne._level),
              Ne._override && Ee !== Q && he(We, Ne._override);
        }
        for (var Ue = [], Ye = null, ke = Oe.start; ke <= Oe.end; ke++) {
          var tt = Z[ke];
          if (!(tt & l)) {
            var ut = Me[ke],
              dt = tt & o,
              Rt = tt === le;
            Ye && ut === Ye._level
              ? ((Ye._end = ke), (Ye._endsWithIsolInit = dt))
              : Ue.push(
                  (Ye = {
                    _start: ke,
                    _end: ke,
                    _level: ut,
                    _startsWithPDI: Rt,
                    _endsWithIsolInit: dt,
                  })
                );
          }
        }
        for (var Bt = [], In = 0; In < Ue.length; In++) {
          var dn = Ue[In];
          if (!dn._startsWithPDI || (dn._startsWithPDI && !Re.has(dn._start))) {
            for (
              var _n = [(Ye = dn)], gn = void 0;
              Ye && Ye._endsWithIsolInit && (gn = Re.get(Ye._end)) != null;

            )
              for (var Gt = In + 1; Gt < Ue.length; Gt++)
                if (Ue[Gt]._start === gn) {
                  _n.push((Ye = Ue[Gt]));
                  break;
                }
            for (var ln = [], Ht = 0; Ht < _n.length; Ht++)
              for (var Dt = _n[Ht], nn = Dt._start; nn <= Dt._end; nn++)
                ln.push(nn);
            for (
              var Ln = Me[ln[0]], te = Oe.level, ye = ln[0] - 1;
              ye >= 0;
              ye--
            )
              if (!(Z[ye] & l)) {
                te = Me[ye];
                break;
              }
            var Ae = ln[ln.length - 1],
              ze = Me[Ae],
              Ce = Oe.level;
            if (!(Z[Ae] & o)) {
              for (var ot = Ae + 1; ot <= Oe.end; ot++)
                if (!(Z[ot] & l)) {
                  Ce = Me[ot];
                  break;
                }
            }
            Bt.push({
              _seqIndices: ln,
              _sosType: Math.max(te, Ln) % 2 ? I : T,
              _eosType: Math.max(Ce, ze) % 2 ? I : T,
            });
          }
        }
        for (var ht = 0; ht < Bt.length; ht++) {
          var xt = Bt[ht],
            qe = xt._seqIndices,
            bt = xt._sosType,
            Lt = xt._eosType,
            Mt = Me[qe[0]] & 1 ? I : T;
          if (ce.get(B))
            for (var qt = 0; qt < qe.length; qt++) {
              var On = qe[qt];
              if (Z[On] & B) {
                for (var tn = bt, cn = qt - 1; cn >= 0; cn--)
                  if (!(Z[qe[cn]] & l)) {
                    tn = Z[qe[cn]];
                    break;
                  }
                he(On, tn & (o | le) ? W : tn);
              }
            }
          if (ce.get(R))
            for (var St = 0; St < qe.length; St++) {
              var ct = qe[St];
              if (Z[ct] & R)
                for (var zn = St - 1; zn >= -1; zn--) {
                  var Ot = zn === -1 ? bt : Z[qe[zn]];
                  if (Ot & a) {
                    Ot === $ && he(ct, D);
                    break;
                  }
                }
            }
          if (ce.get($))
            for (var fn = 0; fn < qe.length; fn++) {
              var Xn = qe[fn];
              Z[Xn] & $ && he(Xn, I);
            }
          if (ce.get(P) || ce.get(j))
            for (var Ut = 1; Ut < qe.length - 1; Ut++) {
              var Pt = qe[Ut];
              if (Z[Pt] & (P | j)) {
                for (
                  var Tt = 0, vn = 0, En = Ut - 1;
                  En >= 0 && ((Tt = Z[qe[En]]), !!(Tt & l));
                  En--
                );
                for (
                  var bn = Ut + 1;
                  bn < qe.length && ((vn = Z[qe[bn]]), !!(vn & l));
                  bn++
                );
                Tt === vn &&
                  (Z[Pt] === P ? Tt === R : Tt & (R | D)) &&
                  he(Pt, Tt);
              }
            }
          if (ce.get(R))
            for (var Bn = 0; Bn < qe.length; Bn++) {
              var lr = qe[Bn];
              if (Z[lr] & R) {
                for (var Vr = Bn - 1; Vr >= 0 && Z[qe[Vr]] & (F | l); Vr--)
                  he(qe[Vr], R);
                for (Bn++; Bn < qe.length && Z[qe[Bn]] & (F | l | R); Bn++)
                  Z[qe[Bn]] !== R && he(qe[Bn], R);
              }
            }
          if (ce.get(F) || ce.get(P) || ce.get(j))
            for (var Ui = 0; Ui < qe.length; Ui++) {
              var ki = qe[Ui];
              if (Z[ki] & (F | P | j)) {
                he(ki, W);
                for (var Or = Ui - 1; Or >= 0 && Z[qe[Or]] & l; Or--)
                  he(qe[Or], W);
                for (var Si = Ui + 1; Si < qe.length && Z[qe[Si]] & l; Si++)
                  he(qe[Si], W);
              }
            }
          if (ce.get(R))
            for (var nr = 0, No = bt; nr < qe.length; nr++) {
              var Bi = qe[nr],
                oo = Z[Bi];
              oo & R ? No === T && he(Bi, T) : oo & a && (No = oo);
            }
          if (ce.get(s)) {
            var ei = I | R | D,
              ao = ei | T,
              ti = [];
            {
              for (var Hi = [], _i = 0; _i < qe.length; _i++)
                if (Z[qe[_i]] & s) {
                  var Wt = pe[qe[_i]],
                    us = void 0;
                  if (w(Wt) !== null)
                    if (Hi.length < 63) Hi.push({ char: Wt, seqIndex: _i });
                    else break;
                  else if ((us = A(Wt)) !== null)
                    for (var so = Hi.length - 1; so >= 0; so--) {
                      var za = Hi[so].char;
                      if (za === us || za === A(M(Wt)) || w(M(za)) === Wt) {
                        ti.push([Hi[so].seqIndex, _i]), (Hi.length = so);
                        break;
                      }
                    }
                }
              ti.sort(function (Dr, Ei) {
                return Dr[0] - Ei[0];
              });
            }
            for (var vt = 0; vt < ti.length; vt++) {
              for (
                var zt = ti[vt],
                  jt = zt[0],
                  Nn = zt[1],
                  Fn = !1,
                  vr = 0,
                  ds = jt + 1;
                ds < Nn;
                ds++
              ) {
                var Ua = qe[ds];
                if (Z[Ua] & ao) {
                  Fn = !0;
                  var Nr = Z[Ua] & ei ? I : T;
                  if (Nr === Mt) {
                    vr = Nr;
                    break;
                  }
                }
              }
              if (Fn && !vr) {
                vr = bt;
                for (var Ff = jt - 1; Ff >= 0; Ff--) {
                  var zm = qe[Ff];
                  if (Z[zm] & ao) {
                    var lo = Z[zm] & ei ? I : T;
                    lo !== Mt ? (vr = lo) : (vr = Mt);
                    break;
                  }
                }
              }
              if (vr) {
                if (((Z[qe[jt]] = Z[qe[Nn]] = vr), vr !== Mt)) {
                  for (var bi = jt + 1; bi < qe.length; bi++)
                    if (!(Z[qe[bi]] & l)) {
                      p(pe[qe[bi]]) & B && (Z[qe[bi]] = vr);
                      break;
                    }
                }
                if (vr !== Mt) {
                  for (var ka = Nn + 1; ka < qe.length; ka++)
                    if (!(Z[qe[ka]] & l)) {
                      p(pe[qe[ka]]) & B && (Z[qe[ka]] = vr);
                      break;
                    }
                }
              }
            }
            for (var Fo = 0; Fo < qe.length; Fo++)
              if (Z[qe[Fo]] & s) {
                for (var Df = Fo, zf = Fo, ji = bt, tc = Fo - 1; tc >= 0; tc--)
                  if (Z[qe[tc]] & l) Df = tc;
                  else {
                    ji = Z[qe[tc]] & ei ? I : T;
                    break;
                  }
                for (var nc = Lt, rc = Fo + 1; rc < qe.length; rc++)
                  if (Z[qe[rc]] & (s | l)) zf = rc;
                  else {
                    nc = Z[qe[rc]] & ei ? I : T;
                    break;
                  }
                for (var wi = Df; wi <= zf; wi++)
                  Z[qe[wi]] = ji === nc ? ji : Mt;
                Fo = zf;
              }
          }
        }
        for (var Fr = Oe.start; Fr <= Oe.end; Fr++) {
          var Au = Me[Fr],
            sa = Z[Fr];
          if (
            (Au & 1
              ? sa & (T | R | D) && Me[Fr]++
              : sa & I
              ? Me[Fr]++
              : sa & (D | R) && (Me[Fr] += 2),
            sa & l && (Me[Fr] = Fr === 0 ? Oe.level : Me[Fr - 1]),
            Fr === Oe.end || p(pe[Fr]) & (V | N))
          )
            for (var Zs = Fr; Zs >= 0 && p(pe[Zs]) & c; Zs--) Me[Zs] = Oe.level;
        }
      }
      return { levels: Me, paragraphs: Le };
      function Ru(Dr, Ei) {
        for (var cr = Dr; cr < pe.length; cr++) {
          var ur = Z[cr];
          if (ur & (I | $)) return 1;
          if (ur & (N | T) || (Ei && ur === le)) return 0;
          if (ur & o) {
            var co = Um(cr);
            cr = co === -1 ? pe.length : co;
          }
        }
        return 0;
      }
      function Um(Dr) {
        for (var Ei = 1, cr = Dr + 1; cr < pe.length; cr++) {
          var ur = Z[cr];
          if (ur & N) break;
          if (ur & le) {
            if (--Ei === 0) return cr;
          } else ur & o && Ei++;
        }
        return -1;
      }
    }
    var me =
        "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",
      se;
    function Y() {
      if (!se) {
        var pe = S(me, !0),
          H = pe.map,
          z = pe.reverseMap;
        z.forEach(function (Z, ge) {
          H.set(ge, Z);
        }),
          (se = H);
      }
    }
    function ve(pe) {
      return Y(), se.get(pe) || null;
    }
    function de(pe, H, z, Z) {
      var ge = pe.length;
      (z = Math.max(0, z == null ? 0 : +z)),
        (Z = Math.min(ge - 1, Z == null ? ge - 1 : +Z));
      for (var ce = new Map(), he = z; he <= Z; he++)
        if (H[he] & 1) {
          var Me = ve(pe[he]);
          Me !== null && ce.set(he, Me);
        }
      return ce;
    }
    function ue(pe, H, z, Z) {
      var ge = pe.length;
      (z = Math.max(0, z == null ? 0 : +z)),
        (Z = Math.min(ge - 1, Z == null ? ge - 1 : +Z));
      var ce = [];
      return (
        H.paragraphs.forEach(function (he) {
          var Me = Math.max(z, he.start),
            Re = Math.min(Z, he.end);
          if (Me < Re) {
            for (
              var Le = H.levels.slice(Me, Re + 1), Oe = Re;
              Oe >= Me && p(pe[Oe]) & c;
              Oe--
            )
              Le[Oe] = he.level;
            for (var Pe = he.level, Se = 1 / 0, Je = 0; Je < Le.length; Je++) {
              var st = Le[Je];
              st > Pe && (Pe = st), st < Se && (Se = st | 1);
            }
            for (var Qe = Pe; Qe >= Se; Qe--)
              for (var Ke = 0; Ke < Le.length; Ke++)
                if (Le[Ke] >= Qe) {
                  for (var Ne = Ke; Ke + 1 < Le.length && Le[Ke + 1] >= Qe; )
                    Ke++;
                  Ke > Ne && ce.push([Ne + Me, Ke + Me]);
                }
          }
        }),
        ce
      );
    }
    function fe(pe, H, z, Z) {
      var ge = Te(pe, H, z, Z),
        ce = [].concat(pe);
      return (
        ge.forEach(function (he, Me) {
          ce[Me] = (H.levels[he] & 1 ? ve(pe[he]) : null) || pe[he];
        }),
        ce.join("")
      );
    }
    function Te(pe, H, z, Z) {
      for (var ge = ue(pe, H, z, Z), ce = [], he = 0; he < pe.length; he++)
        ce[he] = he;
      return (
        ge.forEach(function (Me) {
          for (
            var Re = Me[0],
              Le = Me[1],
              Oe = ce.slice(Re, Le + 1),
              Pe = Oe.length;
            Pe--;

          )
            ce[Le - Pe] = Oe[Pe];
        }),
        ce
      );
    }
    return (
      (e.closingToOpeningBracket = A),
      (e.getBidiCharType = p),
      (e.getBidiCharTypeName = m),
      (e.getCanonicalBracket = M),
      (e.getEmbeddingLevels = _e),
      (e.getMirroredCharacter = ve),
      (e.getMirroredCharactersMap = de),
      (e.getReorderSegments = ue),
      (e.getReorderedIndices = Te),
      (e.getReorderedString = fe),
      (e.openingToClosingBracket = w),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return t;
}
const Nz = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function Ww(t) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function n(r, i) {
    let o = Xt[i];
    return o ? Ww(o) : r;
  }
  return t.replace(e, n);
}
const Xr = [];
for (let t = 0; t < 256; t++) Xr[t] = (t < 16 ? "0" : "") + t.toString(16);
function _X() {
  const t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Xr[t & 255] +
    Xr[(t >> 8) & 255] +
    Xr[(t >> 16) & 255] +
    Xr[(t >> 24) & 255] +
    "-" +
    Xr[e & 255] +
    Xr[(e >> 8) & 255] +
    "-" +
    Xr[((e >> 16) & 15) | 64] +
    Xr[(e >> 24) & 255] +
    "-" +
    Xr[(n & 63) | 128] +
    Xr[(n >> 8) & 255] +
    "-" +
    Xr[(n >> 16) & 255] +
    Xr[(n >> 24) & 255] +
    Xr[r & 255] +
    Xr[(r >> 8) & 255] +
    Xr[(r >> 16) & 255] +
    Xr[(r >> 24) & 255]
  ).toUpperCase();
}
const wc =
    Object.assign ||
    function () {
      let t = arguments[0];
      for (let e = 1, n = arguments.length; e < n; e++) {
        let r = arguments[e];
        if (r)
          for (let i in r)
            Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
      }
      return t;
    },
  bX = Date.now(),
  m3 = new WeakMap(),
  g3 = new Map();
let wX = 1e10;
function Xw(t, e) {
  const n = TX(e);
  let r = m3.get(t);
  if ((r || m3.set(t, (r = Object.create(null))), r[n])) return new r[n]();
  const i = `_onBeforeCompile${n}`,
    o = function (c, u) {
      t.onBeforeCompile.call(this, c, u);
      const d =
        this.customProgramCacheKey() +
        "|" +
        c.vertexShader +
        "|" +
        c.fragmentShader;
      let p = g3[d];
      if (!p) {
        const m = EX(this, c, e, n);
        p = g3[d] = m;
      }
      (c.vertexShader = p.vertexShader),
        (c.fragmentShader = p.fragmentShader),
        wc(c.uniforms, this.uniforms),
        e.timeUniform &&
          (c.uniforms[e.timeUniform] = {
            get value() {
              return Date.now() - bX;
            },
          }),
        this[i] && this[i](c);
    },
    a = function () {
      return s(e.chained ? t : t.clone());
    },
    s = function (c) {
      const u = Object.create(c, l);
      return (
        Object.defineProperty(u, "baseMaterial", { value: t }),
        Object.defineProperty(u, "id", { value: wX++ }),
        (u.uuid = _X()),
        (u.uniforms = wc({}, c.uniforms, e.uniforms)),
        (u.defines = wc({}, c.defines, e.defines)),
        (u.defines[`TROIKA_DERIVED_MATERIAL_${n}`] = ""),
        (u.extensions = wc({}, c.extensions, e.extensions)),
        (u._listeners = void 0),
        u
      );
    },
    l = {
      constructor: { value: a },
      isDerivedMaterial: { value: !0 },
      type: {
        get: () => t.type,
        set: (c) => {
          t.type = c;
        },
      },
      isDerivedFrom: {
        writable: !0,
        configurable: !0,
        value: function (c) {
          const u = this.baseMaterial;
          return c === u || (u.isDerivedMaterial && u.isDerivedFrom(c)) || !1;
        },
      },
      customProgramCacheKey: {
        writable: !0,
        configurable: !0,
        value: function () {
          return t.customProgramCacheKey() + "|" + n;
        },
      },
      onBeforeCompile: {
        get() {
          return o;
        },
        set(c) {
          this[i] = c;
        },
      },
      copy: {
        writable: !0,
        configurable: !0,
        value: function (c) {
          return (
            t.copy.call(this, c),
            !t.isShaderMaterial &&
              !t.isDerivedMaterial &&
              (wc(this.extensions, c.extensions),
              wc(this.defines, c.defines),
              wc(this.uniforms, Up.clone(c.uniforms))),
            this
          );
        },
      },
      clone: {
        writable: !0,
        configurable: !0,
        value: function () {
          const c = new t.constructor();
          return s(c).copy(this);
        },
      },
      getDepthMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let c = this._depthMaterial;
          return (
            c ||
              ((c = this._depthMaterial =
                Xw(
                  t.isDerivedMaterial
                    ? t.getDepthMaterial()
                    : new i1({ depthPacking: tC }),
                  e
                )),
              (c.defines.IS_DEPTH_MATERIAL = ""),
              (c.uniforms = this.uniforms)),
            c
          );
        },
      },
      getDistanceMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let c = this._distanceMaterial;
          return (
            c ||
              ((c = this._distanceMaterial =
                Xw(
                  t.isDerivedMaterial ? t.getDistanceMaterial() : new o1(),
                  e
                )),
              (c.defines.IS_DISTANCE_MATERIAL = ""),
              (c.uniforms = this.uniforms)),
            c
          );
        },
      },
      dispose: {
        writable: !0,
        configurable: !0,
        value() {
          const { _depthMaterial: c, _distanceMaterial: u } = this;
          c && c.dispose(), u && u.dispose(), t.dispose.call(this);
        },
      },
    };
  return (r[n] = a), new a();
}
function EX(t, { vertexShader: e, fragmentShader: n }, r, i) {
  let {
    vertexDefs: o,
    vertexMainIntro: a,
    vertexMainOutro: s,
    vertexTransform: l,
    fragmentDefs: c,
    fragmentMainIntro: u,
    fragmentMainOutro: d,
    fragmentColorTransform: p,
    customRewriter: m,
    timeUniform: v,
  } = r;
  if (
    ((o = o || ""),
    (a = a || ""),
    (s = s || ""),
    (c = c || ""),
    (u = u || ""),
    (d = d || ""),
    (l || m) && (e = Ww(e)),
    (p || m) &&
      ((n = n.replace(
        /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
        `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
      )),
      (n = Ww(n))),
    m)
  ) {
    let S = m({ vertexShader: e, fragmentShader: n });
    (e = S.vertexShader), (n = S.fragmentShader);
  }
  if (p) {
    let S = [];
    (n = n.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      (x) => (S.push(x), "")
    )),
      (d = `${p}
${S.join(`
`)}
${d}`);
  }
  if (v) {
    const S = `
uniform float ${v};
`;
    (o = S + o), (c = S + c);
  }
  return (
    l &&
      ((e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`),
      (o = `${o}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`),
      (a = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${a}
`),
      (e = e.replace(/\b(position|normal|uv)\b/g, (S, x, g, _) =>
        /\battribute\s+vec[23]\s+$/.test(_.substr(0, g))
          ? x
          : `troika_${x}_${i}`
      )),
      (t.map && t.map.channel > 0) ||
        (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))),
    (e = v3(e, i, o, a, s)),
    (n = v3(n, i, c, u, d)),
    { vertexShader: e, fragmentShader: n }
  );
}
function v3(t, e, n, r, i) {
  return (
    (r || i || n) &&
      ((t = t.replace(
        Nz,
        `
${n}
void troikaOrigMain${e}() {`
      )),
      (t += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${i}
}`)),
    t
  );
}
function MX(t, e) {
  return t === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let CX = 0;
const y3 = new Map();
function TX(t) {
  const e = JSON.stringify(t, MX);
  let n = y3.get(e);
  return n == null && y3.set(e, (n = ++CX)), n;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/ function AX() {
  return (
    typeof window > "u" && (self.window = self),
    (function (t) {
      var e = {
        parse: function (i) {
          var o = e._bin,
            a = new Uint8Array(i);
          if (o.readASCII(a, 0, 4) == "ttcf") {
            var s = 4;
            o.readUshort(a, s), (s += 2), o.readUshort(a, s), (s += 2);
            var l = o.readUint(a, s);
            s += 4;
            for (var c = [], u = 0; u < l; u++) {
              var d = o.readUint(a, s);
              (s += 4), c.push(e._readFont(a, d));
            }
            return c;
          }
          return [e._readFont(a, 0)];
        },
        _readFont: function (i, o) {
          var a = e._bin,
            s = o;
          a.readFixed(i, o), (o += 4);
          var l = a.readUshort(i, o);
          (o += 2),
            a.readUshort(i, o),
            (o += 2),
            a.readUshort(i, o),
            (o += 2),
            a.readUshort(i, o),
            (o += 2);
          for (
            var c = [
                "cmap",
                "head",
                "hhea",
                "maxp",
                "hmtx",
                "name",
                "OS/2",
                "post",
                "loca",
                "glyf",
                "kern",
                "CFF ",
                "GDEF",
                "GPOS",
                "GSUB",
                "SVG ",
              ],
              u = { _data: i, _offset: s },
              d = {},
              p = 0;
            p < l;
            p++
          ) {
            var m = a.readASCII(i, o, 4);
            (o += 4), a.readUint(i, o), (o += 4);
            var v = a.readUint(i, o);
            o += 4;
            var S = a.readUint(i, o);
            (o += 4), (d[m] = { offset: v, length: S });
          }
          for (p = 0; p < c.length; p++) {
            var x = c[p];
            d[x] &&
              (u[x.trim()] = e[x.trim()].parse(i, d[x].offset, d[x].length, u));
          }
          return u;
        },
        _tabOffset: function (i, o, a) {
          for (
            var s = e._bin, l = s.readUshort(i, a + 4), c = a + 12, u = 0;
            u < l;
            u++
          ) {
            var d = s.readASCII(i, c, 4);
            (c += 4), s.readUint(i, c), (c += 4);
            var p = s.readUint(i, c);
            if (((c += 4), s.readUint(i, c), (c += 4), d == o)) return p;
          }
          return 0;
        },
      };
      (e._bin = {
        readFixed: function (i, o) {
          return (
            ((i[o] << 8) | i[o + 1]) + ((i[o + 2] << 8) | i[o + 3]) / 65540
          );
        },
        readF2dot14: function (i, o) {
          return e._bin.readShort(i, o) / 16384;
        },
        readInt: function (i, o) {
          return e._bin._view(i).getInt32(o);
        },
        readInt8: function (i, o) {
          return e._bin._view(i).getInt8(o);
        },
        readShort: function (i, o) {
          return e._bin._view(i).getInt16(o);
        },
        readUshort: function (i, o) {
          return e._bin._view(i).getUint16(o);
        },
        readUshorts: function (i, o, a) {
          for (var s = [], l = 0; l < a; l++)
            s.push(e._bin.readUshort(i, o + 2 * l));
          return s;
        },
        readUint: function (i, o) {
          return e._bin._view(i).getUint32(o);
        },
        readUint64: function (i, o) {
          return 4294967296 * e._bin.readUint(i, o) + e._bin.readUint(i, o + 4);
        },
        readASCII: function (i, o, a) {
          for (var s = "", l = 0; l < a; l++)
            s += String.fromCharCode(i[o + l]);
          return s;
        },
        readUnicode: function (i, o, a) {
          for (var s = "", l = 0; l < a; l++) {
            var c = (i[o++] << 8) | i[o++];
            s += String.fromCharCode(c);
          }
          return s;
        },
        _tdec:
          typeof window < "u" && window.TextDecoder
            ? new window.TextDecoder()
            : null,
        readUTF8: function (i, o, a) {
          var s = e._bin._tdec;
          return s && o == 0 && a == i.length
            ? s.decode(i)
            : e._bin.readASCII(i, o, a);
        },
        readBytes: function (i, o, a) {
          for (var s = [], l = 0; l < a; l++) s.push(i[o + l]);
          return s;
        },
        readASCIIArray: function (i, o, a) {
          for (var s = [], l = 0; l < a; l++)
            s.push(String.fromCharCode(i[o + l]));
          return s;
        },
        _view: function (i) {
          return (
            i._dataView ||
            (i._dataView = i.buffer
              ? new DataView(i.buffer, i.byteOffset, i.byteLength)
              : new DataView(new Uint8Array(i).buffer))
          );
        },
      }),
        (e._lctf = {}),
        (e._lctf.parse = function (i, o, a, s, l) {
          var c = e._bin,
            u = {},
            d = o;
          c.readFixed(i, o), (o += 4);
          var p = c.readUshort(i, o);
          o += 2;
          var m = c.readUshort(i, o);
          o += 2;
          var v = c.readUshort(i, o);
          return (
            (o += 2),
            (u.scriptList = e._lctf.readScriptList(i, d + p)),
            (u.featureList = e._lctf.readFeatureList(i, d + m)),
            (u.lookupList = e._lctf.readLookupList(i, d + v, l)),
            u
          );
        }),
        (e._lctf.readLookupList = function (i, o, a) {
          var s = e._bin,
            l = o,
            c = [],
            u = s.readUshort(i, o);
          o += 2;
          for (var d = 0; d < u; d++) {
            var p = s.readUshort(i, o);
            o += 2;
            var m = e._lctf.readLookupTable(i, l + p, a);
            c.push(m);
          }
          return c;
        }),
        (e._lctf.readLookupTable = function (i, o, a) {
          var s = e._bin,
            l = o,
            c = { tabs: [] };
          (c.ltype = s.readUshort(i, o)),
            (o += 2),
            (c.flag = s.readUshort(i, o)),
            (o += 2);
          var u = s.readUshort(i, o);
          o += 2;
          for (var d = c.ltype, p = 0; p < u; p++) {
            var m = s.readUshort(i, o);
            o += 2;
            var v = a(i, d, l + m, c);
            c.tabs.push(v);
          }
          return c;
        }),
        (e._lctf.numOfOnes = function (i) {
          for (var o = 0, a = 0; a < 32; a++) (i >>> a) & 1 && o++;
          return o;
        }),
        (e._lctf.readClassDef = function (i, o) {
          var a = e._bin,
            s = [],
            l = a.readUshort(i, o);
          if (((o += 2), l == 1)) {
            var c = a.readUshort(i, o);
            o += 2;
            var u = a.readUshort(i, o);
            o += 2;
            for (var d = 0; d < u; d++)
              s.push(c + d),
                s.push(c + d),
                s.push(a.readUshort(i, o)),
                (o += 2);
          }
          if (l == 2) {
            var p = a.readUshort(i, o);
            for (o += 2, d = 0; d < p; d++)
              s.push(a.readUshort(i, o)),
                (o += 2),
                s.push(a.readUshort(i, o)),
                (o += 2),
                s.push(a.readUshort(i, o)),
                (o += 2);
          }
          return s;
        }),
        (e._lctf.getInterval = function (i, o) {
          for (var a = 0; a < i.length; a += 3) {
            var s = i[a],
              l = i[a + 1];
            if ((i[a + 2], s <= o && o <= l)) return a;
          }
          return -1;
        }),
        (e._lctf.readCoverage = function (i, o) {
          var a = e._bin,
            s = {};
          (s.fmt = a.readUshort(i, o)), (o += 2);
          var l = a.readUshort(i, o);
          return (
            (o += 2),
            s.fmt == 1 && (s.tab = a.readUshorts(i, o, l)),
            s.fmt == 2 && (s.tab = a.readUshorts(i, o, 3 * l)),
            s
          );
        }),
        (e._lctf.coverageIndex = function (i, o) {
          var a = i.tab;
          if (i.fmt == 1) return a.indexOf(o);
          if (i.fmt == 2) {
            var s = e._lctf.getInterval(a, o);
            if (s != -1) return a[s + 2] + (o - a[s]);
          }
          return -1;
        }),
        (e._lctf.readFeatureList = function (i, o) {
          var a = e._bin,
            s = o,
            l = [],
            c = a.readUshort(i, o);
          o += 2;
          for (var u = 0; u < c; u++) {
            var d = a.readASCII(i, o, 4);
            o += 4;
            var p = a.readUshort(i, o);
            o += 2;
            var m = e._lctf.readFeatureTable(i, s + p);
            (m.tag = d.trim()), l.push(m);
          }
          return l;
        }),
        (e._lctf.readFeatureTable = function (i, o) {
          var a = e._bin,
            s = o,
            l = {},
            c = a.readUshort(i, o);
          (o += 2), c > 0 && (l.featureParams = s + c);
          var u = a.readUshort(i, o);
          (o += 2), (l.tab = []);
          for (var d = 0; d < u; d++) l.tab.push(a.readUshort(i, o + 2 * d));
          return l;
        }),
        (e._lctf.readScriptList = function (i, o) {
          var a = e._bin,
            s = o,
            l = {},
            c = a.readUshort(i, o);
          o += 2;
          for (var u = 0; u < c; u++) {
            var d = a.readASCII(i, o, 4);
            o += 4;
            var p = a.readUshort(i, o);
            (o += 2), (l[d.trim()] = e._lctf.readScriptTable(i, s + p));
          }
          return l;
        }),
        (e._lctf.readScriptTable = function (i, o) {
          var a = e._bin,
            s = o,
            l = {},
            c = a.readUshort(i, o);
          (o += 2), c > 0 && (l.default = e._lctf.readLangSysTable(i, s + c));
          var u = a.readUshort(i, o);
          o += 2;
          for (var d = 0; d < u; d++) {
            var p = a.readASCII(i, o, 4);
            o += 4;
            var m = a.readUshort(i, o);
            (o += 2), (l[p.trim()] = e._lctf.readLangSysTable(i, s + m));
          }
          return l;
        }),
        (e._lctf.readLangSysTable = function (i, o) {
          var a = e._bin,
            s = {};
          a.readUshort(i, o),
            (o += 2),
            (s.reqFeature = a.readUshort(i, o)),
            (o += 2);
          var l = a.readUshort(i, o);
          return (o += 2), (s.features = a.readUshorts(i, o, l)), s;
        }),
        (e.CFF = {}),
        (e.CFF.parse = function (i, o, a) {
          var s = e._bin;
          (i = new Uint8Array(i.buffer, o, a))[(o = 0)],
            i[++o],
            i[++o],
            i[++o],
            o++;
          var l = [];
          o = e.CFF.readIndex(i, o, l);
          for (var c = [], u = 0; u < l.length - 1; u++)
            c.push(s.readASCII(i, o + l[u], l[u + 1] - l[u]));
          o += l[l.length - 1];
          var d = [];
          o = e.CFF.readIndex(i, o, d);
          var p = [];
          for (u = 0; u < d.length - 1; u++)
            p.push(e.CFF.readDict(i, o + d[u], o + d[u + 1]));
          o += d[d.length - 1];
          var m = p[0],
            v = [];
          o = e.CFF.readIndex(i, o, v);
          var S = [];
          for (u = 0; u < v.length - 1; u++)
            S.push(s.readASCII(i, o + v[u], v[u + 1] - v[u]));
          if (
            ((o += v[v.length - 1]), e.CFF.readSubrs(i, o, m), m.CharStrings)
          ) {
            (o = m.CharStrings), (v = []), (o = e.CFF.readIndex(i, o, v));
            var x = [];
            for (u = 0; u < v.length - 1; u++)
              x.push(s.readBytes(i, o + v[u], v[u + 1] - v[u]));
            m.CharStrings = x;
          }
          if (m.ROS) {
            o = m.FDArray;
            var g = [];
            for (
              o = e.CFF.readIndex(i, o, g), m.FDArray = [], u = 0;
              u < g.length - 1;
              u++
            ) {
              var _ = e.CFF.readDict(i, o + g[u], o + g[u + 1]);
              e.CFF._readFDict(i, _, S), m.FDArray.push(_);
            }
            (o += g[g.length - 1]), (o = m.FDSelect), (m.FDSelect = []);
            var y = i[o];
            if ((o++, y != 3)) throw y;
            var w = s.readUshort(i, o);
            for (o += 2, u = 0; u < w + 1; u++)
              m.FDSelect.push(s.readUshort(i, o), i[o + 2]), (o += 3);
          }
          return (
            m.Encoding &&
              (m.Encoding = e.CFF.readEncoding(
                i,
                m.Encoding,
                m.CharStrings.length
              )),
            m.charset &&
              (m.charset = e.CFF.readCharset(
                i,
                m.charset,
                m.CharStrings.length
              )),
            e.CFF._readFDict(i, m, S),
            m
          );
        }),
        (e.CFF._readFDict = function (i, o, a) {
          var s;
          for (var l in (o.Private &&
            ((s = o.Private[1]),
            (o.Private = e.CFF.readDict(i, s, s + o.Private[0])),
            o.Private.Subrs &&
              e.CFF.readSubrs(i, s + o.Private.Subrs, o.Private)),
          o))
            [
              "FamilyName",
              "FontName",
              "FullName",
              "Notice",
              "version",
              "Copyright",
            ].indexOf(l) != -1 && (o[l] = a[o[l] - 426 + 35]);
        }),
        (e.CFF.readSubrs = function (i, o, a) {
          var s = e._bin,
            l = [];
          o = e.CFF.readIndex(i, o, l);
          var c,
            u = l.length;
          (c = u < 1240 ? 107 : u < 33900 ? 1131 : 32768),
            (a.Bias = c),
            (a.Subrs = []);
          for (var d = 0; d < l.length - 1; d++)
            a.Subrs.push(s.readBytes(i, o + l[d], l[d + 1] - l[d]));
        }),
        (e.CFF.tableSE = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
          14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
          31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
          48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
          65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
          82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,
          107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119,
          120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0,
          132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0,
          0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0,
        ]),
        (e.CFF.glyphByUnicode = function (i, o) {
          for (var a = 0; a < i.charset.length; a++)
            if (i.charset[a] == o) return a;
          return -1;
        }),
        (e.CFF.glyphBySE = function (i, o) {
          return o < 0 || o > 255
            ? -1
            : e.CFF.glyphByUnicode(i, e.CFF.tableSE[o]);
        }),
        (e.CFF.readEncoding = function (i, o, a) {
          e._bin;
          var s = [".notdef"],
            l = i[o];
          if ((o++, l != 0)) throw "error: unknown encoding format: " + l;
          var c = i[o];
          o++;
          for (var u = 0; u < c; u++) s.push(i[o + u]);
          return s;
        }),
        (e.CFF.readCharset = function (i, o, a) {
          var s = e._bin,
            l = [".notdef"],
            c = i[o];
          if ((o++, c == 0))
            for (var u = 0; u < a; u++) {
              var d = s.readUshort(i, o);
              (o += 2), l.push(d);
            }
          else {
            if (c != 1 && c != 2) throw "error: format: " + c;
            for (; l.length < a; ) {
              (d = s.readUshort(i, o)), (o += 2);
              var p = 0;
              for (
                c == 1
                  ? ((p = i[o]), o++)
                  : ((p = s.readUshort(i, o)), (o += 2)),
                  u = 0;
                u <= p;
                u++
              )
                l.push(d), d++;
            }
          }
          return l;
        }),
        (e.CFF.readIndex = function (i, o, a) {
          var s = e._bin,
            l = s.readUshort(i, o) + 1,
            c = i[(o += 2)];
          if ((o++, c == 1)) for (var u = 0; u < l; u++) a.push(i[o + u]);
          else if (c == 2)
            for (u = 0; u < l; u++) a.push(s.readUshort(i, o + 2 * u));
          else if (c == 3)
            for (u = 0; u < l; u++)
              a.push(16777215 & s.readUint(i, o + 3 * u - 1));
          else if (l != 1)
            throw "unsupported offset size: " + c + ", count: " + l;
          return (o += l * c) - 1;
        }),
        (e.CFF.getCharString = function (i, o, a) {
          var s = e._bin,
            l = i[o],
            c = i[o + 1];
          i[o + 2], i[o + 3], i[o + 4];
          var u = 1,
            d = null,
            p = null;
          l <= 20 && ((d = l), (u = 1)),
            l == 12 && ((d = 100 * l + c), (u = 2)),
            21 <= l && l <= 27 && ((d = l), (u = 1)),
            l == 28 && ((p = s.readShort(i, o + 1)), (u = 3)),
            29 <= l && l <= 31 && ((d = l), (u = 1)),
            32 <= l && l <= 246 && ((p = l - 139), (u = 1)),
            247 <= l && l <= 250 && ((p = 256 * (l - 247) + c + 108), (u = 2)),
            251 <= l && l <= 254 && ((p = 256 * -(l - 251) - c - 108), (u = 2)),
            l == 255 && ((p = s.readInt(i, o + 1) / 65535), (u = 5)),
            (a.val = p ?? "o" + d),
            (a.size = u);
        }),
        (e.CFF.readCharString = function (i, o, a) {
          for (var s = o + a, l = e._bin, c = []; o < s; ) {
            var u = i[o],
              d = i[o + 1];
            i[o + 2], i[o + 3], i[o + 4];
            var p = 1,
              m = null,
              v = null;
            u <= 20 && ((m = u), (p = 1)),
              u == 12 && ((m = 100 * u + d), (p = 2)),
              (u != 19 && u != 20) || ((m = u), (p = 2)),
              21 <= u && u <= 27 && ((m = u), (p = 1)),
              u == 28 && ((v = l.readShort(i, o + 1)), (p = 3)),
              29 <= u && u <= 31 && ((m = u), (p = 1)),
              32 <= u && u <= 246 && ((v = u - 139), (p = 1)),
              247 <= u &&
                u <= 250 &&
                ((v = 256 * (u - 247) + d + 108), (p = 2)),
              251 <= u &&
                u <= 254 &&
                ((v = 256 * -(u - 251) - d - 108), (p = 2)),
              u == 255 && ((v = l.readInt(i, o + 1) / 65535), (p = 5)),
              c.push(v ?? "o" + m),
              (o += p);
          }
          return c;
        }),
        (e.CFF.readDict = function (i, o, a) {
          for (var s = e._bin, l = {}, c = []; o < a; ) {
            var u = i[o],
              d = i[o + 1];
            i[o + 2], i[o + 3], i[o + 4];
            var p = 1,
              m = null,
              v = null;
            if (
              (u == 28 && ((v = s.readShort(i, o + 1)), (p = 3)),
              u == 29 && ((v = s.readInt(i, o + 1)), (p = 5)),
              32 <= u && u <= 246 && ((v = u - 139), (p = 1)),
              247 <= u &&
                u <= 250 &&
                ((v = 256 * (u - 247) + d + 108), (p = 2)),
              251 <= u &&
                u <= 254 &&
                ((v = 256 * -(u - 251) - d - 108), (p = 2)),
              u == 255)
            )
              throw (
                ((v = s.readInt(i, o + 1) / 65535), (p = 5), "unknown number")
              );
            if (u == 30) {
              var S = [];
              for (p = 1; ; ) {
                var x = i[o + p];
                p++;
                var g = x >> 4,
                  _ = 15 & x;
                if ((g != 15 && S.push(g), _ != 15 && S.push(_), _ == 15))
                  break;
              }
              for (
                var y = "",
                  w = [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    ".",
                    "e",
                    "e-",
                    "reserved",
                    "-",
                    "endOfNumber",
                  ],
                  A = 0;
                A < S.length;
                A++
              )
                y += w[S[A]];
              v = parseFloat(y);
            }
            u <= 21 &&
              ((m = [
                "version",
                "Notice",
                "FullName",
                "FamilyName",
                "Weight",
                "FontBBox",
                "BlueValues",
                "OtherBlues",
                "FamilyBlues",
                "FamilyOtherBlues",
                "StdHW",
                "StdVW",
                "escape",
                "UniqueID",
                "XUID",
                "charset",
                "Encoding",
                "CharStrings",
                "Private",
                "Subrs",
                "defaultWidthX",
                "nominalWidthX",
              ][u]),
              (p = 1),
              u == 12 &&
                ((m = [
                  "Copyright",
                  "isFixedPitch",
                  "ItalicAngle",
                  "UnderlinePosition",
                  "UnderlineThickness",
                  "PaintType",
                  "CharstringType",
                  "FontMatrix",
                  "StrokeWidth",
                  "BlueScale",
                  "BlueShift",
                  "BlueFuzz",
                  "StemSnapH",
                  "StemSnapV",
                  "ForceBold",
                  0,
                  0,
                  "LanguageGroup",
                  "ExpansionFactor",
                  "initialRandomSeed",
                  "SyntheticBase",
                  "PostScript",
                  "BaseFontName",
                  "BaseFontBlend",
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  "ROS",
                  "CIDFontVersion",
                  "CIDFontRevision",
                  "CIDFontType",
                  "CIDCount",
                  "UIDBase",
                  "FDArray",
                  "FDSelect",
                  "FontName",
                ][d]),
                (p = 2))),
              m != null
                ? ((l[m] = c.length == 1 ? c[0] : c), (c = []))
                : c.push(v),
              (o += p);
          }
          return l;
        }),
        (e.cmap = {}),
        (e.cmap.parse = function (i, o, a) {
          (i = new Uint8Array(i.buffer, o, a)), (o = 0);
          var s = e._bin,
            l = {};
          s.readUshort(i, o), (o += 2);
          var c = s.readUshort(i, o);
          o += 2;
          var u = [];
          l.tables = [];
          for (var d = 0; d < c; d++) {
            var p = s.readUshort(i, o);
            o += 2;
            var m = s.readUshort(i, o);
            o += 2;
            var v = s.readUint(i, o);
            o += 4;
            var S = "p" + p + "e" + m,
              x = u.indexOf(v);
            if (x == -1) {
              var g;
              (x = l.tables.length), u.push(v);
              var _ = s.readUshort(i, v);
              _ == 0
                ? (g = e.cmap.parse0(i, v))
                : _ == 4
                ? (g = e.cmap.parse4(i, v))
                : _ == 6
                ? (g = e.cmap.parse6(i, v))
                : _ == 12
                ? (g = e.cmap.parse12(i, v))
                : console.debug("unknown format: " + _, p, m, v),
                l.tables.push(g);
            }
            if (l[S] != null) throw "multiple tables for one platform+encoding";
            l[S] = x;
          }
          return l;
        }),
        (e.cmap.parse0 = function (i, o) {
          var a = e._bin,
            s = {};
          (s.format = a.readUshort(i, o)), (o += 2);
          var l = a.readUshort(i, o);
          (o += 2), a.readUshort(i, o), (o += 2), (s.map = []);
          for (var c = 0; c < l - 6; c++) s.map.push(i[o + c]);
          return s;
        }),
        (e.cmap.parse4 = function (i, o) {
          var a = e._bin,
            s = o,
            l = {};
          (l.format = a.readUshort(i, o)), (o += 2);
          var c = a.readUshort(i, o);
          (o += 2), a.readUshort(i, o), (o += 2);
          var u = a.readUshort(i, o);
          o += 2;
          var d = u / 2;
          (l.searchRange = a.readUshort(i, o)),
            (o += 2),
            (l.entrySelector = a.readUshort(i, o)),
            (o += 2),
            (l.rangeShift = a.readUshort(i, o)),
            (o += 2),
            (l.endCount = a.readUshorts(i, o, d)),
            (o += 2 * d),
            (o += 2),
            (l.startCount = a.readUshorts(i, o, d)),
            (o += 2 * d),
            (l.idDelta = []);
          for (var p = 0; p < d; p++)
            l.idDelta.push(a.readShort(i, o)), (o += 2);
          for (
            l.idRangeOffset = a.readUshorts(i, o, d),
              o += 2 * d,
              l.glyphIdArray = [];
            o < s + c;

          )
            l.glyphIdArray.push(a.readUshort(i, o)), (o += 2);
          return l;
        }),
        (e.cmap.parse6 = function (i, o) {
          var a = e._bin,
            s = {};
          (s.format = a.readUshort(i, o)),
            (o += 2),
            a.readUshort(i, o),
            (o += 2),
            a.readUshort(i, o),
            (o += 2),
            (s.firstCode = a.readUshort(i, o)),
            (o += 2);
          var l = a.readUshort(i, o);
          (o += 2), (s.glyphIdArray = []);
          for (var c = 0; c < l; c++)
            s.glyphIdArray.push(a.readUshort(i, o)), (o += 2);
          return s;
        }),
        (e.cmap.parse12 = function (i, o) {
          var a = e._bin,
            s = {};
          (s.format = a.readUshort(i, o)),
            (o += 2),
            (o += 2),
            a.readUint(i, o),
            (o += 4),
            a.readUint(i, o),
            (o += 4);
          var l = a.readUint(i, o);
          (o += 4), (s.groups = []);
          for (var c = 0; c < l; c++) {
            var u = o + 12 * c,
              d = a.readUint(i, u + 0),
              p = a.readUint(i, u + 4),
              m = a.readUint(i, u + 8);
            s.groups.push([d, p, m]);
          }
          return s;
        }),
        (e.glyf = {}),
        (e.glyf.parse = function (i, o, a, s) {
          for (var l = [], c = 0; c < s.maxp.numGlyphs; c++) l.push(null);
          return l;
        }),
        (e.glyf._parseGlyf = function (i, o) {
          var a = e._bin,
            s = i._data,
            l = e._tabOffset(s, "glyf", i._offset) + i.loca[o];
          if (i.loca[o] == i.loca[o + 1]) return null;
          var c = {};
          if (
            ((c.noc = a.readShort(s, l)),
            (l += 2),
            (c.xMin = a.readShort(s, l)),
            (l += 2),
            (c.yMin = a.readShort(s, l)),
            (l += 2),
            (c.xMax = a.readShort(s, l)),
            (l += 2),
            (c.yMax = a.readShort(s, l)),
            (l += 2),
            c.xMin >= c.xMax || c.yMin >= c.yMax)
          )
            return null;
          if (c.noc > 0) {
            c.endPts = [];
            for (var u = 0; u < c.noc; u++)
              c.endPts.push(a.readUshort(s, l)), (l += 2);
            var d = a.readUshort(s, l);
            if (((l += 2), s.length - l < d)) return null;
            (c.instructions = a.readBytes(s, l, d)), (l += d);
            var p = c.endPts[c.noc - 1] + 1;
            for (c.flags = [], u = 0; u < p; u++) {
              var m = s[l];
              if ((l++, c.flags.push(m), (8 & m) != 0)) {
                var v = s[l];
                l++;
                for (var S = 0; S < v; S++) c.flags.push(m), u++;
              }
            }
            for (c.xs = [], u = 0; u < p; u++) {
              var x = (2 & c.flags[u]) != 0,
                g = (16 & c.flags[u]) != 0;
              x
                ? (c.xs.push(g ? s[l] : -s[l]), l++)
                : g
                ? c.xs.push(0)
                : (c.xs.push(a.readShort(s, l)), (l += 2));
            }
            for (c.ys = [], u = 0; u < p; u++)
              (x = (4 & c.flags[u]) != 0),
                (g = (32 & c.flags[u]) != 0),
                x
                  ? (c.ys.push(g ? s[l] : -s[l]), l++)
                  : g
                  ? c.ys.push(0)
                  : (c.ys.push(a.readShort(s, l)), (l += 2));
            var _ = 0,
              y = 0;
            for (u = 0; u < p; u++)
              (_ += c.xs[u]), (y += c.ys[u]), (c.xs[u] = _), (c.ys[u] = y);
          } else {
            var w;
            c.parts = [];
            do {
              (w = a.readUshort(s, l)), (l += 2);
              var A = {
                m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 },
                p1: -1,
                p2: -1,
              };
              if (
                (c.parts.push(A),
                (A.glyphIndex = a.readUshort(s, l)),
                (l += 2),
                1 & w)
              ) {
                var M = a.readShort(s, l);
                l += 2;
                var T = a.readShort(s, l);
                l += 2;
              } else (M = a.readInt8(s, l)), l++, (T = a.readInt8(s, l)), l++;
              2 & w ? ((A.m.tx = M), (A.m.ty = T)) : ((A.p1 = M), (A.p2 = T)),
                8 & w
                  ? ((A.m.a = A.m.d = a.readF2dot14(s, l)), (l += 2))
                  : 64 & w
                  ? ((A.m.a = a.readF2dot14(s, l)),
                    (l += 2),
                    (A.m.d = a.readF2dot14(s, l)),
                    (l += 2))
                  : 128 & w &&
                    ((A.m.a = a.readF2dot14(s, l)),
                    (l += 2),
                    (A.m.b = a.readF2dot14(s, l)),
                    (l += 2),
                    (A.m.c = a.readF2dot14(s, l)),
                    (l += 2),
                    (A.m.d = a.readF2dot14(s, l)),
                    (l += 2));
            } while (32 & w);
            if (256 & w) {
              var I = a.readUshort(s, l);
              for (l += 2, c.instr = [], u = 0; u < I; u++)
                c.instr.push(s[l]), l++;
            }
          }
          return c;
        }),
        (e.GDEF = {}),
        (e.GDEF.parse = function (i, o, a, s) {
          var l = o;
          o += 4;
          var c = e._bin.readUshort(i, o);
          return {
            glyphClassDef: c === 0 ? null : e._lctf.readClassDef(i, l + c),
          };
        }),
        (e.GPOS = {}),
        (e.GPOS.parse = function (i, o, a, s) {
          return e._lctf.parse(i, o, a, s, e.GPOS.subt);
        }),
        (e.GPOS.subt = function (i, o, a, s) {
          var l = e._bin,
            c = a,
            u = {};
          if (
            ((u.fmt = l.readUshort(i, a)),
            (a += 2),
            o == 1 || o == 2 || o == 3 || o == 7 || (o == 8 && u.fmt <= 2))
          ) {
            var d = l.readUshort(i, a);
            (a += 2), (u.coverage = e._lctf.readCoverage(i, d + c));
          }
          if (o == 1 && u.fmt == 1) {
            var p = l.readUshort(i, a);
            (a += 2), p != 0 && (u.pos = e.GPOS.readValueRecord(i, a, p));
          } else if (o == 2 && u.fmt >= 1 && u.fmt <= 2) {
            (p = l.readUshort(i, a)), (a += 2);
            var m = l.readUshort(i, a);
            a += 2;
            var v = e._lctf.numOfOnes(p),
              S = e._lctf.numOfOnes(m);
            if (u.fmt == 1) {
              u.pairsets = [];
              var x = l.readUshort(i, a);
              a += 2;
              for (var g = 0; g < x; g++) {
                var _ = c + l.readUshort(i, a);
                a += 2;
                var y = l.readUshort(i, _);
                _ += 2;
                for (var w = [], A = 0; A < y; A++) {
                  var M = l.readUshort(i, _);
                  (_ += 2),
                    p != 0 &&
                      ((D = e.GPOS.readValueRecord(i, _, p)), (_ += 2 * v)),
                    m != 0 &&
                      ((j = e.GPOS.readValueRecord(i, _, m)), (_ += 2 * S)),
                    w.push({ gid2: M, val1: D, val2: j });
                }
                u.pairsets.push(w);
              }
            }
            if (u.fmt == 2) {
              var T = l.readUshort(i, a);
              a += 2;
              var I = l.readUshort(i, a);
              a += 2;
              var R = l.readUshort(i, a);
              a += 2;
              var P = l.readUshort(i, a);
              for (
                a += 2,
                  u.classDef1 = e._lctf.readClassDef(i, c + T),
                  u.classDef2 = e._lctf.readClassDef(i, c + I),
                  u.matrix = [],
                  g = 0;
                g < R;
                g++
              ) {
                var F = [];
                for (A = 0; A < P; A++) {
                  var D = null,
                    j = null;
                  p != 0 &&
                    ((D = e.GPOS.readValueRecord(i, a, p)), (a += 2 * v)),
                    m != 0 &&
                      ((j = e.GPOS.readValueRecord(i, a, m)), (a += 2 * S)),
                    F.push({ val1: D, val2: j });
                }
                u.matrix.push(F);
              }
            }
          } else if (o == 4 && u.fmt == 1)
            (u.markCoverage = e._lctf.readCoverage(i, l.readUshort(i, a) + c)),
              (u.baseCoverage = e._lctf.readCoverage(
                i,
                l.readUshort(i, a + 2) + c
              )),
              (u.markClassCount = l.readUshort(i, a + 4)),
              (u.markArray = e.GPOS.readMarkArray(
                i,
                l.readUshort(i, a + 6) + c
              )),
              (u.baseArray = e.GPOS.readBaseArray(
                i,
                l.readUshort(i, a + 8) + c,
                u.markClassCount
              ));
          else if (o == 6 && u.fmt == 1)
            (u.mark1Coverage = e._lctf.readCoverage(i, l.readUshort(i, a) + c)),
              (u.mark2Coverage = e._lctf.readCoverage(
                i,
                l.readUshort(i, a + 2) + c
              )),
              (u.markClassCount = l.readUshort(i, a + 4)),
              (u.mark1Array = e.GPOS.readMarkArray(
                i,
                l.readUshort(i, a + 6) + c
              )),
              (u.mark2Array = e.GPOS.readBaseArray(
                i,
                l.readUshort(i, a + 8) + c,
                u.markClassCount
              ));
          else {
            if (o == 9 && u.fmt == 1) {
              var N = l.readUshort(i, a);
              a += 2;
              var V = l.readUint(i, a);
              if (((a += 4), s.ltype == 9)) s.ltype = N;
              else if (s.ltype != N) throw "invalid extension substitution";
              return e.GPOS.subt(i, s.ltype, c + V);
            }
            console.debug(
              "unsupported GPOS table LookupType",
              o,
              "format",
              u.fmt
            );
          }
          return u;
        }),
        (e.GPOS.readValueRecord = function (i, o, a) {
          var s = e._bin,
            l = [];
          return (
            l.push(1 & a ? s.readShort(i, o) : 0),
            (o += 1 & a ? 2 : 0),
            l.push(2 & a ? s.readShort(i, o) : 0),
            (o += 2 & a ? 2 : 0),
            l.push(4 & a ? s.readShort(i, o) : 0),
            (o += 4 & a ? 2 : 0),
            l.push(8 & a ? s.readShort(i, o) : 0),
            (o += 8 & a ? 2 : 0),
            l
          );
        }),
        (e.GPOS.readBaseArray = function (i, o, a) {
          var s = e._bin,
            l = [],
            c = o,
            u = s.readUshort(i, o);
          o += 2;
          for (var d = 0; d < u; d++) {
            for (var p = [], m = 0; m < a; m++)
              p.push(e.GPOS.readAnchorRecord(i, c + s.readUshort(i, o))),
                (o += 2);
            l.push(p);
          }
          return l;
        }),
        (e.GPOS.readMarkArray = function (i, o) {
          var a = e._bin,
            s = [],
            l = o,
            c = a.readUshort(i, o);
          o += 2;
          for (var u = 0; u < c; u++) {
            var d = e.GPOS.readAnchorRecord(i, a.readUshort(i, o + 2) + l);
            (d.markClass = a.readUshort(i, o)), s.push(d), (o += 4);
          }
          return s;
        }),
        (e.GPOS.readAnchorRecord = function (i, o) {
          var a = e._bin,
            s = {};
          return (
            (s.fmt = a.readUshort(i, o)),
            (s.x = a.readShort(i, o + 2)),
            (s.y = a.readShort(i, o + 4)),
            s
          );
        }),
        (e.GSUB = {}),
        (e.GSUB.parse = function (i, o, a, s) {
          return e._lctf.parse(i, o, a, s, e.GSUB.subt);
        }),
        (e.GSUB.subt = function (i, o, a, s) {
          var l = e._bin,
            c = a,
            u = {};
          if (
            ((u.fmt = l.readUshort(i, a)),
            (a += 2),
            o != 1 && o != 2 && o != 4 && o != 5 && o != 6)
          )
            return null;
          if (
            o == 1 ||
            o == 2 ||
            o == 4 ||
            (o == 5 && u.fmt <= 2) ||
            (o == 6 && u.fmt <= 2)
          ) {
            var d = l.readUshort(i, a);
            (a += 2), (u.coverage = e._lctf.readCoverage(i, c + d));
          }
          if (o == 1 && u.fmt >= 1 && u.fmt <= 2) {
            if (u.fmt == 1) (u.delta = l.readShort(i, a)), (a += 2);
            else if (u.fmt == 2) {
              var p = l.readUshort(i, a);
              (a += 2),
                (u.newg = l.readUshorts(i, a, p)),
                (a += 2 * u.newg.length);
            }
          } else if (o == 2 && u.fmt == 1) {
            (p = l.readUshort(i, a)), (a += 2), (u.seqs = []);
            for (var m = 0; m < p; m++) {
              var v = l.readUshort(i, a) + c;
              a += 2;
              var S = l.readUshort(i, v);
              u.seqs.push(l.readUshorts(i, v + 2, S));
            }
          } else if (o == 4)
            for (
              u.vals = [], p = l.readUshort(i, a), a += 2, m = 0;
              m < p;
              m++
            ) {
              var x = l.readUshort(i, a);
              (a += 2), u.vals.push(e.GSUB.readLigatureSet(i, c + x));
            }
          else if (o == 5 && u.fmt == 2) {
            if (u.fmt == 2) {
              var g = l.readUshort(i, a);
              (a += 2),
                (u.cDef = e._lctf.readClassDef(i, c + g)),
                (u.scset = []);
              var _ = l.readUshort(i, a);
              for (a += 2, m = 0; m < _; m++) {
                var y = l.readUshort(i, a);
                (a += 2),
                  u.scset.push(
                    y == 0 ? null : e.GSUB.readSubClassSet(i, c + y)
                  );
              }
            }
          } else if (o == 6 && u.fmt == 3) {
            if (u.fmt == 3) {
              for (m = 0; m < 3; m++) {
                (p = l.readUshort(i, a)), (a += 2);
                for (var w = [], A = 0; A < p; A++)
                  w.push(
                    e._lctf.readCoverage(i, c + l.readUshort(i, a + 2 * A))
                  );
                (a += 2 * p),
                  m == 0 && (u.backCvg = w),
                  m == 1 && (u.inptCvg = w),
                  m == 2 && (u.ahedCvg = w);
              }
              (p = l.readUshort(i, a)),
                (a += 2),
                (u.lookupRec = e.GSUB.readSubstLookupRecords(i, a, p));
            }
          } else {
            if (o == 7 && u.fmt == 1) {
              var M = l.readUshort(i, a);
              a += 2;
              var T = l.readUint(i, a);
              if (((a += 4), s.ltype == 9)) s.ltype = M;
              else if (s.ltype != M) throw "invalid extension substitution";
              return e.GSUB.subt(i, s.ltype, c + T);
            }
            console.debug(
              "unsupported GSUB table LookupType",
              o,
              "format",
              u.fmt
            );
          }
          return u;
        }),
        (e.GSUB.readSubClassSet = function (i, o) {
          var a = e._bin.readUshort,
            s = o,
            l = [],
            c = a(i, o);
          o += 2;
          for (var u = 0; u < c; u++) {
            var d = a(i, o);
            (o += 2), l.push(e.GSUB.readSubClassRule(i, s + d));
          }
          return l;
        }),
        (e.GSUB.readSubClassRule = function (i, o) {
          var a = e._bin.readUshort,
            s = {},
            l = a(i, o),
            c = a(i, (o += 2));
          (o += 2), (s.input = []);
          for (var u = 0; u < l - 1; u++) s.input.push(a(i, o)), (o += 2);
          return (
            (s.substLookupRecords = e.GSUB.readSubstLookupRecords(i, o, c)), s
          );
        }),
        (e.GSUB.readSubstLookupRecords = function (i, o, a) {
          for (var s = e._bin.readUshort, l = [], c = 0; c < a; c++)
            l.push(s(i, o), s(i, o + 2)), (o += 4);
          return l;
        }),
        (e.GSUB.readChainSubClassSet = function (i, o) {
          var a = e._bin,
            s = o,
            l = [],
            c = a.readUshort(i, o);
          o += 2;
          for (var u = 0; u < c; u++) {
            var d = a.readUshort(i, o);
            (o += 2), l.push(e.GSUB.readChainSubClassRule(i, s + d));
          }
          return l;
        }),
        (e.GSUB.readChainSubClassRule = function (i, o) {
          for (
            var a = e._bin,
              s = {},
              l = ["backtrack", "input", "lookahead"],
              c = 0;
            c < l.length;
            c++
          ) {
            var u = a.readUshort(i, o);
            (o += 2),
              c == 1 && u--,
              (s[l[c]] = a.readUshorts(i, o, u)),
              (o += 2 * s[l[c]].length);
          }
          return (
            (u = a.readUshort(i, o)),
            (o += 2),
            (s.subst = a.readUshorts(i, o, 2 * u)),
            (o += 2 * s.subst.length),
            s
          );
        }),
        (e.GSUB.readLigatureSet = function (i, o) {
          var a = e._bin,
            s = o,
            l = [],
            c = a.readUshort(i, o);
          o += 2;
          for (var u = 0; u < c; u++) {
            var d = a.readUshort(i, o);
            (o += 2), l.push(e.GSUB.readLigature(i, s + d));
          }
          return l;
        }),
        (e.GSUB.readLigature = function (i, o) {
          var a = e._bin,
            s = { chain: [] };
          (s.nglyph = a.readUshort(i, o)), (o += 2);
          var l = a.readUshort(i, o);
          o += 2;
          for (var c = 0; c < l - 1; c++)
            s.chain.push(a.readUshort(i, o)), (o += 2);
          return s;
        }),
        (e.head = {}),
        (e.head.parse = function (i, o, a) {
          var s = e._bin,
            l = {};
          return (
            s.readFixed(i, o),
            (o += 4),
            (l.fontRevision = s.readFixed(i, o)),
            (o += 4),
            s.readUint(i, o),
            (o += 4),
            s.readUint(i, o),
            (o += 4),
            (l.flags = s.readUshort(i, o)),
            (o += 2),
            (l.unitsPerEm = s.readUshort(i, o)),
            (o += 2),
            (l.created = s.readUint64(i, o)),
            (o += 8),
            (l.modified = s.readUint64(i, o)),
            (o += 8),
            (l.xMin = s.readShort(i, o)),
            (o += 2),
            (l.yMin = s.readShort(i, o)),
            (o += 2),
            (l.xMax = s.readShort(i, o)),
            (o += 2),
            (l.yMax = s.readShort(i, o)),
            (o += 2),
            (l.macStyle = s.readUshort(i, o)),
            (o += 2),
            (l.lowestRecPPEM = s.readUshort(i, o)),
            (o += 2),
            (l.fontDirectionHint = s.readShort(i, o)),
            (o += 2),
            (l.indexToLocFormat = s.readShort(i, o)),
            (o += 2),
            (l.glyphDataFormat = s.readShort(i, o)),
            (o += 2),
            l
          );
        }),
        (e.hhea = {}),
        (e.hhea.parse = function (i, o, a) {
          var s = e._bin,
            l = {};
          return (
            s.readFixed(i, o),
            (o += 4),
            (l.ascender = s.readShort(i, o)),
            (o += 2),
            (l.descender = s.readShort(i, o)),
            (o += 2),
            (l.lineGap = s.readShort(i, o)),
            (o += 2),
            (l.advanceWidthMax = s.readUshort(i, o)),
            (o += 2),
            (l.minLeftSideBearing = s.readShort(i, o)),
            (o += 2),
            (l.minRightSideBearing = s.readShort(i, o)),
            (o += 2),
            (l.xMaxExtent = s.readShort(i, o)),
            (o += 2),
            (l.caretSlopeRise = s.readShort(i, o)),
            (o += 2),
            (l.caretSlopeRun = s.readShort(i, o)),
            (o += 2),
            (l.caretOffset = s.readShort(i, o)),
            (o += 2),
            (o += 8),
            (l.metricDataFormat = s.readShort(i, o)),
            (o += 2),
            (l.numberOfHMetrics = s.readUshort(i, o)),
            (o += 2),
            l
          );
        }),
        (e.hmtx = {}),
        (e.hmtx.parse = function (i, o, a, s) {
          for (
            var l = e._bin,
              c = { aWidth: [], lsBearing: [] },
              u = 0,
              d = 0,
              p = 0;
            p < s.maxp.numGlyphs;
            p++
          )
            p < s.hhea.numberOfHMetrics &&
              ((u = l.readUshort(i, o)),
              (o += 2),
              (d = l.readShort(i, o)),
              (o += 2)),
              c.aWidth.push(u),
              c.lsBearing.push(d);
          return c;
        }),
        (e.kern = {}),
        (e.kern.parse = function (i, o, a, s) {
          var l = e._bin,
            c = l.readUshort(i, o);
          if (((o += 2), c == 1)) return e.kern.parseV1(i, o - 2, a, s);
          var u = l.readUshort(i, o);
          o += 2;
          for (var d = { glyph1: [], rval: [] }, p = 0; p < u; p++) {
            (o += 2), (a = l.readUshort(i, o)), (o += 2);
            var m = l.readUshort(i, o);
            o += 2;
            var v = m >>> 8;
            if ((v &= 15) != 0) throw "unknown kern table format: " + v;
            o = e.kern.readFormat0(i, o, d);
          }
          return d;
        }),
        (e.kern.parseV1 = function (i, o, a, s) {
          var l = e._bin;
          l.readFixed(i, o), (o += 4);
          var c = l.readUint(i, o);
          o += 4;
          for (var u = { glyph1: [], rval: [] }, d = 0; d < c; d++) {
            l.readUint(i, o), (o += 4);
            var p = l.readUshort(i, o);
            (o += 2), l.readUshort(i, o), (o += 2);
            var m = p >>> 8;
            if ((m &= 15) != 0) throw "unknown kern table format: " + m;
            o = e.kern.readFormat0(i, o, u);
          }
          return u;
        }),
        (e.kern.readFormat0 = function (i, o, a) {
          var s = e._bin,
            l = -1,
            c = s.readUshort(i, o);
          (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2);
          for (var u = 0; u < c; u++) {
            var d = s.readUshort(i, o);
            o += 2;
            var p = s.readUshort(i, o);
            o += 2;
            var m = s.readShort(i, o);
            (o += 2),
              d != l &&
                (a.glyph1.push(d), a.rval.push({ glyph2: [], vals: [] }));
            var v = a.rval[a.rval.length - 1];
            v.glyph2.push(p), v.vals.push(m), (l = d);
          }
          return o;
        }),
        (e.loca = {}),
        (e.loca.parse = function (i, o, a, s) {
          var l = e._bin,
            c = [],
            u = s.head.indexToLocFormat,
            d = s.maxp.numGlyphs + 1;
          if (u == 0)
            for (var p = 0; p < d; p++)
              c.push(l.readUshort(i, o + (p << 1)) << 1);
          if (u == 1)
            for (p = 0; p < d; p++) c.push(l.readUint(i, o + (p << 2)));
          return c;
        }),
        (e.maxp = {}),
        (e.maxp.parse = function (i, o, a) {
          var s = e._bin,
            l = {},
            c = s.readUint(i, o);
          return (
            (o += 4),
            (l.numGlyphs = s.readUshort(i, o)),
            (o += 2),
            c == 65536 &&
              ((l.maxPoints = s.readUshort(i, o)),
              (o += 2),
              (l.maxContours = s.readUshort(i, o)),
              (o += 2),
              (l.maxCompositePoints = s.readUshort(i, o)),
              (o += 2),
              (l.maxCompositeContours = s.readUshort(i, o)),
              (o += 2),
              (l.maxZones = s.readUshort(i, o)),
              (o += 2),
              (l.maxTwilightPoints = s.readUshort(i, o)),
              (o += 2),
              (l.maxStorage = s.readUshort(i, o)),
              (o += 2),
              (l.maxFunctionDefs = s.readUshort(i, o)),
              (o += 2),
              (l.maxInstructionDefs = s.readUshort(i, o)),
              (o += 2),
              (l.maxStackElements = s.readUshort(i, o)),
              (o += 2),
              (l.maxSizeOfInstructions = s.readUshort(i, o)),
              (o += 2),
              (l.maxComponentElements = s.readUshort(i, o)),
              (o += 2),
              (l.maxComponentDepth = s.readUshort(i, o)),
              (o += 2)),
            l
          );
        }),
        (e.name = {}),
        (e.name.parse = function (i, o, a) {
          var s = e._bin,
            l = {};
          s.readUshort(i, o), (o += 2);
          var c = s.readUshort(i, o);
          (o += 2), s.readUshort(i, o);
          for (
            var u,
              d = [
                "copyright",
                "fontFamily",
                "fontSubfamily",
                "ID",
                "fullName",
                "version",
                "postScriptName",
                "trademark",
                "manufacturer",
                "designer",
                "description",
                "urlVendor",
                "urlDesigner",
                "licence",
                "licenceURL",
                "---",
                "typoFamilyName",
                "typoSubfamilyName",
                "compatibleFull",
                "sampleText",
                "postScriptCID",
                "wwsFamilyName",
                "wwsSubfamilyName",
                "lightPalette",
                "darkPalette",
              ],
              p = (o += 2),
              m = 0;
            m < c;
            m++
          ) {
            var v = s.readUshort(i, o);
            o += 2;
            var S = s.readUshort(i, o);
            o += 2;
            var x = s.readUshort(i, o);
            o += 2;
            var g = s.readUshort(i, o);
            o += 2;
            var _ = s.readUshort(i, o);
            o += 2;
            var y = s.readUshort(i, o);
            o += 2;
            var w,
              A = d[g],
              M = p + 12 * c + y;
            if (v == 0) w = s.readUnicode(i, M, _ / 2);
            else if (v == 3 && S == 0) w = s.readUnicode(i, M, _ / 2);
            else if (S == 0) w = s.readASCII(i, M, _);
            else if (S == 1) w = s.readUnicode(i, M, _ / 2);
            else if (S == 3) w = s.readUnicode(i, M, _ / 2);
            else {
              if (v != 1) throw "unknown encoding " + S + ", platformID: " + v;
              (w = s.readASCII(i, M, _)),
                console.debug(
                  "reading unknown MAC encoding " + S + " as ASCII"
                );
            }
            var T = "p" + v + "," + x.toString(16);
            l[T] == null && (l[T] = {}),
              (l[T][A !== void 0 ? A : g] = w),
              (l[T]._lang = x);
          }
          for (var I in l)
            if (l[I].postScriptName != null && l[I]._lang == 1033) return l[I];
          for (var I in l)
            if (l[I].postScriptName != null && l[I]._lang == 0) return l[I];
          for (var I in l)
            if (l[I].postScriptName != null && l[I]._lang == 3084) return l[I];
          for (var I in l) if (l[I].postScriptName != null) return l[I];
          for (var I in l) {
            u = I;
            break;
          }
          return (
            console.debug("returning name table with languageID " + l[u]._lang),
            l[u]
          );
        }),
        (e["OS/2"] = {}),
        (e["OS/2"].parse = function (i, o, a) {
          var s = e._bin.readUshort(i, o);
          o += 2;
          var l = {};
          if (s == 0) e["OS/2"].version0(i, o, l);
          else if (s == 1) e["OS/2"].version1(i, o, l);
          else if (s == 2 || s == 3 || s == 4) e["OS/2"].version2(i, o, l);
          else {
            if (s != 5) throw "unknown OS/2 table version: " + s;
            e["OS/2"].version5(i, o, l);
          }
          return l;
        }),
        (e["OS/2"].version0 = function (i, o, a) {
          var s = e._bin;
          return (
            (a.xAvgCharWidth = s.readShort(i, o)),
            (o += 2),
            (a.usWeightClass = s.readUshort(i, o)),
            (o += 2),
            (a.usWidthClass = s.readUshort(i, o)),
            (o += 2),
            (a.fsType = s.readUshort(i, o)),
            (o += 2),
            (a.ySubscriptXSize = s.readShort(i, o)),
            (o += 2),
            (a.ySubscriptYSize = s.readShort(i, o)),
            (o += 2),
            (a.ySubscriptXOffset = s.readShort(i, o)),
            (o += 2),
            (a.ySubscriptYOffset = s.readShort(i, o)),
            (o += 2),
            (a.ySuperscriptXSize = s.readShort(i, o)),
            (o += 2),
            (a.ySuperscriptYSize = s.readShort(i, o)),
            (o += 2),
            (a.ySuperscriptXOffset = s.readShort(i, o)),
            (o += 2),
            (a.ySuperscriptYOffset = s.readShort(i, o)),
            (o += 2),
            (a.yStrikeoutSize = s.readShort(i, o)),
            (o += 2),
            (a.yStrikeoutPosition = s.readShort(i, o)),
            (o += 2),
            (a.sFamilyClass = s.readShort(i, o)),
            (o += 2),
            (a.panose = s.readBytes(i, o, 10)),
            (o += 10),
            (a.ulUnicodeRange1 = s.readUint(i, o)),
            (o += 4),
            (a.ulUnicodeRange2 = s.readUint(i, o)),
            (o += 4),
            (a.ulUnicodeRange3 = s.readUint(i, o)),
            (o += 4),
            (a.ulUnicodeRange4 = s.readUint(i, o)),
            (o += 4),
            (a.achVendID = [
              s.readInt8(i, o),
              s.readInt8(i, o + 1),
              s.readInt8(i, o + 2),
              s.readInt8(i, o + 3),
            ]),
            (o += 4),
            (a.fsSelection = s.readUshort(i, o)),
            (o += 2),
            (a.usFirstCharIndex = s.readUshort(i, o)),
            (o += 2),
            (a.usLastCharIndex = s.readUshort(i, o)),
            (o += 2),
            (a.sTypoAscender = s.readShort(i, o)),
            (o += 2),
            (a.sTypoDescender = s.readShort(i, o)),
            (o += 2),
            (a.sTypoLineGap = s.readShort(i, o)),
            (o += 2),
            (a.usWinAscent = s.readUshort(i, o)),
            (o += 2),
            (a.usWinDescent = s.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e["OS/2"].version1 = function (i, o, a) {
          var s = e._bin;
          return (
            (o = e["OS/2"].version0(i, o, a)),
            (a.ulCodePageRange1 = s.readUint(i, o)),
            (o += 4),
            (a.ulCodePageRange2 = s.readUint(i, o)),
            (o += 4)
          );
        }),
        (e["OS/2"].version2 = function (i, o, a) {
          var s = e._bin;
          return (
            (o = e["OS/2"].version1(i, o, a)),
            (a.sxHeight = s.readShort(i, o)),
            (o += 2),
            (a.sCapHeight = s.readShort(i, o)),
            (o += 2),
            (a.usDefault = s.readUshort(i, o)),
            (o += 2),
            (a.usBreak = s.readUshort(i, o)),
            (o += 2),
            (a.usMaxContext = s.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e["OS/2"].version5 = function (i, o, a) {
          var s = e._bin;
          return (
            (o = e["OS/2"].version2(i, o, a)),
            (a.usLowerOpticalPointSize = s.readUshort(i, o)),
            (o += 2),
            (a.usUpperOpticalPointSize = s.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e.post = {}),
        (e.post.parse = function (i, o, a) {
          var s = e._bin,
            l = {};
          return (
            (l.version = s.readFixed(i, o)),
            (o += 4),
            (l.italicAngle = s.readFixed(i, o)),
            (o += 4),
            (l.underlinePosition = s.readShort(i, o)),
            (o += 2),
            (l.underlineThickness = s.readShort(i, o)),
            (o += 2),
            l
          );
        }),
        e == null && (e = {}),
        e.U == null && (e.U = {}),
        (e.U.codeToGlyph = function (i, o) {
          var a = i.cmap,
            s = -1;
          if (
            (a.p0e4 != null
              ? (s = a.p0e4)
              : a.p3e1 != null
              ? (s = a.p3e1)
              : a.p1e0 != null
              ? (s = a.p1e0)
              : a.p0e3 != null && (s = a.p0e3),
            s == -1)
          )
            throw "no familiar platform and encoding!";
          var l = a.tables[s];
          if (l.format == 0) return o >= l.map.length ? 0 : l.map[o];
          if (l.format == 4) {
            for (var c = -1, u = 0; u < l.endCount.length; u++)
              if (o <= l.endCount[u]) {
                c = u;
                break;
              }
            return c == -1 || l.startCount[c] > o
              ? 0
              : 65535 &
                  (l.idRangeOffset[c] != 0
                    ? l.glyphIdArray[
                        o -
                          l.startCount[c] +
                          (l.idRangeOffset[c] >> 1) -
                          (l.idRangeOffset.length - c)
                      ]
                    : o + l.idDelta[c]);
          }
          if (l.format == 12) {
            if (o > l.groups[l.groups.length - 1][1]) return 0;
            for (u = 0; u < l.groups.length; u++) {
              var d = l.groups[u];
              if (d[0] <= o && o <= d[1]) return d[2] + (o - d[0]);
            }
            return 0;
          }
          throw "unknown cmap table format " + l.format;
        }),
        (e.U.glyphToPath = function (i, o) {
          var a = { cmds: [], crds: [] };
          if (i.SVG && i.SVG.entries[o]) {
            var s = i.SVG.entries[o];
            return s == null
              ? a
              : (typeof s == "string" &&
                  ((s = e.SVG.toPath(s)), (i.SVG.entries[o] = s)),
                s);
          }
          if (i.CFF) {
            var l = {
                x: 0,
                y: 0,
                stack: [],
                nStems: 0,
                haveWidth: !1,
                width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0,
                open: !1,
              },
              c = i.CFF,
              u = i.CFF.Private;
            if (c.ROS) {
              for (var d = 0; c.FDSelect[d + 2] <= o; ) d += 2;
              u = c.FDArray[c.FDSelect[d + 1]].Private;
            }
            e.U._drawCFF(i.CFF.CharStrings[o], l, c, u, a);
          } else i.glyf && e.U._drawGlyf(o, i, a);
          return a;
        }),
        (e.U._drawGlyf = function (i, o, a) {
          var s = o.glyf[i];
          s == null && (s = o.glyf[i] = e.glyf._parseGlyf(o, i)),
            s != null &&
              (s.noc > -1 ? e.U._simpleGlyph(s, a) : e.U._compoGlyph(s, o, a));
        }),
        (e.U._simpleGlyph = function (i, o) {
          for (var a = 0; a < i.noc; a++) {
            for (
              var s = a == 0 ? 0 : i.endPts[a - 1] + 1, l = i.endPts[a], c = s;
              c <= l;
              c++
            ) {
              var u = c == s ? l : c - 1,
                d = c == l ? s : c + 1,
                p = 1 & i.flags[c],
                m = 1 & i.flags[u],
                v = 1 & i.flags[d],
                S = i.xs[c],
                x = i.ys[c];
              if (c == s)
                if (p) {
                  if (!m) {
                    e.U.P.moveTo(o, S, x);
                    continue;
                  }
                  e.U.P.moveTo(o, i.xs[u], i.ys[u]);
                } else
                  m
                    ? e.U.P.moveTo(o, i.xs[u], i.ys[u])
                    : e.U.P.moveTo(o, (i.xs[u] + S) / 2, (i.ys[u] + x) / 2);
              p
                ? m && e.U.P.lineTo(o, S, x)
                : v
                ? e.U.P.qcurveTo(o, S, x, i.xs[d], i.ys[d])
                : e.U.P.qcurveTo(o, S, x, (S + i.xs[d]) / 2, (x + i.ys[d]) / 2);
            }
            e.U.P.closePath(o);
          }
        }),
        (e.U._compoGlyph = function (i, o, a) {
          for (var s = 0; s < i.parts.length; s++) {
            var l = { cmds: [], crds: [] },
              c = i.parts[s];
            e.U._drawGlyf(c.glyphIndex, o, l);
            for (var u = c.m, d = 0; d < l.crds.length; d += 2) {
              var p = l.crds[d],
                m = l.crds[d + 1];
              a.crds.push(p * u.a + m * u.b + u.tx),
                a.crds.push(p * u.c + m * u.d + u.ty);
            }
            for (d = 0; d < l.cmds.length; d++) a.cmds.push(l.cmds[d]);
          }
        }),
        (e.U._getGlyphClass = function (i, o) {
          var a = e._lctf.getInterval(o, i);
          return a == -1 ? 0 : o[a + 2];
        }),
        (e.U._applySubs = function (i, o, a, s) {
          for (var l = i.length - o - 1, c = 0; c < a.tabs.length; c++)
            if (a.tabs[c] != null) {
              var u,
                d = a.tabs[c];
              if (
                !d.coverage ||
                (u = e._lctf.coverageIndex(d.coverage, i[o])) != -1
              ) {
                if (a.ltype == 1)
                  i[o],
                    d.fmt == 1 ? (i[o] = i[o] + d.delta) : (i[o] = d.newg[u]);
                else if (a.ltype == 4)
                  for (var p = d.vals[u], m = 0; m < p.length; m++) {
                    var v = p[m],
                      S = v.chain.length;
                    if (!(S > l)) {
                      for (var x = !0, g = 0, _ = 0; _ < S; _++) {
                        for (; i[o + g + (1 + _)] == -1; ) g++;
                        v.chain[_] != i[o + g + (1 + _)] && (x = !1);
                      }
                      if (x) {
                        for (i[o] = v.nglyph, _ = 0; _ < S + g; _++)
                          i[o + _ + 1] = -1;
                        break;
                      }
                    }
                  }
                else if (a.ltype == 5 && d.fmt == 2)
                  for (
                    var y = e._lctf.getInterval(d.cDef, i[o]),
                      w = d.cDef[y + 2],
                      A = d.scset[w],
                      M = 0;
                    M < A.length;
                    M++
                  ) {
                    var T = A[M],
                      I = T.input;
                    if (!(I.length > l)) {
                      for (x = !0, _ = 0; _ < I.length; _++) {
                        var R = e._lctf.getInterval(d.cDef, i[o + 1 + _]);
                        if (y == -1 && d.cDef[R + 2] != I[_]) {
                          x = !1;
                          break;
                        }
                      }
                      if (x) {
                        var P = T.substLookupRecords;
                        for (m = 0; m < P.length; m += 2) P[m], P[m + 1];
                      }
                    }
                  }
                else if (a.ltype == 6 && d.fmt == 3) {
                  if (
                    !e.U._glsCovered(i, d.backCvg, o - d.backCvg.length) ||
                    !e.U._glsCovered(i, d.inptCvg, o) ||
                    !e.U._glsCovered(i, d.ahedCvg, o + d.inptCvg.length)
                  )
                    continue;
                  var F = d.lookupRec;
                  for (M = 0; M < F.length; M += 2) {
                    y = F[M];
                    var D = s[F[M + 1]];
                    e.U._applySubs(i, o + y, D, s);
                  }
                }
              }
            }
        }),
        (e.U._glsCovered = function (i, o, a) {
          for (var s = 0; s < o.length; s++)
            if (e._lctf.coverageIndex(o[s], i[a + s]) == -1) return !1;
          return !0;
        }),
        (e.U.glyphsToPath = function (i, o, a) {
          for (
            var s = { cmds: [], crds: [] }, l = 0, c = 0;
            c < o.length;
            c++
          ) {
            var u = o[c];
            if (u != -1) {
              for (
                var d = c < o.length - 1 && o[c + 1] != -1 ? o[c + 1] : 0,
                  p = e.U.glyphToPath(i, u),
                  m = 0;
                m < p.crds.length;
                m += 2
              )
                s.crds.push(p.crds[m] + l), s.crds.push(p.crds[m + 1]);
              for (a && s.cmds.push(a), m = 0; m < p.cmds.length; m++)
                s.cmds.push(p.cmds[m]);
              a && s.cmds.push("X"),
                (l += i.hmtx.aWidth[u]),
                c < o.length - 1 && (l += e.U.getPairAdjustment(i, u, d));
            }
          }
          return s;
        }),
        (e.U.P = {}),
        (e.U.P.moveTo = function (i, o, a) {
          i.cmds.push("M"), i.crds.push(o, a);
        }),
        (e.U.P.lineTo = function (i, o, a) {
          i.cmds.push("L"), i.crds.push(o, a);
        }),
        (e.U.P.curveTo = function (i, o, a, s, l, c, u) {
          i.cmds.push("C"), i.crds.push(o, a, s, l, c, u);
        }),
        (e.U.P.qcurveTo = function (i, o, a, s, l) {
          i.cmds.push("Q"), i.crds.push(o, a, s, l);
        }),
        (e.U.P.closePath = function (i) {
          i.cmds.push("Z");
        }),
        (e.U._drawCFF = function (i, o, a, s, l) {
          for (
            var c = o.stack,
              u = o.nStems,
              d = o.haveWidth,
              p = o.width,
              m = o.open,
              v = 0,
              S = o.x,
              x = o.y,
              g = 0,
              _ = 0,
              y = 0,
              w = 0,
              A = 0,
              M = 0,
              T = 0,
              I = 0,
              R = 0,
              P = 0,
              F = { val: 0, size: 0 };
            v < i.length;

          ) {
            e.CFF.getCharString(i, v, F);
            var D = F.val;
            if (((v += F.size), D == "o1" || D == "o18"))
              c.length % 2 != 0 && !d && (p = c.shift() + s.nominalWidthX),
                (u += c.length >> 1),
                (c.length = 0),
                (d = !0);
            else if (D == "o3" || D == "o23")
              c.length % 2 != 0 && !d && (p = c.shift() + s.nominalWidthX),
                (u += c.length >> 1),
                (c.length = 0),
                (d = !0);
            else if (D == "o4")
              c.length > 1 &&
                !d &&
                ((p = c.shift() + s.nominalWidthX), (d = !0)),
                m && e.U.P.closePath(l),
                (x += c.pop()),
                e.U.P.moveTo(l, S, x),
                (m = !0);
            else if (D == "o5")
              for (; c.length > 0; )
                (S += c.shift()), (x += c.shift()), e.U.P.lineTo(l, S, x);
            else if (D == "o6" || D == "o7")
              for (var j = c.length, N = D == "o6", V = 0; V < j; V++) {
                var W = c.shift();
                N ? (S += W) : (x += W), (N = !N), e.U.P.lineTo(l, S, x);
              }
            else if (D == "o8" || D == "o24") {
              j = c.length;
              for (var Q = 0; Q + 6 <= j; )
                (g = S + c.shift()),
                  (_ = x + c.shift()),
                  (y = g + c.shift()),
                  (w = _ + c.shift()),
                  (S = y + c.shift()),
                  (x = w + c.shift()),
                  e.U.P.curveTo(l, g, _, y, w, S, x),
                  (Q += 6);
              D == "o24" &&
                ((S += c.shift()), (x += c.shift()), e.U.P.lineTo(l, S, x));
            } else {
              if (D == "o11") break;
              if (D == "o1234" || D == "o1235" || D == "o1236" || D == "o1237")
                D == "o1234" &&
                  ((_ = x),
                  (y = (g = S + c.shift()) + c.shift()),
                  (P = w = _ + c.shift()),
                  (M = w),
                  (I = x),
                  (S =
                    (T = (A = (R = y + c.shift()) + c.shift()) + c.shift()) +
                    c.shift()),
                  e.U.P.curveTo(l, g, _, y, w, R, P),
                  e.U.P.curveTo(l, A, M, T, I, S, x)),
                  D == "o1235" &&
                    ((g = S + c.shift()),
                    (_ = x + c.shift()),
                    (y = g + c.shift()),
                    (w = _ + c.shift()),
                    (R = y + c.shift()),
                    (P = w + c.shift()),
                    (A = R + c.shift()),
                    (M = P + c.shift()),
                    (T = A + c.shift()),
                    (I = M + c.shift()),
                    (S = T + c.shift()),
                    (x = I + c.shift()),
                    c.shift(),
                    e.U.P.curveTo(l, g, _, y, w, R, P),
                    e.U.P.curveTo(l, A, M, T, I, S, x)),
                  D == "o1236" &&
                    ((g = S + c.shift()),
                    (_ = x + c.shift()),
                    (y = g + c.shift()),
                    (P = w = _ + c.shift()),
                    (M = w),
                    (T = (A = (R = y + c.shift()) + c.shift()) + c.shift()),
                    (I = M + c.shift()),
                    (S = T + c.shift()),
                    e.U.P.curveTo(l, g, _, y, w, R, P),
                    e.U.P.curveTo(l, A, M, T, I, S, x)),
                  D == "o1237" &&
                    ((g = S + c.shift()),
                    (_ = x + c.shift()),
                    (y = g + c.shift()),
                    (w = _ + c.shift()),
                    (R = y + c.shift()),
                    (P = w + c.shift()),
                    (A = R + c.shift()),
                    (M = P + c.shift()),
                    (T = A + c.shift()),
                    (I = M + c.shift()),
                    Math.abs(T - S) > Math.abs(I - x)
                      ? (S = T + c.shift())
                      : (x = I + c.shift()),
                    e.U.P.curveTo(l, g, _, y, w, R, P),
                    e.U.P.curveTo(l, A, M, T, I, S, x));
              else if (D == "o14") {
                if (
                  (c.length > 0 &&
                    !d &&
                    ((p = c.shift() + a.nominalWidthX), (d = !0)),
                  c.length == 4)
                ) {
                  var B = c.shift(),
                    $ = c.shift(),
                    G = c.shift(),
                    k = c.shift(),
                    q = e.CFF.glyphBySE(a, G),
                    X = e.CFF.glyphBySE(a, k);
                  e.U._drawCFF(a.CharStrings[q], o, a, s, l),
                    (o.x = B),
                    (o.y = $),
                    e.U._drawCFF(a.CharStrings[X], o, a, s, l);
                }
                m && (e.U.P.closePath(l), (m = !1));
              } else if (D == "o19" || D == "o20")
                c.length % 2 != 0 && !d && (p = c.shift() + s.nominalWidthX),
                  (u += c.length >> 1),
                  (c.length = 0),
                  (d = !0),
                  (v += (u + 7) >> 3);
              else if (D == "o21")
                c.length > 2 &&
                  !d &&
                  ((p = c.shift() + s.nominalWidthX), (d = !0)),
                  (x += c.pop()),
                  (S += c.pop()),
                  m && e.U.P.closePath(l),
                  e.U.P.moveTo(l, S, x),
                  (m = !0);
              else if (D == "o22")
                c.length > 1 &&
                  !d &&
                  ((p = c.shift() + s.nominalWidthX), (d = !0)),
                  (S += c.pop()),
                  m && e.U.P.closePath(l),
                  e.U.P.moveTo(l, S, x),
                  (m = !0);
              else if (D == "o25") {
                for (; c.length > 6; )
                  (S += c.shift()), (x += c.shift()), e.U.P.lineTo(l, S, x);
                (g = S + c.shift()),
                  (_ = x + c.shift()),
                  (y = g + c.shift()),
                  (w = _ + c.shift()),
                  (S = y + c.shift()),
                  (x = w + c.shift()),
                  e.U.P.curveTo(l, g, _, y, w, S, x);
              } else if (D == "o26")
                for (c.length % 2 && (S += c.shift()); c.length > 0; )
                  (g = S),
                    (_ = x + c.shift()),
                    (S = y = g + c.shift()),
                    (x = (w = _ + c.shift()) + c.shift()),
                    e.U.P.curveTo(l, g, _, y, w, S, x);
              else if (D == "o27")
                for (c.length % 2 && (x += c.shift()); c.length > 0; )
                  (_ = x),
                    (y = (g = S + c.shift()) + c.shift()),
                    (w = _ + c.shift()),
                    (S = y + c.shift()),
                    (x = w),
                    e.U.P.curveTo(l, g, _, y, w, S, x);
              else if (D == "o10" || D == "o29") {
                var ee = D == "o10" ? s : a;
                if (c.length == 0) console.debug("error: empty stack");
                else {
                  var J = c.pop(),
                    oe = ee.Subrs[J + ee.Bias];
                  (o.x = S),
                    (o.y = x),
                    (o.nStems = u),
                    (o.haveWidth = d),
                    (o.width = p),
                    (o.open = m),
                    e.U._drawCFF(oe, o, a, s, l),
                    (S = o.x),
                    (x = o.y),
                    (u = o.nStems),
                    (d = o.haveWidth),
                    (p = o.width),
                    (m = o.open);
                }
              } else if (D == "o30" || D == "o31") {
                var ae = c.length,
                  le = ((Q = 0), D == "o31");
                for (Q += ae - (j = -3 & ae); Q < j; )
                  le
                    ? ((_ = x),
                      (y = (g = S + c.shift()) + c.shift()),
                      (x = (w = _ + c.shift()) + c.shift()),
                      j - Q == 5 ? ((S = y + c.shift()), Q++) : (S = y),
                      (le = !1))
                    : ((g = S),
                      (_ = x + c.shift()),
                      (y = g + c.shift()),
                      (w = _ + c.shift()),
                      (S = y + c.shift()),
                      j - Q == 5 ? ((x = w + c.shift()), Q++) : (x = w),
                      (le = !0)),
                    e.U.P.curveTo(l, g, _, y, w, S, x),
                    (Q += 4);
              } else {
                if ((D + "").charAt(0) == "o")
                  throw (console.debug("Unknown operation: " + D, i), D);
                c.push(D);
              }
            }
          }
          (o.x = S),
            (o.y = x),
            (o.nStems = u),
            (o.haveWidth = d),
            (o.width = p),
            (o.open = m);
        });
      var n = e,
        r = { Typr: n };
      return (
        (t.Typr = n),
        (t.default = r),
        Object.defineProperty(t, "__esModule", { value: !0 }),
        t
      );
    })({}).Typr
  );
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/ function RX() {
  return (function (t) {
    var e = Uint8Array,
      n = Uint16Array,
      r = Uint32Array,
      i = new e([
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
        5, 5, 5, 5, 0, 0, 0, 0,
      ]),
      o = new e([
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
        10, 11, 11, 12, 12, 13, 13, 0, 0,
      ]),
      a = new e([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]),
      s = function (D, j) {
        for (var N = new n(31), V = 0; V < 31; ++V) N[V] = j += 1 << D[V - 1];
        var W = new r(N[30]);
        for (V = 1; V < 30; ++V)
          for (var Q = N[V]; Q < N[V + 1]; ++Q) W[Q] = ((Q - N[V]) << 5) | V;
        return [N, W];
      },
      l = s(i, 2),
      c = l[0],
      u = l[1];
    (c[28] = 258), (u[258] = 28);
    for (var d = s(o, 0)[0], p = new n(32768), m = 0; m < 32768; ++m) {
      var v = ((43690 & m) >>> 1) | ((21845 & m) << 1);
      (v =
        ((61680 & (v = ((52428 & v) >>> 2) | ((13107 & v) << 2))) >>> 4) |
        ((3855 & v) << 4)),
        (p[m] = (((65280 & v) >>> 8) | ((255 & v) << 8)) >>> 1);
    }
    var S = function (D, j, N) {
        for (var V = D.length, W = 0, Q = new n(j); W < V; ++W) ++Q[D[W] - 1];
        var B,
          $ = new n(j);
        for (W = 0; W < j; ++W) $[W] = ($[W - 1] + Q[W - 1]) << 1;
        if (N) {
          B = new n(1 << j);
          var G = 15 - j;
          for (W = 0; W < V; ++W)
            if (D[W])
              for (
                var k = (W << 4) | D[W],
                  q = j - D[W],
                  X = $[D[W] - 1]++ << q,
                  ee = X | ((1 << q) - 1);
                X <= ee;
                ++X
              )
                B[p[X] >>> G] = k;
        } else
          for (B = new n(V), W = 0; W < V; ++W)
            D[W] && (B[W] = p[$[D[W] - 1]++] >>> (15 - D[W]));
        return B;
      },
      x = new e(288);
    for (m = 0; m < 144; ++m) x[m] = 8;
    for (m = 144; m < 256; ++m) x[m] = 9;
    for (m = 256; m < 280; ++m) x[m] = 7;
    for (m = 280; m < 288; ++m) x[m] = 8;
    var g = new e(32);
    for (m = 0; m < 32; ++m) g[m] = 5;
    var _ = S(x, 9, 1),
      y = S(g, 5, 1),
      w = function (D) {
        for (var j = D[0], N = 1; N < D.length; ++N) D[N] > j && (j = D[N]);
        return j;
      },
      A = function (D, j, N) {
        var V = (j / 8) | 0;
        return ((D[V] | (D[V + 1] << 8)) >> (7 & j)) & N;
      },
      M = function (D, j) {
        var N = (j / 8) | 0;
        return (D[N] | (D[N + 1] << 8) | (D[N + 2] << 16)) >> (7 & j);
      },
      T = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data",
      ],
      I = function (D, j, N) {
        var V = new Error(j || T[D]);
        if (
          ((V.code = D),
          Error.captureStackTrace && Error.captureStackTrace(V, I),
          !N)
        )
          throw V;
        return V;
      },
      R = function (D, j, N) {
        var V = D.length;
        if (!V || (N && !N.l && V < 5)) return j || new e(0);
        var W = !j || N,
          Q = !N || N.i;
        N || (N = {}), j || (j = new e(3 * V));
        var B,
          $ = function (Ne) {
            var ne = j.length;
            if (Ne > ne) {
              var Ie = new e(Math.max(2 * ne, Ne));
              Ie.set(j), (j = Ie);
            }
          },
          G = N.f || 0,
          k = N.p || 0,
          q = N.b || 0,
          X = N.l,
          ee = N.d,
          J = N.m,
          oe = N.n,
          ae = 8 * V;
        do {
          if (!X) {
            N.f = G = A(D, k, 1);
            var le = A(D, k + 1, 3);
            if (((k += 3), !le)) {
              var _e =
                  D[(z = (((B = k) / 8) | 0) + (7 & B && 1) + 4) - 4] |
                  (D[z - 3] << 8),
                me = z + _e;
              if (me > V) {
                Q && I(0);
                break;
              }
              W && $(q + _e),
                j.set(D.subarray(z, me), q),
                (N.b = q += _e),
                (N.p = k = 8 * me);
              continue;
            }
            if (le == 1) (X = _), (ee = y), (J = 9), (oe = 5);
            else if (le == 2) {
              var se = A(D, k, 31) + 257,
                Y = A(D, k + 10, 15) + 4,
                ve = se + A(D, k + 5, 31) + 1;
              k += 14;
              for (var de = new e(ve), ue = new e(19), fe = 0; fe < Y; ++fe)
                ue[a[fe]] = A(D, k + 3 * fe, 7);
              k += 3 * Y;
              var Te = w(ue),
                pe = (1 << Te) - 1,
                H = S(ue, Te, 1);
              for (fe = 0; fe < ve; ) {
                var z,
                  Z = H[A(D, k, pe)];
                if (((k += 15 & Z), (z = Z >>> 4) < 16)) de[fe++] = z;
                else {
                  var ge = 0,
                    ce = 0;
                  for (
                    z == 16
                      ? ((ce = 3 + A(D, k, 3)), (k += 2), (ge = de[fe - 1]))
                      : z == 17
                      ? ((ce = 3 + A(D, k, 7)), (k += 3))
                      : z == 18 && ((ce = 11 + A(D, k, 127)), (k += 7));
                    ce--;

                  )
                    de[fe++] = ge;
                }
              }
              var he = de.subarray(0, se),
                Me = de.subarray(se);
              (J = w(he)), (oe = w(Me)), (X = S(he, J, 1)), (ee = S(Me, oe, 1));
            } else I(1);
            if (k > ae) {
              Q && I(0);
              break;
            }
          }
          W && $(q + 131072);
          for (var Re = (1 << J) - 1, Le = (1 << oe) - 1, Oe = k; ; Oe = k) {
            var Pe = (ge = X[M(D, k) & Re]) >>> 4;
            if ((k += 15 & ge) > ae) {
              Q && I(0);
              break;
            }
            if ((ge || I(2), Pe < 256)) j[q++] = Pe;
            else {
              if (Pe == 256) {
                (Oe = k), (X = null);
                break;
              }
              var Se = Pe - 254;
              if (Pe > 264) {
                var Je = i[(fe = Pe - 257)];
                (Se = A(D, k, (1 << Je) - 1) + c[fe]), (k += Je);
              }
              var st = ee[M(D, k) & Le],
                Qe = st >>> 4;
              if (
                (st || I(3),
                (k += 15 & st),
                (Me = d[Qe]),
                Qe > 3 &&
                  ((Je = o[Qe]), (Me += M(D, k) & ((1 << Je) - 1)), (k += Je)),
                k > ae)
              ) {
                Q && I(0);
                break;
              }
              W && $(q + 131072);
              for (var Ke = q + Se; q < Ke; q += 4)
                (j[q] = j[q - Me]),
                  (j[q + 1] = j[q + 1 - Me]),
                  (j[q + 2] = j[q + 2 - Me]),
                  (j[q + 3] = j[q + 3 - Me]);
              q = Ke;
            }
          }
          (N.l = X),
            (N.p = Oe),
            (N.b = q),
            X && ((G = 1), (N.m = J), (N.d = ee), (N.n = oe));
        } while (!G);
        return q == j.length
          ? j
          : (function (Ne, ne, Ie) {
              (ne == null || ne < 0) && (ne = 0),
                (Ie == null || Ie > Ne.length) && (Ie = Ne.length);
              var et = new (Ne instanceof n ? n : Ne instanceof r ? r : e)(
                Ie - ne
              );
              return et.set(Ne.subarray(ne, Ie)), et;
            })(j, 0, q);
      },
      P = new e(0),
      F = typeof TextDecoder < "u" && new TextDecoder();
    try {
      F.decode(P, { stream: !0 });
    } catch {}
    return (
      (t.convert_streams = function (D) {
        var j = new DataView(D),
          N = 0;
        function V() {
          var se = j.getUint16(N);
          return (N += 2), se;
        }
        function W() {
          var se = j.getUint32(N);
          return (N += 4), se;
        }
        function Q(se) {
          _e.setUint16(me, se), (me += 2);
        }
        function B(se) {
          _e.setUint32(me, se), (me += 4);
        }
        for (
          var $ = {
              signature: W(),
              flavor: W(),
              length: W(),
              numTables: V(),
              reserved: V(),
              totalSfntSize: W(),
              majorVersion: V(),
              minorVersion: V(),
              metaOffset: W(),
              metaLength: W(),
              metaOrigLength: W(),
              privOffset: W(),
              privLength: W(),
            },
            G = 0;
          Math.pow(2, G) <= $.numTables;

        )
          G++;
        G--;
        for (
          var k = 16 * Math.pow(2, G),
            q = 16 * $.numTables - k,
            X = 12,
            ee = [],
            J = 0;
          J < $.numTables;
          J++
        )
          ee.push({
            tag: W(),
            offset: W(),
            compLength: W(),
            origLength: W(),
            origChecksum: W(),
          }),
            (X += 16);
        var oe,
          ae = new Uint8Array(
            12 +
              16 * ee.length +
              ee.reduce(function (se, Y) {
                return se + Y.origLength + 4;
              }, 0)
          ),
          le = ae.buffer,
          _e = new DataView(le),
          me = 0;
        return (
          B($.flavor),
          Q($.numTables),
          Q(k),
          Q(G),
          Q(q),
          ee.forEach(function (se) {
            B(se.tag),
              B(se.origChecksum),
              B(X),
              B(se.origLength),
              (se.outOffset = X),
              (X += se.origLength) % 4 != 0 && (X += 4 - (X % 4));
          }),
          ee.forEach(function (se) {
            var Y,
              ve = D.slice(se.offset, se.offset + se.compLength);
            if (se.compLength != se.origLength) {
              var de = new Uint8Array(se.origLength);
              (Y = new Uint8Array(ve, 2)), R(Y, de);
            } else de = new Uint8Array(ve);
            ae.set(de, se.outOffset);
            var ue = 0;
            (X = se.outOffset + se.origLength) % 4 != 0 && (ue = 4 - (X % 4)),
              ae.set(new Uint8Array(ue).buffer, se.outOffset + se.origLength),
              (oe = X + ue);
          }),
          le.slice(0, oe)
        );
      }),
      Object.defineProperty(t, "__esModule", { value: !0 }),
      t
    );
  })({}).convert_streams;
}
function PX(t, e) {
  const n = { M: 2, L: 2, Q: 4, C: 6, Z: 0 },
    r = {
      C: "18g,ca,368,1kz",
      D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
      R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
      L: "x9u,jff,a,fd,jv",
      T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n",
    },
    i = 1,
    o = 2,
    a = 4,
    s = 8,
    l = 16,
    c = 32;
  let u;
  function d(T) {
    if (!u) {
      const I = { R: o, L: i, D: a, C: l, U: c, T: s };
      u = new Map();
      for (let R in r) {
        let P = 0;
        r[R].split(",").forEach((F) => {
          let [D, j] = F.split("+");
          (D = parseInt(D, 36)),
            (j = j ? parseInt(j, 36) : 0),
            u.set((P += D), I[R]);
          for (let N = j; N--; ) u.set(++P, I[R]);
        });
      }
    }
    return u.get(T) || c;
  }
  const p = 1,
    m = 2,
    v = 3,
    S = 4,
    x = [null, "isol", "init", "fina", "medi"];
  function g(T) {
    const I = new Uint8Array(T.length);
    let R = c,
      P = p,
      F = -1;
    for (let D = 0; D < T.length; D++) {
      const j = T.codePointAt(D);
      let N = d(j) | 0,
        V = p;
      N & s ||
        (R & (i | a | l)
          ? N & (o | a | l)
            ? ((V = v), (P === p || P === v) && I[F]++)
            : N & (i | c) && (P === m || P === S) && I[F]--
          : R & (o | c) && (P === m || P === S) && I[F]--,
        (P = I[D] = V),
        (R = N),
        (F = D),
        j > 65535 && D++);
    }
    return I;
  }
  function _(T, I) {
    const R = [];
    for (let F = 0; F < I.length; F++) {
      const D = I.codePointAt(F);
      D > 65535 && F++, R.push(t.U.codeToGlyph(T, D));
    }
    const P = T.GSUB;
    if (P) {
      const { lookupList: F, featureList: D } = P;
      let j;
      const N = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/,
        V = [];
      D.forEach((W) => {
        if (N.test(W.tag))
          for (let Q = 0; Q < W.tab.length; Q++) {
            if (V[W.tab[Q]]) continue;
            V[W.tab[Q]] = !0;
            const B = F[W.tab[Q]],
              $ = /^(isol|init|fina|medi)$/.test(W.tag);
            $ && !j && (j = g(I));
            for (let G = 0; G < R.length; G++)
              (!j || !$ || x[j[G]] === W.tag) && t.U._applySubs(R, G, B, F);
          }
      });
    }
    return R;
  }
  function y(T, I) {
    const R = new Int16Array(I.length * 3);
    let P = 0;
    for (; P < I.length; P++) {
      const N = I[P];
      if (N === -1) continue;
      R[P * 3 + 2] = T.hmtx.aWidth[N];
      const V = T.GPOS;
      if (V) {
        const W = V.lookupList;
        for (let Q = 0; Q < W.length; Q++) {
          const B = W[Q];
          for (let $ = 0; $ < B.tabs.length; $++) {
            const G = B.tabs[$];
            if (B.ltype === 1) {
              if (t._lctf.coverageIndex(G.coverage, N) !== -1 && G.pos) {
                j(G.pos, P);
                break;
              }
            } else if (B.ltype === 2) {
              let k = null,
                q = F();
              if (q !== -1) {
                const X = t._lctf.coverageIndex(G.coverage, I[q]);
                if (X !== -1) {
                  if (G.fmt === 1) {
                    const ee = G.pairsets[X];
                    for (let J = 0; J < ee.length; J++)
                      ee[J].gid2 === N && (k = ee[J]);
                  } else if (G.fmt === 2) {
                    const ee = t.U._getGlyphClass(I[q], G.classDef1),
                      J = t.U._getGlyphClass(N, G.classDef2);
                    k = G.matrix[ee][J];
                  }
                  if (k) {
                    k.val1 && j(k.val1, q), k.val2 && j(k.val2, P);
                    break;
                  }
                }
              }
            } else if (B.ltype === 4) {
              const k = t._lctf.coverageIndex(G.markCoverage, N);
              if (k !== -1) {
                const q = F(D),
                  X =
                    q === -1 ? -1 : t._lctf.coverageIndex(G.baseCoverage, I[q]);
                if (X !== -1) {
                  const ee = G.markArray[k],
                    J = G.baseArray[X][ee.markClass];
                  (R[P * 3] = J.x - ee.x + R[q * 3] - R[q * 3 + 2]),
                    (R[P * 3 + 1] = J.y - ee.y + R[q * 3 + 1]);
                  break;
                }
              }
            } else if (B.ltype === 6) {
              const k = t._lctf.coverageIndex(G.mark1Coverage, N);
              if (k !== -1) {
                const q = F();
                if (q !== -1) {
                  const X = I[q];
                  if (w(T, X) === 3) {
                    const ee = t._lctf.coverageIndex(G.mark2Coverage, X);
                    if (ee !== -1) {
                      const J = G.mark1Array[k],
                        oe = G.mark2Array[ee][J.markClass];
                      (R[P * 3] = oe.x - J.x + R[q * 3] - R[q * 3 + 2]),
                        (R[P * 3 + 1] = oe.y - J.y + R[q * 3 + 1]);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (T.kern && !T.cff) {
        const W = F();
        if (W !== -1) {
          const Q = T.kern.glyph1.indexOf(I[W]);
          if (Q !== -1) {
            const B = T.kern.rval[Q].glyph2.indexOf(N);
            B !== -1 && (R[W * 3 + 2] += T.kern.rval[Q].vals[B]);
          }
        }
      }
    }
    return R;
    function F(N) {
      for (let V = P - 1; V >= 0; V--)
        if (I[V] !== -1 && (!N || N(I[V]))) return V;
      return -1;
    }
    function D(N) {
      return w(T, N) === 1;
    }
    function j(N, V) {
      for (let W = 0; W < 3; W++) R[V * 3 + W] += N[W] || 0;
    }
  }
  function w(T, I) {
    const R = T.GDEF && T.GDEF.glyphClassDef;
    return R ? t.U._getGlyphClass(I, R) : 0;
  }
  function A(...T) {
    for (let I = 0; I < T.length; I++) if (typeof T[I] == "number") return T[I];
  }
  function M(T) {
    const I = Object.create(null),
      R = T["OS/2"],
      P = T.hhea,
      F = T.head.unitsPerEm,
      D = A(R && R.sTypoAscender, P && P.ascender, F),
      j = {
        unitsPerEm: F,
        ascender: D,
        descender: A(R && R.sTypoDescender, P && P.descender, 0),
        capHeight: A(R && R.sCapHeight, D),
        xHeight: A(R && R.sxHeight, D),
        lineGap: A(R && R.sTypoLineGap, P && P.lineGap),
        supportsCodePoint(N) {
          return t.U.codeToGlyph(T, N) > 0;
        },
        forEachGlyph(N, V, W, Q) {
          let B = 0;
          const $ = (1 / j.unitsPerEm) * V,
            G = _(T, N);
          let k = 0;
          const q = y(T, G);
          return (
            G.forEach((X, ee) => {
              if (X !== -1) {
                let J = I[X];
                if (!J) {
                  const { cmds: oe, crds: ae } = t.U.glyphToPath(T, X);
                  let le = "",
                    _e = 0;
                  for (let de = 0, ue = oe.length; de < ue; de++) {
                    const fe = n[oe[de]];
                    le += oe[de];
                    for (let Te = 1; Te <= fe; Te++)
                      le += (Te > 1 ? "," : "") + ae[_e++];
                  }
                  let me, se, Y, ve;
                  if (ae.length) {
                    (me = se = 1 / 0), (Y = ve = -1 / 0);
                    for (let de = 0, ue = ae.length; de < ue; de += 2) {
                      let fe = ae[de],
                        Te = ae[de + 1];
                      fe < me && (me = fe),
                        Te < se && (se = Te),
                        fe > Y && (Y = fe),
                        Te > ve && (ve = Te);
                    }
                  } else me = Y = se = ve = 0;
                  J = I[X] = {
                    index: X,
                    advanceWidth: T.hmtx.aWidth[X],
                    xMin: me,
                    yMin: se,
                    xMax: Y,
                    yMax: ve,
                    path: le,
                  };
                }
                Q.call(null, J, B + q[ee * 3] * $, q[ee * 3 + 1] * $, k),
                  (B += q[ee * 3 + 2] * $),
                  W && (B += W * V);
              }
              k += N.codePointAt(k) > 65535 ? 2 : 1;
            }),
            B
          );
        },
      };
    return j;
  }
  return function (I) {
    const R = new Uint8Array(I, 0, 4),
      P = t._bin.readASCII(R, 0, 4);
    if (P === "wOFF") I = e(I);
    else if (P === "wOF2") throw new Error("woff2 fonts not supported");
    return M(t.parse(I)[0]);
  };
}
const IX = If({
  name: "Typr Font Parser",
  dependencies: [AX, RX, PX],
  init(t, e, n) {
    const r = t(),
      i = e();
    return n(r, i);
  },
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/ function LX() {
  return (function (t) {
    var e = function () {
      this.buckets = new Map();
    };
    (e.prototype.add = function (y) {
      var w = y >> 5;
      this.buckets.set(w, (this.buckets.get(w) || 0) | (1 << (31 & y)));
    }),
      (e.prototype.has = function (y) {
        var w = this.buckets.get(y >> 5);
        return w !== void 0 && (w & (1 << (31 & y))) != 0;
      }),
      (e.prototype.serialize = function () {
        var y = [];
        return (
          this.buckets.forEach(function (w, A) {
            y.push((+A).toString(36) + ":" + w.toString(36));
          }),
          y.join(",")
        );
      }),
      (e.prototype.deserialize = function (y) {
        var w = this;
        this.buckets.clear(),
          y.split(",").forEach(function (A) {
            var M = A.split(":");
            w.buckets.set(parseInt(M[0], 36), parseInt(M[1], 36));
          });
      });
    var n = Math.pow(2, 8),
      r = n - 1,
      i = ~r;
    function o(y) {
      var w = (function (M) {
          return M & i;
        })(y).toString(16),
        A = (function (M) {
          return (M & i) + n - 1;
        })(y).toString(16);
      return "codepoint-index/plane" + (y >> 16) + "/" + w + "-" + A + ".json";
    }
    function a(y, w) {
      var A = y & r,
        M = w.codePointAt((A / 6) | 0);
      return ((M = (M || 48) - 48) & (1 << A % 6)) != 0;
    }
    function s(y, w) {
      var A;
      ((A = y),
      A.replace(/U\+/gi, "")
        .replace(/^,+|,+$/g, "")
        .split(/,+/)
        .map(function (M) {
          return M.split("-").map(function (T) {
            return parseInt(T.trim(), 16);
          });
        })).forEach(function (M) {
        var T = M[0],
          I = M[1];
        I === void 0 && (I = T), w(T, I);
      });
    }
    function l(y, w) {
      s(y, function (A, M) {
        for (var T = A; T <= M; T++) w(T);
      });
    }
    var c = {},
      u = {},
      d = new WeakMap(),
      p =
        "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function m(y) {
      var w = d.get(y);
      return (
        w ||
          ((w = new e()),
          l(y.ranges, function (A) {
            return w.add(A);
          }),
          d.set(y, w)),
        w
      );
    }
    var v,
      S = new Map();
    function x(y, w, A) {
      return y[w]
        ? w
        : y[A]
        ? A
        : (function (M) {
            for (var T in M) return T;
          })(y);
    }
    function g(y, w) {
      var A = w;
      if (!y.includes(A)) {
        A = 1 / 0;
        for (var M = 0; M < y.length; M++)
          Math.abs(y[M] - w) < Math.abs(A - w) && (A = y[M]);
      }
      return A;
    }
    function _(y) {
      return (
        v ||
          ((v = new Set()),
          l("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function (w) {
            v.add(w);
          })),
        v.has(y)
      );
    }
    return (
      (t.CodePointSet = e),
      (t.clearCache = function () {
        (c = {}), (u = {});
      }),
      (t.getFontsForString = function (y, w) {
        w === void 0 && (w = {});
        var A,
          M = w.lang;
        M === void 0 &&
          (M = new RegExp("\\p{Script=Hangul}", "u").test((A = y))
            ? "ko"
            : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(
                A
              )
            ? "ja"
            : "en");
        var T = w.category;
        T === void 0 && (T = "sans-serif");
        var I = w.style;
        I === void 0 && (I = "normal");
        var R = w.weight;
        R === void 0 && (R = 400);
        var P = (w.dataUrl || p).replace(/\/$/g, ""),
          F = new Map(),
          D = new Uint8Array(y.length),
          j = {},
          N = {},
          V = new Array(y.length),
          W = new Map(),
          Q = !1;
        function B(k) {
          var q = S.get(k);
          return (
            q ||
              ((q = fetch(P + "/" + k)
                .then(function (X) {
                  if (!X.ok) throw new Error(X.statusText);
                  return X.json().then(function (ee) {
                    if (!Array.isArray(ee) || ee[0] !== 1)
                      throw new Error(
                        "Incorrect schema version; need 1, got " + ee[0]
                      );
                    return ee[1];
                  });
                })
                .catch(function (X) {
                  if (P !== p)
                    return (
                      Q ||
                        (console.error(
                          'unicode-font-resolver: Failed loading from dataUrl "' +
                            P +
                            '", trying default CDN. ' +
                            X.message
                        ),
                        (Q = !0)),
                      (P = p),
                      S.delete(k),
                      B(k)
                    );
                  throw X;
                })),
              S.set(k, q)),
            q
          );
        }
        for (
          var $ = function (k) {
              var q = y.codePointAt(k),
                X = o(q);
              (V[k] = X),
                c[X] ||
                  W.has(X) ||
                  W.set(
                    X,
                    B(X).then(function (ee) {
                      c[X] = ee;
                    })
                  ),
                q > 65535 && (k++, (G = k));
            },
            G = 0;
          G < y.length;
          G++
        )
          $(G);
        return Promise.all(W.values())
          .then(function () {
            W.clear();
            for (
              var k = function (X) {
                  var ee = y.codePointAt(X),
                    J = null,
                    oe = c[V[X]],
                    ae = void 0;
                  for (var le in oe) {
                    var _e = N[le];
                    if (
                      (_e === void 0 &&
                        (_e = N[le] = new RegExp(le).test(M || "en")),
                      _e)
                    ) {
                      for (var me in ((ae = le), oe[le]))
                        if (a(ee, oe[le][me])) {
                          J = me;
                          break;
                        }
                      break;
                    }
                  }
                  if (!J) {
                    e: for (var se in oe)
                      if (se !== ae) {
                        for (var Y in oe[se])
                          if (a(ee, oe[se][Y])) {
                            J = Y;
                            break e;
                          }
                      }
                  }
                  J ||
                    (console.debug("No font coverage for U+" + ee.toString(16)),
                    (J = "latin")),
                    (V[X] = J),
                    u[J] ||
                      W.has(J) ||
                      W.set(
                        J,
                        B("font-meta/" + J + ".json").then(function (ve) {
                          u[J] = ve;
                        })
                      ),
                    ee > 65535 && (X++, (q = X));
                },
                q = 0;
              q < y.length;
              q++
            )
              k(q);
            return Promise.all(W.values());
          })
          .then(function () {
            for (var k, q = null, X = 0; X < y.length; X++) {
              var ee = y.codePointAt(X);
              if (q && (_(ee) || m(q).has(ee))) D[X] = D[X - 1];
              else {
                q = u[V[X]];
                var J = j[q.id];
                if (!J) {
                  var oe = q.typeforms,
                    ae = x(oe, T, "sans-serif"),
                    le = x(oe[ae], I, "normal"),
                    _e = g(
                      (k = oe[ae]) === null || k === void 0 ? void 0 : k[le],
                      R
                    );
                  J = j[q.id] =
                    P +
                    "/font-files/" +
                    q.id +
                    "/" +
                    ae +
                    "." +
                    le +
                    "." +
                    _e +
                    ".woff";
                }
                var me = F.get(J);
                me == null && ((me = F.size), F.set(J, me)), (D[X] = me);
              }
              ee > 65535 && (X++, (D[X] = D[X - 1]));
            }
            return { fontUrls: Array.from(F.keys()), chars: D };
          });
      }),
      Object.defineProperty(t, "__esModule", { value: !0 }),
      t
    );
  })({});
}
function OX(t, e) {
  const n = Object.create(null),
    r = Object.create(null);
  function i(a, s) {
    const l = (c) => {
      console.error(`Failure loading font ${a}`, c);
    };
    try {
      const c = new XMLHttpRequest();
      c.open("get", a, !0),
        (c.responseType = "arraybuffer"),
        (c.onload = function () {
          if (c.status >= 400) l(new Error(c.statusText));
          else if (c.status > 0)
            try {
              const u = t(c.response);
              (u.src = a), s(u);
            } catch (u) {
              l(u);
            }
        }),
        (c.onerror = l),
        c.send();
    } catch (c) {
      l(c);
    }
  }
  function o(a, s) {
    let l = n[a];
    l
      ? s(l)
      : r[a]
      ? r[a].push(s)
      : ((r[a] = [s]),
        i(a, (c) => {
          (c.src = a), (n[a] = c), r[a].forEach((u) => u(c)), delete r[a];
        }));
  }
  return function (
    a,
    s,
    {
      lang: l,
      fonts: c = [],
      style: u = "normal",
      weight: d = "normal",
      unicodeFontsURL: p,
    } = {}
  ) {
    const m = new Uint8Array(a.length),
      v = [];
    a.length || _();
    const S = new Map(),
      x = [];
    if (
      (u !== "italic" && (u = "normal"),
      typeof d != "number" && (d = d === "bold" ? 700 : 400),
      c && !Array.isArray(c) && (c = [c]),
      (c = c
        .slice()
        .filter((w) => !w.lang || w.lang.test(l))
        .reverse()),
      c.length)
    ) {
      let T = 0;
      (function I(R = 0) {
        for (let P = R, F = a.length; P < F; P++) {
          const D = a.codePointAt(P);
          if (
            (T === 1 && v[m[P - 1]].supportsCodePoint(D)) ||
            (P > 0 && /\s/.test(a[P]))
          )
            (m[P] = m[P - 1]), T === 2 && (x[x.length - 1][1] = P);
          else
            for (let j = m[P], N = c.length; j <= N; j++)
              if (j === N) {
                const V = T === 2 ? x[x.length - 1] : (x[x.length] = [P, P]);
                (V[1] = P), (T = 2);
              } else {
                m[P] = j;
                const { src: V, unicodeRange: W } = c[j];
                if (!W || y(D, W)) {
                  const Q = n[V];
                  if (!Q) {
                    o(V, () => {
                      I(P);
                    });
                    return;
                  }
                  if (Q.supportsCodePoint(D)) {
                    let B = S.get(Q);
                    typeof B != "number" &&
                      ((B = v.length), v.push(Q), S.set(Q, B)),
                      (m[P] = B),
                      (T = 1);
                    break;
                  }
                }
              }
          D > 65535 &&
            P + 1 < F &&
            ((m[P + 1] = m[P]), P++, T === 2 && (x[x.length - 1][1] = P));
        }
        g();
      })();
    } else x.push([0, a.length - 1]), g();
    function g() {
      if (x.length) {
        const w = x.map((A) => a.substring(A[0], A[1] + 1)).join(`
`);
        e.getFontsForString(w, {
          lang: l || void 0,
          style: u,
          weight: d,
          dataUrl: p,
        }).then(({ fontUrls: A, chars: M }) => {
          const T = v.length;
          let I = 0;
          x.forEach((P) => {
            for (let F = 0, D = P[1] - P[0]; F <= D; F++)
              m[P[0] + F] = M[I++] + T;
            I++;
          });
          let R = 0;
          A.forEach((P, F) => {
            o(P, (D) => {
              (v[F + T] = D), ++R === A.length && _();
            });
          });
        });
      } else _();
    }
    function _() {
      s({ chars: m, fonts: v });
    }
    function y(w, A) {
      for (let M = 0; M < A.length; M++) {
        const [T, I = T] = A[M];
        if (T <= w && w <= I) return !0;
      }
      return !1;
    }
  };
}
const NX = If({
  name: "FontResolver",
  dependencies: [OX, IX, LX],
  init(t, e, n) {
    return t(e, n());
  },
});
function FX(t, e) {
  const r =
      /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,
    i = "[^\\S\\u00A0]",
    o = new RegExp(
      `${i}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`
    );
  function a(
    {
      text: v,
      lang: S,
      fonts: x,
      style: g,
      weight: _,
      preResolvedFonts: y,
      unicodeFontsURL: w,
    },
    A
  ) {
    const M = ({ chars: T, fonts: I }) => {
      let R, P;
      const F = [];
      for (let D = 0; D < T.length; D++)
        T[D] !== P
          ? ((P = T[D]), F.push((R = { start: D, end: D, fontObj: I[T[D]] })))
          : (R.end = D);
      A(F);
    };
    y
      ? M(y)
      : t(v, M, { lang: S, fonts: x, style: g, weight: _, unicodeFontsURL: w });
  }
  function s(
    {
      text: v = "",
      font: S,
      lang: x,
      sdfGlyphSize: g = 64,
      fontSize: _ = 400,
      fontWeight: y = 1,
      fontStyle: w = "normal",
      letterSpacing: A = 0,
      lineHeight: M = "normal",
      maxWidth: T = 1 / 0,
      direction: I,
      textAlign: R = "left",
      textIndent: P = 0,
      whiteSpace: F = "normal",
      overflowWrap: D = "normal",
      anchorX: j = 0,
      anchorY: N = 0,
      metricsOnly: V = !1,
      unicodeFontsURL: W,
      preResolvedFonts: Q = null,
      includeCaretPositions: B = !1,
      chunkedBoundsSize: $ = 8192,
      colorRanges: G = null,
    },
    k
  ) {
    const q = d(),
      X = { fontLoad: 0, typesetting: 0 };
    v.indexOf("\r") > -1 &&
      (console.info("Typesetter: got text with \\r chars; normalizing to \\n"),
      (v = v
        .replace(
          /\r\n/g,
          `
`
        )
        .replace(
          /\r/g,
          `
`
        ))),
      (_ = +_),
      (A = +A),
      (T = +T),
      (M = M || "normal"),
      (P = +P),
      a(
        {
          text: v,
          lang: x,
          style: w,
          weight: y,
          fonts: typeof S == "string" ? [{ src: S }] : S,
          unicodeFontsURL: W,
          preResolvedFonts: Q,
        },
        (ee) => {
          X.fontLoad = d() - q;
          const J = isFinite(T);
          let oe = null,
            ae = null,
            le = null,
            _e = null,
            me = null,
            se = null,
            Y = null,
            ve = null,
            de = 0,
            ue = 0,
            fe = F !== "nowrap";
          const Te = new Map(),
            pe = d();
          let H = P,
            z = 0,
            Z = new p();
          const ge = [Z];
          ee.forEach((Le) => {
            const { fontObj: Oe } = Le,
              {
                ascender: Pe,
                descender: Se,
                unitsPerEm: Je,
                lineGap: st,
                capHeight: Qe,
                xHeight: Ke,
              } = Oe;
            let Ne = Te.get(Oe);
            if (!Ne) {
              const Ee = _ / Je,
                ie = M === "normal" ? (Pe - Se + st) * Ee : M * _,
                $e = (ie - (Pe - Se) * Ee) / 2,
                He = Math.min(ie, (Pe - Se) * Ee),
                Xe = ((Pe + Se) / 2) * Ee + He / 2;
              (Ne = {
                index: Te.size,
                src: Oe.src,
                fontObj: Oe,
                fontSizeMult: Ee,
                unitsPerEm: Je,
                ascender: Pe * Ee,
                descender: Se * Ee,
                capHeight: Qe * Ee,
                xHeight: Ke * Ee,
                lineHeight: ie,
                baseline: -$e - Pe * Ee,
                caretTop: Xe,
                caretBottom: Xe - He,
              }),
                Te.set(Oe, Ne);
            }
            const { fontSizeMult: ne } = Ne,
              Ie = v.slice(Le.start, Le.end + 1);
            let et, We;
            Oe.forEachGlyph(Ie, _, A, (Ee, ie, $e, He) => {
              (ie += z), (He += Le.start), (et = ie), (We = Ee);
              const Xe = v.charAt(He),
                Ue = Ee.advanceWidth * ne,
                Ye = Z.count;
              let ke;
              if (
                ("isEmpty" in Ee ||
                  ((Ee.isWhitespace = !!Xe && new RegExp(i).test(Xe)),
                  (Ee.canBreakAfter = !!Xe && o.test(Xe)),
                  (Ee.isEmpty =
                    Ee.xMin === Ee.xMax || Ee.yMin === Ee.yMax || r.test(Xe))),
                !Ee.isWhitespace && !Ee.isEmpty && ue++,
                fe && J && !Ee.isWhitespace && ie + Ue + H > T && Ye)
              ) {
                if (Z.glyphAt(Ye - 1).glyphObj.canBreakAfter)
                  (ke = new p()), (H = -ie);
                else
                  for (let ut = Ye; ut--; )
                    if (ut === 0 && D === "break-word") {
                      (ke = new p()), (H = -ie);
                      break;
                    } else if (Z.glyphAt(ut).glyphObj.canBreakAfter) {
                      ke = Z.splitAt(ut + 1);
                      const dt = ke.glyphAt(0).x;
                      H -= dt;
                      for (let Rt = ke.count; Rt--; ) ke.glyphAt(Rt).x -= dt;
                      break;
                    }
                ke && ((Z.isSoftWrapped = !0), (Z = ke), ge.push(Z), (de = T));
              }
              let tt = Z.glyphAt(Z.count);
              (tt.glyphObj = Ee),
                (tt.x = ie + H),
                (tt.y = $e),
                (tt.width = Ue),
                (tt.charIndex = He),
                (tt.fontData = Ne),
                Xe ===
                  `
` && ((Z = new p()), ge.push(Z), (H = -(ie + Ue + A * _) + P));
            }),
              (z = et + We.advanceWidth * ne + A * _);
          });
          let ce = 0;
          ge.forEach((Le) => {
            let Oe = !0;
            for (let Pe = Le.count; Pe--; ) {
              const Se = Le.glyphAt(Pe);
              Oe &&
                !Se.glyphObj.isWhitespace &&
                ((Le.width = Se.x + Se.width),
                Le.width > de && (de = Le.width),
                (Oe = !1));
              let {
                lineHeight: Je,
                capHeight: st,
                xHeight: Qe,
                baseline: Ke,
              } = Se.fontData;
              Je > Le.lineHeight && (Le.lineHeight = Je);
              const Ne = Ke - Le.baseline;
              Ne < 0 && ((Le.baseline += Ne), (Le.cap += Ne), (Le.ex += Ne)),
                (Le.cap = Math.max(Le.cap, Le.baseline + st)),
                (Le.ex = Math.max(Le.ex, Le.baseline + Qe));
            }
            (Le.baseline -= ce),
              (Le.cap -= ce),
              (Le.ex -= ce),
              (ce += Le.lineHeight);
          });
          let he = 0,
            Me = 0;
          if (
            (j &&
              (typeof j == "number"
                ? (he = -j)
                : typeof j == "string" &&
                  (he =
                    -de *
                    (j === "left"
                      ? 0
                      : j === "center"
                      ? 0.5
                      : j === "right"
                      ? 1
                      : c(j)))),
            N &&
              (typeof N == "number"
                ? (Me = -N)
                : typeof N == "string" &&
                  (Me =
                    N === "top"
                      ? 0
                      : N === "top-baseline"
                      ? -ge[0].baseline
                      : N === "top-cap"
                      ? -ge[0].cap
                      : N === "top-ex"
                      ? -ge[0].ex
                      : N === "middle"
                      ? ce / 2
                      : N === "bottom"
                      ? ce
                      : N === "bottom-baseline"
                      ? -ge[ge.length - 1].baseline
                      : c(N) * ce)),
            !V)
          ) {
            const Le = e.getEmbeddingLevels(v, I);
            (oe = new Uint16Array(ue)),
              (ae = new Uint8Array(ue)),
              (le = new Float32Array(ue * 2)),
              (_e = {}),
              (Y = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
              (ve = []),
              B && (se = new Float32Array(v.length * 4)),
              G && (me = new Uint8Array(ue * 3));
            let Oe = 0,
              Pe = -1,
              Se = -1,
              Je,
              st;
            if (
              (ge.forEach((Qe, Ke) => {
                let { count: Ne, width: ne } = Qe;
                if (Ne > 0) {
                  let Ie = 0;
                  for (
                    let He = Ne;
                    He-- && Qe.glyphAt(He).glyphObj.isWhitespace;

                  )
                    Ie++;
                  let et = 0,
                    We = 0;
                  if (R === "center") et = (de - ne) / 2;
                  else if (R === "right") et = de - ne;
                  else if (R === "justify" && Qe.isSoftWrapped) {
                    let He = 0;
                    for (let Xe = Ne - Ie; Xe--; )
                      Qe.glyphAt(Xe).glyphObj.isWhitespace && He++;
                    We = (de - ne) / He;
                  }
                  if (We || et) {
                    let He = 0;
                    for (let Xe = 0; Xe < Ne; Xe++) {
                      let Ue = Qe.glyphAt(Xe);
                      const Ye = Ue.glyphObj;
                      (Ue.x += et + He),
                        We !== 0 &&
                          Ye.isWhitespace &&
                          Xe < Ne - Ie &&
                          ((He += We), (Ue.width += We));
                    }
                  }
                  const Ee = e.getReorderSegments(
                    v,
                    Le,
                    Qe.glyphAt(0).charIndex,
                    Qe.glyphAt(Qe.count - 1).charIndex
                  );
                  for (let He = 0; He < Ee.length; He++) {
                    const [Xe, Ue] = Ee[He];
                    let Ye = 1 / 0,
                      ke = -1 / 0;
                    for (let tt = 0; tt < Ne; tt++)
                      if (Qe.glyphAt(tt).charIndex >= Xe) {
                        let ut = tt,
                          dt = tt;
                        for (; dt < Ne; dt++) {
                          let Rt = Qe.glyphAt(dt);
                          if (Rt.charIndex > Ue) break;
                          dt < Ne - Ie &&
                            ((Ye = Math.min(Ye, Rt.x)),
                            (ke = Math.max(ke, Rt.x + Rt.width)));
                        }
                        for (let Rt = ut; Rt < dt; Rt++) {
                          const Bt = Qe.glyphAt(Rt);
                          Bt.x = ke - (Bt.x + Bt.width - Ye);
                        }
                        break;
                      }
                  }
                  let ie;
                  const $e = (He) => (ie = He);
                  for (let He = 0; He < Ne; He++) {
                    const Xe = Qe.glyphAt(He);
                    ie = Xe.glyphObj;
                    const Ue = ie.index,
                      Ye = Le.levels[Xe.charIndex] & 1;
                    if (Ye) {
                      const ke = e.getMirroredCharacter(v[Xe.charIndex]);
                      ke && Xe.fontData.fontObj.forEachGlyph(ke, 0, 0, $e);
                    }
                    if (B) {
                      const { charIndex: ke, fontData: tt } = Xe,
                        ut = Xe.x + he,
                        dt = Xe.x + Xe.width + he;
                      (se[ke * 4] = Ye ? dt : ut),
                        (se[ke * 4 + 1] = Ye ? ut : dt),
                        (se[ke * 4 + 2] = Qe.baseline + tt.caretBottom + Me),
                        (se[ke * 4 + 3] = Qe.baseline + tt.caretTop + Me);
                      const Rt = ke - Pe;
                      Rt > 1 && u(se, Pe, Rt), (Pe = ke);
                    }
                    if (G) {
                      const { charIndex: ke } = Xe;
                      for (; ke > Se; )
                        Se++, G.hasOwnProperty(Se) && (st = G[Se]);
                    }
                    if (!ie.isWhitespace && !ie.isEmpty) {
                      const ke = Oe++,
                        { fontSizeMult: tt, src: ut, index: dt } = Xe.fontData,
                        Rt = _e[ut] || (_e[ut] = {});
                      Rt[Ue] ||
                        (Rt[Ue] = {
                          path: ie.path,
                          pathBounds: [ie.xMin, ie.yMin, ie.xMax, ie.yMax],
                        });
                      const Bt = Xe.x + he,
                        In = Xe.y + Qe.baseline + Me;
                      (le[ke * 2] = Bt), (le[ke * 2 + 1] = In);
                      const dn = Bt + ie.xMin * tt,
                        _n = In + ie.yMin * tt,
                        gn = Bt + ie.xMax * tt,
                        Gt = In + ie.yMax * tt;
                      dn < Y[0] && (Y[0] = dn),
                        _n < Y[1] && (Y[1] = _n),
                        gn > Y[2] && (Y[2] = gn),
                        Gt > Y[3] && (Y[3] = Gt),
                        ke % $ === 0 &&
                          ((Je = {
                            start: ke,
                            end: ke,
                            rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                          }),
                          ve.push(Je)),
                        Je.end++;
                      const ln = Je.rect;
                      if (
                        (dn < ln[0] && (ln[0] = dn),
                        _n < ln[1] && (ln[1] = _n),
                        gn > ln[2] && (ln[2] = gn),
                        Gt > ln[3] && (ln[3] = Gt),
                        (oe[ke] = Ue),
                        (ae[ke] = dt),
                        G)
                      ) {
                        const Ht = ke * 3;
                        (me[Ht] = (st >> 16) & 255),
                          (me[Ht + 1] = (st >> 8) & 255),
                          (me[Ht + 2] = st & 255);
                      }
                    }
                  }
                }
              }),
              se)
            ) {
              const Qe = v.length - Pe;
              Qe > 1 && u(se, Pe, Qe);
            }
          }
          const Re = [];
          Te.forEach(
            ({
              index: Le,
              src: Oe,
              unitsPerEm: Pe,
              ascender: Se,
              descender: Je,
              lineHeight: st,
              capHeight: Qe,
              xHeight: Ke,
            }) => {
              Re[Le] = {
                src: Oe,
                unitsPerEm: Pe,
                ascender: Se,
                descender: Je,
                lineHeight: st,
                capHeight: Qe,
                xHeight: Ke,
              };
            }
          ),
            (X.typesetting = d() - pe),
            k({
              glyphIds: oe,
              glyphFontIndices: ae,
              glyphPositions: le,
              glyphData: _e,
              fontData: Re,
              caretPositions: se,
              glyphColors: me,
              chunkedBounds: ve,
              fontSize: _,
              topBaseline: Me + ge[0].baseline,
              blockBounds: [he, Me - ce, he + de, Me],
              visibleBounds: Y,
              timings: X,
            });
        }
      );
  }
  function l(v, S) {
    s({ ...v, metricsOnly: !0 }, (x) => {
      const [g, _, y, w] = x.blockBounds;
      S({ width: y - g, height: w - _ });
    });
  }
  function c(v) {
    let S = v.match(/^([\d.]+)%$/),
      x = S ? parseFloat(S[1]) : NaN;
    return isNaN(x) ? 0 : x / 100;
  }
  function u(v, S, x) {
    const g = v[S * 4],
      _ = v[S * 4 + 1],
      y = v[S * 4 + 2],
      w = v[S * 4 + 3],
      A = (_ - g) / x;
    for (let M = 0; M < x; M++) {
      const T = (S + M) * 4;
      (v[T] = g + A * M),
        (v[T + 1] = g + A * (M + 1)),
        (v[T + 2] = y),
        (v[T + 3] = w);
    }
  }
  function d() {
    return (self.performance || Date).now();
  }
  function p() {
    this.data = [];
  }
  const m = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return (
    (p.prototype = {
      width: 0,
      lineHeight: 0,
      baseline: 0,
      cap: 0,
      ex: 0,
      isSoftWrapped: !1,
      get count() {
        return Math.ceil(this.data.length / m.length);
      },
      glyphAt(v) {
        let S = p.flyweight;
        return (S.data = this.data), (S.index = v), S;
      },
      splitAt(v) {
        let S = new p();
        return (S.data = this.data.splice(v * m.length)), S;
      },
    }),
    (p.flyweight = m.reduce(
      (v, S, x, g) => (
        Object.defineProperty(v, S, {
          get() {
            return this.data[this.index * m.length + x];
          },
          set(_) {
            this.data[this.index * m.length + x] = _;
          },
        }),
        v
      ),
      { data: null, index: 0 }
    )),
    { typeset: s, measure: l }
  );
}
const Jc = () => (self.performance || Date).now(),
  C1 = Oz();
let x3;
function DX(t, e, n, r, i, o, a, s, l, c, u = !0) {
  return u
    ? UX(t, e, n, r, i, o, a, s, l, c).then(
        null,
        (d) => (
          x3 ||
            (console.warn("WebGL SDF generation failed, falling back to JS", d),
            (x3 = !0)),
          _3(t, e, n, r, i, o, a, s, l, c)
        )
      )
    : _3(t, e, n, r, i, o, a, s, l, c);
}
const M0 = [],
  zX = 5;
let qw = 0;
function Fz() {
  const t = Jc();
  for (; M0.length && Jc() - t < zX; ) M0.shift()();
  qw = M0.length ? setTimeout(Fz, 0) : 0;
}
const UX = (...t) =>
    new Promise((e, n) => {
      M0.push(() => {
        const r = Jc();
        try {
          C1.webgl.generateIntoCanvas(...t), e({ timing: Jc() - r });
        } catch (i) {
          n(i);
        }
      }),
        qw || (qw = setTimeout(Fz, 0));
    }),
  kX = 4,
  BX = 2e3,
  S3 = {};
let HX = 0;
function _3(t, e, n, r, i, o, a, s, l, c) {
  const u = "TroikaTextSDFGenerator_JS_" + (HX++ % kX);
  let d = S3[u];
  return (
    d ||
      (d = S3[u] =
        {
          workerModule: If({
            name: u,
            workerId: u,
            dependencies: [Oz, Jc],
            init(p, m) {
              const v = p().javascript.generate;
              return function (...S) {
                const x = m();
                return { textureData: v(...S), timing: m() - x };
              };
            },
            getTransferables(p) {
              return [p.textureData.buffer];
            },
          }),
          requests: 0,
          idleTimer: null,
        }),
    d.requests++,
    clearTimeout(d.idleTimer),
    d.workerModule(t, e, n, r, i, o).then(({ textureData: p, timing: m }) => {
      const v = Jc(),
        S = new Uint8Array(p.length * 4);
      for (let x = 0; x < p.length; x++) S[x * 4 + c] = p[x];
      return (
        C1.webglUtils.renderImageData(a, S, s, l, t, e, 1 << (3 - c)),
        (m += Jc() - v),
        --d.requests === 0 &&
          (d.idleTimer = setTimeout(() => {
            yX(u);
          }, BX)),
        { timing: m }
      );
    })
  );
}
function jX(t) {
  t._warm || (C1.webgl.isSupported(t), (t._warm = !0));
}
const VX = C1.webglUtils.resizeWebGLCanvasWithoutClearing,
  Ed = {
    defaultFontURL: null,
    unicodeFontsURL: null,
    sdfGlyphSize: 64,
    sdfMargin: 1 / 16,
    sdfExponent: 9,
    textureWidth: 2048,
    useWorker: !0,
  },
  $X = new pt();
function ud() {
  return (self.performance || Date).now();
}
const b3 = Object.create(null);
function Dz(t, e) {
  t = XX({}, t);
  const n = ud(),
    { defaultFontURL: r } = Ed,
    i = [];
  if (
    (r && i.push({ label: "default", src: w3(r) }),
    t.font && i.push({ label: "user", src: w3(t.font) }),
    (t.font = i),
    (t.text = "" + t.text),
    (t.sdfGlyphSize = t.sdfGlyphSize || Ed.sdfGlyphSize),
    (t.unicodeFontsURL = t.unicodeFontsURL || Ed.unicodeFontsURL),
    t.colorRanges != null)
  ) {
    let m = {};
    for (let v in t.colorRanges)
      if (t.colorRanges.hasOwnProperty(v)) {
        let S = t.colorRanges[v];
        typeof S != "number" && (S = $X.set(S).getHex()), (m[v] = S);
      }
    t.colorRanges = m;
  }
  Object.freeze(t);
  const { textureWidth: o, sdfExponent: a } = Ed,
    { sdfGlyphSize: s } = t,
    l = (o / s) * 4;
  let c = b3[s];
  if (!c) {
    const m = document.createElement("canvas");
    (m.width = o),
      (m.height = (s * 256) / l),
      (c = b3[s] =
        {
          glyphCount: 0,
          sdfGlyphSize: s,
          sdfCanvas: m,
          sdfTexture: new sr(m, void 0, void 0, void 0, Yn, Yn),
          contextLost: !1,
          glyphsByFont: new Map(),
        }),
      (c.sdfTexture.generateMipmaps = !1),
      GX(c);
  }
  const { sdfTexture: u, sdfCanvas: d } = c;
  kz(t).then((m) => {
    const {
        glyphIds: v,
        glyphFontIndices: S,
        fontData: x,
        glyphPositions: g,
        fontSize: _,
        timings: y,
      } = m,
      w = [],
      A = new Float32Array(v.length * 4);
    let M = 0,
      T = 0;
    const I = ud(),
      R = x.map((N) => {
        let V = c.glyphsByFont.get(N.src);
        return V || c.glyphsByFont.set(N.src, (V = new Map())), V;
      });
    v.forEach((N, V) => {
      const W = S[V],
        { src: Q, unitsPerEm: B } = x[W];
      let $ = R[W].get(N);
      if (!$) {
        const { path: ee, pathBounds: J } = m.glyphData[Q][N],
          oe =
            (Math.max(J[2] - J[0], J[3] - J[1]) / s) * (Ed.sdfMargin * s + 0.5),
          ae = c.glyphCount++,
          le = [J[0] - oe, J[1] - oe, J[2] + oe, J[3] + oe];
        R[W].set(N, ($ = { path: ee, atlasIndex: ae, sdfViewBox: le })),
          w.push($);
      }
      const { sdfViewBox: G } = $,
        k = g[T++],
        q = g[T++],
        X = _ / B;
      (A[M++] = k + G[0] * X),
        (A[M++] = q + G[1] * X),
        (A[M++] = k + G[2] * X),
        (A[M++] = q + G[3] * X),
        (v[V] = $.atlasIndex);
    }),
      (y.quads = (y.quads || 0) + (ud() - I));
    const P = ud();
    y.sdf = {};
    const F = d.height,
      D = Math.ceil(c.glyphCount / l),
      j = Math.pow(2, Math.ceil(Math.log2(D * s)));
    j > F &&
      (console.info(`Increasing SDF texture size ${F}->${j}`),
      VX(d, o, j),
      u.dispose()),
      Promise.all(
        w.map((N) =>
          zz(N, c, t.gpuAccelerateSDF).then(({ timing: V }) => {
            y.sdf[N.atlasIndex] = V;
          })
        )
      ).then(() => {
        w.length && !c.contextLost && (Uz(c), (u.needsUpdate = !0)),
          (y.sdfTotal = ud() - P),
          (y.total = ud() - n),
          e(
            Object.freeze({
              parameters: t,
              sdfTexture: u,
              sdfGlyphSize: s,
              sdfExponent: a,
              glyphBounds: A,
              glyphAtlasIndices: v,
              glyphColors: m.glyphColors,
              caretPositions: m.caretPositions,
              chunkedBounds: m.chunkedBounds,
              ascender: m.ascender,
              descender: m.descender,
              lineHeight: m.lineHeight,
              capHeight: m.capHeight,
              xHeight: m.xHeight,
              topBaseline: m.topBaseline,
              blockBounds: m.blockBounds,
              visibleBounds: m.visibleBounds,
              timings: m.timings,
            })
          );
      });
  }),
    Promise.resolve().then(() => {
      c.contextLost || jX(d);
    });
}
function zz(
  { path: t, atlasIndex: e, sdfViewBox: n },
  { sdfGlyphSize: r, sdfCanvas: i, contextLost: o },
  a
) {
  if (o) return Promise.resolve({ timing: -1 });
  const { textureWidth: s, sdfExponent: l } = Ed,
    c = Math.max(n[2] - n[0], n[3] - n[1]),
    u = Math.floor(e / 4),
    d = (u % (s / r)) * r,
    p = Math.floor(u / (s / r)) * r,
    m = e % 4;
  return DX(r, r, t, n, c, l, i, d, p, m, a);
}
function GX(t) {
  const e = t.sdfCanvas;
  e.addEventListener("webglcontextlost", (n) => {
    console.log("Context Lost", n), n.preventDefault(), (t.contextLost = !0);
  }),
    e.addEventListener("webglcontextrestored", (n) => {
      console.log("Context Restored", n), (t.contextLost = !1);
      const r = [];
      t.glyphsByFont.forEach((i) => {
        i.forEach((o) => {
          r.push(zz(o, t, !0));
        });
      }),
        Promise.all(r).then(() => {
          Uz(t), (t.sdfTexture.needsUpdate = !0);
        });
    });
}
function WX({ font: t, characters: e, sdfGlyphSize: n }, r) {
  let i = Array.isArray(e)
    ? e.join(`
`)
    : "" + e;
  Dz({ font: t, sdfGlyphSize: n, text: i }, r);
}
function XX(t, e) {
  for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
  return t;
}
let kv;
function w3(t) {
  return (
    kv || (kv = typeof document > "u" ? {} : document.createElement("a")),
    (kv.href = t),
    kv.href
  );
}
function Uz(t) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: n } = t,
      { width: r, height: i } = e,
      o = t.sdfCanvas.getContext("webgl");
    let a = n.image.data;
    (!a || a.length !== r * i * 4) &&
      ((a = new Uint8Array(r * i * 4)),
      (n.image = { width: r, height: i, data: a }),
      (n.flipY = !1),
      (n.isDataTexture = !0)),
      o.readPixels(0, 0, r, i, o.RGBA, o.UNSIGNED_BYTE, a);
  }
}
const qX = If({
    name: "Typesetter",
    dependencies: [FX, NX, SX],
    init(t, e, n) {
      return t(e, n());
    },
  }),
  kz = If({
    name: "Typesetter",
    dependencies: [qX],
    init(t) {
      return function (e) {
        return new Promise((n) => {
          t.typeset(e, n);
        });
      };
    },
    getTransferables(t) {
      const e = [];
      for (let n in t) t[n] && t[n].buffer && e.push(t[n].buffer);
      return e;
    },
  });
kz.onMainThread;
const E3 = {};
function KX(t) {
  let e = E3[t];
  return e || (e = E3[t] = new Zl(1, 1, t, t).translate(0.5, 0.5, 0)), e;
}
const YX = "aTroikaGlyphBounds",
  M3 = "aTroikaGlyphIndex",
  ZX = "aTroikaGlyphColor";
class QX extends M1 {
  constructor() {
    super(),
      (this.detail = 1),
      (this.curveRadius = 0),
      (this.groups = [
        { start: 0, count: 1 / 0, materialIndex: 0 },
        { start: 0, count: 1 / 0, materialIndex: 1 },
      ]),
      (this.boundingSphere = new Rr()),
      (this.boundingBox = new wr());
  }
  computeBoundingSphere() {}
  computeBoundingBox() {}
  set detail(e) {
    if (e !== this._detail) {
      (this._detail = e), (typeof e != "number" || e < 1) && (e = 1);
      let n = KX(e);
      ["position", "normal", "uv"].forEach((r) => {
        this.attributes[r] = n.attributes[r].clone();
      }),
        this.setIndex(n.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && ((this._curveRadius = e), this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  updateGlyphs(e, n, r, i, o) {
    this.updateAttributeData(YX, e, 4),
      this.updateAttributeData(M3, n, 1),
      this.updateAttributeData(ZX, o, 3),
      (this._blockBounds = r),
      (this._chunkedBounds = i),
      (this.instanceCount = n.length),
      this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: n, boundingBox: r } = this;
      if (n) {
        const { PI: i, floor: o, min: a, max: s, sin: l, cos: c } = Math,
          u = i / 2,
          d = i * 2,
          p = Math.abs(n),
          m = e[0] / p,
          v = e[2] / p,
          S = o((m + u) / d) !== o((v + u) / d) ? -p : a(l(m) * p, l(v) * p),
          x = o((m - u) / d) !== o((v - u) / d) ? p : s(l(m) * p, l(v) * p),
          g =
            o((m + i) / d) !== o((v + i) / d)
              ? p * 2
              : s(p - c(m) * p, p - c(v) * p);
        r.min.set(S, e[1], n < 0 ? -g : 0), r.max.set(x, e[3], n < 0 ? 0 : g);
      } else r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0);
      r.getBoundingSphere(this.boundingSphere);
    }
  }
  applyClipRect(e) {
    let n = this.getAttribute(M3).count,
      r = this._chunkedBounds;
    if (r)
      for (let i = r.length; i--; ) {
        n = r[i].end;
        let o = r[i].rect;
        if (o[1] < e.w && o[3] > e.y && o[0] < e.z && o[2] > e.x) break;
      }
    this.instanceCount = n;
  }
  updateAttributeData(e, n, r) {
    const i = this.getAttribute(e);
    n
      ? i && i.array.length === n.length
        ? (i.array.set(n), (i.needsUpdate = !0))
        : (this.setAttribute(e, new uu(n, r)),
          delete this._maxInstanceCount,
          this.dispose())
      : i && this.deleteAttribute(e);
  }
}
const JX = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,
  eq = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,
  tq = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,
  nq = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function rq(t) {
  const e = Xw(t, {
    chained: !0,
    extensions: { derivatives: !0 },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Ge() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new rn(0, 0, 0, 0) },
      uTroikaClipRect: { value: new rn(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Ge() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new pt() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Yt() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 },
    },
    vertexDefs: JX,
    vertexTransform: eq,
    fragmentDefs: tq,
    fragmentColorTransform: nq,
    customRewriter({ vertexShader: n, fragmentShader: r }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return (
        i.test(r) &&
          ((r = r
            .replace(i, "varying vec3 vTroikaGlyphColor")
            .replace(/\bdiffuse\b/g, "vTroikaGlyphColor")),
          i.test(n) ||
            (n = n.replace(
              Nz,
              `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
            ))),
        { vertexShader: n, fragmentShader: r }
      );
    },
  });
  return (
    (e.transparent = !0),
    (e.forceSinglePass = !0),
    Object.defineProperties(e, {
      isTroikaTextMaterial: { value: !0 },
      shadowSide: {
        get() {
          return this.side;
        },
        set() {},
      },
    }),
    e
  );
}
const BC = new Ks({ color: 16777215, side: Zo, transparent: !0 }),
  C3 = 8421504,
  T3 = new kt(),
  Bv = new K(),
  S_ = new K(),
  bh = [],
  iq = new K(),
  __ = "+x+y";
function A3(t) {
  return Array.isArray(t) ? t[0] : t;
}
let Bz = () => {
    const t = new Jn(new Zl(1, 1), BC);
    return (Bz = () => t), t;
  },
  Hz = () => {
    const t = new Jn(new Zl(1, 1, 32, 1), BC);
    return (Hz = () => t), t;
  };
const oq = { type: "syncstart" },
  aq = { type: "synccomplete" },
  jz = [
    "font",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lang",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize",
  ],
  sq = jz.concat(
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "curveRadius",
    "orientation",
    "glyphGeometryDetail"
  );
let Vz = class extends Jn {
  constructor() {
    const e = new QX();
    super(e, null),
      (this.text = ""),
      (this.anchorX = 0),
      (this.anchorY = 0),
      (this.curveRadius = 0),
      (this.direction = "auto"),
      (this.font = null),
      (this.unicodeFontsURL = null),
      (this.fontSize = 0.1),
      (this.fontWeight = "normal"),
      (this.fontStyle = "normal"),
      (this.lang = null),
      (this.letterSpacing = 0),
      (this.lineHeight = "normal"),
      (this.maxWidth = 1 / 0),
      (this.overflowWrap = "normal"),
      (this.textAlign = "left"),
      (this.textIndent = 0),
      (this.whiteSpace = "normal"),
      (this.material = null),
      (this.color = null),
      (this.colorRanges = null),
      (this.outlineWidth = 0),
      (this.outlineColor = 0),
      (this.outlineOpacity = 1),
      (this.outlineBlur = 0),
      (this.outlineOffsetX = 0),
      (this.outlineOffsetY = 0),
      (this.strokeWidth = 0),
      (this.strokeColor = C3),
      (this.strokeOpacity = 1),
      (this.fillOpacity = 1),
      (this.depthOffset = 0),
      (this.clipRect = null),
      (this.orientation = __),
      (this.glyphGeometryDetail = 1),
      (this.sdfGlyphSize = null),
      (this.gpuAccelerateSDF = !0),
      (this.debugSDF = !1);
  }
  sync(e) {
    this._needsSync &&
      ((this._needsSync = !1),
      this._isSyncing
        ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e)
        : ((this._isSyncing = !0),
          this.dispatchEvent(oq),
          Dz(
            {
              text: this.text,
              font: this.font,
              lang: this.lang,
              fontSize: this.fontSize || 0.1,
              fontWeight: this.fontWeight || "normal",
              fontStyle: this.fontStyle || "normal",
              letterSpacing: this.letterSpacing || 0,
              lineHeight: this.lineHeight || "normal",
              maxWidth: this.maxWidth,
              direction: this.direction || "auto",
              textAlign: this.textAlign,
              textIndent: this.textIndent,
              whiteSpace: this.whiteSpace,
              overflowWrap: this.overflowWrap,
              anchorX: this.anchorX,
              anchorY: this.anchorY,
              colorRanges: this.colorRanges,
              includeCaretPositions: !0,
              sdfGlyphSize: this.sdfGlyphSize,
              gpuAccelerateSDF: this.gpuAccelerateSDF,
              unicodeFontsURL: this.unicodeFontsURL,
            },
            (n) => {
              (this._isSyncing = !1),
                (this._textRenderInfo = n),
                this.geometry.updateGlyphs(
                  n.glyphBounds,
                  n.glyphAtlasIndices,
                  n.blockBounds,
                  n.chunkedBounds,
                  n.glyphColors
                );
              const r = this._queuedSyncs;
              r &&
                ((this._queuedSyncs = null),
                (this._needsSync = !0),
                this.sync(() => {
                  r.forEach((i) => i && i());
                })),
                this.dispatchEvent(aq),
                e && e();
            }
          )));
  }
  onBeforeRender(e, n, r, i, o, a) {
    this.sync(), o.isTroikaTextMaterial && this._prepareForRender(o);
  }
  dispose() {
    this.geometry.dispose();
  }
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  createDerivedMaterial(e) {
    return rq(e);
  }
  get material() {
    let e = this._derivedMaterial;
    const n =
      this._baseMaterial ||
      this._defaultMaterial ||
      (this._defaultMaterial = BC.clone());
    if (
      ((!e || !e.isDerivedFrom(n)) &&
        ((e = this._derivedMaterial = this.createDerivedMaterial(n)),
        n.addEventListener("dispose", function r() {
          n.removeEventListener("dispose", r), e.dispose();
        })),
      this.hasOutline())
    ) {
      let r = e._outlineMtl;
      return (
        r ||
          ((r = e._outlineMtl =
            Object.create(e, { id: { value: e.id + 0.1 } })),
          (r.isTextOutlineMaterial = !0),
          (r.depthWrite = !1),
          (r.map = null),
          e.addEventListener("dispose", function i() {
            e.removeEventListener("dispose", i), r.dispose();
          })),
        [r, e]
      );
    } else return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial
      ? ((this._derivedMaterial = e), (this._baseMaterial = e.baseMaterial))
      : (this._baseMaterial = e);
  }
  hasOutline() {
    return !!(
      this.outlineWidth ||
      this.outlineBlur ||
      this.outlineOffsetX ||
      this.outlineOffsetY
    );
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  get customDepthMaterial() {
    return A3(this.material).getDepthMaterial();
  }
  set customDepthMaterial(e) {}
  get customDistanceMaterial() {
    return A3(this.material).getDistanceMaterial();
  }
  set customDistanceMaterial(e) {}
  _prepareForRender(e) {
    const n = e.isTextOutlineMaterial,
      r = e.uniforms,
      i = this.textRenderInfo;
    if (i) {
      const { sdfTexture: s, blockBounds: l } = i;
      (r.uTroikaSDFTexture.value = s),
        r.uTroikaSDFTextureSize.value.set(s.image.width, s.image.height),
        (r.uTroikaSDFGlyphSize.value = i.sdfGlyphSize),
        (r.uTroikaSDFExponent.value = i.sdfExponent),
        r.uTroikaTotalBounds.value.fromArray(l),
        (r.uTroikaUseGlyphColors.value = !n && !!i.glyphColors);
      let c = 0,
        u = 0,
        d = 0,
        p,
        m,
        v,
        S = 0,
        x = 0;
      if (n) {
        let {
          outlineWidth: _,
          outlineOffsetX: y,
          outlineOffsetY: w,
          outlineBlur: A,
          outlineOpacity: M,
        } = this;
        (c = this._parsePercent(_) || 0),
          (u = Math.max(0, this._parsePercent(A) || 0)),
          (p = M),
          (S = this._parsePercent(y) || 0),
          (x = this._parsePercent(w) || 0);
      } else
        (d = Math.max(0, this._parsePercent(this.strokeWidth) || 0)),
          d &&
            ((v = this.strokeColor),
            r.uTroikaStrokeColor.value.set(v ?? C3),
            (m = this.strokeOpacity),
            m == null && (m = 1)),
          (p = this.fillOpacity);
      (r.uTroikaEdgeOffset.value = c),
        r.uTroikaPositionOffset.value.set(S, x),
        (r.uTroikaBlurRadius.value = u),
        (r.uTroikaStrokeWidth.value = d),
        (r.uTroikaStrokeOpacity.value = m),
        (r.uTroikaFillOpacity.value = p ?? 1),
        (r.uTroikaCurveRadius.value = this.curveRadius || 0);
      let g = this.clipRect;
      if (g && Array.isArray(g) && g.length === 4)
        r.uTroikaClipRect.value.fromArray(g);
      else {
        const _ = (this.fontSize || 0.1) * 100;
        r.uTroikaClipRect.value.set(l[0] - _, l[1] - _, l[2] + _, l[3] + _);
      }
      this.geometry.applyClipRect(r.uTroikaClipRect.value);
    }
    (r.uTroikaSDFDebug.value = !!this.debugSDF),
      (e.polygonOffset = !!this.depthOffset),
      (e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0);
    const o = n ? this.outlineColor || 0 : this.color;
    if (o == null) delete e.color;
    else {
      const s = e.hasOwnProperty("color") ? e.color : (e.color = new pt());
      (o !== s._input || typeof o == "object") && s.set((s._input = o));
    }
    let a = this.orientation || __;
    if (a !== e._orientation) {
      let s = r.uTroikaOrient.value;
      a = a.replace(/[^-+xyz]/g, "");
      let l = a !== __ && a.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (l) {
        let [, c, u, d, p] = l;
        (Bv.set(0, 0, 0)[u] = c === "-" ? 1 : -1),
          (S_.set(0, 0, 0)[p] = d === "-" ? -1 : 1),
          T3.lookAt(iq, Bv.cross(S_), S_),
          s.setFromMatrix4(T3);
      } else s.identity();
      e._orientation = a;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let n = e.match(/^(-?[\d.]+)%$/),
        r = n ? parseFloat(n[1]) : NaN;
      e = (isNaN(r) ? 0 : r / 100) * this.fontSize;
    }
    return e;
  }
  localPositionToTextCoords(e, n = new Ge()) {
    n.copy(e);
    const r = this.curveRadius;
    return (
      r && (n.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), n
    );
  }
  worldPositionToTextCoords(e, n = new Ge()) {
    return Bv.copy(e), this.localPositionToTextCoords(this.worldToLocal(Bv), n);
  }
  raycast(e, n) {
    const { textRenderInfo: r, curveRadius: i } = this;
    if (r) {
      const o = r.blockBounds,
        a = i ? Hz() : Bz(),
        s = a.geometry,
        { position: l, uv: c } = s.attributes;
      for (let u = 0; u < c.count; u++) {
        let d = o[0] + c.getX(u) * (o[2] - o[0]);
        const p = o[1] + c.getY(u) * (o[3] - o[1]);
        let m = 0;
        i && ((m = i - Math.cos(d / i) * i), (d = Math.sin(d / i) * i)),
          l.setXYZ(u, d, p, m);
      }
      (s.boundingSphere = this.geometry.boundingSphere),
        (s.boundingBox = this.geometry.boundingBox),
        (a.matrixWorld = this.matrixWorld),
        (a.material.side = this.material.side),
        (bh.length = 0),
        a.raycast(e, bh);
      for (let u = 0; u < bh.length; u++) (bh[u].object = this), n.push(bh[u]);
    }
  }
  copy(e) {
    const n = this.geometry;
    return (
      super.copy(e),
      (this.geometry = n),
      sq.forEach((r) => {
        this[r] = e[r];
      }),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
jz.forEach((t) => {
  const e = "_private_" + t;
  Object.defineProperty(Vz.prototype, t, {
    get() {
      return this[e];
    },
    set(n) {
      n !== this[e] && ((this[e] = n), (this._needsSync = !0));
    },
  });
});
new wr();
new pt();
const $n = E.forwardRef(
    (
      {
        sdfGlyphSize: t = 64,
        anchorX: e = "center",
        anchorY: n = "middle",
        font: r,
        fontSize: i = 1,
        children: o,
        characters: a,
        onSync: s,
        ...l
      },
      c
    ) => {
      const u = ga(({ invalidate: v }) => v),
        [d] = E.useState(() => new Vz()),
        [p, m] = E.useMemo(() => {
          const v = [];
          let S = "";
          return (
            E.Children.forEach(o, (x) => {
              typeof x == "string" || typeof x == "number"
                ? (S += x)
                : v.push(x);
            }),
            [v, S]
          );
        }, [o]);
      return (
        U7(
          () => new Promise((v) => WX({ font: r, characters: a }, v)),
          ["troika-text", r, a]
        ),
        E.useLayoutEffect(
          () =>
            void d.sync(() => {
              u(), s && s(d);
            })
        ),
        E.useEffect(() => () => d.dispose(), [d]),
        E.createElement(
          "primitive",
          Et(
            {
              object: d,
              ref: c,
              font: r,
              text: m,
              anchorX: e,
              anchorY: n,
              fontSize: i,
              sdfGlyphSize: t,
            },
            l
          ),
          p
        )
      );
    }
  ),
  lq = E.forwardRef(
    (
      {
        makeDefault: t,
        camera: e,
        regress: n,
        domElement: r,
        enableDamping: i = !0,
        keyEvents: o = !1,
        onChange: a,
        onStart: s,
        onEnd: l,
        ...c
      },
      u
    ) => {
      const d = ga((M) => M.invalidate),
        p = ga((M) => M.camera),
        m = ga((M) => M.gl),
        v = ga((M) => M.events),
        S = ga((M) => M.setEvents),
        x = ga((M) => M.set),
        g = ga((M) => M.get),
        _ = ga((M) => M.performance),
        y = e || p,
        w = r || v.connected || m.domElement,
        A = E.useMemo(() => new uX(y), [y]);
      return (
        NC(() => {
          A.enabled && A.update();
        }, -1),
        E.useEffect(
          () => (
            o && A.connect(o === !0 ? w : o),
            A.connect(w),
            () => void A.dispose()
          ),
          [o, w, n, A, d]
        ),
        E.useEffect(() => {
          const M = (R) => {
              d(), n && _.regress(), a && a(R);
            },
            T = (R) => {
              s && s(R);
            },
            I = (R) => {
              l && l(R);
            };
          return (
            A.addEventListener("change", M),
            A.addEventListener("start", T),
            A.addEventListener("end", I),
            () => {
              A.removeEventListener("start", T),
                A.removeEventListener("end", I),
                A.removeEventListener("change", M);
            }
          );
        }, [a, s, l, A, d, S]),
        E.useEffect(() => {
          if (t) {
            const M = g().controls;
            return x({ controls: A }), () => x({ controls: M });
          }
        }, [t, A]),
        E.createElement(
          "primitive",
          Et({ ref: u, object: A, enableDamping: i }, c)
        )
      );
    }
  ),
  Wa = 1e-5;
function cq(t, e, n) {
  const r = new zl(),
    i = n - Wa;
  return (
    r.absarc(Wa, Wa, Wa, -Math.PI / 2, -Math.PI, !0),
    r.absarc(Wa, e - i * 2, Wa, Math.PI, Math.PI / 2, !0),
    r.absarc(t - i * 2, e - i * 2, Wa, Math.PI / 2, 0, !0),
    r.absarc(t - i * 2, Wa, Wa, 0, -Math.PI / 2, !0),
    r
  );
}
const uq = E.forwardRef(function (
    {
      args: [e = 1, n = 1, r = 1] = [],
      radius: i = 0.05,
      steps: o = 1,
      smoothness: a = 4,
      bevelSegments: s = 4,
      creaseAngle: l = 0.4,
      children: c,
      ...u
    },
    d
  ) {
    const p = E.useMemo(() => cq(e, n, i), [e, n, i]),
      m = E.useMemo(
        () => ({
          depth: r - i * 2,
          bevelEnabled: !0,
          bevelSegments: s * 2,
          steps: o,
          bevelSize: i - Wa,
          bevelThickness: i,
          curveSegments: a,
        }),
        [r, i, a]
      ),
      v = E.useRef(null);
    return (
      E.useLayoutEffect(() => {
        v.current && (v.current.center(), nX(v.current, l));
      }, [p, m]),
      E.createElement(
        "mesh",
        Et({ ref: d }, u),
        E.createElement("extrudeGeometry", { ref: v, args: [p, m] }),
        c
      )
    );
  }),
  Tn = ({ text: t, position: e, scale: n, isEnabel: r = "true" }) => {
    const i = E.useRef();
    return (
      NC(() => {
        i.current.rotation.y += 1;
      }),
      L.jsxs("group", {
        position: e,
        scale: n,
        children: [
          L.jsx(uq, {
            ref: i,
            args: [1, 1, 1],
            radius: 0.5,
            children: L.jsx("meshLambertMaterial", {
              color: r ? "green" : "grey",
            }),
          }),
          L.jsx($n, {
            color: r ? "red" : "grey",
            position: [0.1, 0, 0.5],
            scale: 0.6,
            children: t,
          }),
        ],
      })
    );
  };
function qr(t) {
  return `Minified Redux error #${t}; visit https://redux.js.org/Errors?code=${t} for the full message or use the non-minified dev environment for full errors. `;
}
var dq = (typeof Symbol == "function" && Symbol.observable) || "@@observable",
  R3 = dq,
  b_ = () => Math.random().toString(36).substring(7).split("").join("."),
  fq = {
    INIT: `@@redux/INIT${b_()}`,
    REPLACE: `@@redux/REPLACE${b_()}`,
    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${b_()}`,
  },
  my = fq;
function HC(t) {
  if (typeof t != "object" || t === null) return !1;
  let e = t;
  for (; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(t) === e || Object.getPrototypeOf(t) === null;
}
function $z(t, e, n) {
  if (typeof t != "function") throw new Error(qr(2));
  if (
    (typeof e == "function" && typeof n == "function") ||
    (typeof n == "function" && typeof arguments[3] == "function")
  )
    throw new Error(qr(0));
  if (
    (typeof e == "function" && typeof n > "u" && ((n = e), (e = void 0)),
    typeof n < "u")
  ) {
    if (typeof n != "function") throw new Error(qr(1));
    return n($z)(t, e);
  }
  let r = t,
    i = e,
    o = new Map(),
    a = o,
    s = 0,
    l = !1;
  function c() {
    a === o &&
      ((a = new Map()),
      o.forEach((x, g) => {
        a.set(g, x);
      }));
  }
  function u() {
    if (l) throw new Error(qr(3));
    return i;
  }
  function d(x) {
    if (typeof x != "function") throw new Error(qr(4));
    if (l) throw new Error(qr(5));
    let g = !0;
    c();
    const _ = s++;
    return (
      a.set(_, x),
      function () {
        if (g) {
          if (l) throw new Error(qr(6));
          (g = !1), c(), a.delete(_), (o = null);
        }
      }
    );
  }
  function p(x) {
    if (!HC(x)) throw new Error(qr(7));
    if (typeof x.type > "u") throw new Error(qr(8));
    if (typeof x.type != "string") throw new Error(qr(17));
    if (l) throw new Error(qr(9));
    try {
      (l = !0), (i = r(i, x));
    } finally {
      l = !1;
    }
    return (
      (o = a).forEach((_) => {
        _();
      }),
      x
    );
  }
  function m(x) {
    if (typeof x != "function") throw new Error(qr(10));
    (r = x), p({ type: my.REPLACE });
  }
  function v() {
    const x = d;
    return {
      subscribe(g) {
        if (typeof g != "object" || g === null) throw new Error(qr(11));
        function _() {
          const w = g;
          w.next && w.next(u());
        }
        return _(), { unsubscribe: x(_) };
      },
      [R3]() {
        return this;
      },
    };
  }
  return (
    p({ type: my.INIT }),
    { dispatch: p, subscribe: d, getState: u, replaceReducer: m, [R3]: v }
  );
}
function hq(t) {
  Object.keys(t).forEach((e) => {
    const n = t[e];
    if (typeof n(void 0, { type: my.INIT }) > "u") throw new Error(qr(12));
    if (typeof n(void 0, { type: my.PROBE_UNKNOWN_ACTION() }) > "u")
      throw new Error(qr(13));
  });
}
function pq(t) {
  const e = Object.keys(t),
    n = {};
  for (let o = 0; o < e.length; o++) {
    const a = e[o];
    typeof t[a] == "function" && (n[a] = t[a]);
  }
  const r = Object.keys(n);
  let i;
  try {
    hq(n);
  } catch (o) {
    i = o;
  }
  return function (a = {}, s) {
    if (i) throw i;
    let l = !1;
    const c = {};
    for (let u = 0; u < r.length; u++) {
      const d = r[u],
        p = n[d],
        m = a[d],
        v = p(m, s);
      if (typeof v > "u") throw (s && s.type, new Error(qr(14)));
      (c[d] = v), (l = l || v !== m);
    }
    return (l = l || r.length !== Object.keys(a).length), l ? c : a;
  };
}
function gy(...t) {
  return t.length === 0
    ? (e) => e
    : t.length === 1
    ? t[0]
    : t.reduce(
        (e, n) =>
          (...r) =>
            e(n(...r))
      );
}
function mq(...t) {
  return (e) => (n, r) => {
    const i = e(n, r);
    let o = () => {
      throw new Error(qr(15));
    };
    const a = { getState: i.getState, dispatch: (l, ...c) => o(l, ...c) },
      s = t.map((l) => l(a));
    return (o = gy(...s)(i.dispatch)), { ...i, dispatch: o };
  };
}
function gq(t) {
  return HC(t) && "type" in t && typeof t.type == "string";
}
var Gz = Symbol.for("immer-nothing"),
  P3 = Symbol.for("immer-draftable"),
  Po = Symbol.for("immer-state");
function ba(t, ...e) {
  throw new Error(
    `[Immer] minified error nr: ${t}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var gf = Object.getPrototypeOf;
function $l(t) {
  return !!t && !!t[Po];
}
function Gs(t) {
  var e;
  return t
    ? Wz(t) ||
        Array.isArray(t) ||
        !!t[P3] ||
        !!((e = t.constructor) != null && e[P3]) ||
        A1(t) ||
        R1(t)
    : !1;
}
var vq = Object.prototype.constructor.toString();
function Wz(t) {
  if (!t || typeof t != "object") return !1;
  const e = gf(t);
  if (e === null) return !0;
  const n = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return n === Object
    ? !0
    : typeof n == "function" && Function.toString.call(n) === vq;
}
function Xp(t, e) {
  T1(t) === 0
    ? Object.entries(t).forEach(([n, r]) => {
        e(n, r, t);
      })
    : t.forEach((n, r) => e(r, n, t));
}
function T1(t) {
  const e = t[Po];
  return e ? e.type_ : Array.isArray(t) ? 1 : A1(t) ? 2 : R1(t) ? 3 : 0;
}
function Kw(t, e) {
  return T1(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function Xz(t, e, n) {
  const r = T1(t);
  r === 2 ? t.set(e, n) : r === 3 ? t.add(n) : (t[e] = n);
}
function yq(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function A1(t) {
  return t instanceof Map;
}
function R1(t) {
  return t instanceof Set;
}
function Ic(t) {
  return t.copy_ || t.base_;
}
function Yw(t, e) {
  if (A1(t)) return new Map(t);
  if (R1(t)) return new Set(t);
  if (Array.isArray(t)) return Array.prototype.slice.call(t);
  if (!e && Wz(t))
    return gf(t) ? { ...t } : Object.assign(Object.create(null), t);
  const n = Object.getOwnPropertyDescriptors(t);
  delete n[Po];
  let r = Reflect.ownKeys(n);
  for (let i = 0; i < r.length; i++) {
    const o = r[i],
      a = n[o];
    a.writable === !1 && ((a.writable = !0), (a.configurable = !0)),
      (a.get || a.set) &&
        (n[o] = {
          configurable: !0,
          writable: !0,
          enumerable: a.enumerable,
          value: t[o],
        });
  }
  return Object.create(gf(t), n);
}
function jC(t, e = !1) {
  return (
    P1(t) ||
      $l(t) ||
      !Gs(t) ||
      (T1(t) > 1 && (t.set = t.add = t.clear = t.delete = xq),
      Object.freeze(t),
      e && Xp(t, (n, r) => jC(r, !0))),
    t
  );
}
function xq() {
  ba(2);
}
function P1(t) {
  return Object.isFrozen(t);
}
var Sq = {};
function fu(t) {
  const e = Sq[t];
  return e || ba(0, t), e;
}
var qp;
function qz() {
  return qp;
}
function _q(t, e) {
  return {
    drafts_: [],
    parent_: t,
    immer_: e,
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0,
  };
}
function I3(t, e) {
  e &&
    (fu("Patches"),
    (t.patches_ = []),
    (t.inversePatches_ = []),
    (t.patchListener_ = e));
}
function Zw(t) {
  Qw(t), t.drafts_.forEach(bq), (t.drafts_ = null);
}
function Qw(t) {
  t === qp && (qp = t.parent_);
}
function L3(t) {
  return (qp = _q(qp, t));
}
function bq(t) {
  const e = t[Po];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : (e.revoked_ = !0);
}
function O3(t, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const n = e.drafts_[0];
  return (
    t !== void 0 && t !== n
      ? (n[Po].modified_ && (Zw(e), ba(4)),
        Gs(t) && ((t = vy(e, t)), e.parent_ || yy(e, t)),
        e.patches_ &&
          fu("Patches").generateReplacementPatches_(
            n[Po].base_,
            t,
            e.patches_,
            e.inversePatches_
          ))
      : (t = vy(e, n, [])),
    Zw(e),
    e.patches_ && e.patchListener_(e.patches_, e.inversePatches_),
    t !== Gz ? t : void 0
  );
}
function vy(t, e, n) {
  if (P1(e)) return e;
  const r = e[Po];
  if (!r) return Xp(e, (i, o) => N3(t, r, e, i, o, n)), e;
  if (r.scope_ !== t) return e;
  if (!r.modified_) return yy(t, r.base_, !0), r.base_;
  if (!r.finalized_) {
    (r.finalized_ = !0), r.scope_.unfinalizedDrafts_--;
    const i = r.copy_;
    let o = i,
      a = !1;
    r.type_ === 3 && ((o = new Set(i)), i.clear(), (a = !0)),
      Xp(o, (s, l) => N3(t, r, i, s, l, n, a)),
      yy(t, i, !1),
      n &&
        t.patches_ &&
        fu("Patches").generatePatches_(r, n, t.patches_, t.inversePatches_);
  }
  return r.copy_;
}
function N3(t, e, n, r, i, o, a) {
  if ($l(i)) {
    const s =
        o && e && e.type_ !== 3 && !Kw(e.assigned_, r) ? o.concat(r) : void 0,
      l = vy(t, i, s);
    if ((Xz(n, r, l), $l(l))) t.canAutoFreeze_ = !1;
    else return;
  } else a && n.add(i);
  if (Gs(i) && !P1(i)) {
    if (!t.immer_.autoFreeze_ && t.unfinalizedDrafts_ < 1) return;
    vy(t, i), (!e || !e.scope_.parent_) && yy(t, i);
  }
}
function yy(t, e, n = !1) {
  !t.parent_ && t.immer_.autoFreeze_ && t.canAutoFreeze_ && jC(e, n);
}
function wq(t, e) {
  const n = Array.isArray(t),
    r = {
      type_: n ? 1 : 0,
      scope_: e ? e.scope_ : qz(),
      modified_: !1,
      finalized_: !1,
      assigned_: {},
      parent_: e,
      base_: t,
      draft_: null,
      copy_: null,
      revoke_: null,
      isManual_: !1,
    };
  let i = r,
    o = VC;
  n && ((i = [r]), (o = Kp));
  const { revoke: a, proxy: s } = Proxy.revocable(i, o);
  return (r.draft_ = s), (r.revoke_ = a), s;
}
var VC = {
    get(t, e) {
      if (e === Po) return t;
      const n = Ic(t);
      if (!Kw(n, e)) return Eq(t, n, e);
      const r = n[e];
      return t.finalized_ || !Gs(r)
        ? r
        : r === w_(t.base_, e)
        ? (E_(t), (t.copy_[e] = eE(r, t)))
        : r;
    },
    has(t, e) {
      return e in Ic(t);
    },
    ownKeys(t) {
      return Reflect.ownKeys(Ic(t));
    },
    set(t, e, n) {
      const r = Kz(Ic(t), e);
      if (r != null && r.set) return r.set.call(t.draft_, n), !0;
      if (!t.modified_) {
        const i = w_(Ic(t), e),
          o = i == null ? void 0 : i[Po];
        if (o && o.base_ === n)
          return (t.copy_[e] = n), (t.assigned_[e] = !1), !0;
        if (yq(n, i) && (n !== void 0 || Kw(t.base_, e))) return !0;
        E_(t), Jw(t);
      }
      return (
        (t.copy_[e] === n && (n !== void 0 || e in t.copy_)) ||
          (Number.isNaN(n) && Number.isNaN(t.copy_[e])) ||
          ((t.copy_[e] = n), (t.assigned_[e] = !0)),
        !0
      );
    },
    deleteProperty(t, e) {
      return (
        w_(t.base_, e) !== void 0 || e in t.base_
          ? ((t.assigned_[e] = !1), E_(t), Jw(t))
          : delete t.assigned_[e],
        t.copy_ && delete t.copy_[e],
        !0
      );
    },
    getOwnPropertyDescriptor(t, e) {
      const n = Ic(t),
        r = Reflect.getOwnPropertyDescriptor(n, e);
      return (
        r && {
          writable: !0,
          configurable: t.type_ !== 1 || e !== "length",
          enumerable: r.enumerable,
          value: n[e],
        }
      );
    },
    defineProperty() {
      ba(11);
    },
    getPrototypeOf(t) {
      return gf(t.base_);
    },
    setPrototypeOf() {
      ba(12);
    },
  },
  Kp = {};
Xp(VC, (t, e) => {
  Kp[t] = function () {
    return (arguments[0] = arguments[0][0]), e.apply(this, arguments);
  };
});
Kp.deleteProperty = function (t, e) {
  return Kp.set.call(this, t, e, void 0);
};
Kp.set = function (t, e, n) {
  return VC.set.call(this, t[0], e, n, t[0]);
};
function w_(t, e) {
  const n = t[Po];
  return (n ? Ic(n) : t)[e];
}
function Eq(t, e, n) {
  var i;
  const r = Kz(e, n);
  return r
    ? "value" in r
      ? r.value
      : (i = r.get) == null
      ? void 0
      : i.call(t.draft_)
    : void 0;
}
function Kz(t, e) {
  if (!(e in t)) return;
  let n = gf(t);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, e);
    if (r) return r;
    n = gf(n);
  }
}
function Jw(t) {
  t.modified_ || ((t.modified_ = !0), t.parent_ && Jw(t.parent_));
}
function E_(t) {
  t.copy_ || (t.copy_ = Yw(t.base_, t.scope_.immer_.useStrictShallowCopy_));
}
var Mq = class {
  constructor(t) {
    (this.autoFreeze_ = !0),
      (this.useStrictShallowCopy_ = !1),
      (this.produce = (e, n, r) => {
        if (typeof e == "function" && typeof n != "function") {
          const o = n;
          n = e;
          const a = this;
          return function (l = o, ...c) {
            return a.produce(l, (u) => n.call(this, u, ...c));
          };
        }
        typeof n != "function" && ba(6),
          r !== void 0 && typeof r != "function" && ba(7);
        let i;
        if (Gs(e)) {
          const o = L3(this),
            a = eE(e, void 0);
          let s = !0;
          try {
            (i = n(a)), (s = !1);
          } finally {
            s ? Zw(o) : Qw(o);
          }
          return I3(o, r), O3(i, o);
        } else if (!e || typeof e != "object") {
          if (
            ((i = n(e)),
            i === void 0 && (i = e),
            i === Gz && (i = void 0),
            this.autoFreeze_ && jC(i, !0),
            r)
          ) {
            const o = [],
              a = [];
            fu("Patches").generateReplacementPatches_(e, i, o, a), r(o, a);
          }
          return i;
        } else ba(1, e);
      }),
      (this.produceWithPatches = (e, n) => {
        if (typeof e == "function")
          return (a, ...s) => this.produceWithPatches(a, (l) => e(l, ...s));
        let r, i;
        return [
          this.produce(e, n, (a, s) => {
            (r = a), (i = s);
          }),
          r,
          i,
        ];
      }),
      typeof (t == null ? void 0 : t.autoFreeze) == "boolean" &&
        this.setAutoFreeze(t.autoFreeze),
      typeof (t == null ? void 0 : t.useStrictShallowCopy) == "boolean" &&
        this.setUseStrictShallowCopy(t.useStrictShallowCopy);
  }
  createDraft(t) {
    Gs(t) || ba(8), $l(t) && (t = Yz(t));
    const e = L3(this),
      n = eE(t, void 0);
    return (n[Po].isManual_ = !0), Qw(e), n;
  }
  finishDraft(t, e) {
    const n = t && t[Po];
    (!n || !n.isManual_) && ba(9);
    const { scope_: r } = n;
    return I3(r, e), O3(void 0, r);
  }
  setAutoFreeze(t) {
    this.autoFreeze_ = t;
  }
  setUseStrictShallowCopy(t) {
    this.useStrictShallowCopy_ = t;
  }
  applyPatches(t, e) {
    let n;
    for (n = e.length - 1; n >= 0; n--) {
      const i = e[n];
      if (i.path.length === 0 && i.op === "replace") {
        t = i.value;
        break;
      }
    }
    n > -1 && (e = e.slice(n + 1));
    const r = fu("Patches").applyPatches_;
    return $l(t) ? r(t, e) : this.produce(t, (i) => r(i, e));
  }
};
function eE(t, e) {
  const n = A1(t)
    ? fu("MapSet").proxyMap_(t, e)
    : R1(t)
    ? fu("MapSet").proxySet_(t, e)
    : wq(t, e);
  return (e ? e.scope_ : qz()).drafts_.push(n), n;
}
function Yz(t) {
  return $l(t) || ba(10, t), Zz(t);
}
function Zz(t) {
  if (!Gs(t) || P1(t)) return t;
  const e = t[Po];
  let n;
  if (e) {
    if (!e.modified_) return e.base_;
    (e.finalized_ = !0), (n = Yw(t, e.scope_.immer_.useStrictShallowCopy_));
  } else n = Yw(t, !0);
  return (
    Xp(n, (r, i) => {
      Xz(n, r, Zz(i));
    }),
    e && (e.finalized_ = !1),
    n
  );
}
var Io = new Mq(),
  Qz = Io.produce;
Io.produceWithPatches.bind(Io);
Io.setAutoFreeze.bind(Io);
Io.setUseStrictShallowCopy.bind(Io);
Io.applyPatches.bind(Io);
Io.createDraft.bind(Io);
Io.finishDraft.bind(Io);
function Cq(t, e = `expected a function, instead received ${typeof t}`) {
  if (typeof t != "function") throw new TypeError(e);
}
function Tq(t, e = `expected an object, instead received ${typeof t}`) {
  if (typeof t != "object") throw new TypeError(e);
}
function Aq(
  t,
  e = "expected all items to be functions, instead received the following types: "
) {
  if (!t.every((n) => typeof n == "function")) {
    const n = t
      .map((r) =>
        typeof r == "function" ? `function ${r.name || "unnamed"}()` : typeof r
      )
      .join(", ");
    throw new TypeError(`${e}[${n}]`);
  }
}
var F3 = (t) => (Array.isArray(t) ? t : [t]);
function Rq(t) {
  const e = Array.isArray(t[0]) ? t[0] : t;
  return (
    Aq(
      e,
      "createSelector expects all input-selectors to be functions, but received the following types: "
    ),
    e
  );
}
function Pq(t, e) {
  const n = [],
    { length: r } = t;
  for (let i = 0; i < r; i++) n.push(t[i].apply(null, e));
  return n;
}
var Iq = class {
    constructor(t) {
      this.value = t;
    }
    deref() {
      return this.value;
    }
  },
  Lq = typeof WeakRef < "u" ? WeakRef : Iq,
  Oq = 0,
  D3 = 1;
function Hv() {
  return { s: Oq, v: void 0, o: null, p: null };
}
function $C(t, e = {}) {
  let n = Hv();
  const { resultEqualityCheck: r } = e;
  let i,
    o = 0;
  function a() {
    var d;
    let s = n;
    const { length: l } = arguments;
    for (let p = 0, m = l; p < m; p++) {
      const v = arguments[p];
      if (typeof v == "function" || (typeof v == "object" && v !== null)) {
        let S = s.o;
        S === null && (s.o = S = new WeakMap());
        const x = S.get(v);
        x === void 0 ? ((s = Hv()), S.set(v, s)) : (s = x);
      } else {
        let S = s.p;
        S === null && (s.p = S = new Map());
        const x = S.get(v);
        x === void 0 ? ((s = Hv()), S.set(v, s)) : (s = x);
      }
    }
    const c = s;
    let u;
    if (
      (s.s === D3 ? (u = s.v) : ((u = t.apply(null, arguments)), o++),
      (c.s = D3),
      r)
    ) {
      const p =
        ((d = i == null ? void 0 : i.deref) == null ? void 0 : d.call(i)) ?? i;
      p != null && r(p, u) && ((u = p), o !== 0 && o--),
        (i =
          (typeof u == "object" && u !== null) || typeof u == "function"
            ? new Lq(u)
            : u);
    }
    return (c.v = u), u;
  }
  return (
    (a.clearCache = () => {
      (n = Hv()), a.resetResultsCount();
    }),
    (a.resultsCount = () => o),
    (a.resetResultsCount = () => {
      o = 0;
    }),
    a
  );
}
function Jz(t, ...e) {
  const n = typeof t == "function" ? { memoize: t, memoizeOptions: e } : t,
    r = (...i) => {
      let o = 0,
        a = 0,
        s,
        l = {},
        c = i.pop();
      typeof c == "object" && ((l = c), (c = i.pop())),
        Cq(
          c,
          `createSelector expects an output function after the inputs, but received: [${typeof c}]`
        );
      const u = { ...n, ...l },
        {
          memoize: d,
          memoizeOptions: p = [],
          argsMemoize: m = $C,
          argsMemoizeOptions: v = [],
          devModeChecks: S = {},
        } = u,
        x = F3(p),
        g = F3(v),
        _ = Rq(i),
        y = d(function () {
          return o++, c.apply(null, arguments);
        }, ...x),
        w = m(function () {
          a++;
          const M = Pq(_, arguments);
          return (s = y.apply(null, M)), s;
        }, ...g);
      return Object.assign(w, {
        resultFunc: c,
        memoizedResultFunc: y,
        dependencies: _,
        dependencyRecomputations: () => a,
        resetDependencyRecomputations: () => {
          a = 0;
        },
        lastResult: () => s,
        recomputations: () => o,
        resetRecomputations: () => {
          o = 0;
        },
        memoize: d,
        argsMemoize: m,
      });
    };
  return Object.assign(r, { withTypes: () => r }), r;
}
var Nq = Jz($C),
  Fq = Object.assign(
    (t, e = Nq) => {
      Tq(
        t,
        `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof t}`
      );
      const n = Object.keys(t),
        r = n.map((o) => t[o]);
      return e(r, (...o) => o.reduce((a, s, l) => ((a[n[l]] = s), a), {}));
    },
    { withTypes: () => Fq }
  );
function eU(t) {
  return ({ dispatch: n, getState: r }) =>
    (i) =>
    (o) =>
      typeof o == "function" ? o(n, r, t) : i(o);
}
var Dq = eU(),
  zq = eU,
  Uq = (...t) => {
    const e = Jz(...t),
      n = Object.assign(
        (...r) => {
          const i = e(...r),
            o = (a, ...s) => i($l(a) ? Yz(a) : a, ...s);
          return Object.assign(o, i), o;
        },
        { withTypes: () => n }
      );
    return n;
  };
Uq($C);
var kq =
  typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
    ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
    : function () {
        if (arguments.length !== 0)
          return typeof arguments[0] == "object"
            ? gy
            : gy.apply(null, arguments);
      };
function vf(t, e) {
  function n(...r) {
    if (e) {
      let i = e(...r);
      if (!i) throw new Error(eo(0));
      return {
        type: t,
        payload: i.payload,
        ...("meta" in i && { meta: i.meta }),
        ...("error" in i && { error: i.error }),
      };
    }
    return { type: t, payload: r[0] };
  }
  return (
    (n.toString = () => `${t}`),
    (n.type = t),
    (n.match = (r) => gq(r) && r.type === t),
    n
  );
}
var tU = class zh extends Array {
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, zh.prototype);
  }
  static get [Symbol.species]() {
    return zh;
  }
  concat(...e) {
    return super.concat.apply(this, e);
  }
  prepend(...e) {
    return e.length === 1 && Array.isArray(e[0])
      ? new zh(...e[0].concat(this))
      : new zh(...e.concat(this));
  }
};
function z3(t) {
  return Gs(t) ? Qz(t, () => {}) : t;
}
function U3(t, e, n) {
  if (t.has(e)) {
    let i = t.get(e);
    return n.update && ((i = n.update(i, e, t)), t.set(e, i)), i;
  }
  if (!n.insert) throw new Error(eo(10));
  const r = n.insert(e, t);
  return t.set(e, r), r;
}
function Bq(t) {
  return typeof t == "boolean";
}
var Hq = () =>
    function (e) {
      const {
        thunk: n = !0,
        immutableCheck: r = !0,
        serializableCheck: i = !0,
        actionCreatorCheck: o = !0,
      } = e ?? {};
      let a = new tU();
      return n && (Bq(n) ? a.push(Dq) : a.push(zq(n.extraArgument))), a;
    },
  jq = "RTK_autoBatch",
  nU = (t) => (e) => {
    setTimeout(e, t);
  },
  Vq =
    typeof window < "u" && window.requestAnimationFrame
      ? window.requestAnimationFrame
      : nU(10),
  $q =
    (t = { type: "raf" }) =>
    (e) =>
    (...n) => {
      const r = e(...n);
      let i = !0,
        o = !1,
        a = !1;
      const s = new Set(),
        l =
          t.type === "tick"
            ? queueMicrotask
            : t.type === "raf"
            ? Vq
            : t.type === "callback"
            ? t.queueNotification
            : nU(t.timeout),
        c = () => {
          (a = !1), o && ((o = !1), s.forEach((u) => u()));
        };
      return Object.assign({}, r, {
        subscribe(u) {
          const d = () => i && u(),
            p = r.subscribe(d);
          return (
            s.add(u),
            () => {
              p(), s.delete(u);
            }
          );
        },
        dispatch(u) {
          var d;
          try {
            return (
              (i = !((d = u == null ? void 0 : u.meta) != null && d[jq])),
              (o = !i),
              o && (a || ((a = !0), l(c))),
              r.dispatch(u)
            );
          } finally {
            i = !0;
          }
        },
      });
    },
  Gq = (t) =>
    function (n) {
      const { autoBatch: r = !0 } = n ?? {};
      let i = new tU(t);
      return r && i.push($q(typeof r == "object" ? r : void 0)), i;
    },
  Wq = !0;
function Xq(t) {
  const e = Hq(),
    {
      reducer: n = void 0,
      middleware: r,
      devTools: i = !0,
      preloadedState: o = void 0,
      enhancers: a = void 0,
    } = t || {};
  let s;
  if (typeof n == "function") s = n;
  else if (HC(n)) s = pq(n);
  else throw new Error(eo(1));
  let l;
  typeof r == "function" ? (l = r(e)) : (l = e());
  let c = gy;
  i && (c = kq({ trace: !Wq, ...(typeof i == "object" && i) }));
  const u = mq(...l),
    d = Gq(u);
  let p = typeof a == "function" ? a(d) : d();
  const m = c(...p);
  return $z(s, o, m);
}
function rU(t) {
  const e = {},
    n = [];
  let r;
  const i = {
    addCase(o, a) {
      const s = typeof o == "string" ? o : o.type;
      if (!s) throw new Error(eo(28));
      if (s in e) throw new Error(eo(29));
      return (e[s] = a), i;
    },
    addMatcher(o, a) {
      return n.push({ matcher: o, reducer: a }), i;
    },
    addDefaultCase(o) {
      return (r = o), i;
    },
  };
  return t(i), [e, n, r];
}
function qq(t) {
  return typeof t == "function";
}
function Kq(t, e) {
  let [n, r, i] = rU(e),
    o;
  if (qq(t)) o = () => z3(t());
  else {
    const s = z3(t);
    o = () => s;
  }
  function a(s = o(), l) {
    let c = [
      n[l.type],
      ...r.filter(({ matcher: u }) => u(l)).map(({ reducer: u }) => u),
    ];
    return (
      c.filter((u) => !!u).length === 0 && (c = [i]),
      c.reduce((u, d) => {
        if (d)
          if ($l(u)) {
            const m = d(u, l);
            return m === void 0 ? u : m;
          } else {
            if (Gs(u)) return Qz(u, (p) => d(p, l));
            {
              const p = d(u, l);
              if (p === void 0) {
                if (u === null) return u;
                throw new Error(eo(9));
              }
              return p;
            }
          }
        return u;
      }, s)
    );
  }
  return (a.getInitialState = o), a;
}
var Yq = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW",
  Zq = (t = 21) => {
    let e = "",
      n = t;
    for (; n--; ) e += Yq[(Math.random() * 64) | 0];
    return e;
  },
  Qq = Symbol.for("rtk-slice-createasyncthunk");
function Jq(t, e) {
  return `${t}/${e}`;
}
function eK({ creators: t } = {}) {
  var n;
  const e = (n = t == null ? void 0 : t.asyncThunk) == null ? void 0 : n[Qq];
  return function (i) {
    const { name: o, reducerPath: a = o } = i;
    if (!o) throw new Error(eo(11));
    typeof process < "u";
    const s =
        (typeof i.reducers == "function" ? i.reducers(rK()) : i.reducers) || {},
      l = Object.keys(s),
      c = {
        sliceCaseReducersByName: {},
        sliceCaseReducersByType: {},
        actionCreators: {},
        sliceMatchers: [],
      },
      u = {
        addCase(y, w) {
          const A = typeof y == "string" ? y : y.type;
          if (!A) throw new Error(eo(12));
          if (A in c.sliceCaseReducersByType) throw new Error(eo(13));
          return (c.sliceCaseReducersByType[A] = w), u;
        },
        addMatcher(y, w) {
          return c.sliceMatchers.push({ matcher: y, reducer: w }), u;
        },
        exposeAction(y, w) {
          return (c.actionCreators[y] = w), u;
        },
        exposeCaseReducer(y, w) {
          return (c.sliceCaseReducersByName[y] = w), u;
        },
      };
    l.forEach((y) => {
      const w = s[y],
        A = {
          reducerName: y,
          type: Jq(o, y),
          createNotation: typeof i.reducers == "function",
        };
      oK(w) ? sK(A, w, u, e) : iK(A, w, u);
    });
    function d() {
      const [y = {}, w = [], A = void 0] =
          typeof i.extraReducers == "function"
            ? rU(i.extraReducers)
            : [i.extraReducers],
        M = { ...y, ...c.sliceCaseReducersByType };
      return Kq(i.initialState, (T) => {
        for (let I in M) T.addCase(I, M[I]);
        for (let I of c.sliceMatchers) T.addMatcher(I.matcher, I.reducer);
        for (let I of w) T.addMatcher(I.matcher, I.reducer);
        A && T.addDefaultCase(A);
      });
    }
    const p = (y) => y,
      m = new Map();
    let v;
    function S(y, w) {
      return v || (v = d()), v(y, w);
    }
    function x() {
      return v || (v = d()), v.getInitialState();
    }
    function g(y, w = !1) {
      function A(T) {
        let I = T[y];
        return typeof I > "u" && w && (I = x()), I;
      }
      function M(T = p) {
        const I = U3(m, w, { insert: () => new WeakMap() });
        return U3(I, T, {
          insert: () => {
            const R = {};
            for (const [P, F] of Object.entries(i.selectors ?? {}))
              R[P] = tK(F, T, x, w);
            return R;
          },
        });
      }
      return {
        reducerPath: y,
        getSelectors: M,
        get selectors() {
          return M(A);
        },
        selectSlice: A,
      };
    }
    const _ = {
      name: o,
      reducer: S,
      actions: c.actionCreators,
      caseReducers: c.sliceCaseReducersByName,
      getInitialState: x,
      ...g(a),
      injectInto(y, { reducerPath: w, ...A } = {}) {
        const M = w ?? a;
        return (
          y.inject({ reducerPath: M, reducer: S }, A), { ..._, ...g(M, !0) }
        );
      },
    };
    return _;
  };
}
function tK(t, e, n, r) {
  function i(o, ...a) {
    let s = e(o);
    return typeof s > "u" && r && (s = n()), t(s, ...a);
  }
  return (i.unwrapped = t), i;
}
var nK = eK();
function rK() {
  function t(e, n) {
    return { _reducerDefinitionType: "asyncThunk", payloadCreator: e, ...n };
  }
  return (
    (t.withTypes = () => t),
    {
      reducer(e) {
        return Object.assign(
          {
            [e.name](...n) {
              return e(...n);
            },
          }[e.name],
          { _reducerDefinitionType: "reducer" }
        );
      },
      preparedReducer(e, n) {
        return {
          _reducerDefinitionType: "reducerWithPrepare",
          prepare: e,
          reducer: n,
        };
      },
      asyncThunk: t,
    }
  );
}
function iK({ type: t, reducerName: e, createNotation: n }, r, i) {
  let o, a;
  if ("reducer" in r) {
    if (n && !aK(r)) throw new Error(eo(17));
    (o = r.reducer), (a = r.prepare);
  } else o = r;
  i.addCase(t, o)
    .exposeCaseReducer(e, o)
    .exposeAction(e, a ? vf(t, a) : vf(t));
}
function oK(t) {
  return t._reducerDefinitionType === "asyncThunk";
}
function aK(t) {
  return t._reducerDefinitionType === "reducerWithPrepare";
}
function sK({ type: t, reducerName: e }, n, r, i) {
  if (!i) throw new Error(eo(18));
  const {
      payloadCreator: o,
      fulfilled: a,
      pending: s,
      rejected: l,
      settled: c,
      options: u,
    } = n,
    d = i(t, o, u);
  r.exposeAction(e, d),
    a && r.addCase(d.fulfilled, a),
    s && r.addCase(d.pending, s),
    l && r.addCase(d.rejected, l),
    c && r.addMatcher(d.settled, c),
    r.exposeCaseReducer(e, {
      fulfilled: a || jv,
      pending: s || jv,
      rejected: l || jv,
      settled: c || jv,
    });
}
function jv() {}
var lK = (t, e) => {
    if (typeof t != "function") throw new Error(eo(32));
  },
  GC = "listenerMiddleware",
  cK = (t) => {
    let { type: e, actionCreator: n, matcher: r, predicate: i, effect: o } = t;
    if (e) i = vf(e).match;
    else if (n) (e = n.type), (i = n.match);
    else if (r) i = r;
    else if (!i) throw new Error(eo(21));
    return lK(o), { predicate: i, type: e, effect: o };
  },
  uK = Object.assign(
    (t) => {
      const { type: e, predicate: n, effect: r } = cK(t);
      return {
        id: Zq(),
        effect: r,
        type: e,
        predicate: n,
        pending: new Set(),
        unsubscribe: () => {
          throw new Error(eo(22));
        },
      };
    },
    { withTypes: () => uK }
  ),
  dK = Object.assign(vf(`${GC}/add`), { withTypes: () => dK });
vf(`${GC}/removeAll`);
var fK = Object.assign(vf(`${GC}/remove`), { withTypes: () => fK });
function eo(t) {
  return `Minified Redux Toolkit error #${t}; visit https://redux-toolkit.js.org/Errors?code=${t} for the full message or use the non-minified dev environment for full errors. `;
}
const hK = () => ({
    isConverted: !1,
    REvalue: "",
    task: 0,
    progressSteps: [1],
    firstRe: { a: !1, b: !1, union: !1, kleene: !1 },
    secondRe: { a: !1, b: !1, concat: !1, kleene: !1 },
    thirdRe: { a: !0, b: !1, union: !1, kleene: !1 },
    fourthRe: { a: !1, b: !1, b1: !1, concat: !1 },
    clickedStep: {
      character: !0,
      union: !0,
      "Kleene star": !0,
      parentheses: !0,
      concatenation: !0,
    },
    isInfo: !1,
    showConcat: !1,
    infoCom: "",
    currentOperationMessage: "",
  }),
  iU = nK({
    name: "nfa",
    initialState: hK,
    reducers: {
      updateReValue: (t, e) => {
        (t.REvalue = e.payload.val), (t.task = e.payload.task);
      },
      updateConvertStatus: (t, e) => {
        t.isConverted = e.payload;
      },
      updateSteps: (t, e) => {
        t.progressSteps = e.payload;
      },
      updateFirstRe: (t, e) => {
        t.firstRe = e.payload;
      },
      updateSecondRe: (t, e) => {
        t.secondRe = e.payload;
      },
      updateThirdRe: (t, e) => {
        t.thirdRe = e.payload;
      },
      updateFourthRe: (t, e) => {
        t.fourthRe = e.payload;
      },
      updateClear: (t, e) => {
        (t.REvalue = ""),
          (t.showConcat = !1),
          (t.task = 0),
          (t.isConverted = !1),
          (t.progressSteps = [1]),
          (t.firstRe = { a: !1, b: !1, union: !1, kleene: !1 }),
          (t.secondRe = { a: !1, b: !1, concat: !1, kleene: !1 }),
          (t.thirdRe = { a: !1, b: !1, union: !1, kleene: !1 }),
          (t.fourthRe = { a: !1, b: !1, b1: !1, concat: !1 }),
          (t.isInfo = !1),
          (t.currentOperationMessage = "");
      },
      updateClickedStep: (t, e) => {
        t.clickedStep = e.payload;
      },
      updateInfoComponent: (t, e) => {
        t.isInfo = e.payload;
      },
      updateShowConcat: (t, e) => {
        t.showConcat = e.payload;
      },
      updateInfoContent: (t, e) => {
        t.infoCom = e.payload;
      },
      updateOperationMessage: (t, e) => {
        t.currentOperationMessage = e.payload;
      },
    },
  }),
  {
    updateInfoContent: ss,
    updateShowConcat: pK,
    updateConvertStatus: Vv,
    updateReValue: wh,
    updateSteps: Zse,
    updateFirstRe: M_,
    updateSecondRe: C_,
    updateThirdRe: T_,
    updateFourthRe: Eh,
    updateClear: k3,
    updateClickedStep: B3,
    updateInfoComponent: Da,
    updateOperationMessage: mK,
  } = iU.actions,
  gK = iU.reducer,
  H3 = [
    {
      id: 1,
      flow: L.jsxs("h5", {
        children: [
          "create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "a",
          }),
          " ",
          "single state NFA.",
        ],
      }),
      name: "a",
      btn: "a",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 1 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 2 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Transitioning from state 1 to state 2, denoted by the input symbol",
              " ",
              L.jsx("q", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 2,
      flow: L.jsxs("h5", {
        children: [
          "create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "b",
          }),
          " ",
          "single state NFA.",
        ],
      }),
      name: "b",
      btn: "b",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 3 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 4 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "From State 3 to State 4 labeled with input symbol",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 3,
      flow: L.jsxs("h5", {
        children: [
          "Click  to perform",
          " ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "union",
          }),
          " ",
          "operation.",
        ],
      }),
      btn: "Add union",
      name: "union",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 5 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 6 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transitions from the New Start State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "5",
              }),
              " ",
              "  ",
              "to the start states",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "1",
              }),
              ",",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "3",
              }),
              " of the existing NFAs.",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transitions from the accepting states",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "2",
              }),
              " ,",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "4",
              }),
              "  ",
              "of the existing NFAs to the New Final",
            ],
          }),
          L.jsx("h5", { children: " Notes:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "When the union operation is performed, 4 -transitions are used in total:",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "2 -transitions for connecting the New Start State to the existing NFAs",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "2 -transitions for connecting the accepting states of the existing NFAs to the New Final State",
          }),
        ],
      }),
    },
    {
      id: 4,
      flow: L.jsxs("h5", {
        children: [
          "Click  to perform",
          " ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "kleene star",
          }),
          " ",
          "operation.",
        ],
      }),
      btn: "Add Kleene star",
      name: "kleene",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 4 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 5 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from New Start State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "7",
              }),
              " to the original start state ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "5",
              }),
              " of the expression.",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from the accept state",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "6",
              }),
              " of the expression back to the original start state",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "5",
              }),
              " .",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from original accept state",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "6",
              }),
              " to New Accept State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "8",
              }),
              ".",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from New Start State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "7",
              }),
              " directly to New Accept State ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "8",
              }),
              " for zero occurrences.",
            ],
          }),
          L.jsx("h5", { children: " Notes:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "When applying the Kleene closure function, 4 -transitions are used in total:",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "2 -transitions for connecting the New Start State to the original start state and back to the original start state.",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "1 -transition for connecting the original accept state to the New Accept State",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "1 -transition from the New Start State directly to the New Accept State for zero occurrences",
          }),
        ],
      }),
    },
  ],
  vK = [
    {
      id: 1,
      flow: L.jsxs("h5", {
        children: [
          "create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15 },
            children: "a",
          }),
          " single state NFA.",
        ],
      }),
      btn: "a",
      name: "a",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsxs("h4", {
            style: { textAlign: "center", textDecoration: "underline" },
            children: [
              "Create Automaton for ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
            ],
          }),
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 1 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 2 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "From State 1 to State 2 labeled with input symbol",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 2,
      flow: L.jsxs("h5", {
        children: [
          "create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15 },
            children: "b",
          }),
          " single state NFA.",
        ],
      }),
      btn: "b",
      name: "b",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsxs("h4", {
            style: { textAlign: "center", textDecoration: "underline" },
            children: [
              "Create Automaton for ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
            ],
          }),
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 3 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 4 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "From State 3 to State 4 labeled with input symbol",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 3,
      flow: L.jsxs("h5", {
        children: [
          "Click  to perform",
          " ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15 },
            children: "Concatenation",
          }),
          " operation.",
        ],
      }),
      name: "concat",
      btn: "Add Concat",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsxs("h4", {
            style: { textAlign: "center", textDecoration: "underline" },
            children: [
              "Converting Regular Expression to NFA using",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "Concatenation",
              }),
            ],
          }),
          L.jsxs("h6", {
            children: [
              "Create an NFA for the character",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a:",
              }),
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [" ", "Create a start state and an accept state.", " "],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add a transition labeled",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
              " from the start state to the accept state.",
            ],
          }),
          L.jsxs("h6", {
            children: [
              "Create an NFA for the character",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b:",
              }),
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [" ", "Create a start state and an accept state.", " "],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add a transition labeled",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
              " from the start state to the accept state.",
            ],
          }),
          L.jsxs("h5", {
            children: [
              " ",
              "Connect the NFAs for ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
              " ",
              "and ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
              " and",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
              " to represent the concatenation:",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Merge the accept state of the NFA for",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
              " with the start state of the NFA for ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
              ", and remove the accept state of the NFA for",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
              ".",
            ],
          }),
        ],
      }),
    },
    {
      id: 4,
      flow: L.jsxs("h5", {
        children: [
          "Click to perform",
          " ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15 },
            children: "kleene star",
          }),
          " operation.",
        ],
      }),
      name: "kleene",
      btn: "Add Kleene star",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsxs("h4", {
            style: { textAlign: "center", textDecoration: "underline" },
            children: [
              "Converting Regular Expression to NFA using",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "Kleene Closure",
              }),
            ],
          }),
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 4 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 5 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from New Start State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "4",
              }),
              " to the original start state ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "1",
              }),
              " of the expression.",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from the accept state",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "3",
              }),
              " of the expression back to the original start state",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "1",
              }),
              " .",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from original accept state",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "3",
              }),
              " to New Accept State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "5",
              }),
              ".",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from New Start State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "4",
              }),
              " directly to New Accept State ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "5",
              }),
              " for zero occurrences.",
            ],
          }),
          L.jsx("h5", { children: " Notes:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "When applying the Kleene closure function, 4 -transitions are used in total:",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "2 -transitions for connecting the New Start State to the original start state and back to the original start state",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "1 -transition for connecting the original accept state to the New Accept State",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "1 -transition from the New Start State directly to the New Accept State for zero occurrence",
          }),
        ],
      }),
    },
  ],
  yK = [
    {
      id: 1,
      flow: L.jsxs("h5", {
        children: [
          "create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15 },
            children: "a",
          }),
          " single state NFA.",
        ],
      }),
      btn: "a",
      name: "a",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsxs("h4", {
            style: { textAlign: "center", textDecoration: "underline" },
            children: [
              "Create Automaton for ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
            ],
          }),
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 1 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 2 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "From State 1 to State 2 labeled with input symbol",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 2,
      flow: L.jsxs("h5", {
        children: [
          "create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15 },
            children: "b",
          }),
          " single state NFA.",
        ],
      }),
      btn: "b",
      name: "b",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsxs("h4", {
            style: { textAlign: "center", textDecoration: "underline" },
            children: [
              "Create Automaton for ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
            ],
          }),
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 3 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 4 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "From State 3 to State 4 labeled with input symbol",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 3,
      flow: L.jsxs("h5", {
        children: [
          "create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15 },
            children: "b",
          }),
          " single state NFA.",
        ],
      }),
      btn: "b",
      name: "b1",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsxs("h4", {
            style: { textAlign: "center", textDecoration: "underline" },
            children: [
              "Create Automaton for ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
            ],
          }),
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 5 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 6 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "From State 3 to State 4 labeled with input symbol",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 4,
      flow: L.jsxs("h5", {
        children: [
          "Click  to perform",
          " ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15 },
            children: "Concatenation",
          }),
          " operation.",
        ],
      }),
      name: "concat",
      btn: "Add Concat",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsxs("h4", {
            style: { textAlign: "center", textDecoration: "underline" },
            children: [
              "Converting Regular Expression to NFA using",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "Concatenation",
              }),
            ],
          }),
          L.jsxs("h6", {
            children: [
              "Create an NFA for the character",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a:",
              }),
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [" ", "Create a start state and an accept state.", " "],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add a transition labeled",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
              " from the start state to the accept state.",
            ],
          }),
          L.jsxs("h6", {
            children: [
              "Create an NFA for the character",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b:",
              }),
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [" ", "Create a start state and an accept state.", " "],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add a transition labeled",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
              " from the start state to the accept state.",
            ],
          }),
          L.jsxs("h6", {
            children: [
              "Create an NFA for the character",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b:",
              }),
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [" ", "Create a start state and an accept state.", " "],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add a transition labeled",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
              " from the start state to the accept state.",
            ],
          }),
          L.jsxs("h5", {
            children: [
              " ",
              "Connect the NFAs for ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
              " ",
              "and ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
              " and",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
              " to represent the concatenation:",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add a transition from the accept state of the",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
              " NFA to the start state of the ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
              " NFA,",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add a transition from the accept state of the",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
              " NFA to the start state of the ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
              " NFA,",
            ],
          }),
        ],
      }),
    },
  ],
  xK = [
    {
      id: 1,
      flow: L.jsxs("h5", {
        children: [
          "Create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "a",
          }),
          " ",
          "single state NFA.",
        ],
      }),
      name: "a",
      btn: "Add a",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 1 (Initial State)",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 2 (Final State)",
          }),
          L.jsx("h5", { children: "Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Transitioning from state 1 to state 2, denoted by the input symbol",
              " ",
              L.jsx("q", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 2,
      flow: L.jsxs("h5", {
        children: [
          "Create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "b",
          }),
          " ",
          "single state NFA.",
        ],
      }),
      name: "b",
      btn: "Add b",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 3 (Initial State)",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 4 (Final State)",
          }),
          L.jsx("h5", { children: "Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "From State 3 to State 4 labeled with input symbol",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 3,
      flow: L.jsxs("h5", {
        children: [
          "Click to perform",
          " ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "union",
          }),
          " ",
          "operation.",
        ],
      }),
      btn: "Add union",
      name: "Add union",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 5 (Initial State)",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 6 (Final State)",
          }),
          L.jsx("h5", { children: "Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transitions from the New Start State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "5",
              }),
              " to the start states",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "1",
              }),
              ",",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "3",
              }),
              " of the existing NFAs.",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transitions from the accepting states",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "2",
              }),
              ",",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "4",
              }),
              " of the existing NFAs to the New Final State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "6",
              }),
              ".",
            ],
          }),
          L.jsx("h5", { children: "Notes:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "When the union operation is performed, 4 -transitions are used in total:",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "2 -transitions for connecting the New Start State to the existing NFAs.",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "2 -transitions for connecting the accepting states of the existing NFAs to the New Final State.",
          }),
        ],
      }),
    },
  ],
  SK = [
    {
      id: 1,
      flow: L.jsxs("h5", {
        children: [
          "Create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "a",
          }),
          " ",
          "single state NFA.",
        ],
      }),
      name: "a",
      btn: "Add a",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 1 (Initial State)",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 2 (Final State)",
          }),
          L.jsx("h5", { children: "Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Transitioning from state 1 to state 2, denoted by the input symbol",
              " ",
              L.jsx("q", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 2,
      flow: L.jsxs("h5", {
        children: [
          "Click to perform",
          " ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "Kleene star",
          }),
          " ",
          "operation on ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "a",
          }),
          ".",
        ],
      }),
      btn: "Add Kleene star",
      name: "kleene",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 3 (New Initial State)",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 4 (New Final State)",
          }),
          L.jsx("h5", { children: "Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from New Start State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "3",
              }),
              " to the original start state",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "1",
              }),
              ".",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from the accept state",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "2",
              }),
              " back to the original start state",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "1",
              }),
              ".",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from original accept state",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "2",
              }),
              " to New Accept State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "4",
              }),
              ".",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from New Start State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "3",
              }),
              " directly to New Accept State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "4",
              }),
              " for zero occurrences.",
            ],
          }),
          L.jsx("h5", { children: "Notes:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "4 -transitions are used to apply the Kleene star to `a`.",
          }),
        ],
      }),
    },
    {
      id: 3,
      flow: L.jsxs("h5", {
        children: [
          "Create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "b",
          }),
          " ",
          "single state NFA.",
        ],
      }),
      name: "b1",
      btn: "Add b",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 5 (Initial State)",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 6 (Final State)",
          }),
          L.jsx("h5", { children: "Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "From State 5 to State 6 labeled with input symbol",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
              ".",
            ],
          }),
        ],
      }),
    },
    {
      id: 4,
      flow: L.jsxs("h5", {
        children: [
          "Click to perform",
          " ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "concatenation",
          }),
          " ",
          "operation between ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "a*",
          }),
          " and",
          " ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "b",
          }),
          ".",
        ],
      }),
      btn: "Add Concat",
      name: "concat",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 3 (Initial State from a*)",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 6 (Final State from b)",
          }),
          L.jsx("h5", { children: "Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transition from the accept state of a*",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "4",
              }),
              " to the start state of b",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "5",
              }),
              ".",
            ],
          }),
        ],
      }),
    },
  ],
  _K = [
    {
      id: 1,
      flow: L.jsxs("h5", {
        children: [
          "Create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "a",
          }),
          " ",
          "single state NFA.",
        ],
      }),
      name: "a",
      btn: "Add a",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 1 (Initial State)",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 2 (Final State)",
          }),
          L.jsx("h5", { children: "Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Transitioning from state 1 to state 2, denoted by the input symbol",
              " ",
              L.jsx("q", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 2,
      flow: L.jsxs("h5", {
        children: [
          "Create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "b",
          }),
          " ",
          "single state NFA.",
        ],
      }),
      name: "b",
      btn: "Add b",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 3 (Initial State)",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 4 (Final State)",
          }),
          L.jsx("h5", { children: "Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "From State 3 to State 4 labeled with input symbol",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 3,
      flow: L.jsxs("h5", {
        children: [
          "Click to perform",
          " ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "concatenation",
          }),
          " ",
          "operation.",
        ],
      }),
      btn: "Add Concat",
      name: "concat",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 1 (Initial State)",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 4 (Final State)",
          }),
          L.jsx("h5", { children: "Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Merge the accept state of `a`",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "2",
              }),
              " with the start state of `b`",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "3",
              }),
              ", resulting in a single path from 1 to 4.",
            ],
          }),
        ],
      }),
    },
  ],
  WC = [
    {
      id: 1,
      flow: L.jsxs("h5", {
        children: [
          "create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "a",
          }),
          " ",
          "single state NFA.",
        ],
      }),
      name: "a",
      btn: "a",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 1 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 2 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Transitioning from state 1 to state 2, denoted by the input symbol",
              " ",
              L.jsx("q", {
                style: { color: "green", fontSize: 15 },
                children: "a",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 2,
      flow: L.jsxs("h5", {
        children: [
          "create ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "b",
          }),
          " ",
          "single state NFA.",
        ],
      }),
      name: "b",
      btn: "b",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 3 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 4 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "From State 3 to State 4 labeled with input symbol",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "b",
              }),
            ],
          }),
        ],
      }),
    },
    {
      id: 3,
      flow: L.jsxs("h5", {
        children: [
          "Click to perform",
          " ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "union",
          }),
          " ",
          "operation.",
        ],
      }),
      btn: "Add union",
      name: "union",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 5 (Initial State) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 6 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transitions from the New Start State",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "5",
              }),
              " ",
              "  ",
              "to the start states",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "1",
              }),
              ",",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "3",
              }),
              " of the existing NFAs.",
            ],
          }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "Add -transitions from the accepting states",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "2",
              }),
              " ,",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "4",
              }),
              "  ",
              "of the existing NFAs to the New Final",
            ],
          }),
          L.jsx("h5", { children: " Notes:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "When the union operation is performed, 4 -transitions are used in total:",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "2 -transitions for connecting the New Start State to the existing NFAs",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "2 -transitions for connecting the accepting states of the existing NFAs to the New Final State",
          }),
        ],
      }),
    },
    {
      id: 4,
      flow: L.jsxs("h5", {
        children: [
          "Click to perform",
          " ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "concatenation",
          }),
          " ",
          "operation with ",
          L.jsx("q", {
            style: { color: "green", fontSize: 15, margin: 0 },
            children: "c",
          }),
          ".",
        ],
      }),
      btn: "Add Concat",
      name: "concat",
      info: L.jsxs("div", {
        style: { width: "100%" },
        children: [
          L.jsx("h5", { children: "States:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 6 (Start for c transition) ",
          }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children: "State 7 (Final State)",
          }),
          L.jsx("h5", { children: " Transition:" }),
          L.jsxs("p", {
            style: { fontSize: 13 },
            children: [
              "From State 6 to State 7 labeled with input symbol",
              " ",
              L.jsx("b", {
                style: { color: "green", fontSize: 15 },
                children: "c",
              }),
              ", completing the concatenation of the union NFA with the 'c' transition.",
            ],
          }),
          L.jsx("h5", { children: " Notes:" }),
          L.jsx("p", {
            style: { fontSize: 13 },
            children:
              "This step adds a new state (7) and a 'c' transition from the final state of the union NFA (6), representing the concatenation operation for the regular expression (a|b)c.",
          }),
        ],
      }),
    },
  ],
  Pi = [0, H3, vK, H3, yK, xK, SK, _K, WC],
  hu = ({
    isEnabel: t,
    position: e = [-2, 1, 0],
    textone: n = "1",
    texttwo: r = "2",
  }) => {
    const i = new K(2, 0, 0),
      o = new K(0, 0, 0),
      a = Fa();
    return L.jsxs("group", {
      onClick: () => {
        a(Da(!0)), a(ss(Pi[1][0].info));
      },
      position: e,
      children: [
        L.jsx(Tn, { scale: 0.35, text: n, position: [0, 0, 0], isEnabel: t }),
        L.jsx($n, {
          position: [1, 0.15, 0],
          scale: 0.2,
          color: t ? "white" : "grey",
          children: "a",
        }),
        L.jsx("arrowHelper", {
          args: [i, o, 1.87, t ? "white" : "grey", 0.2, 0.09],
        }),
        L.jsx(Tn, { isEnabel: t, scale: 0.35, text: r, position: [2, 0, 0] }),
      ],
    });
  },
  eu = ({
    isEnabel: t,
    position: e = [-2, -1, 0],
    textone: n = "3",
    texttwo: r = "4",
  }) => {
    const i = new K(2, 0, 0),
      o = new K(0, 0, 0),
      a = Fa();
    return L.jsxs("group", {
      onClick: () => {
        a(Da(!0)), a(ss(Pi[1][1].info));
      },
      position: e,
      children: [
        L.jsx(Tn, { scale: 0.35, text: n, position: [0, 0, 0], isEnabel: t }),
        L.jsx($n, {
          position: [1, 0.15, 0],
          scale: 0.2,
          color: t ? "white" : "grey",
          children: "b",
        }),
        L.jsx("arrowHelper", {
          args: [i, o, 1.87, t ? "white" : "grey", 0.2, 0.09],
        }),
        L.jsx(Tn, { scale: 0.35, text: r, position: [2, 0, 0], isEnabel: t }),
      ],
    });
  },
  XC = ({ isEnabel: t }) => {
    const e = new K(-2, -1, 0),
      n = new K(4, 0.45, 0),
      r = new K(2, 0, 0),
      i = new K(4, -0.45, 0),
      o = new K(-2, -1, 0),
      a = new K(4, -0.45, 0),
      s = new K(2, -2, 0),
      l = new K(4, 0.45, 0),
      c = Fa();
    return L.jsxs("group", {
      onClick: () => {
        c(Da(!0)), c(ss(Pi[1][2].info));
      },
      position: [-2, 1, 0],
      children: [
        L.jsx(Tn, {
          scale: 0.35,
          text: "5",
          position: [-2, -1, 0],
          isEnabel: t,
        }),
        L.jsxs("group", {
          children: [
            L.jsx(bl, {
              position: [-1.2, -0.2, 0],
              children: L.jsx("div", {
                style: { color: t ? "white" : "grey", userSelect: "none" },
                children: "",
              }),
            }),
            L.jsx("arrowHelper", {
              args: [n, e, 2.1, t ? "#00DFFF" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx(bl, {
              position: [3, -0.15, 0],
              children: L.jsx("div", {
                style: { color: t ? "white" : "grey", userSelect: "none" },
                children: "",
              }),
            }),
            L.jsx("arrowHelper", {
              args: [i, r, 2.1, t ? "#00DFFF" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx(bl, {
              position: [-1.2, -1.4, 0],
              children: L.jsx("div", {
                style: { color: t ? "white" : "grey", userSelect: "none" },
                children: "",
              }),
            }),
            L.jsx("arrowHelper", {
              args: [a, o, 2.1, t ? "#00DFFF" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx(bl, {
              position: [3, -1.45, 0],
              children: L.jsx("div", {
                style: { color: t ? "white" : "grey", userSelect: "none" },
                children: "",
              }),
            }),
            L.jsx("arrowHelper", {
              args: [l, s, 2.1, t ? "#00DFFF" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsx(Tn, {
          scale: 0.35,
          text: "6",
          position: [4, -1, 0],
          isEnabel: t,
        }),
      ],
    });
  },
  oU = ({ isEnabel: t }) => {
    const e = new K(-3.5, -1, 0),
      n = new K(4, 0, 0),
      r = new K(4, -1, 0),
      i = new K(4, -0, 0),
      o = new K(5.5, 1.3, 0),
      a = new K(3.5, -1, 0),
      s = new K(-2, -3, 0),
      l = new K(-2, 1.5, 0),
      c = Fa();
    return L.jsxs("group", {
      onClick: () => {
        c(Da(!0)), c(ss(Pi[1][3].info));
      },
      position: [-2, 1, 0],
      children: [
        L.jsx(Tn, {
          scale: 0.35,
          text: "7",
          position: [-3.5, -1, 0],
          isEnabel: t,
        }),
        L.jsxs("group", {
          children: [
            L.jsx($n, {
              position: [-3, -0.8, 0],
              scale: 0.2,
              color: t ? "white" : "grey",
              children: "",
            }),
            L.jsx("arrowHelper", {
              args: [n, e, 1.3, t ? "#FFA305" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx($n, {
              position: [4.5, -0.8, 0],
              scale: 0.2,
              color: t ? "white" : "grey",
              children: "",
            }),
            L.jsx("arrowHelper", {
              args: [i, r, 1.3, t ? "#FFA305" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx(Jo, {
              points: [
                [-3.5, -1, 0],
                [-3.5, 1.3, 0],
              ],
              linewidth: 1.3,
              color: t ? "#FFA305" : "grey",
            }),
            L.jsx(Jo, {
              points: [
                [-3.5, 1.3, 0],
                [5.5, 1.3, 0],
              ],
              linewidth: 1.3,
              color: t ? "#FFA305" : "grey",
            }),
            L.jsx($n, {
              position: [1, 1.5, 0],
              scale: 0.2,
              color: t ? "white" : "grey",
              children: "",
            }),
            L.jsx("arrowHelper", {
              args: [a, o, 2.1, t ? "#FFA305" : "grey", , 0.2, 0.09],
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx(Jo, {
              points: [
                [4, -1, 0],
                [4, -3, 0],
              ],
              linewidth: 1.3,
              color: t ? "#FFA305" : "grey",
            }),
            L.jsx(Jo, {
              points: [
                [4, -3, 0],
                [-2, -3, 0],
              ],
              linewidth: 1.3,
              color: t ? "#FFA305" : "grey",
            }),
            L.jsx($n, {
              position: [1, -3.2, 0],
              scale: 0.2,
              color: t ? "white" : "grey",
              children: "",
            }),
            L.jsx("arrowHelper", {
              args: [l, s, 1.8, t ? "#FFA305" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsx(Tn, {
          scale: 0.35,
          text: "8",
          position: [5.5, -1, 0],
          isEnabel: t,
        }),
      ],
    });
  },
  bK = () => {
    const { firstRe: t, clickedStep: e } = oa((n) => n.NFA);
    return (
      console.log(e),
      L.jsxs("group", {
        children: [
          t.a && L.jsx(hu, { isEnabel: e.character }),
          t.b && L.jsx(eu, { isEnabel: e.character }),
          t.union && L.jsx(XC, { isEnabel: e.union }),
          t.kleene && L.jsx(oU, { isEnabel: e["Kleene star"] }),
        ],
      })
    );
  },
  aU = ({ isEnabel: t }) => {
    const e = new K(2, 0, 0),
      n = new K(0, 0, 0),
      r = new K(2, 0, 0),
      i = new K(4, 0, 0);
    return L.jsxs("group", {
      position: [-2, 0, 0],
      children: [
        L.jsx(Tn, { scale: 0.35, text: "1", position: [0, 0, 0], isEnabel: t }),
        L.jsx($n, { fontSize: 0.18, position: [1, 0.11, 0], children: "a" }),
        L.jsx($n, { fontSize: 0.18, position: [3, 0.11, 0], children: "b" }),
        L.jsx("arrowHelper", {
          args: [e, n, 1.87, t ? "#FF00D1" : "white", 0.2, 0.09],
        }),
        L.jsx(Tn, { scale: 0.35, text: "2", position: [2, 0, 0], isEnabel: t }),
        L.jsx(Tn, { scale: 0.35, text: "3", position: [4, 0, 0], isEnabel: t }),
        L.jsx("arrowHelper", {
          args: [i, r, 1.87, t ? "#FF00D1" : "white", 0.2, 0.09],
        }),
      ],
    });
  },
  wK = ({ isEnabel: t }) => {
    const e = new K(-2, -1, 0),
      n = new K(1.5, 0, 0),
      r = new K(6, 1.3, 0),
      i = new K(4, -1.5, 0),
      o = new K(4, -1, 0),
      a = new K(6, 0, 0),
      s = new K(0, -2.5, 0),
      l = new K(-2, 1.5, 0);
    return L.jsxs("group", {
      position: [-2, 1, 0],
      children: [
        L.jsx(Tn, {
          scale: 0.35,
          text: "4",
          position: [-2, -1, 0],
          isEnabel: t,
        }),
        L.jsx(Tn, {
          scale: 0.35,
          text: "5",
          position: [6, -1, 0],
          isEnabel: t,
        }),
        L.jsxs("group", {
          children: [
            L.jsx($n, {
              position: [-1, -0.85, 0],
              scale: 0.2,
              color: t ? "white" : "grey",
              children: "",
            }),
            L.jsx("arrowHelper", {
              args: [n, e, 1.85, t ? "#FFA305" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsx("arrowHelper", {
          args: [a, o, 1.8, t ? "#FFA305" : "grey", 0.2, 0.09],
        }),
        L.jsxs("group", {
          children: [
            L.jsx($n, {
              position: [4.8, -0.8, 0],
              scale: 0.2,
              color: t ? "white" : "grey",
              children: "",
            }),
            L.jsx("arrowHelper", {
              args: [i, r, 2.1, t ? "#FFA305" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx(Jo, {
              points: [
                [-2, -1, 0],
                [-2, 1.3, 0],
              ],
              linewidth: 1.3,
              color: t ? "#FFA305" : "grey",
            }),
            L.jsx(Jo, {
              points: [
                [-2, 1.3, 0],
                [6, 1.3, 0],
              ],
              linewidth: 1.3,
              color: t ? "#FFA305" : "grey",
            }),
            L.jsx($n, {
              position: [2, 1.46, 0],
              scale: 0.2,
              color: t ? "white" : "grey",
              children: "E",
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx("arrowHelper", {
              args: [l, s, 1.3, t ? "#FFA305" : "grey", 0.2, 0.09],
            }),
            L.jsx(Jo, {
              points: [
                [4, -1, 0],
                [4, -2.5, 0],
              ],
              linewidth: 1.3,
              color: t ? "#FFA305" : "grey",
            }),
            L.jsx(Jo, {
              points: [
                [4, -2.5, 0],
                [0, -2.5, 0],
              ],
              linewidth: 1.3,
              color: t ? "#FFA305" : "grey",
            }),
            L.jsx($n, {
              position: [2, -2.3, 0],
              scale: 0.2,
              color: t ? "white" : "grey",
              children: "",
            }),
          ],
        }),
      ],
    });
  },
  EK = () => {
    const { secondRe: t, clickedStep: e, showConcat: n } = oa((r) => r.NFA);
    return (
      console.log(t),
      L.jsxs("group", {
        children: [
          t.a && !n && L.jsx(hu, { isEnabel: e.character }),
          t.b && !n && L.jsx(eu, { isEnabel: e.character }),
          t.concat && n && L.jsx(aU, { isEnabel: e.concatenation }),
          t.kleene && L.jsx(wK, { isEnabel: e["Kleene star"] }),
        ],
      })
    );
  },
  MK = ({ isEnabel: t }) => {
    const e = new K(13, 0, 0),
      n = new K(8.5, 0, 0),
      r = new K(10, 0, 0),
      i = new K(11, 0, 0),
      o = new K(14, 0, 0),
      a = new K(11.5, 0, 0);
    return L.jsxs("group", {
      position: [-5, 0, 0],
      children: [
        L.jsx($n, {
          position: [9.3, 0.2, 0],
          scale: 0.2,
          color: t ? "white" : "grey",
          children: "a",
        }),
        L.jsx($n, {
          position: [11, 0.2, 0],
          scale: 0.2,
          color: t ? "white" : "grey",
          children: "b",
        }),
        L.jsx($n, {
          position: [12.2, 0.2, 0],
          scale: 0.2,
          color: t ? "white" : "grey",
          children: "b",
        }),
        L.jsx(Tn, {
          scale: 0.35,
          text: "9",
          position: [10.1, 0, 0],
          isEnabel: t,
        }),
        L.jsx(Tn, {
          scale: 0.35,
          text: "10",
          position: [11.6, 0, 0],
          isEnabel: t,
        }),
        L.jsx(Tn, {
          scale: 0.35,
          text: "11",
          position: [13.1, 0, 0],
          isEnabel: t,
        }),
        L.jsx("arrowHelper", {
          args: [i, r, 1.46, t ? "#FF00D1" : "white", 0.2, 0.09],
        }),
        L.jsx("arrowHelper", {
          args: [e, n, 1.46, t ? "#FF00D1" : "white", 0.2, 0.09],
        }),
        L.jsx("arrowHelper", {
          args: [o, a, 1.46, t ? "#FF00D1" : "white", 0.2, 0.09],
        }),
      ],
    });
  },
  CK = () => {
    const {
      thirdRe: t,
      clickedStep: e,
      fourthRe: n,
      showConcat: r,
    } = oa((i) => i.NFA);
    return (
      console.log(n, "fourthRe"),
      L.jsxs("group", {
        children: [
          t.a && L.jsx(hu, { isEnabel: e.character }),
          t.b && L.jsx(eu, { isEnabel: e.character }),
          t.union && L.jsx(XC, { isEnabel: e.union }),
          t.kleene && L.jsx(oU, { isEnabel: e["Kleene star"] }),
          n.a &&
            !r &&
            L.jsx(hu, {
              textone: "9",
              texttwo: "10",
              position: [5, 1, 0],
              isEnabel: e.character,
            }),
          n.b &&
            !r &&
            L.jsx(eu, {
              textone: "11",
              texttwo: "12",
              position: [5, 0, 0],
              isEnabel: e.character,
            }),
          n.b1 &&
            !r &&
            L.jsx(eu, {
              textone: "13",
              texttwo: "14",
              position: [5, -1, 0],
              isEnabel: e.character,
            }),
          n.concat && r && L.jsx(MK, { isEnabel: e.concatenation }),
        ],
      })
    );
  },
  TK = () => {
    const { firstRe: t, clickedStep: e } = oa((n) => n.NFA);
    return L.jsxs("group", {
      children: [
        t.a && L.jsx(hu, { isEnabel: e.character }),
        t.b && L.jsx(eu, { isEnabel: e.character }),
        t.union && L.jsx(XC, { isEnabel: e.union }),
      ],
    });
  },
  AK = ({
    isEnabel: t,
    position: e = [-6, -1, 0],
    textone: n = "3",
    texttwo: r = "4",
  }) => {
    const i = new K(2, 0, 0),
      o = new K(0, 0, 0),
      a = Fa();
    return L.jsxs("group", {
      onClick: () => {
        a(Da(!0)), a(ss(Pi[1][1].info));
      },
      position: e,
      children: [
        L.jsx(Tn, { scale: 0.35, text: n, position: [0, 0, 0], isEnabel: t }),
        L.jsx($n, {
          position: [1, 0.15, 0],
          scale: 0.2,
          color: t ? "white" : "grey",
          children: "b",
        }),
        L.jsx("arrowHelper", {
          args: [i, o, 1.87, t ? "white" : "grey", 0.2, 0.09],
        }),
        L.jsx(Tn, { scale: 0.35, text: r, position: [2, 0, 0], isEnabel: t }),
      ],
    });
  },
  RK = ({ isEnabel: t }) => {
    new K(2, 0, 0), new K(0, 0, 0);
    const e = new K(2, 0, 0),
      n = new K(4, 0, 0);
    return L.jsxs("group", {
      position: [0, 1, 0],
      children: [
        L.jsx(Tn, { scale: 0.35, text: "3", position: [4, 0, 0], isEnabel: t }),
        L.jsx("arrowHelper", {
          args: [n, e, 1.87, t ? "#FF00D1" : "white", 0.2, 0.09],
        }),
      ],
    });
  },
  PK = ({ isEnabel: t }) => {
    const e = new K(-2, -1, 0),
      n = new K(1.5, 0, 0),
      r = new K(4, 1.3, 0),
      i = new K(4, -1.5, 0),
      o = new K(2, -1, 0),
      a = new K(4, 0, 0),
      s = new K(0, -2.5, 0),
      l = new K(-2, 1.5, 0);
    return L.jsxs("group", {
      position: [-2, 2, 0],
      children: [
        L.jsx(Tn, {
          scale: 0.35,
          text: "4",
          position: [-2, -1, 0],
          isEnabel: t,
        }),
        L.jsx(Tn, {
          scale: 0.35,
          text: "5",
          position: [4, -1, 0],
          isEnabel: t,
        }),
        L.jsxs("group", {
          children: [
            L.jsx($n, {
              position: [-1, -0.85, 0],
              scale: 0.2,
              color: t ? "white" : "grey",
              children: "",
            }),
            L.jsx("arrowHelper", {
              args: [n, e, 1.85, t ? "#FFA305" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsx("arrowHelper", {
          args: [a, o, 1.8, t ? "#FFA305" : "grey", 0.2, 0.09],
        }),
        L.jsxs("group", {
          children: [
            L.jsx($n, {
              position: [2.8, -0.8, 0],
              scale: 0.2,
              color: t ? "white" : "grey",
              children: "",
            }),
            L.jsx("arrowHelper", {
              args: [i, r, 2.1, t ? "#FFA305" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx(Jo, {
              points: [
                [-2, -1, 0],
                [-2, 1.3, 0],
              ],
              linewidth: 1.3,
              color: t ? "#FFA305" : "grey",
            }),
            L.jsx(Jo, {
              points: [
                [-2, 1.3, 0],
                [4, 1.3, 0],
              ],
              linewidth: 1.3,
              color: t ? "#FFA305" : "grey",
            }),
            L.jsx($n, {
              position: [2, 1.46, 0],
              scale: 0.2,
              color: t ? "white" : "grey",
              children: "",
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx("arrowHelper", {
              args: [l, s, 1.3, t ? "#FFA305" : "grey", 0.2, 0.09],
            }),
            L.jsx(Jo, {
              points: [
                [2, -1, 0],
                [2, -2.5, 0],
              ],
              linewidth: 1.3,
              color: t ? "#FFA305" : "grey",
            }),
            L.jsx(Jo, {
              points: [
                [2, -2.5, 0],
                [0, -2.5, 0],
              ],
              linewidth: 1.3,
              color: t ? "#FFA305" : "grey",
            }),
            L.jsx($n, {
              position: [1, -2.8, 0],
              scale: 0.2,
              color: t ? "white" : "grey",
              children: "",
            }),
          ],
        }),
      ],
    });
  },
  IK = () => {
    const { secondRe: t, clickedStep: e } = oa((n) => n.NFA);
    return L.jsxs("group", {
      children: [
        t.a &&
          L.jsx(hu, {
            isEnable: e.character,
            position: [-2, 1, 0],
            textone: "1",
            texttwo: "2",
          }),
        t.kleene && L.jsx(PK, { isEnable: e["Kleene star"] }),
        t.b &&
          !t.concat &&
          L.jsx(AK, {
            isEnable: e.character,
            position: [-2, -2, 0],
            textone: "5",
            texttwo: "6",
          }),
        t.concat && L.jsx(RK, { isEnable: e.concatenation }),
      ],
    });
  },
  LK = () => {
    const { secondRe: t, clickedStep: e, showConcat: n } = oa((r) => r.NFA);
    return (
      console.log(t),
      L.jsxs("group", {
        children: [
          t.a && !n && L.jsx(hu, { isEnabel: e.character }),
          t.b && !n && L.jsx(eu, { isEnabel: e.character }),
          t.concat && n && L.jsx(aU, { isEnabel: e.concatenation }),
        ],
      })
    );
  },
  OK = ({
    isEnabel: t,
    position: e = [-2, 1, 0],
    textone: n = "1",
    texttwo: r = "2",
  }) => {
    const i = new K(2, 0, 0),
      o = new K(0, 0, 0),
      a = Fa();
    return L.jsxs("group", {
      onClick: () => {
        a(Da(!0)), a(ss(Pi[1][0].info));
      },
      position: e,
      children: [
        L.jsx(Tn, { scale: 0.35, text: n, position: [0, 0, 0], isEnabel: t }),
        L.jsx($n, {
          position: [1, 0.15, 0],
          scale: 0.2,
          color: t ? "white" : "grey",
          children: "a",
        }),
        L.jsx("arrowHelper", {
          args: [i, o, 1.87, t ? "white" : "grey", 0.2, 0.09],
        }),
        L.jsx(Tn, { isEnabel: t, scale: 0.35, text: r, position: [2, 0, 0] }),
      ],
    });
  },
  NK = ({
    isEnabel: t,
    position: e = [-2, -1, 0],
    textone: n = "2",
    texttwo: r = "4",
  }) => {
    const i = new K(2, 0, 0),
      o = new K(0, 0, 0),
      a = Fa();
    return L.jsxs("group", {
      onClick: () => {
        a(Da(!0)), a(ss(Pi[1][1].info));
      },
      position: e,
      children: [
        L.jsx(Tn, { scale: 0.35, text: n, position: [0, 0, 0], isEnabel: t }),
        L.jsx($n, {
          position: [1, 0.15, 0],
          scale: 0.2,
          color: t ? "white" : "grey",
          children: "b",
        }),
        L.jsx("arrowHelper", {
          args: [i, o, 1.87, t ? "white" : "grey", 0.2, 0.09],
        }),
        L.jsx(Tn, { scale: 0.35, text: r, position: [2, 0, 0], isEnabel: t }),
      ],
    });
  },
  FK = ({ isEnabel: t }) => {
    const e = new K(-2, -1, 0),
      n = new K(4, 0.45, 0),
      r = new K(2, 0, 0),
      i = new K(4, -0.45, 0),
      o = new K(-2, -1, 0),
      a = new K(4, -0.45, 0),
      s = new K(2, -2, 0),
      l = new K(4, 0.45, 0),
      c = Fa();
    return L.jsxs("group", {
      onClick: () => {
        c(Da(!0)), c(ss(Pi[1][2].info));
      },
      position: [-2, 1, 0],
      children: [
        L.jsx(Tn, {
          scale: 0.35,
          text: "5",
          position: [-2, -1, 0],
          isEnabel: t,
        }),
        L.jsxs("group", {
          children: [
            L.jsx(bl, {
              position: [-1.2, -0.2, 0],
              children: L.jsx("div", {
                style: { color: t ? "white" : "grey", fontSize: "16px" },
                children: "",
              }),
            }),
            L.jsx("arrowHelper", {
              args: [n, e, 2.1, t ? "#00DFFF" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx(bl, {
              position: [3, -0.15, 0],
              children: L.jsx("div", {
                style: { color: t ? "white" : "grey", fontSize: "16px" },
                children: "",
              }),
            }),
            L.jsx("arrowHelper", {
              args: [i, r, 2.1, t ? "#00DFFF" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx(bl, {
              position: [-1.2, -1.4, 0],
              children: L.jsx("div", {
                style: { color: t ? "white" : "grey", fontSize: "16px" },
                children: "",
              }),
            }),
            L.jsx("arrowHelper", {
              args: [a, o, 2.1, t ? "#00DFFF" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsxs("group", {
          children: [
            L.jsx(bl, {
              position: [3, -1.45, 0],
              children: L.jsx("div", {
                style: { color: t ? "white" : "grey", fontSize: "16px" },
                children: "",
              }),
            }),
            L.jsx("arrowHelper", {
              args: [l, s, 2.1, t ? "#00DFFF" : "grey", 0.2, 0.09],
            }),
          ],
        }),
        L.jsx(Tn, {
          scale: 0.35,
          text: "6",
          position: [4, -1, 0],
          isEnabel: t,
        }),
      ],
    });
  },
  DK = ({
    isEnabel: t,
    position: e = [0, 0, 0],
    endPosition: n = [2, 0, 0],
  }) => {
    const r = Fa(),
      i = t ? "#FF00D1" : "grey",
      o = new K(0, 0, 0),
      a = new K(...n).sub(new K(...e)),
      s = a.clone().normalize(),
      l = a.length() - 0.35,
      c = o.clone().lerp(a, 0.5).add(new K(0, -0.2, 0)),
      u = s.clone().multiplyScalar(l).add(o);
    return L.jsxs("group", {
      position: e,
      onClick: () => {
        r(Da(!0)), r(ss(WC[3].info));
      },
      children: [
        L.jsx(Tn, { scale: 0.35, text: "6", position: [0, 0, 0], isEnabel: t }),
        L.jsx("arrowHelper", { args: [s, o, l, i, 0.3, 0.09] }),
        L.jsx($n, {
          position: c.toArray(),
          scale: 0.2,
          color: i,
          children: "c",
        }),
        L.jsx(Tn, {
          scale: 0.35,
          text: "7",
          position: u.toArray(),
          isEnabel: t,
          isAccept: !0,
        }),
      ],
    });
  },
  zK = () => {
    const { firstRe: t, clickedStep: e, fourthRe: n } = oa((o) => o.NFA);
    console.log(e);
    const r = [2, 0, 0],
      i = [r[0] + 2 + 0.35, r[1], r[2]];
    return L.jsxs("group", {
      children: [
        t.a && L.jsx(OK, { isEnabel: e.character }),
        t.b && L.jsx(NK, { isEnabel: e.character }),
        t.union && L.jsx(FK, { isEnabel: e.union }),
        n.concat &&
          L.jsx(DK, { isEnabel: e.concatenation, position: r, endPosition: i }),
      ],
    });
  },
  UK = () => {
    const { REvalue: t } = oa((e) => e.NFA);
    return L.jsxs("group", {
      scale: 0.5,
      children: [
        t === "(a|b)*" && L.jsx(bK, {}),
        t === "(ab)*" && L.jsx(EK, {}),
        t === "(a|b)*abb" && L.jsx(CK, {}),
        t === "a|b" && L.jsx(TK, {}),
        t === "a*b" && L.jsx(IK, {}),
        t === "ab" && L.jsx(LK, {}),
        t === "(a|b)c" && L.jsx(zK, {}),
      ],
    });
  },
  kK = () => {
    const { isInfo: t, currentOperationMessage: e } = oa((n) => n.NFA);
    return L.jsxs("div", {
      style: {
        height: "100%",
        display: "flex",
        flexDirection: "column",
        position: "relative",
      },
      children: [
        L.jsxs(E9, {
          camera: { position: [-0.5, 2, 40], fov: 10 },
          style: { height: "100%", width: "100%", background: "#0c0f21" },
          children: [
            L.jsx("pointLight", { position: [1, 1, 5], intensity: 260 }),
            L.jsx(UK, {}),
            L.jsx(lq, {}),
            e &&
              L.jsx($n, {
                position: [-0.3, -2, 0],
                fontSize: 0.15,
                color: "white",
                anchorX: "center",
                anchorY: "middle",
                textAlign: "center",
                animation: "fadeIn 0.5s ease-in",
                children: e,
              }),
          ],
        }),
        L.jsx("style", {
          children: `
          @keyframes fadeIn {
            from {
              opacity: 0;
            }
            to {
              opacity: 1;
            }
          }
        `,
        }),
      ],
    });
  };
var sU = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ (function (t) {
  (function () {
    var e = {}.hasOwnProperty;
    function n() {
      for (var o = "", a = 0; a < arguments.length; a++) {
        var s = arguments[a];
        s && (o = i(o, r(s)));
      }
      return o;
    }
    function r(o) {
      if (typeof o == "string" || typeof o == "number") return o;
      if (typeof o != "object") return "";
      if (Array.isArray(o)) return n.apply(null, o);
      if (
        o.toString !== Object.prototype.toString &&
        !o.toString.toString().includes("[native code]")
      )
        return o.toString();
      var a = "";
      for (var s in o) e.call(o, s) && o[s] && (a = i(a, s));
      return a;
    }
    function i(o, a) {
      return a ? (o ? o + " " + a : o + a) : o;
    }
    t.exports ? ((n.default = n), (t.exports = n)) : (window.classNames = n);
  })();
})(sU);
var BK = sU.exports;
const nt = Ny(BK);
var lU = { exports: {} },
  An = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var qC = Symbol.for("react.element"),
  KC = Symbol.for("react.portal"),
  I1 = Symbol.for("react.fragment"),
  L1 = Symbol.for("react.strict_mode"),
  O1 = Symbol.for("react.profiler"),
  N1 = Symbol.for("react.provider"),
  F1 = Symbol.for("react.context"),
  HK = Symbol.for("react.server_context"),
  D1 = Symbol.for("react.forward_ref"),
  z1 = Symbol.for("react.suspense"),
  U1 = Symbol.for("react.suspense_list"),
  k1 = Symbol.for("react.memo"),
  B1 = Symbol.for("react.lazy"),
  jK = Symbol.for("react.offscreen"),
  cU;
cU = Symbol.for("react.module.reference");
function aa(t) {
  if (typeof t == "object" && t !== null) {
    var e = t.$$typeof;
    switch (e) {
      case qC:
        switch (((t = t.type), t)) {
          case I1:
          case O1:
          case L1:
          case z1:
          case U1:
            return t;
          default:
            switch (((t = t && t.$$typeof), t)) {
              case HK:
              case F1:
              case D1:
              case B1:
              case k1:
              case N1:
                return t;
              default:
                return e;
            }
        }
      case KC:
        return e;
    }
  }
}
An.ContextConsumer = F1;
An.ContextProvider = N1;
An.Element = qC;
An.ForwardRef = D1;
An.Fragment = I1;
An.Lazy = B1;
An.Memo = k1;
An.Portal = KC;
An.Profiler = O1;
An.StrictMode = L1;
An.Suspense = z1;
An.SuspenseList = U1;
An.isAsyncMode = function () {
  return !1;
};
An.isConcurrentMode = function () {
  return !1;
};
An.isContextConsumer = function (t) {
  return aa(t) === F1;
};
An.isContextProvider = function (t) {
  return aa(t) === N1;
};
An.isElement = function (t) {
  return typeof t == "object" && t !== null && t.$$typeof === qC;
};
An.isForwardRef = function (t) {
  return aa(t) === D1;
};
An.isFragment = function (t) {
  return aa(t) === I1;
};
An.isLazy = function (t) {
  return aa(t) === B1;
};
An.isMemo = function (t) {
  return aa(t) === k1;
};
An.isPortal = function (t) {
  return aa(t) === KC;
};
An.isProfiler = function (t) {
  return aa(t) === O1;
};
An.isStrictMode = function (t) {
  return aa(t) === L1;
};
An.isSuspense = function (t) {
  return aa(t) === z1;
};
An.isSuspenseList = function (t) {
  return aa(t) === U1;
};
An.isValidElementType = function (t) {
  return (
    typeof t == "string" ||
    typeof t == "function" ||
    t === I1 ||
    t === O1 ||
    t === L1 ||
    t === z1 ||
    t === U1 ||
    t === jK ||
    (typeof t == "object" &&
      t !== null &&
      (t.$$typeof === B1 ||
        t.$$typeof === k1 ||
        t.$$typeof === N1 ||
        t.$$typeof === F1 ||
        t.$$typeof === D1 ||
        t.$$typeof === cU ||
        t.getModuleId !== void 0))
  );
};
An.typeOf = aa;
lU.exports = An;
var uU = lU.exports;
function yf(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    n = [];
  return (
    at.Children.forEach(t, function (r) {
      (r == null && !e.keepEmpty) ||
        (Array.isArray(r)
          ? (n = n.concat(yf(r)))
          : uU.isFragment(r) && r.props
          ? (n = n.concat(yf(r.props.children, e)))
          : n.push(r));
    }),
    n
  );
}
var tE = {},
  VK = function (e) {};
function $K(t, e) {}
function GK(t, e) {}
function WK() {
  tE = {};
}
function dU(t, e, n) {
  !e && !tE[n] && (t(!1, n), (tE[n] = !0));
}
function Ni(t, e) {
  dU($K, t, e);
}
function XK(t, e) {
  dU(GK, t, e);
}
Ni.preMessage = VK;
Ni.resetWarned = WK;
Ni.noteOnce = XK;
function un(t) {
  "@babel/helpers - typeof";
  return (
    (un =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    un(t)
  );
}
function qK(t, e) {
  if (un(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (un(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function fU(t) {
  var e = qK(t, "string");
  return un(e) == "symbol" ? e : e + "";
}
function be(t, e, n) {
  return (
    (e = fU(e)) in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
function j3(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(t, i).enumerable;
      })),
      n.push.apply(n, r);
  }
  return n;
}
function De(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? j3(Object(n), !0).forEach(function (r) {
          be(t, r, n[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
      : j3(Object(n)).forEach(function (r) {
          Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
        });
  }
  return t;
}
function xy(t) {
  return t instanceof HTMLElement || t instanceof SVGElement;
}
function C0(t) {
  return xy(t) ? t : t instanceof at.Component ? jN.findDOMNode(t) : null;
}
function H1(t, e, n) {
  var r = E.useRef({});
  return (
    (!("value" in r.current) || n(r.current.condition, e)) &&
      ((r.current.value = t()), (r.current.condition = e)),
    r.current.value
  );
}
function YC(t, e) {
  typeof t == "function"
    ? t(e)
    : un(t) === "object" && t && "current" in t && (t.current = e);
}
function ls() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  var r = e.filter(function (i) {
    return i;
  });
  return r.length <= 1
    ? r[0]
    : function (i) {
        e.forEach(function (o) {
          YC(o, i);
        });
      };
}
function Em() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return H1(
    function () {
      return ls.apply(void 0, e);
    },
    e,
    function (r, i) {
      return (
        r.length !== i.length ||
        r.every(function (o, a) {
          return o !== i[a];
        })
      );
    }
  );
}
function wu(t) {
  var e,
    n,
    r = uU.isMemo(t) ? t.type.type : t.type;
  return !(
    (typeof r == "function" &&
      !((e = r.prototype) !== null && e !== void 0 && e.render)) ||
    (typeof t == "function" &&
      !((n = t.prototype) !== null && n !== void 0 && n.render))
  );
}
var nE = E.createContext(null);
function KK(t) {
  var e = t.children,
    n = t.onBatchResize,
    r = E.useRef(0),
    i = E.useRef([]),
    o = E.useContext(nE),
    a = E.useCallback(
      function (s, l, c) {
        r.current += 1;
        var u = r.current;
        i.current.push({ size: s, element: l, data: c }),
          Promise.resolve().then(function () {
            u === r.current && (n == null || n(i.current), (i.current = []));
          }),
          o == null || o(s, l, c);
      },
      [n, o]
    );
  return E.createElement(nE.Provider, { value: a }, e);
}
var hU = (function () {
    if (typeof Map < "u") return Map;
    function t(e, n) {
      var r = -1;
      return (
        e.some(function (i, o) {
          return i[0] === n ? ((r = o), !0) : !1;
        }),
        r
      );
    }
    return (function () {
      function e() {
        this.__entries__ = [];
      }
      return (
        Object.defineProperty(e.prototype, "size", {
          get: function () {
            return this.__entries__.length;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.get = function (n) {
          var r = t(this.__entries__, n),
            i = this.__entries__[r];
          return i && i[1];
        }),
        (e.prototype.set = function (n, r) {
          var i = t(this.__entries__, n);
          ~i ? (this.__entries__[i][1] = r) : this.__entries__.push([n, r]);
        }),
        (e.prototype.delete = function (n) {
          var r = this.__entries__,
            i = t(r, n);
          ~i && r.splice(i, 1);
        }),
        (e.prototype.has = function (n) {
          return !!~t(this.__entries__, n);
        }),
        (e.prototype.clear = function () {
          this.__entries__.splice(0);
        }),
        (e.prototype.forEach = function (n, r) {
          r === void 0 && (r = null);
          for (var i = 0, o = this.__entries__; i < o.length; i++) {
            var a = o[i];
            n.call(r, a[1], a[0]);
          }
        }),
        e
      );
    })();
  })(),
  rE =
    typeof window < "u" &&
    typeof document < "u" &&
    window.document === document,
  Sy = (function () {
    return typeof global < "u" && global.Math === Math
      ? global
      : typeof self < "u" && self.Math === Math
      ? self
      : typeof window < "u" && window.Math === Math
      ? window
      : Function("return this")();
  })(),
  YK = (function () {
    return typeof requestAnimationFrame == "function"
      ? requestAnimationFrame.bind(Sy)
      : function (t) {
          return setTimeout(function () {
            return t(Date.now());
          }, 1e3 / 60);
        };
  })(),
  ZK = 2;
function QK(t, e) {
  var n = !1,
    r = !1,
    i = 0;
  function o() {
    n && ((n = !1), t()), r && s();
  }
  function a() {
    YK(o);
  }
  function s() {
    var l = Date.now();
    if (n) {
      if (l - i < ZK) return;
      r = !0;
    } else (n = !0), (r = !1), setTimeout(a, e);
    i = l;
  }
  return s;
}
var JK = 20,
  eY = ["top", "right", "bottom", "left", "width", "height", "size", "weight"],
  tY = typeof MutationObserver < "u",
  nY = (function () {
    function t() {
      (this.connected_ = !1),
        (this.mutationEventsAdded_ = !1),
        (this.mutationsObserver_ = null),
        (this.observers_ = []),
        (this.onTransitionEnd_ = this.onTransitionEnd_.bind(this)),
        (this.refresh = QK(this.refresh.bind(this), JK));
    }
    return (
      (t.prototype.addObserver = function (e) {
        ~this.observers_.indexOf(e) || this.observers_.push(e),
          this.connected_ || this.connect_();
      }),
      (t.prototype.removeObserver = function (e) {
        var n = this.observers_,
          r = n.indexOf(e);
        ~r && n.splice(r, 1),
          !n.length && this.connected_ && this.disconnect_();
      }),
      (t.prototype.refresh = function () {
        var e = this.updateObservers_();
        e && this.refresh();
      }),
      (t.prototype.updateObservers_ = function () {
        var e = this.observers_.filter(function (n) {
          return n.gatherActive(), n.hasActive();
        });
        return (
          e.forEach(function (n) {
            return n.broadcastActive();
          }),
          e.length > 0
        );
      }),
      (t.prototype.connect_ = function () {
        !rE ||
          this.connected_ ||
          (document.addEventListener("transitionend", this.onTransitionEnd_),
          window.addEventListener("resize", this.refresh),
          tY
            ? ((this.mutationsObserver_ = new MutationObserver(this.refresh)),
              this.mutationsObserver_.observe(document, {
                attributes: !0,
                childList: !0,
                characterData: !0,
                subtree: !0,
              }))
            : (document.addEventListener("DOMSubtreeModified", this.refresh),
              (this.mutationEventsAdded_ = !0)),
          (this.connected_ = !0));
      }),
      (t.prototype.disconnect_ = function () {
        !rE ||
          !this.connected_ ||
          (document.removeEventListener("transitionend", this.onTransitionEnd_),
          window.removeEventListener("resize", this.refresh),
          this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
          this.mutationEventsAdded_ &&
            document.removeEventListener("DOMSubtreeModified", this.refresh),
          (this.mutationsObserver_ = null),
          (this.mutationEventsAdded_ = !1),
          (this.connected_ = !1));
      }),
      (t.prototype.onTransitionEnd_ = function (e) {
        var n = e.propertyName,
          r = n === void 0 ? "" : n,
          i = eY.some(function (o) {
            return !!~r.indexOf(o);
          });
        i && this.refresh();
      }),
      (t.getInstance = function () {
        return this.instance_ || (this.instance_ = new t()), this.instance_;
      }),
      (t.instance_ = null),
      t
    );
  })(),
  pU = function (t, e) {
    for (var n = 0, r = Object.keys(e); n < r.length; n++) {
      var i = r[n];
      Object.defineProperty(t, i, {
        value: e[i],
        enumerable: !1,
        writable: !1,
        configurable: !0,
      });
    }
    return t;
  },
  xf = function (t) {
    var e = t && t.ownerDocument && t.ownerDocument.defaultView;
    return e || Sy;
  },
  mU = j1(0, 0, 0, 0);
function _y(t) {
  return parseFloat(t) || 0;
}
function V3(t) {
  for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
  return e.reduce(function (r, i) {
    var o = t["border-" + i + "-width"];
    return r + _y(o);
  }, 0);
}
function rY(t) {
  for (
    var e = ["top", "right", "bottom", "left"], n = {}, r = 0, i = e;
    r < i.length;
    r++
  ) {
    var o = i[r],
      a = t["padding-" + o];
    n[o] = _y(a);
  }
  return n;
}
function iY(t) {
  var e = t.getBBox();
  return j1(0, 0, e.width, e.height);
}
function oY(t) {
  var e = t.clientWidth,
    n = t.clientHeight;
  if (!e && !n) return mU;
  var r = xf(t).getComputedStyle(t),
    i = rY(r),
    o = i.left + i.right,
    a = i.top + i.bottom,
    s = _y(r.width),
    l = _y(r.height);
  if (
    (r.boxSizing === "border-box" &&
      (Math.round(s + o) !== e && (s -= V3(r, "left", "right") + o),
      Math.round(l + a) !== n && (l -= V3(r, "top", "bottom") + a)),
    !sY(t))
  ) {
    var c = Math.round(s + o) - e,
      u = Math.round(l + a) - n;
    Math.abs(c) !== 1 && (s -= c), Math.abs(u) !== 1 && (l -= u);
  }
  return j1(i.left, i.top, s, l);
}
var aY = (function () {
  return typeof SVGGraphicsElement < "u"
    ? function (t) {
        return t instanceof xf(t).SVGGraphicsElement;
      }
    : function (t) {
        return t instanceof xf(t).SVGElement && typeof t.getBBox == "function";
      };
})();
function sY(t) {
  return t === xf(t).document.documentElement;
}
function lY(t) {
  return rE ? (aY(t) ? iY(t) : oY(t)) : mU;
}
function cY(t) {
  var e = t.x,
    n = t.y,
    r = t.width,
    i = t.height,
    o = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object,
    a = Object.create(o.prototype);
  return (
    pU(a, {
      x: e,
      y: n,
      width: r,
      height: i,
      top: n,
      right: e + r,
      bottom: i + n,
      left: e,
    }),
    a
  );
}
function j1(t, e, n, r) {
  return { x: t, y: e, width: n, height: r };
}
var uY = (function () {
    function t(e) {
      (this.broadcastWidth = 0),
        (this.broadcastHeight = 0),
        (this.contentRect_ = j1(0, 0, 0, 0)),
        (this.target = e);
    }
    return (
      (t.prototype.isActive = function () {
        var e = lY(this.target);
        return (
          (this.contentRect_ = e),
          e.width !== this.broadcastWidth || e.height !== this.broadcastHeight
        );
      }),
      (t.prototype.broadcastRect = function () {
        var e = this.contentRect_;
        return (
          (this.broadcastWidth = e.width), (this.broadcastHeight = e.height), e
        );
      }),
      t
    );
  })(),
  dY = (function () {
    function t(e, n) {
      var r = cY(n);
      pU(this, { target: e, contentRect: r });
    }
    return t;
  })(),
  fY = (function () {
    function t(e, n, r) {
      if (
        ((this.activeObservations_ = []),
        (this.observations_ = new hU()),
        typeof e != "function")
      )
        throw new TypeError(
          "The callback provided as parameter 1 is not a function."
        );
      (this.callback_ = e), (this.controller_ = n), (this.callbackCtx_ = r);
    }
    return (
      (t.prototype.observe = function (e) {
        if (!arguments.length)
          throw new TypeError("1 argument required, but only 0 present.");
        if (!(typeof Element > "u" || !(Element instanceof Object))) {
          if (!(e instanceof xf(e).Element))
            throw new TypeError('parameter 1 is not of type "Element".');
          var n = this.observations_;
          n.has(e) ||
            (n.set(e, new uY(e)),
            this.controller_.addObserver(this),
            this.controller_.refresh());
        }
      }),
      (t.prototype.unobserve = function (e) {
        if (!arguments.length)
          throw new TypeError("1 argument required, but only 0 present.");
        if (!(typeof Element > "u" || !(Element instanceof Object))) {
          if (!(e instanceof xf(e).Element))
            throw new TypeError('parameter 1 is not of type "Element".');
          var n = this.observations_;
          n.has(e) &&
            (n.delete(e), n.size || this.controller_.removeObserver(this));
        }
      }),
      (t.prototype.disconnect = function () {
        this.clearActive(),
          this.observations_.clear(),
          this.controller_.removeObserver(this);
      }),
      (t.prototype.gatherActive = function () {
        var e = this;
        this.clearActive(),
          this.observations_.forEach(function (n) {
            n.isActive() && e.activeObservations_.push(n);
          });
      }),
      (t.prototype.broadcastActive = function () {
        if (this.hasActive()) {
          var e = this.callbackCtx_,
            n = this.activeObservations_.map(function (r) {
              return new dY(r.target, r.broadcastRect());
            });
          this.callback_.call(e, n, e), this.clearActive();
        }
      }),
      (t.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
      }),
      (t.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
      }),
      t
    );
  })(),
  gU = typeof WeakMap < "u" ? new WeakMap() : new hU(),
  vU = (function () {
    function t(e) {
      if (!(this instanceof t))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var n = nY.getInstance(),
        r = new fY(e, n, this);
      gU.set(this, r);
    }
    return t;
  })();
["observe", "unobserve", "disconnect"].forEach(function (t) {
  vU.prototype[t] = function () {
    var e;
    return (e = gU.get(this))[t].apply(e, arguments);
  };
});
var hY = (function () {
    return typeof Sy.ResizeObserver < "u" ? Sy.ResizeObserver : vU;
  })(),
  wl = new Map();
function pY(t) {
  t.forEach(function (e) {
    var n,
      r = e.target;
    (n = wl.get(r)) === null ||
      n === void 0 ||
      n.forEach(function (i) {
        return i(r);
      });
  });
}
var yU = new hY(pY);
function mY(t, e) {
  wl.has(t) || (wl.set(t, new Set()), yU.observe(t)), wl.get(t).add(e);
}
function gY(t, e) {
  wl.has(t) &&
    (wl.get(t).delete(e), wl.get(t).size || (yU.unobserve(t), wl.delete(t)));
}
function ro(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function $3(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(t, fU(r.key), r);
  }
}
function io(t, e, n) {
  return (
    e && $3(t.prototype, e),
    n && $3(t, n),
    Object.defineProperty(t, "prototype", { writable: !1 }),
    t
  );
}
function iE(t, e) {
  return (
    (iE = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (n, r) {
          return (n.__proto__ = r), n;
        }),
    iE(t, e)
  );
}
function Eu(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  (t.prototype = Object.create(e && e.prototype, {
    constructor: { value: t, writable: !0, configurable: !0 },
  })),
    Object.defineProperty(t, "prototype", { writable: !1 }),
    e && iE(t, e);
}
function Gl(t) {
  return (
    (Gl = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        }),
    Gl(t)
  );
}
function V1() {
  try {
    var t = !Boolean.prototype.valueOf.call(
      Reflect.construct(Boolean, [], function () {})
    );
  } catch {}
  return (V1 = function () {
    return !!t;
  })();
}
function hn(t) {
  if (t === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return t;
}
function ZC(t, e) {
  if (e && (un(e) == "object" || typeof e == "function")) return e;
  if (e !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    );
  return hn(t);
}
function Mm(t) {
  var e = V1();
  return function () {
    var n,
      r = Gl(t);
    if (e) {
      var i = Gl(this).constructor;
      n = Reflect.construct(r, arguments, i);
    } else n = r.apply(this, arguments);
    return ZC(this, n);
  };
}
var vY = (function (t) {
  Eu(n, t);
  var e = Mm(n);
  function n() {
    return ro(this, n), e.apply(this, arguments);
  }
  return (
    io(n, [
      {
        key: "render",
        value: function () {
          return this.props.children;
        },
      },
    ]),
    n
  );
})(E.Component);
function yY(t, e) {
  var n = t.children,
    r = t.disabled,
    i = E.useRef(null),
    o = E.useRef(null),
    a = E.useContext(nE),
    s = typeof n == "function",
    l = s ? n(i) : n,
    c = E.useRef({ width: -1, height: -1, offsetWidth: -1, offsetHeight: -1 }),
    u = !s && E.isValidElement(l) && wu(l),
    d = u ? l.ref : null,
    p = Em(d, i),
    m = function () {
      var g;
      return (
        C0(i.current) ||
        (i.current && un(i.current) === "object"
          ? C0(
              (g = i.current) === null || g === void 0
                ? void 0
                : g.nativeElement
            )
          : null) ||
        C0(o.current)
      );
    };
  E.useImperativeHandle(e, function () {
    return m();
  });
  var v = E.useRef(t);
  v.current = t;
  var S = E.useCallback(function (x) {
    var g = v.current,
      _ = g.onResize,
      y = g.data,
      w = x.getBoundingClientRect(),
      A = w.width,
      M = w.height,
      T = x.offsetWidth,
      I = x.offsetHeight,
      R = Math.floor(A),
      P = Math.floor(M);
    if (
      c.current.width !== R ||
      c.current.height !== P ||
      c.current.offsetWidth !== T ||
      c.current.offsetHeight !== I
    ) {
      var F = { width: R, height: P, offsetWidth: T, offsetHeight: I };
      c.current = F;
      var D = T === Math.round(A) ? A : T,
        j = I === Math.round(M) ? M : I,
        N = De(De({}, F), {}, { offsetWidth: D, offsetHeight: j });
      a == null || a(N, x, y),
        _ &&
          Promise.resolve().then(function () {
            _(N, x);
          });
    }
  }, []);
  return (
    E.useEffect(
      function () {
        var x = m();
        return (
          x && !r && mY(x, S),
          function () {
            return gY(x, S);
          }
        );
      },
      [i.current, r]
    ),
    E.createElement(vY, { ref: o }, u ? E.cloneElement(l, { ref: p }) : l)
  );
}
var xY = E.forwardRef(yY),
  SY = "rc-observer-key";
function _Y(t, e) {
  var n = t.children,
    r = typeof n == "function" ? [n] : yf(n);
  return r.map(function (i, o) {
    var a = (i == null ? void 0 : i.key) || "".concat(SY, "-").concat(o);
    return E.createElement(
      xY,
      Et({}, t, { key: a, ref: o === 0 ? e : void 0 }),
      i
    );
  });
}
var Ds = E.forwardRef(_Y);
Ds.Collection = KK;
function Ys(t, e) {
  var n = De({}, t);
  return (
    Array.isArray(e) &&
      e.forEach(function (r) {
        delete n[r];
      }),
    n
  );
}
function oE(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function bY(t) {
  if (Array.isArray(t)) return oE(t);
}
function xU(t) {
  if (
    (typeof Symbol < "u" && t[Symbol.iterator] != null) ||
    t["@@iterator"] != null
  )
    return Array.from(t);
}
function QC(t, e) {
  if (t) {
    if (typeof t == "string") return oE(t, e);
    var n = {}.toString.call(t).slice(8, -1);
    return (
      n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set"
        ? Array.from(t)
        : n === "Arguments" ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
        ? oE(t, e)
        : void 0
    );
  }
}
function wY() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function It(t) {
  return bY(t) || xU(t) || QC(t) || wY();
}
var SU = function (e) {
    return +setTimeout(e, 16);
  },
  _U = function (e) {
    return clearTimeout(e);
  };
typeof window < "u" &&
  "requestAnimationFrame" in window &&
  ((SU = function (e) {
    return window.requestAnimationFrame(e);
  }),
  (_U = function (e) {
    return window.cancelAnimationFrame(e);
  }));
var G3 = 0,
  JC = new Map();
function bU(t) {
  JC.delete(t);
}
var Er = function (e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  G3 += 1;
  var r = G3;
  function i(o) {
    if (o === 0) bU(r), e();
    else {
      var a = SU(function () {
        i(o - 1);
      });
      JC.set(r, a);
    }
  }
  return i(n), r;
};
Er.cancel = function (t) {
  var e = JC.get(t);
  return bU(t), _U(e);
};
function wU(t) {
  if (Array.isArray(t)) return t;
}
function EY(t, e) {
  var n =
    t == null
      ? null
      : (typeof Symbol < "u" && t[Symbol.iterator]) || t["@@iterator"];
  if (n != null) {
    var r,
      i,
      o,
      a,
      s = [],
      l = !0,
      c = !1;
    try {
      if (((o = (n = n.call(t)).next), e === 0)) {
        if (Object(n) !== n) return;
        l = !1;
      } else
        for (
          ;
          !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== e);
          l = !0
        );
    } catch (u) {
      (c = !0), (i = u);
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return;
      } finally {
        if (c) throw i;
      }
    }
    return s;
  }
}
function EU() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ve(t, e) {
  return wU(t) || EY(t, e) || QC(t, e) || EU();
}
function by(t) {
  for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4)
    (n =
      (t.charCodeAt(r) & 255) |
      ((t.charCodeAt(++r) & 255) << 8) |
      ((t.charCodeAt(++r) & 255) << 16) |
      ((t.charCodeAt(++r) & 255) << 24)),
      (n = (n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)),
      (n ^= n >>> 24),
      (e =
        ((n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)) ^
        ((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)));
  switch (i) {
    case 3:
      e ^= (t.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (t.charCodeAt(r + 1) & 255) << 8;
    case 1:
      (e ^= t.charCodeAt(r) & 255),
        (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16));
  }
  return (
    (e ^= e >>> 13),
    (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
    ((e ^ (e >>> 15)) >>> 0).toString(36)
  );
}
function to() {
  return !!(
    typeof window < "u" &&
    window.document &&
    window.document.createElement
  );
}
function MY(t, e) {
  if (!t) return !1;
  if (t.contains) return t.contains(e);
  for (var n = e; n; ) {
    if (n === t) return !0;
    n = n.parentNode;
  }
  return !1;
}
var W3 = "data-rc-order",
  X3 = "data-rc-priority",
  CY = "rc-util-key",
  aE = new Map();
function MU() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    e = t.mark;
  return e ? (e.startsWith("data-") ? e : "data-".concat(e)) : CY;
}
function $1(t) {
  if (t.attachTo) return t.attachTo;
  var e = document.querySelector("head");
  return e || document.body;
}
function TY(t) {
  return t === "queue" ? "prependQueue" : t ? "prepend" : "append";
}
function CU(t) {
  return Array.from((aE.get(t) || t).children).filter(function (e) {
    return e.tagName === "STYLE";
  });
}
function TU(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!to()) return null;
  var n = e.csp,
    r = e.prepend,
    i = e.priority,
    o = i === void 0 ? 0 : i,
    a = TY(r),
    s = a === "prependQueue",
    l = document.createElement("style");
  l.setAttribute(W3, a),
    s && o && l.setAttribute(X3, "".concat(o)),
    n != null && n.nonce && (l.nonce = n == null ? void 0 : n.nonce),
    (l.innerHTML = t);
  var c = $1(e),
    u = c.firstChild;
  if (r) {
    if (s) {
      var d = CU(c).filter(function (p) {
        if (!["prepend", "prependQueue"].includes(p.getAttribute(W3)))
          return !1;
        var m = Number(p.getAttribute(X3) || 0);
        return o >= m;
      });
      if (d.length) return c.insertBefore(l, d[d.length - 1].nextSibling), l;
    }
    c.insertBefore(l, u);
  } else c.appendChild(l);
  return l;
}
function AU(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    n = $1(e);
  return CU(n).find(function (r) {
    return r.getAttribute(MU(e)) === t;
  });
}
function Yp(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    n = AU(t, e);
  if (n) {
    var r = $1(e);
    r.removeChild(n);
  }
}
function AY(t, e) {
  var n = aE.get(t);
  if (!n || !MY(document, n)) {
    var r = TU("", e),
      i = r.parentNode;
    aE.set(t, i), t.removeChild(r);
  }
}
function Wl(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    r = $1(n);
  AY(r, n);
  var i = AU(e, n);
  if (i) {
    var o, a;
    if (
      (o = n.csp) !== null &&
      o !== void 0 &&
      o.nonce &&
      i.nonce !== ((a = n.csp) === null || a === void 0 ? void 0 : a.nonce)
    ) {
      var s;
      i.nonce = (s = n.csp) === null || s === void 0 ? void 0 : s.nonce;
    }
    return i.innerHTML !== t && (i.innerHTML = t), i;
  }
  var l = TU(t, n);
  return l.setAttribute(MU(n), e), l;
}
function RY(t, e) {
  if (t == null) return {};
  var n = {};
  for (var r in t)
    if ({}.hasOwnProperty.call(t, r)) {
      if (e.indexOf(r) !== -1) continue;
      n[r] = t[r];
    }
  return n;
}
function on(t, e) {
  if (t == null) return {};
  var n,
    r,
    i = RY(t, e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    for (r = 0; r < o.length; r++)
      (n = o[r]),
        e.indexOf(n) === -1 &&
          {}.propertyIsEnumerable.call(t, n) &&
          (i[n] = t[n]);
  }
  return i;
}
function G1(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
    r = new Set();
  function i(o, a) {
    var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1,
      l = r.has(o);
    if ((Ni(!l, "Warning: There may be circular references"), l)) return !1;
    if (o === a) return !0;
    if (n && s > 1) return !1;
    r.add(o);
    var c = s + 1;
    if (Array.isArray(o)) {
      if (!Array.isArray(a) || o.length !== a.length) return !1;
      for (var u = 0; u < o.length; u++) if (!i(o[u], a[u], c)) return !1;
      return !0;
    }
    if (o && a && un(o) === "object" && un(a) === "object") {
      var d = Object.keys(o);
      return d.length !== Object.keys(a).length
        ? !1
        : d.every(function (p) {
            return i(o[p], a[p], c);
          });
    }
    return !1;
  }
  return i(t, e);
}
var PY = "%";
function sE(t) {
  return t.join(PY);
}
var IY = (function () {
    function t(e) {
      ro(this, t),
        be(this, "instanceId", void 0),
        be(this, "cache", new Map()),
        (this.instanceId = e);
    }
    return (
      io(t, [
        {
          key: "get",
          value: function (n) {
            return this.opGet(sE(n));
          },
        },
        {
          key: "opGet",
          value: function (n) {
            return this.cache.get(n) || null;
          },
        },
        {
          key: "update",
          value: function (n, r) {
            return this.opUpdate(sE(n), r);
          },
        },
        {
          key: "opUpdate",
          value: function (n, r) {
            var i = this.cache.get(n),
              o = r(i);
            o === null ? this.cache.delete(n) : this.cache.set(n, o);
          },
        },
      ]),
      t
    );
  })(),
  Sf = "data-token-hash",
  Ta = "data-css-hash",
  El = "__cssinjs_instance__";
function LY() {
  var t = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    var e = document.body.querySelectorAll("style[".concat(Ta, "]")) || [],
      n = document.head.firstChild;
    Array.from(e).forEach(function (i) {
      (i[El] = i[El] || t), i[El] === t && document.head.insertBefore(i, n);
    });
    var r = {};
    Array.from(document.querySelectorAll("style[".concat(Ta, "]"))).forEach(
      function (i) {
        var o = i.getAttribute(Ta);
        if (r[o]) {
          if (i[El] === t) {
            var a;
            (a = i.parentNode) === null || a === void 0 || a.removeChild(i);
          }
        } else r[o] = !0;
      }
    );
  }
  return new IY(t);
}
var OY = E.createContext({
  hashPriority: "low",
  cache: LY(),
  defaultCache: !0,
});
const W1 = OY;
function NY(t, e) {
  if (t.length !== e.length) return !1;
  for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;
  return !0;
}
var e2 = (function () {
  function t() {
    ro(this, t),
      be(this, "cache", void 0),
      be(this, "keys", void 0),
      be(this, "cacheCallTimes", void 0),
      (this.cache = new Map()),
      (this.keys = []),
      (this.cacheCallTimes = 0);
  }
  return (
    io(t, [
      {
        key: "size",
        value: function () {
          return this.keys.length;
        },
      },
      {
        key: "internalGet",
        value: function (n) {
          var r,
            i,
            o =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : !1,
            a = { map: this.cache };
          return (
            n.forEach(function (s) {
              if (!a) a = void 0;
              else {
                var l;
                a =
                  (l = a) === null ||
                  l === void 0 ||
                  (l = l.map) === null ||
                  l === void 0
                    ? void 0
                    : l.get(s);
              }
            }),
            (r = a) !== null &&
              r !== void 0 &&
              r.value &&
              o &&
              (a.value[1] = this.cacheCallTimes++),
            (i = a) === null || i === void 0 ? void 0 : i.value
          );
        },
      },
      {
        key: "get",
        value: function (n) {
          var r;
          return (r = this.internalGet(n, !0)) === null || r === void 0
            ? void 0
            : r[0];
        },
      },
      {
        key: "has",
        value: function (n) {
          return !!this.internalGet(n);
        },
      },
      {
        key: "set",
        value: function (n, r) {
          var i = this;
          if (!this.has(n)) {
            if (this.size() + 1 > t.MAX_CACHE_SIZE + t.MAX_CACHE_OFFSET) {
              var o = this.keys.reduce(
                  function (c, u) {
                    var d = Ve(c, 2),
                      p = d[1];
                    return i.internalGet(u)[1] < p
                      ? [u, i.internalGet(u)[1]]
                      : c;
                  },
                  [this.keys[0], this.cacheCallTimes]
                ),
                a = Ve(o, 1),
                s = a[0];
              this.delete(s);
            }
            this.keys.push(n);
          }
          var l = this.cache;
          n.forEach(function (c, u) {
            if (u === n.length - 1)
              l.set(c, { value: [r, i.cacheCallTimes++] });
            else {
              var d = l.get(c);
              d ? d.map || (d.map = new Map()) : l.set(c, { map: new Map() }),
                (l = l.get(c).map);
            }
          });
        },
      },
      {
        key: "deleteByPath",
        value: function (n, r) {
          var i = n.get(r[0]);
          if (r.length === 1) {
            var o;
            return (
              i.map ? n.set(r[0], { map: i.map }) : n.delete(r[0]),
              (o = i.value) === null || o === void 0 ? void 0 : o[0]
            );
          }
          var a = this.deleteByPath(i.map, r.slice(1));
          return (!i.map || i.map.size === 0) && !i.value && n.delete(r[0]), a;
        },
      },
      {
        key: "delete",
        value: function (n) {
          if (this.has(n))
            return (
              (this.keys = this.keys.filter(function (r) {
                return !NY(r, n);
              })),
              this.deleteByPath(this.cache, n)
            );
        },
      },
    ]),
    t
  );
})();
be(e2, "MAX_CACHE_SIZE", 20);
be(e2, "MAX_CACHE_OFFSET", 5);
var q3 = 0,
  RU = (function () {
    function t(e) {
      ro(this, t),
        be(this, "derivatives", void 0),
        be(this, "id", void 0),
        (this.derivatives = Array.isArray(e) ? e : [e]),
        (this.id = q3),
        e.length === 0 && (e.length > 0, void 0),
        (q3 += 1);
    }
    return (
      io(t, [
        {
          key: "getDerivativeToken",
          value: function (n) {
            return this.derivatives.reduce(function (r, i) {
              return i(n, r);
            }, void 0);
          },
        },
      ]),
      t
    );
  })(),
  A_ = new e2();
function lE(t) {
  var e = Array.isArray(t) ? t : [t];
  return A_.has(e) || A_.set(e, new RU(e)), A_.get(e);
}
var FY = new WeakMap(),
  R_ = {};
function DY(t, e) {
  for (var n = FY, r = 0; r < e.length; r += 1) {
    var i = e[r];
    n.has(i) || n.set(i, new WeakMap()), (n = n.get(i));
  }
  return n.has(R_) || n.set(R_, t()), n.get(R_);
}
var K3 = new WeakMap();
function rp(t) {
  var e = K3.get(t) || "";
  return (
    e ||
      (Object.keys(t).forEach(function (n) {
        var r = t[n];
        (e += n),
          r instanceof RU
            ? (e += r.id)
            : r && un(r) === "object"
            ? (e += rp(r))
            : (e += r);
      }),
      K3.set(t, e)),
    e
  );
}
function Y3(t, e) {
  return by("".concat(e, "_").concat(rp(t)));
}
var ip = "random-"
    .concat(Date.now(), "-")
    .concat(Math.random())
    .replace(/\./g, ""),
  PU = "_bAmBoO_";
function zY(t, e, n) {
  if (to()) {
    var r, i;
    Wl(t, ip);
    var o = document.createElement("div");
    (o.style.position = "fixed"),
      (o.style.left = "0"),
      (o.style.top = "0"),
      e == null || e(o),
      document.body.appendChild(o);
    var a = n
      ? n(o)
      : (r = getComputedStyle(o).content) === null || r === void 0
      ? void 0
      : r.includes(PU);
    return (
      (i = o.parentNode) === null || i === void 0 || i.removeChild(o), Yp(ip), a
    );
  }
  return !1;
}
var P_ = void 0;
function UY() {
  return (
    P_ === void 0 &&
      (P_ = zY(
        "@layer "
          .concat(ip, " { .")
          .concat(ip, ' { content: "')
          .concat(PU, '"!important; } }'),
        function (t) {
          t.className = ip;
        }
      )),
    P_
  );
}
var cE = to();
function Ze(t) {
  return typeof t == "number" ? "".concat(t, "px") : t;
}
function wy(t, e, n) {
  var r,
    i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
    o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
  if (o) return t;
  var a = De(De({}, i), {}, ((r = {}), be(r, Sf, e), be(r, Ta, n), r)),
    s = Object.keys(a)
      .map(function (l) {
        var c = a[l];
        return c ? "".concat(l, '="').concat(c, '"') : null;
      })
      .filter(function (l) {
        return l;
      })
      .join(" ");
  return "<style ".concat(s, ">").concat(t, "</style>");
}
var IU = function (e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return "--"
      .concat(n ? "".concat(n, "-") : "")
      .concat(e)
      .replace(/([a-z0-9])([A-Z])/g, "$1-$2")
      .replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2")
      .replace(/([a-z])([A-Z0-9])/g, "$1-$2")
      .toLowerCase();
  },
  kY = function (e, n, r) {
    return Object.keys(e).length
      ? "."
          .concat(n)
          .concat(r != null && r.scope ? ".".concat(r.scope) : "", "{")
          .concat(
            Object.entries(e)
              .map(function (i) {
                var o = Ve(i, 2),
                  a = o[0],
                  s = o[1];
                return "".concat(a, ":").concat(s, ";");
              })
              .join(""),
            "}"
          )
      : "";
  },
  LU = function (e, n, r) {
    var i = {},
      o = {};
    return (
      Object.entries(e).forEach(function (a) {
        var s,
          l,
          c = Ve(a, 2),
          u = c[0],
          d = c[1];
        if (r != null && (s = r.preserve) !== null && s !== void 0 && s[u])
          o[u] = d;
        else if (
          (typeof d == "string" || typeof d == "number") &&
          !(r != null && (l = r.ignore) !== null && l !== void 0 && l[u])
        ) {
          var p,
            m = IU(u, r == null ? void 0 : r.prefix);
          (i[m] =
            typeof d == "number" &&
            !(r != null && (p = r.unitless) !== null && p !== void 0 && p[u])
              ? "".concat(d, "px")
              : String(d)),
            (o[u] = "var(".concat(m, ")"));
        }
      }),
      [o, kY(i, n, { scope: r == null ? void 0 : r.scope })]
    );
  },
  Z3 = to() ? E.useLayoutEffect : E.useEffect,
  Hr = function (e, n) {
    var r = E.useRef(!0);
    Z3(function () {
      return e(r.current);
    }, n),
      Z3(function () {
        return (
          (r.current = !1),
          function () {
            r.current = !0;
          }
        );
      }, []);
  },
  uE = function (e, n) {
    Hr(function (r) {
      if (!r) return e();
    }, n);
  },
  BY = De({}, ru),
  Q3 = BY.useInsertionEffect,
  HY = function (e, n, r) {
    E.useMemo(e, r),
      Hr(function () {
        return n(!0);
      }, r);
  },
  jY = Q3
    ? function (t, e, n) {
        return Q3(function () {
          return t(), e();
        }, n);
      }
    : HY;
const VY = jY;
var $Y = De({}, ru),
  GY = $Y.useInsertionEffect,
  WY = function (e) {
    var n = [],
      r = !1;
    function i(o) {
      r || n.push(o);
    }
    return (
      E.useEffect(function () {
        return (
          (r = !1),
          function () {
            (r = !0),
              n.length &&
                n.forEach(function (o) {
                  return o();
                });
          }
        );
      }, e),
      i
    );
  },
  XY = function () {
    return function (e) {
      e();
    };
  },
  qY = typeof GY < "u" ? WY : XY;
const KY = qY;
function t2(t, e, n, r, i) {
  var o = E.useContext(W1),
    a = o.cache,
    s = [t].concat(It(e)),
    l = sE(s),
    c = KY([l]),
    u = function (v) {
      a.opUpdate(l, function (S) {
        var x = S || [void 0, void 0],
          g = Ve(x, 2),
          _ = g[0],
          y = _ === void 0 ? 0 : _,
          w = g[1],
          A = w,
          M = A || n(),
          T = [y, M];
        return v ? v(T) : T;
      });
    };
  E.useMemo(
    function () {
      u();
    },
    [l]
  );
  var d = a.opGet(l),
    p = d[1];
  return (
    VY(
      function () {
        i == null || i(p);
      },
      function (m) {
        return (
          u(function (v) {
            var S = Ve(v, 2),
              x = S[0],
              g = S[1];
            return m && x === 0 && (i == null || i(p)), [x + 1, g];
          }),
          function () {
            a.opUpdate(l, function (v) {
              var S = v || [],
                x = Ve(S, 2),
                g = x[0],
                _ = g === void 0 ? 0 : g,
                y = x[1],
                w = _ - 1;
              return w === 0
                ? (c(function () {
                    (m || !a.opGet(l)) && (r == null || r(y, !1));
                  }),
                  null)
                : [_ - 1, y];
            });
          }
        );
      },
      [l]
    ),
    p
  );
}
var YY = {},
  ZY = "css",
  Fc = new Map();
function QY(t) {
  Fc.set(t, (Fc.get(t) || 0) + 1);
}
function JY(t, e) {
  if (typeof document < "u") {
    var n = document.querySelectorAll(
      "style[".concat(Sf, '="').concat(t, '"]')
    );
    n.forEach(function (r) {
      if (r[El] === e) {
        var i;
        (i = r.parentNode) === null || i === void 0 || i.removeChild(r);
      }
    });
  }
}
var eZ = 0;
function tZ(t, e) {
  Fc.set(t, (Fc.get(t) || 0) - 1);
  var n = Array.from(Fc.keys()),
    r = n.filter(function (i) {
      var o = Fc.get(i) || 0;
      return o <= 0;
    });
  n.length - r.length > eZ &&
    r.forEach(function (i) {
      JY(i, e), Fc.delete(i);
    });
}
var nZ = function (e, n, r, i) {
    var o = r.getDerivativeToken(e),
      a = De(De({}, o), n);
    return i && (a = i(a)), a;
  },
  OU = "token";
function rZ(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    r = E.useContext(W1),
    i = r.cache.instanceId,
    o = r.container,
    a = n.salt,
    s = a === void 0 ? "" : a,
    l = n.override,
    c = l === void 0 ? YY : l,
    u = n.formatToken,
    d = n.getComputedToken,
    p = n.cssVar,
    m = DY(function () {
      return Object.assign.apply(Object, [{}].concat(It(e)));
    }, e),
    v = rp(m),
    S = rp(c),
    x = p ? rp(p) : "",
    g = t2(
      OU,
      [s, t.id, v, S, x],
      function () {
        var _,
          y = d ? d(m, c, t) : nZ(m, c, t, u),
          w = De({}, y),
          A = "";
        if (p) {
          var M = LU(y, p.key, {
              prefix: p.prefix,
              ignore: p.ignore,
              unitless: p.unitless,
              preserve: p.preserve,
            }),
            T = Ve(M, 2);
          (y = T[0]), (A = T[1]);
        }
        var I = Y3(y, s);
        (y._tokenKey = I), (w._tokenKey = Y3(w, s));
        var R =
          (_ = p == null ? void 0 : p.key) !== null && _ !== void 0 ? _ : I;
        (y._themeKey = R), QY(R);
        var P = "".concat(ZY, "-").concat(by(I));
        return (
          (y._hashId = P), [y, P, w, A, (p == null ? void 0 : p.key) || ""]
        );
      },
      function (_) {
        tZ(_[0]._themeKey, i);
      },
      function (_) {
        var y = Ve(_, 4),
          w = y[0],
          A = y[3];
        if (p && A) {
          var M = Wl(A, by("css-variables-".concat(w._themeKey)), {
            mark: Ta,
            prepend: "queue",
            attachTo: o,
            priority: -999,
          });
          (M[El] = i), M.setAttribute(Sf, w._themeKey);
        }
      }
    );
  return g;
}
var iZ = function (e, n, r) {
    var i = Ve(e, 5),
      o = i[2],
      a = i[3],
      s = i[4],
      l = r || {},
      c = l.plain;
    if (!a) return null;
    var u = o._tokenKey,
      d = -999,
      p = { "data-rc-order": "prependQueue", "data-rc-priority": "".concat(d) },
      m = wy(a, s, u, p, c);
    return [d, u, m];
  },
  oZ = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  NU = "comm",
  FU = "rule",
  DU = "decl",
  aZ = "@import",
  sZ = "@keyframes",
  lZ = "@layer",
  zU = Math.abs,
  n2 = String.fromCharCode;
function UU(t) {
  return t.trim();
}
function T0(t, e, n) {
  return t.replace(e, n);
}
function cZ(t, e, n) {
  return t.indexOf(e, n);
}
function Zp(t, e) {
  return t.charCodeAt(e) | 0;
}
function Qp(t, e, n) {
  return t.slice(e, n);
}
function As(t) {
  return t.length;
}
function uZ(t) {
  return t.length;
}
function $v(t, e) {
  return e.push(t), t;
}
var X1 = 1,
  _f = 1,
  kU = 0,
  ia = 0,
  _r = 0,
  Lf = "";
function r2(t, e, n, r, i, o, a, s) {
  return {
    value: t,
    root: e,
    parent: n,
    type: r,
    props: i,
    children: o,
    line: X1,
    column: _f,
    length: a,
    return: "",
    siblings: s,
  };
}
function dZ() {
  return _r;
}
function fZ() {
  return (
    (_r = ia > 0 ? Zp(Lf, --ia) : 0), _f--, _r === 10 && ((_f = 1), X1--), _r
  );
}
function Aa() {
  return (
    (_r = ia < kU ? Zp(Lf, ia++) : 0), _f++, _r === 10 && ((_f = 1), X1++), _r
  );
}
function tu() {
  return Zp(Lf, ia);
}
function A0() {
  return ia;
}
function q1(t, e) {
  return Qp(Lf, t, e);
}
function dE(t) {
  switch (t) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function hZ(t) {
  return (X1 = _f = 1), (kU = As((Lf = t))), (ia = 0), [];
}
function pZ(t) {
  return (Lf = ""), t;
}
function I_(t) {
  return UU(q1(ia - 1, fE(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
}
function mZ(t) {
  for (; (_r = tu()) && _r < 33; ) Aa();
  return dE(t) > 2 || dE(_r) > 3 ? "" : " ";
}
function gZ(t, e) {
  for (
    ;
    --e &&
    Aa() &&
    !(_r < 48 || _r > 102 || (_r > 57 && _r < 65) || (_r > 70 && _r < 97));

  );
  return q1(t, A0() + (e < 6 && tu() == 32 && Aa() == 32));
}
function fE(t) {
  for (; Aa(); )
    switch (_r) {
      case t:
        return ia;
      case 34:
      case 39:
        t !== 34 && t !== 39 && fE(_r);
        break;
      case 40:
        t === 41 && fE(t);
        break;
      case 92:
        Aa();
        break;
    }
  return ia;
}
function vZ(t, e) {
  for (; Aa() && t + _r !== 57; ) if (t + _r === 84 && tu() === 47) break;
  return "/*" + q1(e, ia - 1) + "*" + n2(t === 47 ? t : Aa());
}
function yZ(t) {
  for (; !dE(tu()); ) Aa();
  return q1(t, ia);
}
function xZ(t) {
  return pZ(R0("", null, null, null, [""], (t = hZ(t)), 0, [0], t));
}
function R0(t, e, n, r, i, o, a, s, l) {
  for (
    var c = 0,
      u = 0,
      d = a,
      p = 0,
      m = 0,
      v = 0,
      S = 1,
      x = 1,
      g = 1,
      _ = 0,
      y = "",
      w = i,
      A = o,
      M = r,
      T = y;
    x;

  )
    switch (((v = _), (_ = Aa()))) {
      case 40:
        if (v != 108 && Zp(T, d - 1) == 58) {
          cZ((T += T0(I_(_), "&", "&\f")), "&\f", zU(c ? s[c - 1] : 0)) != -1 &&
            (g = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        T += I_(_);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        T += mZ(v);
        break;
      case 92:
        T += gZ(A0() - 1, 7);
        continue;
      case 47:
        switch (tu()) {
          case 42:
          case 47:
            $v(SZ(vZ(Aa(), A0()), e, n, l), l);
            break;
          default:
            T += "/";
        }
        break;
      case 123 * S:
        s[c++] = As(T) * g;
      case 125 * S:
      case 59:
      case 0:
        switch (_) {
          case 0:
          case 125:
            x = 0;
          case 59 + u:
            g == -1 && (T = T0(T, /\f/g, "")),
              m > 0 &&
                As(T) - d &&
                $v(
                  m > 32
                    ? eI(T + ";", r, n, d - 1, l)
                    : eI(T0(T, " ", "") + ";", r, n, d - 2, l),
                  l
                );
            break;
          case 59:
            T += ";";
          default:
            if (
              ($v(
                (M = J3(T, e, n, c, u, i, s, y, (w = []), (A = []), d, o)),
                o
              ),
              _ === 123)
            )
              if (u === 0) R0(T, e, M, M, w, o, d, s, A);
              else
                switch (p === 99 && Zp(T, 3) === 110 ? 100 : p) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    R0(
                      t,
                      M,
                      M,
                      r && $v(J3(t, M, M, 0, 0, i, s, y, i, (w = []), d, A), A),
                      i,
                      A,
                      d,
                      s,
                      r ? w : A
                    );
                    break;
                  default:
                    R0(T, M, M, M, [""], A, 0, s, A);
                }
        }
        (c = u = m = 0), (S = g = 1), (y = T = ""), (d = a);
        break;
      case 58:
        (d = 1 + As(T)), (m = v);
      default:
        if (S < 1) {
          if (_ == 123) --S;
          else if (_ == 125 && S++ == 0 && fZ() == 125) continue;
        }
        switch (((T += n2(_)), _ * S)) {
          case 38:
            g = u > 0 ? 1 : ((T += "\f"), -1);
            break;
          case 44:
            (s[c++] = (As(T) - 1) * g), (g = 1);
            break;
          case 64:
            tu() === 45 && (T += I_(Aa())),
              (p = tu()),
              (u = d = As((y = T += yZ(A0())))),
              _++;
            break;
          case 45:
            v === 45 && As(T) == 2 && (S = 0);
        }
    }
  return o;
}
function J3(t, e, n, r, i, o, a, s, l, c, u, d) {
  for (
    var p = i - 1, m = i === 0 ? o : [""], v = uZ(m), S = 0, x = 0, g = 0;
    S < r;
    ++S
  )
    for (var _ = 0, y = Qp(t, p + 1, (p = zU((x = a[S])))), w = t; _ < v; ++_)
      (w = UU(x > 0 ? m[_] + " " + y : T0(y, /&\f/g, m[_]))) && (l[g++] = w);
  return r2(t, e, n, i === 0 ? FU : s, l, c, u, d);
}
function SZ(t, e, n, r) {
  return r2(t, e, n, NU, n2(dZ()), Qp(t, 2, -2), 0, r);
}
function eI(t, e, n, r, i) {
  return r2(t, e, n, DU, Qp(t, 0, r), Qp(t, r + 1, -1), r, i);
}
function hE(t, e) {
  for (var n = "", r = 0; r < t.length; r++) n += e(t[r], r, t, e) || "";
  return n;
}
function _Z(t, e, n, r) {
  switch (t.type) {
    case lZ:
      if (t.children.length) break;
    case aZ:
    case DU:
      return (t.return = t.return || t.value);
    case NU:
      return "";
    case sZ:
      return (t.return = t.value + "{" + hE(t.children, r) + "}");
    case FU:
      if (!As((t.value = t.props.join(",")))) return "";
  }
  return As((n = hE(t.children, r)))
    ? (t.return = t.value + "{" + n + "}")
    : "";
}
var tI = "data-ant-cssinjs-cache-path",
  BU = "_FILE_STYLE__",
  nu,
  HU = !0;
function bZ() {
  if (!nu && ((nu = {}), to())) {
    var t = document.createElement("div");
    (t.className = tI),
      (t.style.position = "fixed"),
      (t.style.visibility = "hidden"),
      (t.style.top = "-9999px"),
      document.body.appendChild(t);
    var e = getComputedStyle(t).content || "";
    (e = e.replace(/^"/, "").replace(/"$/, "")),
      e.split(";").forEach(function (i) {
        var o = i.split(":"),
          a = Ve(o, 2),
          s = a[0],
          l = a[1];
        nu[s] = l;
      });
    var n = document.querySelector("style[".concat(tI, "]"));
    if (n) {
      var r;
      (HU = !1),
        (r = n.parentNode) === null || r === void 0 || r.removeChild(n);
    }
    document.body.removeChild(t);
  }
}
function wZ(t) {
  return bZ(), !!nu[t];
}
function EZ(t) {
  var e = nu[t],
    n = null;
  if (e && to())
    if (HU) n = BU;
    else {
      var r = document.querySelector(
        "style[".concat(Ta, '="').concat(nu[t], '"]')
      );
      r ? (n = r.innerHTML) : delete nu[t];
    }
  return [n, e];
}
var MZ = "_skip_check_",
  jU = "_multi_value_";
function pE(t) {
  var e = hE(xZ(t), _Z);
  return e.replace(/\{%%%\:[^;];}/g, ";");
}
function CZ(t) {
  return un(t) === "object" && t && (MZ in t || jU in t);
}
function TZ(t, e, n) {
  if (!e) return t;
  var r = ".".concat(e),
    i = n === "low" ? ":where(".concat(r, ")") : r,
    o = t.split(",").map(function (a) {
      var s,
        l = a.trim().split(/\s+/),
        c = l[0] || "",
        u =
          ((s = c.match(/^\w+/)) === null || s === void 0 ? void 0 : s[0]) ||
          "";
      return (
        (c = "".concat(u).concat(i).concat(c.slice(u.length))),
        [c].concat(It(l.slice(1))).join(" ")
      );
    });
  return o.join(",");
}
var AZ = function t(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r =
      arguments.length > 2 && arguments[2] !== void 0
        ? arguments[2]
        : { root: !0, parentSelectors: [] },
    i = r.root,
    o = r.injectHash,
    a = r.parentSelectors,
    s = n.hashId,
    l = n.layer;
  n.path;
  var c = n.hashPriority,
    u = n.transformers,
    d = u === void 0 ? [] : u;
  n.linters;
  var p = "",
    m = {};
  function v(y) {
    var w = y.getName(s);
    if (!m[w]) {
      var A = t(y.style, n, { root: !1, parentSelectors: a }),
        M = Ve(A, 1),
        T = M[0];
      m[w] = "@keyframes ".concat(y.getName(s)).concat(T);
    }
  }
  function S(y) {
    var w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return (
      y.forEach(function (A) {
        Array.isArray(A) ? S(A, w) : A && w.push(A);
      }),
      w
    );
  }
  var x = S(Array.isArray(e) ? e : [e]);
  if (
    (x.forEach(function (y) {
      var w = typeof y == "string" && !i ? {} : y;
      if (typeof w == "string")
        p += "".concat(
          w,
          `
`
        );
      else if (w._keyframe) v(w);
      else {
        var A = d.reduce(function (M, T) {
          var I;
          return (
            (T == null || (I = T.visit) === null || I === void 0
              ? void 0
              : I.call(T, M)) || M
          );
        }, w);
        Object.keys(A).forEach(function (M) {
          var T = A[M];
          if (
            un(T) === "object" &&
            T &&
            (M !== "animationName" || !T._keyframe) &&
            !CZ(T)
          ) {
            var I = !1,
              R = M.trim(),
              P = !1;
            (i || o) && s
              ? R.startsWith("@")
                ? (I = !0)
                : (R = TZ(M, s, c))
              : i && !s && (R === "&" || R === "") && ((R = ""), (P = !0));
            var F = t(T, n, {
                root: P,
                injectHash: I,
                parentSelectors: [].concat(It(a), [R]),
              }),
              D = Ve(F, 2),
              j = D[0],
              N = D[1];
            (m = De(De({}, m), N)), (p += "".concat(R).concat(j));
          } else {
            let Q = function (B, $) {
              var G = B.replace(/[A-Z]/g, function (q) {
                  return "-".concat(q.toLowerCase());
                }),
                k = $;
              !oZ[B] &&
                typeof k == "number" &&
                k !== 0 &&
                (k = "".concat(k, "px")),
                B === "animationName" &&
                  $ !== null &&
                  $ !== void 0 &&
                  $._keyframe &&
                  (v($), (k = $.getName(s))),
                (p += "".concat(G, ":").concat(k, ";"));
            };
            var V,
              W =
                (V = T == null ? void 0 : T.value) !== null && V !== void 0
                  ? V
                  : T;
            un(T) === "object" &&
            T !== null &&
            T !== void 0 &&
            T[jU] &&
            Array.isArray(W)
              ? W.forEach(function (B) {
                  Q(M, B);
                })
              : Q(M, W);
          }
        });
      }
    }),
    !i)
  )
    p = "{".concat(p, "}");
  else if (l && UY()) {
    var g = l.split(","),
      _ = g[g.length - 1].trim();
    (p = "@layer ".concat(_, " {").concat(p, "}")),
      g.length > 1 && (p = "@layer ".concat(l, "{%%%:%}").concat(p));
  }
  return [p, m];
};
function VU(t, e) {
  return by("".concat(t.join("%")).concat(e));
}
function RZ() {
  return null;
}
var $U = "style";
function mE(t, e) {
  var n = t.token,
    r = t.path,
    i = t.hashId,
    o = t.layer,
    a = t.nonce,
    s = t.clientOnly,
    l = t.order,
    c = l === void 0 ? 0 : l,
    u = E.useContext(W1),
    d = u.autoClear;
  u.mock;
  var p = u.defaultCache,
    m = u.hashPriority,
    v = u.container,
    S = u.ssrInline,
    x = u.transformers,
    g = u.linters,
    _ = u.cache,
    y = n._tokenKey,
    w = [y].concat(It(r)),
    A = cE,
    M = t2(
      $U,
      w,
      function () {
        var F = w.join("|");
        if (wZ(F)) {
          var D = EZ(F),
            j = Ve(D, 2),
            N = j[0],
            V = j[1];
          if (N) return [N, y, V, {}, s, c];
        }
        var W = e(),
          Q = AZ(W, {
            hashId: i,
            hashPriority: m,
            layer: o,
            path: r.join("-"),
            transformers: x,
            linters: g,
          }),
          B = Ve(Q, 2),
          $ = B[0],
          G = B[1],
          k = pE($),
          q = VU(w, k);
        return [k, y, q, G, s, c];
      },
      function (F, D) {
        var j = Ve(F, 3),
          N = j[2];
        (D || d) && cE && Yp(N, { mark: Ta });
      },
      function (F) {
        var D = Ve(F, 4),
          j = D[0];
        D[1];
        var N = D[2],
          V = D[3];
        if (A && j !== BU) {
          var W = { mark: Ta, prepend: "queue", attachTo: v, priority: c },
            Q = typeof a == "function" ? a() : a;
          Q && (W.csp = { nonce: Q });
          var B = Wl(j, N, W);
          (B[El] = _.instanceId),
            B.setAttribute(Sf, y),
            Object.keys(V).forEach(function ($) {
              Wl(pE(V[$]), "_effect-".concat($), W);
            });
        }
      }
    ),
    T = Ve(M, 3),
    I = T[0],
    R = T[1],
    P = T[2];
  return function (F) {
    var D;
    if (!S || A || !p) D = E.createElement(RZ, null);
    else {
      var j;
      D = E.createElement(
        "style",
        Et({}, ((j = {}), be(j, Sf, R), be(j, Ta, P), j), {
          dangerouslySetInnerHTML: { __html: I },
        })
      );
    }
    return E.createElement(E.Fragment, null, D, F);
  };
}
var PZ = function (e, n, r) {
    var i = Ve(e, 6),
      o = i[0],
      a = i[1],
      s = i[2],
      l = i[3],
      c = i[4],
      u = i[5],
      d = r || {},
      p = d.plain;
    if (c) return null;
    var m = o,
      v = { "data-rc-order": "prependQueue", "data-rc-priority": "".concat(u) };
    return (
      (m = wy(o, a, s, v, p)),
      l &&
        Object.keys(l).forEach(function (S) {
          if (!n[S]) {
            n[S] = !0;
            var x = pE(l[S]);
            m += wy(x, a, "_effect-".concat(S), v, p);
          }
        }),
      [u, s, m]
    );
  },
  GU = "cssVar",
  IZ = function (e, n) {
    var r = e.key,
      i = e.prefix,
      o = e.unitless,
      a = e.ignore,
      s = e.token,
      l = e.scope,
      c = l === void 0 ? "" : l,
      u = E.useContext(W1),
      d = u.cache.instanceId,
      p = u.container,
      m = s._tokenKey,
      v = [].concat(It(e.path), [r, c, m]),
      S = t2(
        GU,
        v,
        function () {
          var x = n(),
            g = LU(x, r, { prefix: i, unitless: o, ignore: a, scope: c }),
            _ = Ve(g, 2),
            y = _[0],
            w = _[1],
            A = VU(v, w);
          return [y, w, A, r];
        },
        function (x) {
          var g = Ve(x, 3),
            _ = g[2];
          cE && Yp(_, { mark: Ta });
        },
        function (x) {
          var g = Ve(x, 3),
            _ = g[1],
            y = g[2];
          if (_) {
            var w = Wl(_, y, {
              mark: Ta,
              prepend: "queue",
              attachTo: p,
              priority: -999,
            });
            (w[El] = d), w.setAttribute(Sf, r);
          }
        }
      );
    return S;
  },
  LZ = function (e, n, r) {
    var i = Ve(e, 4),
      o = i[1],
      a = i[2],
      s = i[3],
      l = r || {},
      c = l.plain;
    if (!o) return null;
    var u = -999,
      d = { "data-rc-order": "prependQueue", "data-rc-priority": "".concat(u) },
      p = wy(o, s, a, d, c);
    return [u, a, p];
  },
  Mh;
(Mh = {}), be(Mh, $U, PZ), be(Mh, OU, iZ), be(Mh, GU, LZ);
var gr = (function () {
  function t(e, n) {
    ro(this, t),
      be(this, "name", void 0),
      be(this, "style", void 0),
      be(this, "_keyframe", !0),
      (this.name = e),
      (this.style = n);
  }
  return (
    io(t, [
      {
        key: "getName",
        value: function () {
          var n =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return n ? "".concat(n, "-").concat(this.name) : this.name;
        },
      },
    ]),
    t
  );
})();
function dd(t) {
  return (t.notSplit = !0), t;
}
dd(["borderTop", "borderBottom"]),
  dd(["borderTop"]),
  dd(["borderBottom"]),
  dd(["borderLeft", "borderRight"]),
  dd(["borderLeft"]),
  dd(["borderRight"]);
var OZ = E.createContext({});
const i2 = OZ;
function NZ(t) {
  return wU(t) || xU(t) || QC(t) || EU();
}
function Ya(t, e) {
  for (var n = t, r = 0; r < e.length; r += 1) {
    if (n == null) return;
    n = n[e[r]];
  }
  return n;
}
function WU(t, e, n, r) {
  if (!e.length) return n;
  var i = NZ(e),
    o = i[0],
    a = i.slice(1),
    s;
  return (
    !t && typeof o == "number"
      ? (s = [])
      : Array.isArray(t)
      ? (s = It(t))
      : (s = De({}, t)),
    r && n === void 0 && a.length === 1
      ? delete s[o][a[0]]
      : (s[o] = WU(s[o], a, n, r)),
    s
  );
}
function ya(t, e, n) {
  var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return e.length && r && n === void 0 && !Ya(t, e.slice(0, -1))
    ? t
    : WU(t, e, n, r);
}
function FZ(t) {
  return (
    un(t) === "object" &&
    t !== null &&
    Object.getPrototypeOf(t) === Object.prototype
  );
}
function nI(t) {
  return Array.isArray(t) ? [] : {};
}
var DZ = typeof Reflect > "u" ? Object.keys : Reflect.ownKeys;
function $d() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  var r = nI(e[0]);
  return (
    e.forEach(function (i) {
      function o(a, s) {
        var l = new Set(s),
          c = Ya(i, a),
          u = Array.isArray(c);
        if (u || FZ(c)) {
          if (!l.has(c)) {
            l.add(c);
            var d = Ya(r, a);
            u
              ? (r = ya(r, a, []))
              : (!d || un(d) !== "object") && (r = ya(r, a, nI(c))),
              DZ(c).forEach(function (p) {
                o([].concat(It(a), [p]), l);
              });
          }
        } else r = ya(r, a, c);
      }
      o([]);
    }),
    r
  );
}
function zZ() {}
const UZ = E.createContext({}),
  XU = () => {
    const t = () => {};
    return (t.deprecated = zZ), t;
  },
  kZ = E.createContext(void 0);
var BZ = {
    items_per_page: "/ page",
    jump_to: "Go to",
    jump_to_confirm: "confirm",
    page: "Page",
    prev_page: "Previous Page",
    next_page: "Next Page",
    prev_5: "Previous 5 Pages",
    next_5: "Next 5 Pages",
    prev_3: "Previous 3 Pages",
    next_3: "Next 3 Pages",
    page_size: "Page Size",
  },
  HZ = {
    locale: "en_US",
    today: "Today",
    now: "Now",
    backToToday: "Back to today",
    ok: "OK",
    clear: "Clear",
    month: "Month",
    year: "Year",
    timeSelect: "select time",
    dateSelect: "select date",
    weekSelect: "Choose a week",
    monthSelect: "Choose a month",
    yearSelect: "Choose a year",
    decadeSelect: "Choose a decade",
    yearFormat: "YYYY",
    dateFormat: "M/D/YYYY",
    dayFormat: "D",
    dateTimeFormat: "M/D/YYYY HH:mm:ss",
    monthBeforeYear: !0,
    previousMonth: "Previous month (PageUp)",
    nextMonth: "Next month (PageDown)",
    previousYear: "Last year (Control + left)",
    nextYear: "Next year (Control + right)",
    previousDecade: "Last decade",
    nextDecade: "Next decade",
    previousCentury: "Last century",
    nextCentury: "Next century",
  };
const jZ = {
    placeholder: "Select time",
    rangePlaceholder: ["Start time", "End time"],
  },
  qU = jZ,
  VZ = {
    lang: Object.assign(
      {
        placeholder: "Select date",
        yearPlaceholder: "Select year",
        quarterPlaceholder: "Select quarter",
        monthPlaceholder: "Select month",
        weekPlaceholder: "Select week",
        rangePlaceholder: ["Start date", "End date"],
        rangeYearPlaceholder: ["Start year", "End year"],
        rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
        rangeMonthPlaceholder: ["Start month", "End month"],
        rangeWeekPlaceholder: ["Start week", "End week"],
      },
      HZ
    ),
    timePickerLocale: Object.assign({}, qU),
  },
  rI = VZ,
  vo = "${label} is not a valid ${type}",
  K1 = {
    locale: "en",
    Pagination: BZ,
    DatePicker: rI,
    TimePicker: qU,
    Calendar: rI,
    global: { placeholder: "Please select" },
    Table: {
      filterTitle: "Filter menu",
      filterConfirm: "OK",
      filterReset: "Reset",
      filterEmptyText: "No filters",
      filterCheckall: "Select all items",
      filterSearchPlaceholder: "Search in filters",
      emptyText: "No data",
      selectAll: "Select current page",
      selectInvert: "Invert current page",
      selectNone: "Clear all data",
      selectionAll: "Select all data",
      sortTitle: "Sort",
      expand: "Expand row",
      collapse: "Collapse row",
      triggerDesc: "Click to sort descending",
      triggerAsc: "Click to sort ascending",
      cancelSort: "Click to cancel sorting",
    },
    Tour: { Next: "Next", Previous: "Previous", Finish: "Finish" },
    Modal: { okText: "OK", cancelText: "Cancel", justOkText: "OK" },
    Popconfirm: { okText: "OK", cancelText: "Cancel" },
    Transfer: {
      titles: ["", ""],
      searchPlaceholder: "Search here",
      itemUnit: "item",
      itemsUnit: "items",
      remove: "Remove",
      selectCurrent: "Select current page",
      removeCurrent: "Remove current page",
      selectAll: "Select all data",
      removeAll: "Remove all data",
      selectInvert: "Invert current page",
    },
    Upload: {
      uploading: "Uploading...",
      removeFile: "Remove file",
      uploadError: "Upload error",
      previewFile: "Preview file",
      downloadFile: "Download file",
    },
    Empty: { description: "No data" },
    Icon: { icon: "icon" },
    Text: { edit: "Edit", copy: "Copy", copied: "Copied", expand: "Expand" },
    Form: {
      optional: "(optional)",
      defaultValidateMessages: {
        default: "Field validation error for ${label}",
        required: "Please enter ${label}",
        enum: "${label} must be one of [${enum}]",
        whitespace: "${label} cannot be a blank character",
        date: {
          format: "${label} date format is invalid",
          parse: "${label} cannot be converted to a date",
          invalid: "${label} is an invalid date",
        },
        types: {
          string: vo,
          method: vo,
          array: vo,
          object: vo,
          number: vo,
          date: vo,
          boolean: vo,
          integer: vo,
          float: vo,
          regexp: vo,
          email: vo,
          url: vo,
          hex: vo,
        },
        string: {
          len: "${label} must be ${len} characters",
          min: "${label} must be at least ${min} characters",
          max: "${label} must be up to ${max} characters",
          range: "${label} must be between ${min}-${max} characters",
        },
        number: {
          len: "${label} must be equal to ${len}",
          min: "${label} must be minimum ${min}",
          max: "${label} must be maximum ${max}",
          range: "${label} must be between ${min}-${max}",
        },
        array: {
          len: "Must be ${len} ${label}",
          min: "At least ${min} ${label}",
          max: "At most ${max} ${label}",
          range: "The amount of ${label} must be between ${min}-${max}",
        },
        pattern: { mismatch: "${label} does not match the pattern ${pattern}" },
      },
    },
    Image: { preview: "Preview" },
    QRCode: {
      expired: "QR code expired",
      refresh: "Refresh",
      scanned: "Scanned",
    },
    ColorPicker: { presetEmpty: "Empty" },
  };
Object.assign({}, K1.Modal);
let P0 = [];
const iI = () =>
  P0.reduce((t, e) => Object.assign(Object.assign({}, t), e), K1.Modal);
function $Z(t) {
  if (t) {
    const e = Object.assign({}, t);
    return (
      P0.push(e),
      iI(),
      () => {
        (P0 = P0.filter((n) => n !== e)), iI();
      }
    );
  }
  Object.assign({}, K1.Modal);
}
const GZ = E.createContext(void 0),
  KU = GZ,
  WZ = "internalMark",
  XZ = (t) => {
    const { locale: e = {}, children: n, _ANT_MARK__: r } = t;
    E.useEffect(() => $Z(e && e.Modal), [e]);
    const i = E.useMemo(
      () => Object.assign(Object.assign({}, e), { exist: !0 }),
      [e]
    );
    return E.createElement(KU.Provider, { value: i }, n);
  },
  qZ = XZ;
function Qr(t, e) {
  KZ(t) && (t = "100%");
  var n = YZ(t);
  return (
    (t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t)))),
    n && (t = parseInt(String(t * e), 10) / 100),
    Math.abs(t - e) < 1e-6
      ? 1
      : (e === 360
          ? (t = (t < 0 ? (t % e) + e : t % e) / parseFloat(String(e)))
          : (t = (t % e) / parseFloat(String(e))),
        t)
  );
}
function Gv(t) {
  return Math.min(1, Math.max(0, t));
}
function KZ(t) {
  return typeof t == "string" && t.indexOf(".") !== -1 && parseFloat(t) === 1;
}
function YZ(t) {
  return typeof t == "string" && t.indexOf("%") !== -1;
}
function YU(t) {
  return (t = parseFloat(t)), (isNaN(t) || t < 0 || t > 1) && (t = 1), t;
}
function Wv(t) {
  return t <= 1 ? "".concat(Number(t) * 100, "%") : t;
}
function Vc(t) {
  return t.length === 1 ? "0" + t : String(t);
}
function ZZ(t, e, n) {
  return { r: Qr(t, 255) * 255, g: Qr(e, 255) * 255, b: Qr(n, 255) * 255 };
}
function oI(t, e, n) {
  (t = Qr(t, 255)), (e = Qr(e, 255)), (n = Qr(n, 255));
  var r = Math.max(t, e, n),
    i = Math.min(t, e, n),
    o = 0,
    a = 0,
    s = (r + i) / 2;
  if (r === i) (a = 0), (o = 0);
  else {
    var l = r - i;
    switch (((a = s > 0.5 ? l / (2 - r - i) : l / (r + i)), r)) {
      case t:
        o = (e - n) / l + (e < n ? 6 : 0);
        break;
      case e:
        o = (n - t) / l + 2;
        break;
      case n:
        o = (t - e) / l + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: a, l: s };
}
function L_(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? t + (e - t) * (6 * n)
      : n < 1 / 2
      ? e
      : n < 2 / 3
      ? t + (e - t) * (2 / 3 - n) * 6
      : t
  );
}
function QZ(t, e, n) {
  var r, i, o;
  if (((t = Qr(t, 360)), (e = Qr(e, 100)), (n = Qr(n, 100)), e === 0))
    (i = n), (o = n), (r = n);
  else {
    var a = n < 0.5 ? n * (1 + e) : n + e - n * e,
      s = 2 * n - a;
    (r = L_(s, a, t + 1 / 3)), (i = L_(s, a, t)), (o = L_(s, a, t - 1 / 3));
  }
  return { r: r * 255, g: i * 255, b: o * 255 };
}
function gE(t, e, n) {
  (t = Qr(t, 255)), (e = Qr(e, 255)), (n = Qr(n, 255));
  var r = Math.max(t, e, n),
    i = Math.min(t, e, n),
    o = 0,
    a = r,
    s = r - i,
    l = r === 0 ? 0 : s / r;
  if (r === i) o = 0;
  else {
    switch (r) {
      case t:
        o = (e - n) / s + (e < n ? 6 : 0);
        break;
      case e:
        o = (n - t) / s + 2;
        break;
      case n:
        o = (t - e) / s + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: l, v: a };
}
function JZ(t, e, n) {
  (t = Qr(t, 360) * 6), (e = Qr(e, 100)), (n = Qr(n, 100));
  var r = Math.floor(t),
    i = t - r,
    o = n * (1 - e),
    a = n * (1 - i * e),
    s = n * (1 - (1 - i) * e),
    l = r % 6,
    c = [n, a, o, o, s, n][l],
    u = [s, n, n, a, o, o][l],
    d = [o, o, s, n, n, a][l];
  return { r: c * 255, g: u * 255, b: d * 255 };
}
function vE(t, e, n, r) {
  var i = [
    Vc(Math.round(t).toString(16)),
    Vc(Math.round(e).toString(16)),
    Vc(Math.round(n).toString(16)),
  ];
  return r &&
    i[0].startsWith(i[0].charAt(1)) &&
    i[1].startsWith(i[1].charAt(1)) &&
    i[2].startsWith(i[2].charAt(1))
    ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0)
    : i.join("");
}
function eQ(t, e, n, r, i) {
  var o = [
    Vc(Math.round(t).toString(16)),
    Vc(Math.round(e).toString(16)),
    Vc(Math.round(n).toString(16)),
    Vc(tQ(r)),
  ];
  return i &&
    o[0].startsWith(o[0].charAt(1)) &&
    o[1].startsWith(o[1].charAt(1)) &&
    o[2].startsWith(o[2].charAt(1)) &&
    o[3].startsWith(o[3].charAt(1))
    ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) + o[3].charAt(0)
    : o.join("");
}
function tQ(t) {
  return Math.round(parseFloat(t) * 255).toString(16);
}
function aI(t) {
  return xo(t) / 255;
}
function xo(t) {
  return parseInt(t, 16);
}
function nQ(t) {
  return { r: t >> 16, g: (t & 65280) >> 8, b: t & 255 };
}
var yE = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32",
};
function Md(t) {
  var e = { r: 0, g: 0, b: 0 },
    n = 1,
    r = null,
    i = null,
    o = null,
    a = !1,
    s = !1;
  return (
    typeof t == "string" && (t = oQ(t)),
    typeof t == "object" &&
      (ws(t.r) && ws(t.g) && ws(t.b)
        ? ((e = ZZ(t.r, t.g, t.b)),
          (a = !0),
          (s = String(t.r).substr(-1) === "%" ? "prgb" : "rgb"))
        : ws(t.h) && ws(t.s) && ws(t.v)
        ? ((r = Wv(t.s)),
          (i = Wv(t.v)),
          (e = JZ(t.h, r, i)),
          (a = !0),
          (s = "hsv"))
        : ws(t.h) &&
          ws(t.s) &&
          ws(t.l) &&
          ((r = Wv(t.s)),
          (o = Wv(t.l)),
          (e = QZ(t.h, r, o)),
          (a = !0),
          (s = "hsl")),
      Object.prototype.hasOwnProperty.call(t, "a") && (n = t.a)),
    (n = YU(n)),
    {
      ok: a,
      format: t.format || s,
      r: Math.min(255, Math.max(e.r, 0)),
      g: Math.min(255, Math.max(e.g, 0)),
      b: Math.min(255, Math.max(e.b, 0)),
      a: n,
    }
  );
}
var rQ = "[-\\+]?\\d+%?",
  iQ = "[-\\+]?\\d*\\.\\d+%?",
  Ml = "(?:".concat(iQ, ")|(?:").concat(rQ, ")"),
  O_ = "[\\s|\\(]+("
    .concat(Ml, ")[,|\\s]+(")
    .concat(Ml, ")[,|\\s]+(")
    .concat(Ml, ")\\s*\\)?"),
  N_ = "[\\s|\\(]+("
    .concat(Ml, ")[,|\\s]+(")
    .concat(Ml, ")[,|\\s]+(")
    .concat(Ml, ")[,|\\s]+(")
    .concat(Ml, ")\\s*\\)?"),
  ha = {
    CSS_UNIT: new RegExp(Ml),
    rgb: new RegExp("rgb" + O_),
    rgba: new RegExp("rgba" + N_),
    hsl: new RegExp("hsl" + O_),
    hsla: new RegExp("hsla" + N_),
    hsv: new RegExp("hsv" + O_),
    hsva: new RegExp("hsva" + N_),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  };
function oQ(t) {
  if (((t = t.trim().toLowerCase()), t.length === 0)) return !1;
  var e = !1;
  if (yE[t]) (t = yE[t]), (e = !0);
  else if (t === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = ha.rgb.exec(t);
  return n
    ? { r: n[1], g: n[2], b: n[3] }
    : ((n = ha.rgba.exec(t)),
      n
        ? { r: n[1], g: n[2], b: n[3], a: n[4] }
        : ((n = ha.hsl.exec(t)),
          n
            ? { h: n[1], s: n[2], l: n[3] }
            : ((n = ha.hsla.exec(t)),
              n
                ? { h: n[1], s: n[2], l: n[3], a: n[4] }
                : ((n = ha.hsv.exec(t)),
                  n
                    ? { h: n[1], s: n[2], v: n[3] }
                    : ((n = ha.hsva.exec(t)),
                      n
                        ? { h: n[1], s: n[2], v: n[3], a: n[4] }
                        : ((n = ha.hex8.exec(t)),
                          n
                            ? {
                                r: xo(n[1]),
                                g: xo(n[2]),
                                b: xo(n[3]),
                                a: aI(n[4]),
                                format: e ? "name" : "hex8",
                              }
                            : ((n = ha.hex6.exec(t)),
                              n
                                ? {
                                    r: xo(n[1]),
                                    g: xo(n[2]),
                                    b: xo(n[3]),
                                    format: e ? "name" : "hex",
                                  }
                                : ((n = ha.hex4.exec(t)),
                                  n
                                    ? {
                                        r: xo(n[1] + n[1]),
                                        g: xo(n[2] + n[2]),
                                        b: xo(n[3] + n[3]),
                                        a: aI(n[4] + n[4]),
                                        format: e ? "name" : "hex8",
                                      }
                                    : ((n = ha.hex3.exec(t)),
                                      n
                                        ? {
                                            r: xo(n[1] + n[1]),
                                            g: xo(n[2] + n[2]),
                                            b: xo(n[3] + n[3]),
                                            format: e ? "name" : "hex",
                                          }
                                        : !1)))))))));
}
function ws(t) {
  return !!ha.CSS_UNIT.exec(String(t));
}
var Mo = (function () {
    function t(e, n) {
      e === void 0 && (e = ""), n === void 0 && (n = {});
      var r;
      if (e instanceof t) return e;
      typeof e == "number" && (e = nQ(e)), (this.originalInput = e);
      var i = Md(e);
      (this.originalInput = e),
        (this.r = i.r),
        (this.g = i.g),
        (this.b = i.b),
        (this.a = i.a),
        (this.roundA = Math.round(100 * this.a) / 100),
        (this.format = (r = n.format) !== null && r !== void 0 ? r : i.format),
        (this.gradientType = n.gradientType),
        this.r < 1 && (this.r = Math.round(this.r)),
        this.g < 1 && (this.g = Math.round(this.g)),
        this.b < 1 && (this.b = Math.round(this.b)),
        (this.isValid = i.ok);
    }
    return (
      (t.prototype.isDark = function () {
        return this.getBrightness() < 128;
      }),
      (t.prototype.isLight = function () {
        return !this.isDark();
      }),
      (t.prototype.getBrightness = function () {
        var e = this.toRgb();
        return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
      }),
      (t.prototype.getLuminance = function () {
        var e = this.toRgb(),
          n,
          r,
          i,
          o = e.r / 255,
          a = e.g / 255,
          s = e.b / 255;
        return (
          o <= 0.03928
            ? (n = o / 12.92)
            : (n = Math.pow((o + 0.055) / 1.055, 2.4)),
          a <= 0.03928
            ? (r = a / 12.92)
            : (r = Math.pow((a + 0.055) / 1.055, 2.4)),
          s <= 0.03928
            ? (i = s / 12.92)
            : (i = Math.pow((s + 0.055) / 1.055, 2.4)),
          0.2126 * n + 0.7152 * r + 0.0722 * i
        );
      }),
      (t.prototype.getAlpha = function () {
        return this.a;
      }),
      (t.prototype.setAlpha = function (e) {
        return (
          (this.a = YU(e)), (this.roundA = Math.round(100 * this.a) / 100), this
        );
      }),
      (t.prototype.isMonochrome = function () {
        var e = this.toHsl().s;
        return e === 0;
      }),
      (t.prototype.toHsv = function () {
        var e = gE(this.r, this.g, this.b);
        return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
      }),
      (t.prototype.toHsvString = function () {
        var e = gE(this.r, this.g, this.b),
          n = Math.round(e.h * 360),
          r = Math.round(e.s * 100),
          i = Math.round(e.v * 100);
        return this.a === 1
          ? "hsv(".concat(n, ", ").concat(r, "%, ").concat(i, "%)")
          : "hsva("
              .concat(n, ", ")
              .concat(r, "%, ")
              .concat(i, "%, ")
              .concat(this.roundA, ")");
      }),
      (t.prototype.toHsl = function () {
        var e = oI(this.r, this.g, this.b);
        return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
      }),
      (t.prototype.toHslString = function () {
        var e = oI(this.r, this.g, this.b),
          n = Math.round(e.h * 360),
          r = Math.round(e.s * 100),
          i = Math.round(e.l * 100);
        return this.a === 1
          ? "hsl(".concat(n, ", ").concat(r, "%, ").concat(i, "%)")
          : "hsla("
              .concat(n, ", ")
              .concat(r, "%, ")
              .concat(i, "%, ")
              .concat(this.roundA, ")");
      }),
      (t.prototype.toHex = function (e) {
        return e === void 0 && (e = !1), vE(this.r, this.g, this.b, e);
      }),
      (t.prototype.toHexString = function (e) {
        return e === void 0 && (e = !1), "#" + this.toHex(e);
      }),
      (t.prototype.toHex8 = function (e) {
        return e === void 0 && (e = !1), eQ(this.r, this.g, this.b, this.a, e);
      }),
      (t.prototype.toHex8String = function (e) {
        return e === void 0 && (e = !1), "#" + this.toHex8(e);
      }),
      (t.prototype.toHexShortString = function (e) {
        return (
          e === void 0 && (e = !1),
          this.a === 1 ? this.toHexString(e) : this.toHex8String(e)
        );
      }),
      (t.prototype.toRgb = function () {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a,
        };
      }),
      (t.prototype.toRgbString = function () {
        var e = Math.round(this.r),
          n = Math.round(this.g),
          r = Math.round(this.b);
        return this.a === 1
          ? "rgb(".concat(e, ", ").concat(n, ", ").concat(r, ")")
          : "rgba("
              .concat(e, ", ")
              .concat(n, ", ")
              .concat(r, ", ")
              .concat(this.roundA, ")");
      }),
      (t.prototype.toPercentageRgb = function () {
        var e = function (n) {
          return "".concat(Math.round(Qr(n, 255) * 100), "%");
        };
        return { r: e(this.r), g: e(this.g), b: e(this.b), a: this.a };
      }),
      (t.prototype.toPercentageRgbString = function () {
        var e = function (n) {
          return Math.round(Qr(n, 255) * 100);
        };
        return this.a === 1
          ? "rgb("
              .concat(e(this.r), "%, ")
              .concat(e(this.g), "%, ")
              .concat(e(this.b), "%)")
          : "rgba("
              .concat(e(this.r), "%, ")
              .concat(e(this.g), "%, ")
              .concat(e(this.b), "%, ")
              .concat(this.roundA, ")");
      }),
      (t.prototype.toName = function () {
        if (this.a === 0) return "transparent";
        if (this.a < 1) return !1;
        for (
          var e = "#" + vE(this.r, this.g, this.b, !1),
            n = 0,
            r = Object.entries(yE);
          n < r.length;
          n++
        ) {
          var i = r[n],
            o = i[0],
            a = i[1];
          if (e === a) return o;
        }
        return !1;
      }),
      (t.prototype.toString = function (e) {
        var n = !!e;
        e = e ?? this.format;
        var r = !1,
          i = this.a < 1 && this.a >= 0,
          o = !n && i && (e.startsWith("hex") || e === "name");
        return o
          ? e === "name" && this.a === 0
            ? this.toName()
            : this.toRgbString()
          : (e === "rgb" && (r = this.toRgbString()),
            e === "prgb" && (r = this.toPercentageRgbString()),
            (e === "hex" || e === "hex6") && (r = this.toHexString()),
            e === "hex3" && (r = this.toHexString(!0)),
            e === "hex4" && (r = this.toHex8String(!0)),
            e === "hex8" && (r = this.toHex8String()),
            e === "name" && (r = this.toName()),
            e === "hsl" && (r = this.toHslString()),
            e === "hsv" && (r = this.toHsvString()),
            r || this.toHexString());
      }),
      (t.prototype.toNumber = function () {
        return (
          (Math.round(this.r) << 16) +
          (Math.round(this.g) << 8) +
          Math.round(this.b)
        );
      }),
      (t.prototype.clone = function () {
        return new t(this.toString());
      }),
      (t.prototype.lighten = function (e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return (n.l += e / 100), (n.l = Gv(n.l)), new t(n);
      }),
      (t.prototype.brighten = function (e) {
        e === void 0 && (e = 10);
        var n = this.toRgb();
        return (
          (n.r = Math.max(
            0,
            Math.min(255, n.r - Math.round(255 * -(e / 100)))
          )),
          (n.g = Math.max(
            0,
            Math.min(255, n.g - Math.round(255 * -(e / 100)))
          )),
          (n.b = Math.max(
            0,
            Math.min(255, n.b - Math.round(255 * -(e / 100)))
          )),
          new t(n)
        );
      }),
      (t.prototype.darken = function (e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return (n.l -= e / 100), (n.l = Gv(n.l)), new t(n);
      }),
      (t.prototype.tint = function (e) {
        return e === void 0 && (e = 10), this.mix("white", e);
      }),
      (t.prototype.shade = function (e) {
        return e === void 0 && (e = 10), this.mix("black", e);
      }),
      (t.prototype.desaturate = function (e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return (n.s -= e / 100), (n.s = Gv(n.s)), new t(n);
      }),
      (t.prototype.saturate = function (e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return (n.s += e / 100), (n.s = Gv(n.s)), new t(n);
      }),
      (t.prototype.greyscale = function () {
        return this.desaturate(100);
      }),
      (t.prototype.spin = function (e) {
        var n = this.toHsl(),
          r = (n.h + e) % 360;
        return (n.h = r < 0 ? 360 + r : r), new t(n);
      }),
      (t.prototype.mix = function (e, n) {
        n === void 0 && (n = 50);
        var r = this.toRgb(),
          i = new t(e).toRgb(),
          o = n / 100,
          a = {
            r: (i.r - r.r) * o + r.r,
            g: (i.g - r.g) * o + r.g,
            b: (i.b - r.b) * o + r.b,
            a: (i.a - r.a) * o + r.a,
          };
        return new t(a);
      }),
      (t.prototype.analogous = function (e, n) {
        e === void 0 && (e = 6), n === void 0 && (n = 30);
        var r = this.toHsl(),
          i = 360 / n,
          o = [this];
        for (r.h = (r.h - ((i * e) >> 1) + 720) % 360; --e; )
          (r.h = (r.h + i) % 360), o.push(new t(r));
        return o;
      }),
      (t.prototype.complement = function () {
        var e = this.toHsl();
        return (e.h = (e.h + 180) % 360), new t(e);
      }),
      (t.prototype.monochromatic = function (e) {
        e === void 0 && (e = 6);
        for (
          var n = this.toHsv(), r = n.h, i = n.s, o = n.v, a = [], s = 1 / e;
          e--;

        )
          a.push(new t({ h: r, s: i, v: o })), (o = (o + s) % 1);
        return a;
      }),
      (t.prototype.splitcomplement = function () {
        var e = this.toHsl(),
          n = e.h;
        return [
          this,
          new t({ h: (n + 72) % 360, s: e.s, l: e.l }),
          new t({ h: (n + 216) % 360, s: e.s, l: e.l }),
        ];
      }),
      (t.prototype.onBackground = function (e) {
        var n = this.toRgb(),
          r = new t(e).toRgb(),
          i = n.a + r.a * (1 - n.a);
        return new t({
          r: (n.r * n.a + r.r * r.a * (1 - n.a)) / i,
          g: (n.g * n.a + r.g * r.a * (1 - n.a)) / i,
          b: (n.b * n.a + r.b * r.a * (1 - n.a)) / i,
          a: i,
        });
      }),
      (t.prototype.triad = function () {
        return this.polyad(3);
      }),
      (t.prototype.tetrad = function () {
        return this.polyad(4);
      }),
      (t.prototype.polyad = function (e) {
        for (
          var n = this.toHsl(), r = n.h, i = [this], o = 360 / e, a = 1;
          a < e;
          a++
        )
          i.push(new t({ h: (r + a * o) % 360, s: n.s, l: n.l }));
        return i;
      }),
      (t.prototype.equals = function (e) {
        return this.toRgbString() === new t(e).toRgbString();
      }),
      t
    );
  })(),
  Xv = 2,
  sI = 0.16,
  aQ = 0.05,
  sQ = 0.05,
  lQ = 0.15,
  ZU = 5,
  QU = 4,
  cQ = [
    { index: 7, opacity: 0.15 },
    { index: 6, opacity: 0.25 },
    { index: 5, opacity: 0.3 },
    { index: 5, opacity: 0.45 },
    { index: 5, opacity: 0.65 },
    { index: 5, opacity: 0.85 },
    { index: 4, opacity: 0.9 },
    { index: 3, opacity: 0.95 },
    { index: 2, opacity: 0.97 },
    { index: 1, opacity: 0.98 },
  ];
function lI(t) {
  var e = t.r,
    n = t.g,
    r = t.b,
    i = gE(e, n, r);
  return { h: i.h * 360, s: i.s, v: i.v };
}
function qv(t) {
  var e = t.r,
    n = t.g,
    r = t.b;
  return "#".concat(vE(e, n, r, !1));
}
function uQ(t, e, n) {
  var r = n / 100,
    i = {
      r: (e.r - t.r) * r + t.r,
      g: (e.g - t.g) * r + t.g,
      b: (e.b - t.b) * r + t.b,
    };
  return i;
}
function cI(t, e, n) {
  var r;
  return (
    Math.round(t.h) >= 60 && Math.round(t.h) <= 240
      ? (r = n ? Math.round(t.h) - Xv * e : Math.round(t.h) + Xv * e)
      : (r = n ? Math.round(t.h) + Xv * e : Math.round(t.h) - Xv * e),
    r < 0 ? (r += 360) : r >= 360 && (r -= 360),
    r
  );
}
function uI(t, e, n) {
  if (t.h === 0 && t.s === 0) return t.s;
  var r;
  return (
    n ? (r = t.s - sI * e) : e === QU ? (r = t.s + sI) : (r = t.s + aQ * e),
    r > 1 && (r = 1),
    n && e === ZU && r > 0.1 && (r = 0.1),
    r < 0.06 && (r = 0.06),
    Number(r.toFixed(2))
  );
}
function dI(t, e, n) {
  var r;
  return (
    n ? (r = t.v + sQ * e) : (r = t.v - lQ * e),
    r > 1 && (r = 1),
    Number(r.toFixed(2))
  );
}
function pu(t) {
  for (
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      n = [],
      r = Md(t),
      i = ZU;
    i > 0;
    i -= 1
  ) {
    var o = lI(r),
      a = qv(Md({ h: cI(o, i, !0), s: uI(o, i, !0), v: dI(o, i, !0) }));
    n.push(a);
  }
  n.push(qv(r));
  for (var s = 1; s <= QU; s += 1) {
    var l = lI(r),
      c = qv(Md({ h: cI(l, s), s: uI(l, s), v: dI(l, s) }));
    n.push(c);
  }
  return e.theme === "dark"
    ? cQ.map(function (u) {
        var d = u.index,
          p = u.opacity,
          m = qv(uQ(Md(e.backgroundColor || "#141414"), Md(n[d]), p * 100));
        return m;
      })
    : n;
}
var F_ = {
    red: "#F5222D",
    volcano: "#FA541C",
    orange: "#FA8C16",
    gold: "#FAAD14",
    yellow: "#FADB14",
    lime: "#A0D911",
    green: "#52C41A",
    cyan: "#13C2C2",
    blue: "#1677FF",
    geekblue: "#2F54EB",
    purple: "#722ED1",
    magenta: "#EB2F96",
    grey: "#666666",
  },
  I0 = {},
  D_ = {};
Object.keys(F_).forEach(function (t) {
  (I0[t] = pu(F_[t])),
    (I0[t].primary = I0[t][5]),
    (D_[t] = pu(F_[t], { theme: "dark", backgroundColor: "#141414" })),
    (D_[t].primary = D_[t][5]);
});
var dQ = I0.blue;
const fQ = (t) => {
  const { controlHeight: e } = t;
  return {
    controlHeightSM: e * 0.75,
    controlHeightXS: e * 0.5,
    controlHeightLG: e * 1.25,
  };
};
function hQ(t) {
  const { sizeUnit: e, sizeStep: n } = t;
  return {
    sizeXXL: e * (n + 8),
    sizeXL: e * (n + 4),
    sizeLG: e * (n + 2),
    sizeMD: e * (n + 1),
    sizeMS: e * n,
    size: e * n,
    sizeSM: e * (n - 1),
    sizeXS: e * (n - 2),
    sizeXXS: e * (n - 3),
  };
}
const JU = {
    blue: "#1677ff",
    purple: "#722ED1",
    cyan: "#13C2C2",
    green: "#52C41A",
    magenta: "#EB2F96",
    pink: "#eb2f96",
    red: "#F5222D",
    orange: "#FA8C16",
    yellow: "#FADB14",
    volcano: "#FA541C",
    geekblue: "#2F54EB",
    gold: "#FAAD14",
    lime: "#A0D911",
  },
  pQ = Object.assign(Object.assign({}, JU), {
    colorPrimary: "#1677ff",
    colorSuccess: "#52c41a",
    colorWarning: "#faad14",
    colorError: "#ff4d4f",
    colorInfo: "#1677ff",
    colorLink: "",
    colorTextBase: "",
    colorBgBase: "",
    fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
    fontFamilyCode:
      "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
    fontSize: 14,
    lineWidth: 1,
    lineType: "solid",
    motionUnit: 0.1,
    motionBase: 0,
    motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
    motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
    motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
    motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
    motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
    borderRadius: 6,
    sizeUnit: 4,
    sizeStep: 4,
    sizePopupArrow: 16,
    controlHeight: 32,
    zIndexBase: 0,
    zIndexPopupBase: 1e3,
    opacityImage: 1,
    wireframe: !1,
    motion: !0,
  }),
  Jp = pQ;
function mQ(t, e) {
  let { generateColorPalettes: n, generateNeutralColorPalettes: r } = e;
  const {
      colorSuccess: i,
      colorWarning: o,
      colorError: a,
      colorInfo: s,
      colorPrimary: l,
      colorBgBase: c,
      colorTextBase: u,
    } = t,
    d = n(l),
    p = n(i),
    m = n(o),
    v = n(a),
    S = n(s),
    x = r(c, u),
    g = t.colorLink || t.colorInfo,
    _ = n(g);
  return Object.assign(Object.assign({}, x), {
    colorPrimaryBg: d[1],
    colorPrimaryBgHover: d[2],
    colorPrimaryBorder: d[3],
    colorPrimaryBorderHover: d[4],
    colorPrimaryHover: d[5],
    colorPrimary: d[6],
    colorPrimaryActive: d[7],
    colorPrimaryTextHover: d[8],
    colorPrimaryText: d[9],
    colorPrimaryTextActive: d[10],
    colorSuccessBg: p[1],
    colorSuccessBgHover: p[2],
    colorSuccessBorder: p[3],
    colorSuccessBorderHover: p[4],
    colorSuccessHover: p[4],
    colorSuccess: p[6],
    colorSuccessActive: p[7],
    colorSuccessTextHover: p[8],
    colorSuccessText: p[9],
    colorSuccessTextActive: p[10],
    colorErrorBg: v[1],
    colorErrorBgHover: v[2],
    colorErrorBorder: v[3],
    colorErrorBorderHover: v[4],
    colorErrorHover: v[5],
    colorError: v[6],
    colorErrorActive: v[7],
    colorErrorTextHover: v[8],
    colorErrorText: v[9],
    colorErrorTextActive: v[10],
    colorWarningBg: m[1],
    colorWarningBgHover: m[2],
    colorWarningBorder: m[3],
    colorWarningBorderHover: m[4],
    colorWarningHover: m[4],
    colorWarning: m[6],
    colorWarningActive: m[7],
    colorWarningTextHover: m[8],
    colorWarningText: m[9],
    colorWarningTextActive: m[10],
    colorInfoBg: S[1],
    colorInfoBgHover: S[2],
    colorInfoBorder: S[3],
    colorInfoBorderHover: S[4],
    colorInfoHover: S[4],
    colorInfo: S[6],
    colorInfoActive: S[7],
    colorInfoTextHover: S[8],
    colorInfoText: S[9],
    colorInfoTextActive: S[10],
    colorLinkHover: _[4],
    colorLink: _[6],
    colorLinkActive: _[7],
    colorBgMask: new Mo("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff",
  });
}
const gQ = (t) => {
  let e = t,
    n = t,
    r = t,
    i = t;
  return (
    t < 6 && t >= 5
      ? (e = t + 1)
      : t < 16 && t >= 6
      ? (e = t + 2)
      : t >= 16 && (e = 16),
    t < 7 && t >= 5
      ? (n = 4)
      : t < 8 && t >= 7
      ? (n = 5)
      : t < 14 && t >= 8
      ? (n = 6)
      : t < 16 && t >= 14
      ? (n = 7)
      : t >= 16 && (n = 8),
    t < 6 && t >= 2 ? (r = 1) : t >= 6 && (r = 2),
    t > 4 && t < 8 ? (i = 4) : t >= 8 && (i = 6),
    {
      borderRadius: t,
      borderRadiusXS: r,
      borderRadiusSM: n,
      borderRadiusLG: e,
      borderRadiusOuter: i,
    }
  );
};
function vQ(t) {
  const { motionUnit: e, motionBase: n, borderRadius: r, lineWidth: i } = t;
  return Object.assign(
    {
      motionDurationFast: `${(n + e).toFixed(1)}s`,
      motionDurationMid: `${(n + e * 2).toFixed(1)}s`,
      motionDurationSlow: `${(n + e * 3).toFixed(1)}s`,
      lineWidthBold: i + 1,
    },
    gQ(r)
  );
}
const Es = (t, e) => new Mo(t).setAlpha(e).toRgbString(),
  Ch = (t, e) => new Mo(t).darken(e).toHexString(),
  yQ = (t) => {
    const e = pu(t);
    return {
      1: e[0],
      2: e[1],
      3: e[2],
      4: e[3],
      5: e[4],
      6: e[5],
      7: e[6],
      8: e[4],
      9: e[5],
      10: e[6],
    };
  },
  xQ = (t, e) => {
    const n = t || "#fff",
      r = e || "#000";
    return {
      colorBgBase: n,
      colorTextBase: r,
      colorText: Es(r, 0.88),
      colorTextSecondary: Es(r, 0.65),
      colorTextTertiary: Es(r, 0.45),
      colorTextQuaternary: Es(r, 0.25),
      colorFill: Es(r, 0.15),
      colorFillSecondary: Es(r, 0.06),
      colorFillTertiary: Es(r, 0.04),
      colorFillQuaternary: Es(r, 0.02),
      colorBgLayout: Ch(n, 4),
      colorBgContainer: Ch(n, 0),
      colorBgElevated: Ch(n, 0),
      colorBgSpotlight: Es(r, 0.85),
      colorBgBlur: "transparent",
      colorBorder: Ch(n, 15),
      colorBorderSecondary: Ch(n, 6),
    };
  };
function L0(t) {
  return (t + 8) / t;
}
function SQ(t) {
  const e = new Array(10).fill(null).map((n, r) => {
    const i = r - 1,
      o = t * Math.pow(2.71828, i / 5),
      a = r > 1 ? Math.floor(o) : Math.ceil(o);
    return Math.floor(a / 2) * 2;
  });
  return (e[1] = t), e.map((n) => ({ size: n, lineHeight: L0(n) }));
}
const _Q = (t) => {
  const e = SQ(t),
    n = e.map((u) => u.size),
    r = e.map((u) => u.lineHeight),
    i = n[1],
    o = n[0],
    a = n[2],
    s = r[1],
    l = r[0],
    c = r[2];
  return {
    fontSizeSM: o,
    fontSize: i,
    fontSizeLG: a,
    fontSizeXL: n[3],
    fontSizeHeading1: n[6],
    fontSizeHeading2: n[5],
    fontSizeHeading3: n[4],
    fontSizeHeading4: n[3],
    fontSizeHeading5: n[2],
    lineHeight: s,
    lineHeightLG: c,
    lineHeightSM: l,
    fontHeight: Math.round(s * i),
    fontHeightLG: Math.round(c * a),
    fontHeightSM: Math.round(l * o),
    lineHeightHeading1: r[6],
    lineHeightHeading2: r[5],
    lineHeightHeading3: r[4],
    lineHeightHeading4: r[3],
    lineHeightHeading5: r[2],
  };
};
function bQ(t) {
  const e = Object.keys(JU)
    .map((n) => {
      const r = pu(t[n]);
      return new Array(10)
        .fill(1)
        .reduce(
          (i, o, a) => (
            (i[`${n}-${a + 1}`] = r[a]), (i[`${n}${a + 1}`] = r[a]), i
          ),
          {}
        );
    })
    .reduce((n, r) => ((n = Object.assign(Object.assign({}, n), r)), n), {});
  return Object.assign(
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(Object.assign({}, t), e),
            mQ(t, {
              generateColorPalettes: yQ,
              generateNeutralColorPalettes: xQ,
            })
          ),
          _Q(t.fontSize)
        ),
        hQ(t)
      ),
      fQ(t)
    ),
    vQ(t)
  );
}
const ek = lE(bQ),
  tk = { token: Jp, override: { override: Jp }, hashed: !0 },
  nk = at.createContext(tk),
  rk = "anticon",
  wQ = (t, e) => e || (t ? `ant-${t}` : "ant"),
  Rn = E.createContext({ getPrefixCls: wQ, iconPrefixCls: rk }),
  EQ = `-ant-${Date.now()}-${Math.random()}`;
function MQ(t, e) {
  const n = {},
    r = (a, s) => {
      let l = a.clone();
      return (l = (s == null ? void 0 : s(l)) || l), l.toRgbString();
    },
    i = (a, s) => {
      const l = new Mo(a),
        c = pu(l.toRgbString());
      (n[`${s}-color`] = r(l)),
        (n[`${s}-color-disabled`] = c[1]),
        (n[`${s}-color-hover`] = c[4]),
        (n[`${s}-color-active`] = c[6]),
        (n[`${s}-color-outline`] = l.clone().setAlpha(0.2).toRgbString()),
        (n[`${s}-color-deprecated-bg`] = c[0]),
        (n[`${s}-color-deprecated-border`] = c[2]);
    };
  if (e.primaryColor) {
    i(e.primaryColor, "primary");
    const a = new Mo(e.primaryColor),
      s = pu(a.toRgbString());
    s.forEach((c, u) => {
      n[`primary-${u + 1}`] = c;
    }),
      (n["primary-color-deprecated-l-35"] = r(a, (c) => c.lighten(35))),
      (n["primary-color-deprecated-l-20"] = r(a, (c) => c.lighten(20))),
      (n["primary-color-deprecated-t-20"] = r(a, (c) => c.tint(20))),
      (n["primary-color-deprecated-t-50"] = r(a, (c) => c.tint(50))),
      (n["primary-color-deprecated-f-12"] = r(a, (c) =>
        c.setAlpha(c.getAlpha() * 0.12)
      ));
    const l = new Mo(s[0]);
    (n["primary-color-active-deprecated-f-30"] = r(l, (c) =>
      c.setAlpha(c.getAlpha() * 0.3)
    )),
      (n["primary-color-active-deprecated-d-02"] = r(l, (c) => c.darken(2)));
  }
  return (
    e.successColor && i(e.successColor, "success"),
    e.warningColor && i(e.warningColor, "warning"),
    e.errorColor && i(e.errorColor, "error"),
    e.infoColor && i(e.infoColor, "info"),
    `
  :root {
    ${Object.keys(n).map((a) => `--${t}-${a}: ${n[a]};`).join(`
`)}
  }
  `.trim()
  );
}
function CQ(t, e) {
  const n = MQ(t, e);
  to() && Wl(n, `${EQ}-dynamic-theme`);
}
const xE = E.createContext(!1),
  TQ = (t) => {
    let { children: e, disabled: n } = t;
    const r = E.useContext(xE);
    return E.createElement(xE.Provider, { value: n ?? r }, e);
  },
  Cm = xE,
  SE = E.createContext(void 0),
  AQ = (t) => {
    let { children: e, size: n } = t;
    const r = E.useContext(SE);
    return E.createElement(SE.Provider, { value: n || r }, e);
  },
  Y1 = SE;
function RQ() {
  const t = E.useContext(Cm),
    e = E.useContext(Y1);
  return { componentDisabled: t, componentSize: e };
}
const Ey = [
    "blue",
    "purple",
    "cyan",
    "green",
    "magenta",
    "pink",
    "red",
    "orange",
    "yellow",
    "volcano",
    "geekblue",
    "lime",
    "gold",
  ],
  PQ = "5.13.3";
function z_(t) {
  return t >= 0 && t <= 255;
}
function Kv(t, e) {
  const { r: n, g: r, b: i, a: o } = new Mo(t).toRgb();
  if (o < 1) return t;
  const { r: a, g: s, b: l } = new Mo(e).toRgb();
  for (let c = 0.01; c <= 1; c += 0.01) {
    const u = Math.round((n - a * (1 - c)) / c),
      d = Math.round((r - s * (1 - c)) / c),
      p = Math.round((i - l * (1 - c)) / c);
    if (z_(u) && z_(d) && z_(p))
      return new Mo({
        r: u,
        g: d,
        b: p,
        a: Math.round(c * 100) / 100,
      }).toRgbString();
  }
  return new Mo({ r: n, g: r, b: i, a: 1 }).toRgbString();
}
var IQ = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
function ik(t) {
  const { override: e } = t,
    n = IQ(t, ["override"]),
    r = Object.assign({}, e);
  Object.keys(Jp).forEach((p) => {
    delete r[p];
  });
  const i = Object.assign(Object.assign({}, n), r),
    o = 480,
    a = 576,
    s = 768,
    l = 992,
    c = 1200,
    u = 1600;
  if (i.motion === !1) {
    const p = "0s";
    (i.motionDurationFast = p),
      (i.motionDurationMid = p),
      (i.motionDurationSlow = p);
  }
  return Object.assign(
    Object.assign(Object.assign({}, i), {
      colorFillContent: i.colorFillSecondary,
      colorFillContentHover: i.colorFill,
      colorFillAlter: i.colorFillQuaternary,
      colorBgContainerDisabled: i.colorFillTertiary,
      colorBorderBg: i.colorBgContainer,
      colorSplit: Kv(i.colorBorderSecondary, i.colorBgContainer),
      colorTextPlaceholder: i.colorTextQuaternary,
      colorTextDisabled: i.colorTextQuaternary,
      colorTextHeading: i.colorText,
      colorTextLabel: i.colorTextSecondary,
      colorTextDescription: i.colorTextTertiary,
      colorTextLightSolid: i.colorWhite,
      colorHighlight: i.colorError,
      colorBgTextHover: i.colorFillSecondary,
      colorBgTextActive: i.colorFill,
      colorIcon: i.colorTextTertiary,
      colorIconHover: i.colorText,
      colorErrorOutline: Kv(i.colorErrorBg, i.colorBgContainer),
      colorWarningOutline: Kv(i.colorWarningBg, i.colorBgContainer),
      fontSizeIcon: i.fontSizeSM,
      lineWidthFocus: i.lineWidth * 4,
      lineWidth: i.lineWidth,
      controlOutlineWidth: i.lineWidth * 2,
      controlInteractiveSize: i.controlHeight / 2,
      controlItemBgHover: i.colorFillTertiary,
      controlItemBgActive: i.colorPrimaryBg,
      controlItemBgActiveHover: i.colorPrimaryBgHover,
      controlItemBgActiveDisabled: i.colorFill,
      controlTmpOutline: i.colorFillQuaternary,
      controlOutline: Kv(i.colorPrimaryBg, i.colorBgContainer),
      lineType: i.lineType,
      borderRadius: i.borderRadius,
      borderRadiusXS: i.borderRadiusXS,
      borderRadiusSM: i.borderRadiusSM,
      borderRadiusLG: i.borderRadiusLG,
      fontWeightStrong: 600,
      opacityLoading: 0.65,
      linkDecoration: "none",
      linkHoverDecoration: "none",
      linkFocusDecoration: "none",
      controlPaddingHorizontal: 12,
      controlPaddingHorizontalSM: 8,
      paddingXXS: i.sizeXXS,
      paddingXS: i.sizeXS,
      paddingSM: i.sizeSM,
      padding: i.size,
      paddingMD: i.sizeMD,
      paddingLG: i.sizeLG,
      paddingXL: i.sizeXL,
      paddingContentHorizontalLG: i.sizeLG,
      paddingContentVerticalLG: i.sizeMS,
      paddingContentHorizontal: i.sizeMS,
      paddingContentVertical: i.sizeSM,
      paddingContentHorizontalSM: i.size,
      paddingContentVerticalSM: i.sizeXS,
      marginXXS: i.sizeXXS,
      marginXS: i.sizeXS,
      marginSM: i.sizeSM,
      margin: i.size,
      marginMD: i.sizeMD,
      marginLG: i.sizeLG,
      marginXL: i.sizeXL,
      marginXXL: i.sizeXXL,
      boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
      screenXS: o,
      screenXSMin: o,
      screenXSMax: a - 1,
      screenSM: a,
      screenSMMin: a,
      screenSMMax: s - 1,
      screenMD: s,
      screenMDMin: s,
      screenMDMax: l - 1,
      screenLG: l,
      screenLGMin: l,
      screenLGMax: c - 1,
      screenXL: c,
      screenXLMin: c,
      screenXLMax: u - 1,
      screenXXL: u,
      screenXXLMin: u,
      boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
      boxShadowCard: `
      0 1px 2px -2px ${new Mo("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new Mo("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new Mo("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
      boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)",
    }),
    r
  );
}
var fI = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const ok = {
    lineHeight: !0,
    lineHeightSM: !0,
    lineHeightLG: !0,
    lineHeightHeading1: !0,
    lineHeightHeading2: !0,
    lineHeightHeading3: !0,
    lineHeightHeading4: !0,
    lineHeightHeading5: !0,
    opacityLoading: !0,
    fontWeightStrong: !0,
    zIndexPopupBase: !0,
    zIndexBase: !0,
  },
  ak = {
    size: !0,
    sizeSM: !0,
    sizeLG: !0,
    sizeMD: !0,
    sizeXS: !0,
    sizeXXS: !0,
    sizeMS: !0,
    sizeXL: !0,
    sizeXXL: !0,
    sizeUnit: !0,
    sizeStep: !0,
    motionBase: !0,
    motionUnit: !0,
  },
  LQ = {
    screenXS: !0,
    screenXSMin: !0,
    screenXSMax: !0,
    screenSM: !0,
    screenSMMin: !0,
    screenSMMax: !0,
    screenMD: !0,
    screenMDMin: !0,
    screenMDMax: !0,
    screenLG: !0,
    screenLGMin: !0,
    screenLGMax: !0,
    screenXL: !0,
    screenXLMin: !0,
    screenXLMax: !0,
    screenXXL: !0,
    screenXXLMin: !0,
  },
  sk = (t, e, n) => {
    const r = n.getDerivativeToken(t),
      { override: i } = e,
      o = fI(e, ["override"]);
    let a = Object.assign(Object.assign({}, r), { override: i });
    return (
      (a = ik(a)),
      o &&
        Object.entries(o).forEach((s) => {
          let [l, c] = s;
          const { theme: u } = c,
            d = fI(c, ["theme"]);
          let p = d;
          u &&
            (p = sk(
              Object.assign(Object.assign({}, a), d),
              { override: d },
              u
            )),
            (a[l] = p);
        }),
      a
    );
  };
function is() {
  const {
      token: t,
      hashed: e,
      theme: n,
      override: r,
      cssVar: i,
    } = at.useContext(nk),
    o = `${PQ}-${e || ""}`,
    a = n || ek,
    [s, l, c] = rZ(a, [Jp, t], {
      salt: o,
      override: r,
      getComputedToken: sk,
      formatToken: ik,
      cssVar: i && {
        prefix: i.prefix,
        key: i.key,
        unitless: ok,
        ignore: ak,
        preserve: LQ,
      },
    });
  return [a, c, e ? l : "", s, i];
}
function Yo(t) {
  var e = E.useRef();
  e.current = t;
  var n = E.useCallback(function () {
    for (var r, i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    return (r = e.current) === null || r === void 0
      ? void 0
      : r.call.apply(r, [e].concat(o));
  }, []);
  return n;
}
function ef(t) {
  var e = E.useRef(!1),
    n = E.useState(t),
    r = Ve(n, 2),
    i = r[0],
    o = r[1];
  E.useEffect(function () {
    return (
      (e.current = !1),
      function () {
        e.current = !0;
      }
    );
  }, []);
  function a(s, l) {
    (l && e.current) || o(s);
  }
  return [i, a];
}
function U_(t) {
  return t !== void 0;
}
function ta(t, e) {
  var n = e || {},
    r = n.defaultValue,
    i = n.value,
    o = n.onChange,
    a = n.postState,
    s = ef(function () {
      return U_(i)
        ? i
        : U_(r)
        ? typeof r == "function"
          ? r()
          : r
        : typeof t == "function"
        ? t()
        : t;
    }),
    l = Ve(s, 2),
    c = l[0],
    u = l[1],
    d = i !== void 0 ? i : c,
    p = a ? a(d) : d,
    m = Yo(o),
    v = ef([d]),
    S = Ve(v, 2),
    x = S[0],
    g = S[1];
  uE(
    function () {
      var y = x[0];
      c !== y && m(c, y);
    },
    [x]
  ),
    uE(
      function () {
        U_(i) || u(i);
      },
      [i]
    );
  var _ = Yo(function (y, w) {
    u(y, w), g([d], w);
  });
  return [p, _];
}
const o2 = {
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis",
  },
  os = function (t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return {
      boxSizing: "border-box",
      margin: 0,
      padding: 0,
      color: t.colorText,
      fontSize: t.fontSize,
      lineHeight: t.lineHeight,
      listStyle: "none",
      fontFamily: e ? "inherit" : t.fontFamily,
    };
  },
  OQ = () => ({
    display: "inline-flex",
    alignItems: "center",
    color: "inherit",
    fontStyle: "normal",
    lineHeight: 0,
    textAlign: "center",
    textTransform: "none",
    verticalAlign: "-0.125em",
    textRendering: "optimizeLegibility",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "> *": { lineHeight: 1 },
    svg: { display: "inline-block" },
  }),
  Tm = () => ({
    "&::before": { display: "table", content: '""' },
    "&::after": { display: "table", clear: "both", content: '""' },
  }),
  NQ = (t) => ({
    a: {
      color: t.colorLink,
      textDecoration: t.linkDecoration,
      backgroundColor: "transparent",
      outline: "none",
      cursor: "pointer",
      transition: `color ${t.motionDurationSlow}`,
      "-webkit-text-decoration-skip": "objects",
      "&:hover": { color: t.colorLinkHover },
      "&:active": { color: t.colorLinkActive },
      "&:active,\n  &:hover": {
        textDecoration: t.linkHoverDecoration,
        outline: 0,
      },
      "&:focus": { textDecoration: t.linkFocusDecoration, outline: 0 },
      "&[disabled]": { color: t.colorTextDisabled, cursor: "not-allowed" },
    },
  }),
  FQ = (t, e) => {
    const { fontFamily: n, fontSize: r } = t,
      i = `[class^="${e}"], [class*=" ${e}"]`;
    return {
      [i]: {
        fontFamily: n,
        fontSize: r,
        boxSizing: "border-box",
        "&::before, &::after": { boxSizing: "border-box" },
        [i]: {
          boxSizing: "border-box",
          "&::before, &::after": { boxSizing: "border-box" },
        },
      },
    };
  },
  a2 = (t) => ({
    outline: `${Ze(t.lineWidthFocus)} solid ${t.colorPrimaryBorder}`,
    outlineOffset: 1,
    transition: "outline-offset 0s, outline 0s",
  }),
  s2 = (t) => ({ "&:focus-visible": Object.assign({}, a2(t)) });
let DQ = io(function t() {
  ro(this, t);
});
const lk = DQ;
function zQ(t, e, n) {
  return (
    (e = Gl(e)),
    ZC(
      t,
      V1() ? Reflect.construct(e, n || [], Gl(t).constructor) : e.apply(t, n)
    )
  );
}
let UQ = (function (t) {
  Eu(e, t);
  function e(n) {
    var r;
    return (
      ro(this, e),
      (r = zQ(this, e)),
      (r.result = 0),
      n instanceof e
        ? (r.result = n.result)
        : typeof n == "number" && (r.result = n),
      r
    );
  }
  return (
    io(e, [
      {
        key: "add",
        value: function (r) {
          return (
            r instanceof e
              ? (this.result += r.result)
              : typeof r == "number" && (this.result += r),
            this
          );
        },
      },
      {
        key: "sub",
        value: function (r) {
          return (
            r instanceof e
              ? (this.result -= r.result)
              : typeof r == "number" && (this.result -= r),
            this
          );
        },
      },
      {
        key: "mul",
        value: function (r) {
          return (
            r instanceof e
              ? (this.result *= r.result)
              : typeof r == "number" && (this.result *= r),
            this
          );
        },
      },
      {
        key: "div",
        value: function (r) {
          return (
            r instanceof e
              ? (this.result /= r.result)
              : typeof r == "number" && (this.result /= r),
            this
          );
        },
      },
      {
        key: "equal",
        value: function () {
          return this.result;
        },
      },
    ]),
    e
  );
})(lk);
function kQ(t, e, n) {
  return (
    (e = Gl(e)),
    ZC(
      t,
      V1() ? Reflect.construct(e, n || [], Gl(t).constructor) : e.apply(t, n)
    )
  );
}
const ck = "CALC_UNIT";
function k_(t) {
  return typeof t == "number" ? `${t}${ck}` : t;
}
let BQ = (function (t) {
  Eu(e, t);
  function e(n) {
    var r;
    return (
      ro(this, e),
      (r = kQ(this, e)),
      (r.result = ""),
      n instanceof e
        ? (r.result = `(${n.result})`)
        : typeof n == "number"
        ? (r.result = k_(n))
        : typeof n == "string" && (r.result = n),
      r
    );
  }
  return (
    io(e, [
      {
        key: "add",
        value: function (r) {
          return (
            r instanceof e
              ? (this.result = `${this.result} + ${r.getResult()}`)
              : (typeof r == "number" || typeof r == "string") &&
                (this.result = `${this.result} + ${k_(r)}`),
            (this.lowPriority = !0),
            this
          );
        },
      },
      {
        key: "sub",
        value: function (r) {
          return (
            r instanceof e
              ? (this.result = `${this.result} - ${r.getResult()}`)
              : (typeof r == "number" || typeof r == "string") &&
                (this.result = `${this.result} - ${k_(r)}`),
            (this.lowPriority = !0),
            this
          );
        },
      },
      {
        key: "mul",
        value: function (r) {
          return (
            this.lowPriority && (this.result = `(${this.result})`),
            r instanceof e
              ? (this.result = `${this.result} * ${r.getResult(!0)}`)
              : (typeof r == "number" || typeof r == "string") &&
                (this.result = `${this.result} * ${r}`),
            (this.lowPriority = !1),
            this
          );
        },
      },
      {
        key: "div",
        value: function (r) {
          return (
            this.lowPriority && (this.result = `(${this.result})`),
            r instanceof e
              ? (this.result = `${this.result} / ${r.getResult(!0)}`)
              : (typeof r == "number" || typeof r == "string") &&
                (this.result = `${this.result} / ${r}`),
            (this.lowPriority = !1),
            this
          );
        },
      },
      {
        key: "getResult",
        value: function (r) {
          return this.lowPriority || r ? `(${this.result})` : this.result;
        },
      },
      {
        key: "equal",
        value: function (r) {
          const { unit: i = !0 } = r || {},
            o = new RegExp(`${ck}`, "g");
          return (
            (this.result = this.result.replace(o, i ? "px" : "")),
            typeof this.lowPriority < "u" ? `calc(${this.result})` : this.result
          );
        },
      },
    ]),
    e
  );
})(lk);
const HQ = (t) => {
  const e = t === "css" ? BQ : UQ;
  return (n) => new e(n);
};
function jQ(t) {
  return t === "js"
    ? { max: Math.max, min: Math.min }
    : {
        max: function () {
          for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
            n[r] = arguments[r];
          return `max(${n.map((i) => Ze(i)).join(",")})`;
        },
        min: function () {
          for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
            n[r] = arguments[r];
          return `min(${n.map((i) => Ze(i)).join(",")})`;
        },
      };
}
const uk = typeof CSSINJS_STATISTIC < "u";
let _E = !0;
function xi() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  if (!uk) return Object.assign.apply(Object, [{}].concat(e));
  _E = !1;
  const r = {};
  return (
    e.forEach((i) => {
      Object.keys(i).forEach((a) => {
        Object.defineProperty(r, a, {
          configurable: !0,
          enumerable: !0,
          get: () => i[a],
        });
      });
    }),
    (_E = !0),
    r
  );
}
const hI = {};
function VQ() {}
const $Q = (t) => {
    let e,
      n = t,
      r = VQ;
    return (
      uk &&
        typeof Proxy < "u" &&
        ((e = new Set()),
        (n = new Proxy(t, {
          get(i, o) {
            return _E && e.add(o), i[o];
          },
        })),
        (r = (i, o) => {
          var a;
          hI[i] = {
            global: Array.from(e),
            component: Object.assign(
              Object.assign(
                {},
                (a = hI[i]) === null || a === void 0 ? void 0 : a.component
              ),
              o
            ),
          };
        })),
      { token: n, keys: e, flush: r }
    );
  },
  dk = (t, e) => {
    const [n, r] = is();
    return mE(
      {
        theme: n,
        token: r,
        hashId: "",
        path: ["ant-design-icons", t],
        nonce: () => (e == null ? void 0 : e.nonce),
      },
      () => [
        {
          [`.${t}`]: Object.assign(Object.assign({}, OQ()), {
            [`.${t} .${t}-icon`]: { display: "block" },
          }),
        },
      ]
    );
  },
  fk = (t, e, n) => {
    var r;
    return typeof n == "function"
      ? n(xi(e, (r = e[t]) !== null && r !== void 0 ? r : {}))
      : n ?? {};
  },
  hk = (t, e, n, r) => {
    const i = Object.assign({}, e[t]);
    if (r != null && r.deprecatedTokens) {
      const { deprecatedTokens: a } = r;
      a.forEach((s) => {
        let [l, c] = s;
        var u;
        ((i != null && i[l]) || (i != null && i[c])) &&
          (((u = i[c]) !== null && u !== void 0) ||
            (i[c] = i == null ? void 0 : i[l]));
      });
    }
    const o = Object.assign(Object.assign({}, n), i);
    return (
      Object.keys(o).forEach((a) => {
        o[a] === e[a] && delete o[a];
      }),
      o
    );
  },
  GQ = (t, e) =>
    `${[
      e,
      t
        .replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2")
        .replace(/([a-z])([A-Z])/g, "$1-$2"),
    ]
      .filter(Boolean)
      .join("-")}`;
function l2(t, e, n) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const i = Array.isArray(t) ? t : [t, t],
    [o] = i,
    a = i.join("-");
  return (s) => {
    const [l, c, u, d, p] = is(),
      { getPrefixCls: m, iconPrefixCls: v, csp: S } = E.useContext(Rn),
      x = m(),
      g = p ? "css" : "js",
      _ = HQ(g),
      { max: y, min: w } = jQ(g),
      A = {
        theme: l,
        token: d,
        hashId: u,
        nonce: () => (S == null ? void 0 : S.nonce),
        clientOnly: r.clientOnly,
        order: r.order || -999,
      };
    return (
      mE(
        Object.assign(Object.assign({}, A), {
          clientOnly: !1,
          path: ["Shared", x],
        }),
        () => [{ "&": NQ(d) }]
      ),
      dk(v, S),
      [
        mE(Object.assign(Object.assign({}, A), { path: [a, s, v] }), () => {
          if (r.injectStyle === !1) return [];
          const { token: T, flush: I } = $Q(d),
            R = fk(o, c, n),
            P = `.${s}`,
            F = hk(o, c, R, { deprecatedTokens: r.deprecatedTokens });
          p &&
            Object.keys(R).forEach((N) => {
              R[N] = `var(${IU(N, GQ(o, p.prefix))})`;
            });
          const D = xi(
              T,
              {
                componentCls: P,
                prefixCls: s,
                iconCls: `.${v}`,
                antCls: `.${x}`,
                calc: _,
                max: y,
                min: w,
              },
              p ? R : F
            ),
            j = e(D, {
              hashId: u,
              prefixCls: s,
              rootPrefixCls: x,
              iconPrefixCls: v,
            });
          return I(o, F), [r.resetStyle === !1 ? null : FQ(D, s), j];
        }),
        u,
      ]
    );
  };
}
const WQ = (t, e, n, r) => {
    const i = l2(t, e, n, Object.assign({ resetStyle: !1, order: -998 }, r));
    return (a) => {
      let { prefixCls: s } = a;
      return i(s), null;
    };
  },
  XQ = (t, e, n) => {
    function r(c) {
      return `${t}${c.slice(0, 1).toUpperCase()}${c.slice(1)}`;
    }
    const { unitless: i = {}, injectStyle: o = !0 } = n ?? {},
      a = { [r("zIndexPopup")]: !0 };
    Object.keys(i).forEach((c) => {
      a[r(c)] = i[c];
    });
    const s = (c) => {
      let { rootCls: u, cssVar: d } = c;
      const [, p] = is();
      return (
        IZ(
          {
            path: [t],
            prefix: d.prefix,
            key: d == null ? void 0 : d.key,
            unitless: Object.assign(Object.assign({}, ok), a),
            ignore: ak,
            token: p,
            scope: u,
          },
          () => {
            const m = fk(t, p, e),
              v = hk(t, p, m, {
                deprecatedTokens: n == null ? void 0 : n.deprecatedTokens,
              });
            return (
              Object.keys(m).forEach((S) => {
                (v[r(S)] = v[S]), delete v[S];
              }),
              v
            );
          }
        ),
        null
      );
    };
    return (c) => {
      const [, , , , u] = is();
      return [
        (d) =>
          o && u
            ? at.createElement(
                at.Fragment,
                null,
                at.createElement(s, { rootCls: c, cssVar: u, component: t }),
                d
              )
            : d,
        u == null ? void 0 : u.key,
      ];
    };
  },
  ec = (t, e, n, r) => {
    const i = l2(t, e, n, r),
      o = XQ(Array.isArray(t) ? t[0] : t, n, r);
    return function (a) {
      let s =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : a;
      const [, l] = i(a),
        [c, u] = o(s);
      return [c, l, u];
    };
  };
function qQ(t, e) {
  return Ey.reduce((n, r) => {
    const i = t[`${r}1`],
      o = t[`${r}3`],
      a = t[`${r}6`],
      s = t[`${r}7`];
    return Object.assign(
      Object.assign({}, n),
      e(r, { lightColor: i, lightBorderColor: o, darkColor: a, textColor: s })
    );
  }, {});
}
const KQ = Object.assign({}, ru),
  { useId: pI } = KQ,
  YQ = () => "",
  ZQ = typeof pI > "u" ? YQ : pI;
function QQ(t, e) {
  XU();
  const n = t || {},
    r = n.inherit === !1 || !e ? tk : e,
    i = ZQ();
  return H1(
    () => {
      var o, a;
      if (!t) return e;
      const s = Object.assign({}, r.components);
      Object.keys(t.components || {}).forEach((u) => {
        s[u] = Object.assign(Object.assign({}, s[u]), t.components[u]);
      });
      const l = `css-var-${i.replace(/:/g, "")}`,
        c =
          ((o = n.cssVar) !== null && o !== void 0 ? o : r.cssVar) &&
          Object.assign(
            Object.assign(
              Object.assign(
                { prefix: "ant" },
                typeof r.cssVar == "object" ? r.cssVar : {}
              ),
              typeof n.cssVar == "object" ? n.cssVar : {}
            ),
            {
              key:
                (typeof n.cssVar == "object" &&
                  ((a = n.cssVar) === null || a === void 0 ? void 0 : a.key)) ||
                l,
            }
          );
      return Object.assign(Object.assign(Object.assign({}, r), n), {
        token: Object.assign(Object.assign({}, r.token), n.token),
        components: s,
        cssVar: c,
      });
    },
    [n, r],
    (o, a) =>
      o.some((s, l) => {
        const c = a[l];
        return !G1(s, c, !0);
      })
  );
}
var JQ = ["children"],
  pk = E.createContext({});
function eJ(t) {
  var e = t.children,
    n = on(t, JQ);
  return E.createElement(pk.Provider, { value: n }, e);
}
var tJ = (function (t) {
    Eu(n, t);
    var e = Mm(n);
    function n() {
      return ro(this, n), e.apply(this, arguments);
    }
    return (
      io(n, [
        {
          key: "render",
          value: function () {
            return this.props.children;
          },
        },
      ]),
      n
    );
  })(E.Component),
  Lc = "none",
  Yv = "appear",
  Zv = "enter",
  Qv = "leave",
  mI = "none",
  xa = "prepare",
  Gd = "start",
  Wd = "active",
  c2 = "end",
  mk = "prepared";
function gI(t, e) {
  var n = {};
  return (
    (n[t.toLowerCase()] = e.toLowerCase()),
    (n["Webkit".concat(t)] = "webkit".concat(e)),
    (n["Moz".concat(t)] = "moz".concat(e)),
    (n["ms".concat(t)] = "MS".concat(e)),
    (n["O".concat(t)] = "o".concat(e.toLowerCase())),
    n
  );
}
function nJ(t, e) {
  var n = {
    animationend: gI("Animation", "AnimationEnd"),
    transitionend: gI("Transition", "TransitionEnd"),
  };
  return (
    t &&
      ("AnimationEvent" in e || delete n.animationend.animation,
      "TransitionEvent" in e || delete n.transitionend.transition),
    n
  );
}
var rJ = nJ(to(), typeof window < "u" ? window : {}),
  gk = {};
if (to()) {
  var iJ = document.createElement("div");
  gk = iJ.style;
}
var Jv = {};
function vk(t) {
  if (Jv[t]) return Jv[t];
  var e = rJ[t];
  if (e)
    for (var n = Object.keys(e), r = n.length, i = 0; i < r; i += 1) {
      var o = n[i];
      if (Object.prototype.hasOwnProperty.call(e, o) && o in gk)
        return (Jv[t] = e[o]), Jv[t];
    }
  return "";
}
var yk = vk("animationend"),
  xk = vk("transitionend"),
  Sk = !!(yk && xk),
  vI = yk || "animationend",
  yI = xk || "transitionend";
function xI(t, e) {
  if (!t) return null;
  if (un(t) === "object") {
    var n = e.replace(/-\w/g, function (r) {
      return r[1].toUpperCase();
    });
    return t[n];
  }
  return "".concat(t, "-").concat(e);
}
const oJ = function (t) {
  var e = E.useRef(),
    n = E.useRef(t);
  n.current = t;
  var r = E.useCallback(function (a) {
    n.current(a);
  }, []);
  function i(a) {
    a && (a.removeEventListener(yI, r), a.removeEventListener(vI, r));
  }
  function o(a) {
    e.current && e.current !== a && i(e.current),
      a &&
        a !== e.current &&
        (a.addEventListener(yI, r), a.addEventListener(vI, r), (e.current = a));
  }
  return (
    E.useEffect(function () {
      return function () {
        i(e.current);
      };
    }, []),
    [o, i]
  );
};
var _k = to() ? E.useLayoutEffect : E.useEffect;
const aJ = function () {
  var t = E.useRef(null);
  function e() {
    Er.cancel(t.current);
  }
  function n(r) {
    var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    e();
    var o = Er(function () {
      i <= 1
        ? r({
            isCanceled: function () {
              return o !== t.current;
            },
          })
        : n(r, i - 1);
    });
    t.current = o;
  }
  return (
    E.useEffect(function () {
      return function () {
        e();
      };
    }, []),
    [n, e]
  );
};
var sJ = [xa, Gd, Wd, c2],
  lJ = [xa, mk],
  bk = !1,
  cJ = !0;
function wk(t) {
  return t === Wd || t === c2;
}
const uJ = function (t, e, n) {
  var r = ef(mI),
    i = Ve(r, 2),
    o = i[0],
    a = i[1],
    s = aJ(),
    l = Ve(s, 2),
    c = l[0],
    u = l[1];
  function d() {
    a(xa, !0);
  }
  var p = e ? lJ : sJ;
  return (
    _k(
      function () {
        if (o !== mI && o !== c2) {
          var m = p.indexOf(o),
            v = p[m + 1],
            S = n(o);
          S === bk
            ? a(v, !0)
            : v &&
              c(function (x) {
                function g() {
                  x.isCanceled() || a(v, !0);
                }
                S === !0 ? g() : Promise.resolve(S).then(g);
              });
        }
      },
      [t, o]
    ),
    E.useEffect(function () {
      return function () {
        u();
      };
    }, []),
    [d, o]
  );
};
function dJ(t, e, n, r) {
  var i = r.motionEnter,
    o = i === void 0 ? !0 : i,
    a = r.motionAppear,
    s = a === void 0 ? !0 : a,
    l = r.motionLeave,
    c = l === void 0 ? !0 : l,
    u = r.motionDeadline,
    d = r.motionLeaveImmediately,
    p = r.onAppearPrepare,
    m = r.onEnterPrepare,
    v = r.onLeavePrepare,
    S = r.onAppearStart,
    x = r.onEnterStart,
    g = r.onLeaveStart,
    _ = r.onAppearActive,
    y = r.onEnterActive,
    w = r.onLeaveActive,
    A = r.onAppearEnd,
    M = r.onEnterEnd,
    T = r.onLeaveEnd,
    I = r.onVisibleChanged,
    R = ef(),
    P = Ve(R, 2),
    F = P[0],
    D = P[1],
    j = ef(Lc),
    N = Ve(j, 2),
    V = N[0],
    W = N[1],
    Q = ef(null),
    B = Ve(Q, 2),
    $ = B[0],
    G = B[1],
    k = E.useRef(!1),
    q = E.useRef(null);
  function X() {
    return n();
  }
  var ee = E.useRef(!1);
  function J() {
    W(Lc, !0), G(null, !0);
  }
  function oe(H) {
    var z = X();
    if (!(H && !H.deadline && H.target !== z)) {
      var Z = ee.current,
        ge;
      V === Yv && Z
        ? (ge = A == null ? void 0 : A(z, H))
        : V === Zv && Z
        ? (ge = M == null ? void 0 : M(z, H))
        : V === Qv && Z && (ge = T == null ? void 0 : T(z, H)),
        V !== Lc && Z && ge !== !1 && J();
    }
  }
  var ae = oJ(oe),
    le = Ve(ae, 1),
    _e = le[0],
    me = function (z) {
      var Z, ge, ce;
      switch (z) {
        case Yv:
          return (Z = {}), be(Z, xa, p), be(Z, Gd, S), be(Z, Wd, _), Z;
        case Zv:
          return (ge = {}), be(ge, xa, m), be(ge, Gd, x), be(ge, Wd, y), ge;
        case Qv:
          return (ce = {}), be(ce, xa, v), be(ce, Gd, g), be(ce, Wd, w), ce;
        default:
          return {};
      }
    },
    se = E.useMemo(
      function () {
        return me(V);
      },
      [V]
    ),
    Y = uJ(V, !t, function (H) {
      if (H === xa) {
        var z = se[xa];
        return z ? z(X()) : bk;
      }
      if (ue in se) {
        var Z;
        G(
          ((Z = se[ue]) === null || Z === void 0
            ? void 0
            : Z.call(se, X(), null)) || null
        );
      }
      return (
        ue === Wd &&
          (_e(X()),
          u > 0 &&
            (clearTimeout(q.current),
            (q.current = setTimeout(function () {
              oe({ deadline: !0 });
            }, u)))),
        ue === mk && J(),
        cJ
      );
    }),
    ve = Ve(Y, 2),
    de = ve[0],
    ue = ve[1],
    fe = wk(ue);
  (ee.current = fe),
    _k(
      function () {
        D(e);
        var H = k.current;
        k.current = !0;
        var z;
        !H && e && s && (z = Yv),
          H && e && o && (z = Zv),
          ((H && !e && c) || (!H && d && !e && c)) && (z = Qv);
        var Z = me(z);
        z && (t || Z[xa]) ? (W(z), de()) : W(Lc);
      },
      [e]
    ),
    E.useEffect(
      function () {
        ((V === Yv && !s) || (V === Zv && !o) || (V === Qv && !c)) && W(Lc);
      },
      [s, o, c]
    ),
    E.useEffect(function () {
      return function () {
        (k.current = !1), clearTimeout(q.current);
      };
    }, []);
  var Te = E.useRef(!1);
  E.useEffect(
    function () {
      F && (Te.current = !0),
        F !== void 0 &&
          V === Lc &&
          ((Te.current || F) && (I == null || I(F)), (Te.current = !0));
    },
    [F, V]
  );
  var pe = $;
  return (
    se[xa] && ue === Gd && (pe = De({ transition: "none" }, pe)),
    [V, ue, pe, F ?? e]
  );
}
function fJ(t) {
  var e = t;
  un(t) === "object" && (e = t.transitionSupport);
  function n(i, o) {
    return !!(i.motionName && e && o !== !1);
  }
  var r = E.forwardRef(function (i, o) {
    var a = i.visible,
      s = a === void 0 ? !0 : a,
      l = i.removeOnLeave,
      c = l === void 0 ? !0 : l,
      u = i.forceRender,
      d = i.children,
      p = i.motionName,
      m = i.leavedClassName,
      v = i.eventProps,
      S = E.useContext(pk),
      x = S.motion,
      g = n(i, x),
      _ = E.useRef(),
      y = E.useRef();
    function w() {
      try {
        return _.current instanceof HTMLElement ? _.current : C0(y.current);
      } catch {
        return null;
      }
    }
    var A = dJ(g, s, w, i),
      M = Ve(A, 4),
      T = M[0],
      I = M[1],
      R = M[2],
      P = M[3],
      F = E.useRef(P);
    P && (F.current = !0);
    var D = E.useCallback(
        function (G) {
          (_.current = G), YC(o, G);
        },
        [o]
      ),
      j,
      N = De(De({}, v), {}, { visible: s });
    if (!d) j = null;
    else if (T === Lc)
      P
        ? (j = d(De({}, N), D))
        : !c && F.current && m
        ? (j = d(De(De({}, N), {}, { className: m }), D))
        : u || (!c && !m)
        ? (j = d(De(De({}, N), {}, { style: { display: "none" } }), D))
        : (j = null);
    else {
      var V, W;
      I === xa
        ? (W = "prepare")
        : wk(I)
        ? (W = "active")
        : I === Gd && (W = "start");
      var Q = xI(p, "".concat(T, "-").concat(W));
      j = d(
        De(
          De({}, N),
          {},
          {
            className: nt(
              xI(p, T),
              ((V = {}), be(V, Q, Q && W), be(V, p, typeof p == "string"), V)
            ),
            style: R,
          }
        ),
        D
      );
    }
    if (E.isValidElement(j) && wu(j)) {
      var B = j,
        $ = B.ref;
      $ || (j = E.cloneElement(j, { ref: D }));
    }
    return E.createElement(tJ, { ref: y }, j);
  });
  return (r.displayName = "CSSMotion"), r;
}
const Mu = fJ(Sk);
var bE = "add",
  wE = "keep",
  EE = "remove",
  B_ = "removed";
function hJ(t) {
  var e;
  return (
    t && un(t) === "object" && "key" in t ? (e = t) : (e = { key: t }),
    De(De({}, e), {}, { key: String(e.key) })
  );
}
function ME() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return t.map(hJ);
}
function pJ() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
    e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
    n = [],
    r = 0,
    i = e.length,
    o = ME(t),
    a = ME(e);
  o.forEach(function (c) {
    for (var u = !1, d = r; d < i; d += 1) {
      var p = a[d];
      if (p.key === c.key) {
        r < d &&
          ((n = n.concat(
            a.slice(r, d).map(function (m) {
              return De(De({}, m), {}, { status: bE });
            })
          )),
          (r = d)),
          n.push(De(De({}, p), {}, { status: wE })),
          (r += 1),
          (u = !0);
        break;
      }
    }
    u || n.push(De(De({}, c), {}, { status: EE }));
  }),
    r < i &&
      (n = n.concat(
        a.slice(r).map(function (c) {
          return De(De({}, c), {}, { status: bE });
        })
      ));
  var s = {};
  n.forEach(function (c) {
    var u = c.key;
    s[u] = (s[u] || 0) + 1;
  });
  var l = Object.keys(s).filter(function (c) {
    return s[c] > 1;
  });
  return (
    l.forEach(function (c) {
      (n = n.filter(function (u) {
        var d = u.key,
          p = u.status;
        return d !== c || p !== EE;
      })),
        n.forEach(function (u) {
          u.key === c && (u.status = wE);
        });
    }),
    n
  );
}
var mJ = ["component", "children", "onVisibleChanged", "onAllRemoved"],
  gJ = ["status"],
  vJ = [
    "eventProps",
    "visible",
    "children",
    "motionName",
    "motionAppear",
    "motionEnter",
    "motionLeave",
    "motionLeaveImmediately",
    "motionDeadline",
    "removeOnLeave",
    "leavedClassName",
    "onAppearPrepare",
    "onAppearStart",
    "onAppearActive",
    "onAppearEnd",
    "onEnterStart",
    "onEnterActive",
    "onEnterEnd",
    "onLeaveStart",
    "onLeaveActive",
    "onLeaveEnd",
  ];
function yJ(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Mu,
    n = (function (r) {
      Eu(o, r);
      var i = Mm(o);
      function o() {
        var a;
        ro(this, o);
        for (var s = arguments.length, l = new Array(s), c = 0; c < s; c++)
          l[c] = arguments[c];
        return (
          (a = i.call.apply(i, [this].concat(l))),
          be(hn(a), "state", { keyEntities: [] }),
          be(hn(a), "removeKey", function (u) {
            var d = a.state.keyEntities,
              p = d.map(function (m) {
                return m.key !== u ? m : De(De({}, m), {}, { status: B_ });
              });
            return (
              a.setState({ keyEntities: p }),
              p.filter(function (m) {
                var v = m.status;
                return v !== B_;
              }).length
            );
          }),
          a
        );
      }
      return (
        io(
          o,
          [
            {
              key: "render",
              value: function () {
                var s = this,
                  l = this.state.keyEntities,
                  c = this.props,
                  u = c.component,
                  d = c.children,
                  p = c.onVisibleChanged,
                  m = c.onAllRemoved,
                  v = on(c, mJ),
                  S = u || E.Fragment,
                  x = {};
                return (
                  vJ.forEach(function (g) {
                    (x[g] = v[g]), delete v[g];
                  }),
                  delete v.keys,
                  E.createElement(
                    S,
                    v,
                    l.map(function (g, _) {
                      var y = g.status,
                        w = on(g, gJ),
                        A = y === bE || y === wE;
                      return E.createElement(
                        e,
                        Et({}, x, {
                          key: w.key,
                          visible: A,
                          eventProps: w,
                          onVisibleChanged: function (T) {
                            if ((p == null || p(T, { key: w.key }), !T)) {
                              var I = s.removeKey(w.key);
                              I === 0 && m && m();
                            }
                          },
                        }),
                        function (M, T) {
                          return d(De(De({}, M), {}, { index: _ }), T);
                        }
                      );
                    })
                  )
                );
              },
            },
          ],
          [
            {
              key: "getDerivedStateFromProps",
              value: function (s, l) {
                var c = s.keys,
                  u = l.keyEntities,
                  d = ME(c),
                  p = pJ(u, d);
                return {
                  keyEntities: p.filter(function (m) {
                    var v = u.find(function (S) {
                      var x = S.key;
                      return m.key === x;
                    });
                    return !(v && v.status === B_ && m.status === EE);
                  }),
                };
              },
            },
          ]
        ),
        o
      );
    })(E.Component);
  return be(n, "defaultProps", { component: "div" }), n;
}
yJ(Sk);
function xJ(t) {
  const { children: e } = t,
    [, n] = is(),
    { motion: r } = n,
    i = E.useRef(!1);
  return (
    (i.current = i.current || r === !1),
    i.current ? E.createElement(eJ, { motion: r }, e) : e
  );
}
const SJ = () => null;
var _J = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const bJ = [
    "getTargetContainer",
    "getPopupContainer",
    "renderEmpty",
    "input",
    "pagination",
    "form",
    "select",
    "button",
  ],
  wJ = "ant";
let Ek;
function EJ() {
  return Ek || wJ;
}
function MJ(t) {
  return Object.keys(t).some((e) => e.endsWith("Color"));
}
const CJ = (t) => {
    const { prefixCls: e, iconPrefixCls: n, theme: r, holderRender: i } = t;
    e !== void 0 && (Ek = e), r && MJ(r) && CQ(EJ(), r);
  },
  TJ = (t) => {
    const {
        children: e,
        csp: n,
        autoInsertSpaceInButton: r,
        alert: i,
        anchor: o,
        form: a,
        locale: s,
        componentSize: l,
        direction: c,
        space: u,
        virtual: d,
        dropdownMatchSelectWidth: p,
        popupMatchSelectWidth: m,
        popupOverflow: v,
        legacyLocale: S,
        parentContext: x,
        iconPrefixCls: g,
        theme: _,
        componentDisabled: y,
        segmented: w,
        statistic: A,
        spin: M,
        calendar: T,
        carousel: I,
        cascader: R,
        collapse: P,
        typography: F,
        checkbox: D,
        descriptions: j,
        divider: N,
        drawer: V,
        skeleton: W,
        steps: Q,
        image: B,
        layout: $,
        list: G,
        mentions: k,
        modal: q,
        progress: X,
        result: ee,
        slider: J,
        breadcrumb: oe,
        menu: ae,
        pagination: le,
        input: _e,
        empty: me,
        badge: se,
        radio: Y,
        rate: ve,
        switch: de,
        transfer: ue,
        avatar: fe,
        message: Te,
        tag: pe,
        table: H,
        card: z,
        tabs: Z,
        timeline: ge,
        timePicker: ce,
        upload: he,
        notification: Me,
        tree: Re,
        colorPicker: Le,
        datePicker: Oe,
        rangePicker: Pe,
        flex: Se,
        wave: Je,
        dropdown: st,
        warning: Qe,
      } = t,
      Ke = E.useCallback(
        (Ue, Ye) => {
          const { prefixCls: ke } = t;
          if (Ye) return Ye;
          const tt = ke || x.getPrefixCls("");
          return Ue ? `${tt}-${Ue}` : tt;
        },
        [x.getPrefixCls, t.prefixCls]
      ),
      Ne = g || x.iconPrefixCls || rk,
      ne = n || x.csp;
    dk(Ne, ne);
    const Ie = QQ(_, x.theme),
      et = {
        csp: ne,
        autoInsertSpaceInButton: r,
        alert: i,
        anchor: o,
        locale: s || S,
        direction: c,
        space: u,
        virtual: d,
        popupMatchSelectWidth: m ?? p,
        popupOverflow: v,
        getPrefixCls: Ke,
        iconPrefixCls: Ne,
        theme: Ie,
        segmented: w,
        statistic: A,
        spin: M,
        calendar: T,
        carousel: I,
        cascader: R,
        collapse: P,
        typography: F,
        checkbox: D,
        descriptions: j,
        divider: N,
        drawer: V,
        skeleton: W,
        steps: Q,
        image: B,
        input: _e,
        layout: $,
        list: G,
        mentions: k,
        modal: q,
        progress: X,
        result: ee,
        slider: J,
        breadcrumb: oe,
        menu: ae,
        pagination: le,
        empty: me,
        badge: se,
        radio: Y,
        rate: ve,
        switch: de,
        transfer: ue,
        avatar: fe,
        message: Te,
        tag: pe,
        table: H,
        card: z,
        tabs: Z,
        timeline: ge,
        timePicker: ce,
        upload: he,
        notification: Me,
        tree: Re,
        colorPicker: Le,
        datePicker: Oe,
        rangePicker: Pe,
        flex: Se,
        wave: Je,
        dropdown: st,
        warning: Qe,
      },
      We = Object.assign({}, x);
    Object.keys(et).forEach((Ue) => {
      et[Ue] !== void 0 && (We[Ue] = et[Ue]);
    }),
      bJ.forEach((Ue) => {
        const Ye = t[Ue];
        Ye && (We[Ue] = Ye);
      });
    const Ee = H1(
        () => We,
        We,
        (Ue, Ye) => {
          const ke = Object.keys(Ue),
            tt = Object.keys(Ye);
          return ke.length !== tt.length || ke.some((ut) => Ue[ut] !== Ye[ut]);
        }
      ),
      ie = E.useMemo(() => ({ prefixCls: Ne, csp: ne }), [Ne, ne]);
    let $e = E.createElement(
      E.Fragment,
      null,
      E.createElement(SJ, { dropdownMatchSelectWidth: p }),
      e
    );
    const He = E.useMemo(() => {
      var Ue, Ye, ke, tt;
      return $d(
        ((Ue = K1.Form) === null || Ue === void 0
          ? void 0
          : Ue.defaultValidateMessages) || {},
        ((ke =
          (Ye = Ee.locale) === null || Ye === void 0 ? void 0 : Ye.Form) ===
          null || ke === void 0
          ? void 0
          : ke.defaultValidateMessages) || {},
        ((tt = Ee.form) === null || tt === void 0
          ? void 0
          : tt.validateMessages) || {},
        (a == null ? void 0 : a.validateMessages) || {}
      );
    }, [Ee, a == null ? void 0 : a.validateMessages]);
    Object.keys(He).length > 0 &&
      ($e = E.createElement(kZ.Provider, { value: He }, $e)),
      s && ($e = E.createElement(qZ, { locale: s, _ANT_MARK__: WZ }, $e)),
      (Ne || ne) && ($e = E.createElement(i2.Provider, { value: ie }, $e)),
      l && ($e = E.createElement(AQ, { size: l }, $e)),
      ($e = E.createElement(xJ, null, $e));
    const Xe = E.useMemo(() => {
      const Ue = Ie || {},
        { algorithm: Ye, token: ke, components: tt, cssVar: ut } = Ue,
        dt = _J(Ue, ["algorithm", "token", "components", "cssVar"]),
        Rt = Ye && (!Array.isArray(Ye) || Ye.length > 0) ? lE(Ye) : ek,
        Bt = {};
      Object.entries(tt || {}).forEach((dn) => {
        let [_n, gn] = dn;
        const Gt = Object.assign({}, gn);
        "algorithm" in Gt &&
          (Gt.algorithm === !0
            ? (Gt.theme = Rt)
            : (Array.isArray(Gt.algorithm) ||
                typeof Gt.algorithm == "function") &&
              (Gt.theme = lE(Gt.algorithm)),
          delete Gt.algorithm),
          (Bt[_n] = Gt);
      });
      const In = Object.assign(Object.assign({}, Jp), ke);
      return Object.assign(Object.assign({}, dt), {
        theme: Rt,
        token: In,
        components: Bt,
        override: Object.assign({ override: In }, Bt),
        cssVar: ut,
      });
    }, [Ie]);
    return (
      _ && ($e = E.createElement(nk.Provider, { value: Xe }, $e)),
      Ee.warning &&
        ($e = E.createElement(UZ.Provider, { value: Ee.warning }, $e)),
      y !== void 0 && ($e = E.createElement(TQ, { disabled: y }, $e)),
      E.createElement(Rn.Provider, { value: Ee }, $e)
    );
  },
  Am = (t) => {
    const e = E.useContext(Rn),
      n = E.useContext(KU);
    return E.createElement(
      TJ,
      Object.assign({ parentContext: e, legacyLocale: n }, t)
    );
  };
Am.ConfigContext = Rn;
Am.SizeContext = Y1;
Am.config = CJ;
Am.useConfig = RQ;
Object.defineProperty(Am, "SizeContext", { get: () => Y1 });
function Mk(t) {
  var e;
  return t == null || (e = t.getRootNode) === null || e === void 0
    ? void 0
    : e.call(t);
}
function AJ(t) {
  return Mk(t) instanceof ShadowRoot;
}
function My(t) {
  return AJ(t) ? Mk(t) : null;
}
function RJ(t) {
  return t.replace(/-(.)/g, function (e, n) {
    return n.toUpperCase();
  });
}
function PJ(t, e) {
  Ni(t, "[@ant-design/icons] ".concat(e));
}
function SI(t) {
  return (
    un(t) === "object" &&
    typeof t.name == "string" &&
    typeof t.theme == "string" &&
    (un(t.icon) === "object" || typeof t.icon == "function")
  );
}
function _I() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(t).reduce(function (e, n) {
    var r = t[n];
    switch (n) {
      case "class":
        (e.className = r), delete e.class;
        break;
      default:
        delete e[n], (e[RJ(n)] = r);
    }
    return e;
  }, {});
}
function CE(t, e, n) {
  return n
    ? at.createElement(
        t.tag,
        De(De({ key: e }, _I(t.attrs)), n),
        (t.children || []).map(function (r, i) {
          return CE(r, "".concat(e, "-").concat(t.tag, "-").concat(i));
        })
      )
    : at.createElement(
        t.tag,
        De({ key: e }, _I(t.attrs)),
        (t.children || []).map(function (r, i) {
          return CE(r, "".concat(e, "-").concat(t.tag, "-").concat(i));
        })
      );
}
function Ck(t) {
  return pu(t)[0];
}
function Tk(t) {
  return t ? (Array.isArray(t) ? t : [t]) : [];
}
var IJ = `
.anticon {
  display: inline-block;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`,
  LJ = function (e) {
    var n = E.useContext(i2),
      r = n.csp,
      i = n.prefixCls,
      o = IJ;
    i && (o = o.replace(/anticon/g, i)),
      E.useEffect(function () {
        var a = e.current,
          s = My(a);
        Wl(o, "@ant-design-icons", { prepend: !0, csp: r, attachTo: s });
      }, []);
  },
  OJ = [
    "icon",
    "className",
    "onClick",
    "style",
    "primaryColor",
    "secondaryColor",
  ],
  op = { primaryColor: "#333", secondaryColor: "#E6E6E6", calculated: !1 };
function NJ(t) {
  var e = t.primaryColor,
    n = t.secondaryColor;
  (op.primaryColor = e),
    (op.secondaryColor = n || Ck(e)),
    (op.calculated = !!n);
}
function FJ() {
  return De({}, op);
}
var Z1 = function (e) {
  var n = e.icon,
    r = e.className,
    i = e.onClick,
    o = e.style,
    a = e.primaryColor,
    s = e.secondaryColor,
    l = on(e, OJ),
    c = E.useRef(),
    u = op;
  if (
    (a && (u = { primaryColor: a, secondaryColor: s || Ck(a) }),
    LJ(c),
    PJ(SI(n), "icon should be icon definiton, but got ".concat(n)),
    !SI(n))
  )
    return null;
  var d = n;
  return (
    d &&
      typeof d.icon == "function" &&
      (d = De(
        De({}, d),
        {},
        { icon: d.icon(u.primaryColor, u.secondaryColor) }
      )),
    CE(
      d.icon,
      "svg-".concat(d.name),
      De(
        De(
          {
            className: r,
            onClick: i,
            style: o,
            "data-icon": d.name,
            width: "1em",
            height: "1em",
            fill: "currentColor",
            "aria-hidden": "true",
          },
          l
        ),
        {},
        { ref: c }
      )
    )
  );
};
Z1.displayName = "IconReact";
Z1.getTwoToneColors = FJ;
Z1.setTwoToneColors = NJ;
const u2 = Z1;
function Ak(t) {
  var e = Tk(t),
    n = Ve(e, 2),
    r = n[0],
    i = n[1];
  return u2.setTwoToneColors({ primaryColor: r, secondaryColor: i });
}
function DJ() {
  var t = u2.getTwoToneColors();
  return t.calculated ? [t.primaryColor, t.secondaryColor] : t.primaryColor;
}
var zJ = [
  "className",
  "icon",
  "spin",
  "rotate",
  "tabIndex",
  "onClick",
  "twoToneColor",
];
Ak(dQ.primary);
var Q1 = E.forwardRef(function (t, e) {
  var n,
    r = t.className,
    i = t.icon,
    o = t.spin,
    a = t.rotate,
    s = t.tabIndex,
    l = t.onClick,
    c = t.twoToneColor,
    u = on(t, zJ),
    d = E.useContext(i2),
    p = d.prefixCls,
    m = p === void 0 ? "anticon" : p,
    v = d.rootClassName,
    S = nt(
      v,
      m,
      ((n = {}),
      be(n, "".concat(m, "-").concat(i.name), !!i.name),
      be(n, "".concat(m, "-spin"), !!o || i.name === "loading"),
      n),
      r
    ),
    x = s;
  x === void 0 && l && (x = -1);
  var g = a
      ? {
          msTransform: "rotate(".concat(a, "deg)"),
          transform: "rotate(".concat(a, "deg)"),
        }
      : void 0,
    _ = Tk(c),
    y = Ve(_, 2),
    w = y[0],
    A = y[1];
  return E.createElement(
    "span",
    Et({ role: "img", "aria-label": i.name }, u, {
      ref: e,
      tabIndex: x,
      onClick: l,
      className: S,
    }),
    E.createElement(u2, {
      icon: i,
      primaryColor: w,
      secondaryColor: A,
      style: g,
    })
  );
});
Q1.displayName = "AntdIcon";
Q1.getTwoToneColor = DJ;
Q1.setTwoToneColor = Ak;
const cs = Q1;
var UJ = {
  icon: {
    tag: "svg",
    attrs: {
      "fill-rule": "evenodd",
      viewBox: "64 64 896 896",
      focusable: "false",
    },
    children: [
      {
        tag: "path",
        attrs: {
          d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z",
        },
      },
    ],
  },
  name: "close-circle",
  theme: "filled",
};
const kJ = UJ;
var BJ = function (e, n) {
  return E.createElement(cs, Et({}, e, { ref: n, icon: kJ }));
};
const d2 = E.forwardRef(BJ);
var HJ = {
  icon: {
    tag: "svg",
    attrs: {
      "fill-rule": "evenodd",
      viewBox: "64 64 896 896",
      focusable: "false",
    },
    children: [
      {
        tag: "path",
        attrs: {
          d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z",
        },
      },
    ],
  },
  name: "close",
  theme: "outlined",
};
const jJ = HJ;
var VJ = function (e, n) {
  return E.createElement(cs, Et({}, e, { ref: n, icon: jJ }));
};
const $J = E.forwardRef(VJ);
var GJ = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`,
  WJ = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`,
  XJ = ""
    .concat(GJ, " ")
    .concat(WJ)
    .split(/[\s\n]+/),
  qJ = "aria-",
  KJ = "data-";
function bI(t, e) {
  return t.indexOf(e) === 0;
}
function YJ(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    n;
  e === !1
    ? (n = { aria: !0, data: !0, attr: !0 })
    : e === !0
    ? (n = { aria: !0 })
    : (n = De({}, e));
  var r = {};
  return (
    Object.keys(t).forEach(function (i) {
      ((n.aria && (i === "role" || bI(i, qJ))) ||
        (n.data && bI(i, KJ)) ||
        (n.attr && XJ.includes(i))) &&
        (r[i] = t[i]);
    }),
    r
  );
}
const { isValidElement: f2 } = ru;
function Rk(t) {
  return t && f2(t) && t.type === E.Fragment;
}
function ZJ(t, e, n) {
  return f2(t)
    ? E.cloneElement(t, typeof n == "function" ? n(t.props || {}) : n)
    : e;
}
function em(t, e) {
  return ZJ(t, t, e);
}
const Rm = (t) => {
  const [, , , , e] = is();
  return e ? `${t}-css-var` : "";
};
var gt = {
    MAC_ENTER: 3,
    BACKSPACE: 8,
    TAB: 9,
    NUM_CENTER: 12,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    PRINT_SCREEN: 44,
    INSERT: 45,
    DELETE: 46,
    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,
    QUESTION_MARK: 63,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    META: 91,
    WIN_KEY_RIGHT: 92,
    CONTEXT_MENU: 93,
    NUM_ZERO: 96,
    NUM_ONE: 97,
    NUM_TWO: 98,
    NUM_THREE: 99,
    NUM_FOUR: 100,
    NUM_FIVE: 101,
    NUM_SIX: 102,
    NUM_SEVEN: 103,
    NUM_EIGHT: 104,
    NUM_NINE: 105,
    NUM_MULTIPLY: 106,
    NUM_PLUS: 107,
    NUM_MINUS: 109,
    NUM_PERIOD: 110,
    NUM_DIVISION: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    NUMLOCK: 144,
    SEMICOLON: 186,
    DASH: 189,
    EQUALS: 187,
    COMMA: 188,
    PERIOD: 190,
    SLASH: 191,
    APOSTROPHE: 192,
    SINGLE_QUOTE: 222,
    OPEN_SQUARE_BRACKET: 219,
    BACKSLASH: 220,
    CLOSE_SQUARE_BRACKET: 221,
    WIN_KEY: 224,
    MAC_FF_META: 224,
    WIN_IME: 229,
    isTextModifyingKeyEvent: function (e) {
      var n = e.keyCode;
      if ((e.altKey && !e.ctrlKey) || e.metaKey || (n >= gt.F1 && n <= gt.F12))
        return !1;
      switch (n) {
        case gt.ALT:
        case gt.CAPS_LOCK:
        case gt.CONTEXT_MENU:
        case gt.CTRL:
        case gt.DOWN:
        case gt.END:
        case gt.ESC:
        case gt.HOME:
        case gt.INSERT:
        case gt.LEFT:
        case gt.MAC_FF_META:
        case gt.META:
        case gt.NUMLOCK:
        case gt.NUM_CENTER:
        case gt.PAGE_DOWN:
        case gt.PAGE_UP:
        case gt.PAUSE:
        case gt.PRINT_SCREEN:
        case gt.RIGHT:
        case gt.SHIFT:
        case gt.UP:
        case gt.WIN_KEY:
        case gt.WIN_KEY_RIGHT:
          return !1;
        default:
          return !0;
      }
    },
    isCharacterKey: function (e) {
      if (
        (e >= gt.ZERO && e <= gt.NINE) ||
        (e >= gt.NUM_ZERO && e <= gt.NUM_MULTIPLY) ||
        (e >= gt.A && e <= gt.Z) ||
        (window.navigator.userAgent.indexOf("WebKit") !== -1 && e === 0)
      )
        return !0;
      switch (e) {
        case gt.SPACE:
        case gt.QUESTION_MARK:
        case gt.NUM_PLUS:
        case gt.NUM_MINUS:
        case gt.NUM_PERIOD:
        case gt.NUM_DIVISION:
        case gt.SEMICOLON:
        case gt.DASH:
        case gt.EQUALS:
        case gt.COMMA:
        case gt.PERIOD:
        case gt.SLASH:
        case gt.APOSTROPHE:
        case gt.SINGLE_QUOTE:
        case gt.OPEN_SQUARE_BRACKET:
        case gt.BACKSLASH:
        case gt.CLOSE_SQUARE_BRACKET:
          return !0;
        default:
          return !1;
      }
    },
  },
  QJ = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "0 0 1024 1024", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z",
          },
        },
      ],
    },
    name: "loading",
    theme: "outlined",
  };
const JJ = QJ;
var eee = function (e, n) {
  return E.createElement(cs, Et({}, e, { ref: n, icon: JJ }));
};
const tee = E.forwardRef(eee),
  nee = at.createContext(void 0),
  Pk = nee,
  Oc = 100,
  ree = 10,
  iee = Oc * ree,
  Ik = {
    Modal: Oc,
    Drawer: Oc,
    Popover: Oc,
    Popconfirm: Oc,
    Tooltip: Oc,
    Tour: Oc,
  },
  oee = {
    SelectLike: 50,
    Dropdown: 50,
    DatePicker: 50,
    Menu: 50,
    ImagePreview: 1,
  };
function aee(t) {
  return t in Ik;
}
function see(t, e) {
  const [, n] = is(),
    r = at.useContext(Pk),
    i = aee(t);
  if (e !== void 0) return [e, e];
  let o = r ?? 0;
  return (
    i
      ? ((o += (r ? 0 : n.zIndexPopupBase) + Ik[t]),
        (o = Math.min(o, n.zIndexPopupBase + iee)))
      : (o += oee[t]),
    [r === void 0 ? e : o, o]
  );
}
function Lk(t, e) {
  (this.v = t), (this.k = e);
}
function di(t, e, n, r) {
  var i = Object.defineProperty;
  try {
    i({}, "", {});
  } catch {
    i = 0;
  }
  (di = function (a, s, l, c) {
    function u(d, p) {
      di(a, d, function (m) {
        return this._invoke(d, p, m);
      });
    }
    s
      ? i
        ? i(a, s, { value: l, enumerable: !c, configurable: !c, writable: !c })
        : (a[s] = l)
      : (u("next", 0), u("throw", 1), u("return", 2));
  }),
    di(t, e, n, r);
}
function h2() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var t,
    e,
    n = typeof Symbol == "function" ? Symbol : {},
    r = n.iterator || "@@iterator",
    i = n.toStringTag || "@@toStringTag";
  function o(m, v, S, x) {
    var g = v && v.prototype instanceof s ? v : s,
      _ = Object.create(g.prototype);
    return (
      di(
        _,
        "_invoke",
        (function (y, w, A) {
          var M,
            T,
            I,
            R = 0,
            P = A || [],
            F = !1,
            D = {
              p: 0,
              n: 0,
              v: t,
              a: j,
              f: j.bind(t, 4),
              d: function (V, W) {
                return (M = V), (T = 0), (I = t), (D.n = W), a;
              },
            };
          function j(N, V) {
            for (T = N, I = V, e = 0; !F && R && !W && e < P.length; e++) {
              var W,
                Q = P[e],
                B = D.p,
                $ = Q[2];
              N > 3
                ? (W = $ === V) &&
                  ((I = Q[(T = Q[4]) ? 5 : ((T = 3), 3)]), (Q[4] = Q[5] = t))
                : Q[0] <= B &&
                  ((W = N < 2 && B < Q[1])
                    ? ((T = 0), (D.v = V), (D.n = Q[1]))
                    : B < $ &&
                      (W = N < 3 || Q[0] > V || V > $) &&
                      ((Q[4] = N), (Q[5] = V), (D.n = $), (T = 0)));
            }
            if (W || N > 1) return a;
            throw ((F = !0), V);
          }
          return function (N, V, W) {
            if (R > 1) throw TypeError("Generator is already running");
            for (
              F && V === 1 && j(V, W), T = V, I = W;
              (e = T < 2 ? t : I) || !F;

            ) {
              M ||
                (T
                  ? T < 3
                    ? (T > 1 && (D.n = -1), j(T, I))
                    : (D.n = I)
                  : (D.v = I));
              try {
                if (((R = 2), M)) {
                  if ((T || (N = "next"), (e = M[N]))) {
                    if (!(e = e.call(M, I)))
                      throw TypeError("iterator result is not an object");
                    if (!e.done) return e;
                    (I = e.value), T < 2 && (T = 0);
                  } else
                    T === 1 && (e = M.return) && e.call(M),
                      T < 2 &&
                        ((I = TypeError(
                          "The iterator does not provide a '" + N + "' method"
                        )),
                        (T = 1));
                  M = t;
                } else if ((e = (F = D.n < 0) ? I : y.call(w, D)) !== a) break;
              } catch (Q) {
                (M = t), (T = 1), (I = Q);
              } finally {
                R = 1;
              }
            }
            return { value: e, done: F };
          };
        })(m, S, x),
        !0
      ),
      _
    );
  }
  var a = {};
  function s() {}
  function l() {}
  function c() {}
  e = Object.getPrototypeOf;
  var u = [][r]
      ? e(e([][r]()))
      : (di((e = {}), r, function () {
          return this;
        }),
        e),
    d = (c.prototype = s.prototype = Object.create(u));
  function p(m) {
    return (
      Object.setPrototypeOf
        ? Object.setPrototypeOf(m, c)
        : ((m.__proto__ = c), di(m, i, "GeneratorFunction")),
      (m.prototype = Object.create(d)),
      m
    );
  }
  return (
    (l.prototype = c),
    di(d, "constructor", c),
    di(c, "constructor", l),
    (l.displayName = "GeneratorFunction"),
    di(c, i, "GeneratorFunction"),
    di(d),
    di(d, i, "Generator"),
    di(d, r, function () {
      return this;
    }),
    di(d, "toString", function () {
      return "[object Generator]";
    }),
    (h2 = function () {
      return { w: o, m: p };
    })()
  );
}
function Cy(t, e) {
  function n(i, o, a, s) {
    try {
      var l = t[i](o),
        c = l.value;
      return c instanceof Lk
        ? e.resolve(c.v).then(
            function (u) {
              n("next", u, a, s);
            },
            function (u) {
              n("throw", u, a, s);
            }
          )
        : e.resolve(c).then(
            function (u) {
              (l.value = u), a(l);
            },
            function (u) {
              return n("throw", u, a, s);
            }
          );
    } catch (u) {
      s(u);
    }
  }
  var r;
  this.next ||
    (di(Cy.prototype),
    di(
      Cy.prototype,
      (typeof Symbol == "function" && Symbol.asyncIterator) || "@asyncIterator",
      function () {
        return this;
      }
    )),
    di(
      this,
      "_invoke",
      function (i, o, a) {
        function s() {
          return new e(function (l, c) {
            n(i, a, l, c);
          });
        }
        return (r = r ? r.then(s, s) : s());
      },
      !0
    );
}
function Ok(t, e, n, r, i) {
  return new Cy(h2().w(t, e, n, r), i || Promise);
}
function lee(t, e, n, r, i) {
  var o = Ok(t, e, n, r, i);
  return o.next().then(function (a) {
    return a.done ? a.value : o.next();
  });
}
function cee(t) {
  var e = Object(t),
    n = [];
  for (var r in e) n.unshift(r);
  return function i() {
    for (; n.length; )
      if ((r = n.pop()) in e) return (i.value = r), (i.done = !1), i;
    return (i.done = !0), i;
  };
}
function wI(t) {
  if (t != null) {
    var e = t[(typeof Symbol == "function" && Symbol.iterator) || "@@iterator"],
      n = 0;
    if (e) return e.call(t);
    if (typeof t.next == "function") return t;
    if (!isNaN(t.length))
      return {
        next: function () {
          return (
            t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t }
          );
        },
      };
  }
  throw new TypeError(un(t) + " is not iterable");
}
function vi() {
  var t = h2(),
    e = t.m(vi),
    n = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__)
      .constructor;
  function r(a) {
    var s = typeof a == "function" && a.constructor;
    return (
      !!s && (s === n || (s.displayName || s.name) === "GeneratorFunction")
    );
  }
  var i = { throw: 1, return: 2, break: 3, continue: 3 };
  function o(a) {
    var s, l;
    return function (c) {
      s ||
        ((s = {
          stop: function () {
            return l(c.a, 2);
          },
          catch: function () {
            return c.v;
          },
          abrupt: function (d, p) {
            return l(c.a, i[d], p);
          },
          delegateYield: function (d, p, m) {
            return (s.resultName = p), l(c.d, wI(d), m);
          },
          finish: function (d) {
            return l(c.f, d);
          },
        }),
        (l = function (d, p, m) {
          (c.p = s.prev), (c.n = s.next);
          try {
            return d(p, m);
          } finally {
            s.next = c.n;
          }
        })),
        s.resultName && ((s[s.resultName] = c.v), (s.resultName = void 0)),
        (s.sent = c.v),
        (s.next = c.n);
      try {
        return a.call(this, s);
      } finally {
        (c.p = s.prev), (c.n = s.next);
      }
    };
  }
  return (vi = function () {
    return {
      wrap: function (l, c, u, d) {
        return t.w(o(l), c, u, d && d.reverse());
      },
      isGeneratorFunction: r,
      mark: t.m,
      awrap: function (l, c) {
        return new Lk(l, c);
      },
      AsyncIterator: Cy,
      async: function (l, c, u, d, p) {
        return (r(c) ? Ok : lee)(o(l), c, u, d, p);
      },
      keys: cee,
      values: wI,
    };
  })();
}
function EI(t, e, n, r, i, o, a) {
  try {
    var s = t[o](a),
      l = s.value;
  } catch (c) {
    return void n(c);
  }
  s.done ? e(l) : Promise.resolve(l).then(r, i);
}
function Cu(t) {
  return function () {
    var e = this,
      n = arguments;
    return new Promise(function (r, i) {
      var o = t.apply(e, n);
      function a(l) {
        EI(o, r, i, a, s, "next", l);
      }
      function s(l) {
        EI(o, r, i, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
var Pm = De({}, j6),
  uee = Pm.version,
  dee = Pm.render,
  fee = Pm.unmountComponentAtNode,
  J1;
try {
  var hee = Number((uee || "").split(".")[0]);
  hee >= 18 && (J1 = Pm.createRoot);
} catch {}
function MI(t) {
  var e = Pm.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  e && un(e) === "object" && (e.usingClientEntryPoint = t);
}
var Ty = "__rc_react_root__";
function pee(t, e) {
  MI(!0);
  var n = e[Ty] || J1(e);
  MI(!1), n.render(t), (e[Ty] = n);
}
function mee(t, e) {
  dee(t, e);
}
function gee(t, e) {
  if (J1) {
    pee(t, e);
    return;
  }
  mee(t, e);
}
function vee(t) {
  return TE.apply(this, arguments);
}
function TE() {
  return (
    (TE = Cu(
      vi().mark(function t(e) {
        return vi().wrap(function (r) {
          for (;;)
            switch ((r.prev = r.next)) {
              case 0:
                return r.abrupt(
                  "return",
                  Promise.resolve().then(function () {
                    var i;
                    (i = e[Ty]) === null || i === void 0 || i.unmount(),
                      delete e[Ty];
                  })
                );
              case 1:
              case "end":
                return r.stop();
            }
        }, t);
      })
    )),
    TE.apply(this, arguments)
  );
}
function yee(t) {
  fee(t);
}
function xee(t) {
  return AE.apply(this, arguments);
}
function AE() {
  return (
    (AE = Cu(
      vi().mark(function t(e) {
        return vi().wrap(function (r) {
          for (;;)
            switch ((r.prev = r.next)) {
              case 0:
                if (J1 === void 0) {
                  r.next = 2;
                  break;
                }
                return r.abrupt("return", vee(e));
              case 2:
                yee(e);
              case 3:
              case "end":
                return r.stop();
            }
        }, t);
      })
    )),
    AE.apply(this, arguments)
  );
}
const Nk = (t, e, n) => (n !== void 0 ? n : `${t}-${e}`),
  p2 = function (t) {
    if (!t) return !1;
    if (t instanceof Element) {
      if (t.offsetParent) return !0;
      if (t.getBBox) {
        var e = t.getBBox(),
          n = e.width,
          r = e.height;
        if (n || r) return !0;
      }
      if (t.getBoundingClientRect) {
        var i = t.getBoundingClientRect(),
          o = i.width,
          a = i.height;
        if (o || a) return !0;
      }
    }
    return !1;
  },
  See = (t) => {
    const { componentCls: e, colorPrimary: n } = t;
    return {
      [e]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none",
        boxSizing: "border-box",
        color: `var(--wave-color, ${n})`,
        boxShadow: "0 0 0 0 currentcolor",
        opacity: 0.2,
        "&.wave-motion-appear": {
          transition: [
            `box-shadow 0.4s ${t.motionEaseOutCirc}`,
            `opacity 2s ${t.motionEaseOutCirc}`,
          ].join(","),
          "&-active": { boxShadow: "0 0 0 6px currentcolor", opacity: 0 },
          "&.wave-quick": {
            transition: [
              `box-shadow 0.3s ${t.motionEaseInOut}`,
              `opacity 0.35s ${t.motionEaseInOut}`,
            ].join(","),
          },
        },
      },
    };
  },
  _ee = l2("Wave", (t) => [See(t)]);
function bee(t) {
  const e = (t || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  return e && e[1] && e[2] && e[3] ? !(e[1] === e[2] && e[2] === e[3]) : !0;
}
function H_(t) {
  return (
    t &&
    t !== "#fff" &&
    t !== "#ffffff" &&
    t !== "rgb(255, 255, 255)" &&
    t !== "rgba(255, 255, 255, 1)" &&
    bee(t) &&
    !/rgba\((?:\d*, ){3}0\)/.test(t) &&
    t !== "transparent"
  );
}
function wee(t) {
  const {
    borderTopColor: e,
    borderColor: n,
    backgroundColor: r,
  } = getComputedStyle(t);
  return H_(e) ? e : H_(n) ? n : H_(r) ? r : null;
}
const m2 = "ant-wave-target";
function j_(t) {
  return Number.isNaN(t) ? 0 : t;
}
const Eee = (t) => {
    const { className: e, target: n, component: r } = t,
      i = E.useRef(null),
      [o, a] = E.useState(null),
      [s, l] = E.useState([]),
      [c, u] = E.useState(0),
      [d, p] = E.useState(0),
      [m, v] = E.useState(0),
      [S, x] = E.useState(0),
      [g, _] = E.useState(!1),
      y = {
        left: c,
        top: d,
        width: m,
        height: S,
        borderRadius: s.map((M) => `${M}px`).join(" "),
      };
    o && (y["--wave-color"] = o);
    function w() {
      const M = getComputedStyle(n);
      a(wee(n));
      const T = M.position === "static",
        { borderLeftWidth: I, borderTopWidth: R } = M;
      u(T ? n.offsetLeft : j_(-parseFloat(I))),
        p(T ? n.offsetTop : j_(-parseFloat(R))),
        v(n.offsetWidth),
        x(n.offsetHeight);
      const {
        borderTopLeftRadius: P,
        borderTopRightRadius: F,
        borderBottomLeftRadius: D,
        borderBottomRightRadius: j,
      } = M;
      l([P, F, j, D].map((N) => j_(parseFloat(N))));
    }
    if (
      (E.useEffect(() => {
        if (n) {
          const M = Er(() => {
            w(), _(!0);
          });
          let T;
          return (
            typeof ResizeObserver < "u" &&
              ((T = new ResizeObserver(w)), T.observe(n)),
            () => {
              Er.cancel(M), T == null || T.disconnect();
            }
          );
        }
      }, []),
      !g)
    )
      return null;
    const A =
      (r === "Checkbox" || r === "Radio") &&
      (n == null ? void 0 : n.classList.contains(m2));
    return E.createElement(
      Mu,
      {
        visible: !0,
        motionAppear: !0,
        motionName: "wave-motion",
        motionDeadline: 5e3,
        onAppearEnd: (M, T) => {
          var I;
          if (T.deadline || T.propertyName === "opacity") {
            const R =
              (I = i.current) === null || I === void 0
                ? void 0
                : I.parentElement;
            xee(R).then(() => {
              R == null || R.remove();
            });
          }
          return !1;
        },
      },
      (M) => {
        let { className: T } = M;
        return E.createElement("div", {
          ref: i,
          className: nt(e, { "wave-quick": A }, T),
          style: y,
        });
      }
    );
  },
  Mee = (t, e) => {
    var n;
    const { component: r } = e;
    if (
      r === "Checkbox" &&
      !(!((n = t.querySelector("input")) === null || n === void 0) && n.checked)
    )
      return;
    const i = document.createElement("div");
    (i.style.position = "absolute"),
      (i.style.left = "0px"),
      (i.style.top = "0px"),
      t == null || t.insertBefore(i, t == null ? void 0 : t.firstChild),
      gee(E.createElement(Eee, Object.assign({}, e, { target: t })), i);
  },
  Cee = Mee;
function Tee(t, e, n) {
  const { wave: r } = E.useContext(Rn),
    [, i, o] = is(),
    a = Yo((c) => {
      const u = t.current;
      if ((r != null && r.disabled) || !u) return;
      const d = u.querySelector(`.${m2}`) || u,
        { showEffect: p } = r || {};
      (p || Cee)(d, {
        className: e,
        token: i,
        component: n,
        event: c,
        hashId: o,
      });
    }),
    s = E.useRef();
  return (c) => {
    Er.cancel(s.current),
      (s.current = Er(() => {
        a(c);
      }));
  };
}
const Aee = (t) => {
    const { children: e, disabled: n, component: r } = t,
      { getPrefixCls: i } = E.useContext(Rn),
      o = E.useRef(null),
      a = i("wave"),
      [, s] = _ee(a),
      l = Tee(o, nt(a, s), r);
    if (
      (at.useEffect(() => {
        const u = o.current;
        if (!u || u.nodeType !== 1 || n) return;
        const d = (p) => {
          !p2(p.target) ||
            !u.getAttribute ||
            u.getAttribute("disabled") ||
            u.disabled ||
            u.className.includes("disabled") ||
            u.className.includes("-leave") ||
            l(p);
        };
        return (
          u.addEventListener("click", d, !0),
          () => {
            u.removeEventListener("click", d, !0);
          }
        );
      }, [n]),
      !at.isValidElement(e))
    )
      return e ?? null;
    const c = wu(e) ? ls(e.ref, o) : o;
    return em(e, { ref: c });
  },
  Fk = Aee,
  Tu = (t) => {
    const e = at.useContext(Y1);
    return at.useMemo(
      () =>
        t
          ? typeof t == "string"
            ? t ?? e
            : t instanceof Function
            ? t(e)
            : e
          : e,
      [t, e]
    );
  },
  Dk = E.createContext(null),
  g2 = (t, e) => {
    const n = E.useContext(Dk),
      r = E.useMemo(() => {
        if (!n) return "";
        const { compactDirection: i, isFirstItem: o, isLastItem: a } = n,
          s = i === "vertical" ? "-vertical-" : "-";
        return nt(`${t}-compact${s}item`, {
          [`${t}-compact${s}first-item`]: o,
          [`${t}-compact${s}last-item`]: a,
          [`${t}-compact${s}item-rtl`]: e === "rtl",
        });
      }, [t, e, n]);
    return {
      compactSize: n == null ? void 0 : n.compactSize,
      compactDirection: n == null ? void 0 : n.compactDirection,
      compactItemClassnames: r,
    };
  },
  RE = (t) => {
    let { children: e } = t;
    return E.createElement(Dk.Provider, { value: null }, e);
  };
var Ree = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const zk = E.createContext(void 0),
  Pee = (t) => {
    const { getPrefixCls: e, direction: n } = E.useContext(Rn),
      { prefixCls: r, size: i, className: o } = t,
      a = Ree(t, ["prefixCls", "size", "className"]),
      s = e("btn-group", r),
      [, , l] = is();
    let c = "";
    switch (i) {
      case "large":
        c = "lg";
        break;
      case "small":
        c = "sm";
        break;
    }
    const u = nt(s, { [`${s}-${c}`]: c, [`${s}-rtl`]: n === "rtl" }, o, l);
    return E.createElement(
      zk.Provider,
      { value: i },
      E.createElement("div", Object.assign({}, a, { className: u }))
    );
  },
  Iee = Pee,
  CI = /^[\u4e00-\u9fa5]{2}$/,
  PE = CI.test.bind(CI);
function TI(t) {
  return typeof t == "string";
}
function V_(t) {
  return t === "text" || t === "link";
}
function Lee(t, e) {
  if (t == null) return;
  const n = e ? " " : "";
  return typeof t != "string" &&
    typeof t != "number" &&
    TI(t.type) &&
    PE(t.props.children)
    ? em(t, { children: t.props.children.split("").join(n) })
    : TI(t)
    ? PE(t)
      ? at.createElement("span", null, t.split("").join(n))
      : at.createElement("span", null, t)
    : Rk(t)
    ? at.createElement("span", null, t)
    : t;
}
function Oee(t, e) {
  let n = !1;
  const r = [];
  return (
    at.Children.forEach(t, (i) => {
      const o = typeof i,
        a = o === "string" || o === "number";
      if (n && a) {
        const s = r.length - 1,
          l = r[s];
        r[s] = `${l}${i}`;
      } else r.push(i);
      n = a;
    }),
    at.Children.map(r, (i) => Lee(i, e))
  );
}
const Nee = E.forwardRef((t, e) => {
    const { className: n, style: r, children: i, prefixCls: o } = t,
      a = nt(`${o}-icon`, n);
    return at.createElement("span", { ref: e, className: a, style: r }, i);
  }),
  Uk = Nee,
  AI = E.forwardRef((t, e) => {
    let { prefixCls: n, className: r, style: i, iconClassName: o } = t;
    const a = nt(`${n}-loading-icon`, r);
    return at.createElement(
      Uk,
      { prefixCls: n, className: a, style: i, ref: e },
      at.createElement(tee, { className: o })
    );
  }),
  $_ = () => ({ width: 0, opacity: 0, transform: "scale(0)" }),
  G_ = (t) => ({ width: t.scrollWidth, opacity: 1, transform: "scale(1)" }),
  Fee = (t) => {
    const {
        prefixCls: e,
        loading: n,
        existIcon: r,
        className: i,
        style: o,
      } = t,
      a = !!n;
    return r
      ? at.createElement(AI, { prefixCls: e, className: i, style: o })
      : at.createElement(
          Mu,
          {
            visible: a,
            motionName: `${e}-loading-icon-motion`,
            motionLeave: a,
            removeOnLeave: !0,
            onAppearStart: $_,
            onAppearActive: G_,
            onEnterStart: $_,
            onEnterActive: G_,
            onLeaveStart: G_,
            onLeaveActive: $_,
          },
          (s, l) => {
            let { className: c, style: u } = s;
            return at.createElement(AI, {
              prefixCls: e,
              className: i,
              style: Object.assign(Object.assign({}, o), u),
              ref: l,
              iconClassName: c,
            });
          }
        );
  },
  Dee = Fee,
  RI = (t, e) => ({
    [`> span, > ${t}`]: {
      "&:not(:last-child)": {
        [`&, & > ${t}`]: { "&:not(:disabled)": { borderInlineEndColor: e } },
      },
      "&:not(:first-child)": {
        [`&, & > ${t}`]: { "&:not(:disabled)": { borderInlineStartColor: e } },
      },
    },
  }),
  zee = (t) => {
    const {
      componentCls: e,
      fontSize: n,
      lineWidth: r,
      groupBorderColor: i,
      colorErrorHover: o,
    } = t;
    return {
      [`${e}-group`]: [
        {
          position: "relative",
          display: "inline-flex",
          [`> span, > ${e}`]: {
            "&:not(:last-child)": {
              [`&, & > ${e}`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
              },
            },
            "&:not(:first-child)": {
              marginInlineStart: t.calc(r).mul(-1).equal(),
              [`&, & > ${e}`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0,
              },
            },
          },
          [e]: {
            position: "relative",
            zIndex: 1,
            "&:hover,\n          &:focus,\n          &:active": { zIndex: 2 },
            "&[disabled]": { zIndex: 0 },
          },
          [`${e}-icon-only`]: { fontSize: n },
        },
        RI(`${e}-primary`, i),
        RI(`${e}-danger`, o),
      ],
    };
  },
  Uee = zee,
  kk = (t) => {
    const { paddingInline: e, onlyIconSize: n, paddingBlock: r } = t;
    return xi(t, {
      buttonPaddingHorizontal: e,
      buttonPaddingVertical: r,
      buttonIconOnlyFontSize: n,
    });
  },
  Bk = (t) => {
    var e, n, r, i, o, a;
    const s = (e = t.contentFontSize) !== null && e !== void 0 ? e : t.fontSize,
      l = (n = t.contentFontSizeSM) !== null && n !== void 0 ? n : t.fontSize,
      c = (r = t.contentFontSizeLG) !== null && r !== void 0 ? r : t.fontSizeLG,
      u = (i = t.contentLineHeight) !== null && i !== void 0 ? i : L0(s),
      d = (o = t.contentLineHeightSM) !== null && o !== void 0 ? o : L0(l),
      p = (a = t.contentLineHeightLG) !== null && a !== void 0 ? a : L0(c);
    return {
      fontWeight: 400,
      defaultShadow: `0 ${t.controlOutlineWidth}px 0 ${t.controlTmpOutline}`,
      primaryShadow: `0 ${t.controlOutlineWidth}px 0 ${t.controlOutline}`,
      dangerShadow: `0 ${t.controlOutlineWidth}px 0 ${t.colorErrorOutline}`,
      primaryColor: t.colorTextLightSolid,
      dangerColor: t.colorTextLightSolid,
      borderColorDisabled: t.colorBorder,
      defaultGhostColor: t.colorBgContainer,
      ghostBg: "transparent",
      defaultGhostBorderColor: t.colorBgContainer,
      paddingInline: t.paddingContentHorizontal - t.lineWidth,
      paddingInlineLG: t.paddingContentHorizontal - t.lineWidth,
      paddingInlineSM: 8 - t.lineWidth,
      onlyIconSize: t.fontSizeLG,
      onlyIconSizeSM: t.fontSizeLG - 2,
      onlyIconSizeLG: t.fontSizeLG + 2,
      groupBorderColor: t.colorPrimaryHover,
      linkHoverBg: "transparent",
      textHoverBg: t.colorBgTextHover,
      defaultColor: t.colorText,
      defaultBg: t.colorBgContainer,
      defaultBorderColor: t.colorBorder,
      defaultBorderColorDisabled: t.colorBorder,
      contentFontSize: s,
      contentFontSizeSM: l,
      contentFontSizeLG: c,
      contentLineHeight: u,
      contentLineHeightSM: d,
      contentLineHeightLG: p,
      paddingBlock: Math.max((t.controlHeight - s * u) / 2 - t.lineWidth, 0),
      paddingBlockSM: Math.max(
        (t.controlHeightSM - l * d) / 2 - t.lineWidth,
        0
      ),
      paddingBlockLG: Math.max(
        (t.controlHeightLG - c * p) / 2 - t.lineWidth,
        0
      ),
    };
  },
  kee = (t) => {
    const { componentCls: e, iconCls: n, fontWeight: r } = t;
    return {
      [e]: {
        outline: "none",
        position: "relative",
        display: "inline-block",
        fontWeight: r,
        whiteSpace: "nowrap",
        textAlign: "center",
        backgroundImage: "none",
        background: "transparent",
        border: `${Ze(t.lineWidth)} ${t.lineType} transparent`,
        cursor: "pointer",
        transition: `all ${t.motionDurationMid} ${t.motionEaseInOut}`,
        userSelect: "none",
        touchAction: "manipulation",
        color: t.colorText,
        "&:disabled > *": { pointerEvents: "none" },
        "> span": { display: "inline-block" },
        [`${e}-icon`]: { lineHeight: 0 },
        [`> ${n} + span, > span + ${n}`]: { marginInlineStart: t.marginXS },
        [`&:not(${e}-icon-only) > ${e}-icon`]: {
          [`&${e}-loading-icon, &:not(:last-child)`]: {
            marginInlineEnd: t.marginXS,
          },
        },
        "> a": { color: "currentColor" },
        "&:not(:disabled)": Object.assign({}, s2(t)),
        [`&${e}-two-chinese-chars::first-letter`]: { letterSpacing: "0.34em" },
        [`&${e}-two-chinese-chars > *:not(${n})`]: {
          marginInlineEnd: "-0.34em",
          letterSpacing: "0.34em",
        },
        [`&-icon-only${e}-compact-item`]: { flex: "none" },
      },
    };
  },
  Ws = (t, e, n) => ({
    [`&:not(:disabled):not(${t}-disabled)`]: { "&:hover": e, "&:active": n },
  }),
  Bee = (t) => ({
    minWidth: t.controlHeight,
    paddingInlineStart: 0,
    paddingInlineEnd: 0,
    borderRadius: "50%",
  }),
  Hee = (t) => ({
    borderRadius: t.controlHeight,
    paddingInlineStart: t.calc(t.controlHeight).div(2).equal(),
    paddingInlineEnd: t.calc(t.controlHeight).div(2).equal(),
  }),
  jee = (t) => ({
    cursor: "not-allowed",
    borderColor: t.borderColorDisabled,
    color: t.colorTextDisabled,
    background: t.colorBgContainerDisabled,
    boxShadow: "none",
  }),
  tm = (t, e, n, r, i, o, a, s) => ({
    [`&${t}-background-ghost`]: Object.assign(
      Object.assign(
        {
          color: n || void 0,
          background: e,
          borderColor: r || void 0,
          boxShadow: "none",
        },
        Ws(
          t,
          Object.assign({ background: e }, a),
          Object.assign({ background: e }, s)
        )
      ),
      {
        "&:disabled": {
          cursor: "not-allowed",
          color: i || void 0,
          borderColor: o || void 0,
        },
      }
    ),
  }),
  v2 = (t) => ({
    [`&:disabled, &${t.componentCls}-disabled`]: Object.assign({}, jee(t)),
  }),
  Hk = (t) => Object.assign({}, v2(t)),
  Ay = (t) => ({
    [`&:disabled, &${t.componentCls}-disabled`]: {
      cursor: "not-allowed",
      color: t.colorTextDisabled,
    },
  }),
  jk = (t) =>
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(Object.assign({}, Hk(t)), {
            background: t.defaultBg,
            borderColor: t.defaultBorderColor,
            color: t.defaultColor,
            boxShadow: t.defaultShadow,
          }),
          Ws(
            t.componentCls,
            { color: t.colorPrimaryHover, borderColor: t.colorPrimaryHover },
            { color: t.colorPrimaryActive, borderColor: t.colorPrimaryActive }
          )
        ),
        tm(
          t.componentCls,
          t.ghostBg,
          t.defaultGhostColor,
          t.defaultGhostBorderColor,
          t.colorTextDisabled,
          t.colorBorder
        )
      ),
      {
        [`&${t.componentCls}-dangerous`]: Object.assign(
          Object.assign(
            Object.assign(
              { color: t.colorError, borderColor: t.colorError },
              Ws(
                t.componentCls,
                {
                  color: t.colorErrorHover,
                  borderColor: t.colorErrorBorderHover,
                },
                { color: t.colorErrorActive, borderColor: t.colorErrorActive }
              )
            ),
            tm(
              t.componentCls,
              t.ghostBg,
              t.colorError,
              t.colorError,
              t.colorTextDisabled,
              t.colorBorder
            )
          ),
          v2(t)
        ),
      }
    ),
  Vee = (t) =>
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(Object.assign({}, Hk(t)), {
            color: t.primaryColor,
            background: t.colorPrimary,
            boxShadow: t.primaryShadow,
          }),
          Ws(
            t.componentCls,
            { color: t.colorTextLightSolid, background: t.colorPrimaryHover },
            { color: t.colorTextLightSolid, background: t.colorPrimaryActive }
          )
        ),
        tm(
          t.componentCls,
          t.ghostBg,
          t.colorPrimary,
          t.colorPrimary,
          t.colorTextDisabled,
          t.colorBorder,
          { color: t.colorPrimaryHover, borderColor: t.colorPrimaryHover },
          { color: t.colorPrimaryActive, borderColor: t.colorPrimaryActive }
        )
      ),
      {
        [`&${t.componentCls}-dangerous`]: Object.assign(
          Object.assign(
            Object.assign(
              {
                background: t.colorError,
                boxShadow: t.dangerShadow,
                color: t.dangerColor,
              },
              Ws(
                t.componentCls,
                { background: t.colorErrorHover },
                { background: t.colorErrorActive }
              )
            ),
            tm(
              t.componentCls,
              t.ghostBg,
              t.colorError,
              t.colorError,
              t.colorTextDisabled,
              t.colorBorder,
              { color: t.colorErrorHover, borderColor: t.colorErrorHover },
              { color: t.colorErrorActive, borderColor: t.colorErrorActive }
            )
          ),
          v2(t)
        ),
      }
    ),
  $ee = (t) =>
    Object.assign(Object.assign({}, jk(t)), { borderStyle: "dashed" }),
  Gee = (t) =>
    Object.assign(
      Object.assign(
        Object.assign(
          { color: t.colorLink },
          Ws(
            t.componentCls,
            { color: t.colorLinkHover, background: t.linkHoverBg },
            { color: t.colorLinkActive }
          )
        ),
        Ay(t)
      ),
      {
        [`&${t.componentCls}-dangerous`]: Object.assign(
          Object.assign(
            { color: t.colorError },
            Ws(
              t.componentCls,
              { color: t.colorErrorHover },
              { color: t.colorErrorActive }
            )
          ),
          Ay(t)
        ),
      }
    ),
  Wee = (t) =>
    Object.assign(
      Object.assign(
        Object.assign(
          {},
          Ws(
            t.componentCls,
            { color: t.colorText, background: t.textHoverBg },
            { color: t.colorText, background: t.colorBgTextActive }
          )
        ),
        Ay(t)
      ),
      {
        [`&${t.componentCls}-dangerous`]: Object.assign(
          Object.assign({ color: t.colorError }, Ay(t)),
          Ws(
            t.componentCls,
            { color: t.colorErrorHover, background: t.colorErrorBg },
            { color: t.colorErrorHover, background: t.colorErrorBg }
          )
        ),
      }
    ),
  Xee = (t) => {
    const { componentCls: e } = t;
    return {
      [`${e}-default`]: jk(t),
      [`${e}-primary`]: Vee(t),
      [`${e}-dashed`]: $ee(t),
      [`${e}-link`]: Gee(t),
      [`${e}-text`]: Wee(t),
      [`${e}-ghost`]: tm(
        t.componentCls,
        t.ghostBg,
        t.colorBgContainer,
        t.colorBgContainer,
        t.colorTextDisabled,
        t.colorBorder
      ),
    };
  },
  y2 = function (t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const {
        componentCls: n,
        controlHeight: r,
        fontSize: i,
        lineHeight: o,
        borderRadius: a,
        buttonPaddingHorizontal: s,
        iconCls: l,
        buttonPaddingVertical: c,
      } = t,
      u = `${n}-icon-only`;
    return [
      {
        [`${e}`]: {
          fontSize: i,
          lineHeight: o,
          height: r,
          padding: `${Ze(c)} ${Ze(s)}`,
          borderRadius: a,
          [`&${u}`]: {
            width: r,
            paddingInlineStart: 0,
            paddingInlineEnd: 0,
            [`&${n}-round`]: { width: "auto" },
            [l]: { fontSize: t.buttonIconOnlyFontSize },
          },
          [`&${n}-loading`]: { opacity: t.opacityLoading, cursor: "default" },
          [`${n}-loading-icon`]: {
            transition: `width ${t.motionDurationSlow} ${t.motionEaseInOut}, opacity ${t.motionDurationSlow} ${t.motionEaseInOut}`,
          },
        },
      },
      { [`${n}${n}-circle${e}`]: Bee(t) },
      { [`${n}${n}-round${e}`]: Hee(t) },
    ];
  },
  qee = (t) => {
    const e = xi(t, {
      fontSize: t.contentFontSize,
      lineHeight: t.contentLineHeight,
    });
    return y2(e, t.componentCls);
  },
  Kee = (t) => {
    const e = xi(t, {
      controlHeight: t.controlHeightSM,
      fontSize: t.contentFontSizeSM,
      lineHeight: t.contentLineHeightSM,
      padding: t.paddingXS,
      buttonPaddingHorizontal: t.paddingInlineSM,
      buttonPaddingVertical: t.paddingBlockSM,
      borderRadius: t.borderRadiusSM,
      buttonIconOnlyFontSize: t.onlyIconSizeSM,
    });
    return y2(e, `${t.componentCls}-sm`);
  },
  Yee = (t) => {
    const e = xi(t, {
      controlHeight: t.controlHeightLG,
      fontSize: t.contentFontSizeLG,
      lineHeight: t.contentLineHeightLG,
      buttonPaddingHorizontal: t.paddingInlineLG,
      buttonPaddingVertical: t.paddingBlockLG,
      borderRadius: t.borderRadiusLG,
      buttonIconOnlyFontSize: t.onlyIconSizeLG,
    });
    return y2(e, `${t.componentCls}-lg`);
  },
  Zee = (t) => {
    const { componentCls: e } = t;
    return { [e]: { [`&${e}-block`]: { width: "100%" } } };
  },
  Qee = ec(
    "Button",
    (t) => {
      const e = kk(t);
      return [kee(e), qee(e), Kee(e), Yee(e), Zee(e), Xee(e), Uee(e)];
    },
    Bk,
    {
      unitless: {
        fontWeight: !0,
        contentLineHeight: !0,
        contentLineHeightSM: !0,
        contentLineHeightLG: !0,
      },
    }
  );
function Jee(t, e, n) {
  const { focusElCls: r, focus: i, borderElCls: o } = n,
    a = o ? "> *" : "",
    s = ["hover", i ? "focus" : null, "active"]
      .filter(Boolean)
      .map((l) => `&:${l} ${a}`)
      .join(",");
  return {
    [`&-item:not(${e}-last-item)`]: {
      marginInlineEnd: t.calc(t.lineWidth).mul(-1).equal(),
    },
    "&-item": Object.assign(
      Object.assign(
        { [s]: { zIndex: 2 } },
        r ? { [`&${r}`]: { zIndex: 2 } } : {}
      ),
      { [`&[disabled] ${a}`]: { zIndex: 0 } }
    ),
  };
}
function ete(t, e, n) {
  const { borderElCls: r } = n,
    i = r ? `> ${r}` : "";
  return {
    [`&-item:not(${e}-first-item):not(${e}-last-item) ${i}`]: {
      borderRadius: 0,
    },
    [`&-item:not(${e}-last-item)${e}-first-item`]: {
      [`& ${i}, &${t}-sm ${i}, &${t}-lg ${i}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
      },
    },
    [`&-item:not(${e}-first-item)${e}-last-item`]: {
      [`& ${i}, &${t}-sm ${i}, &${t}-lg ${i}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
      },
    },
  };
}
function Vk(t) {
  let e =
    arguments.length > 1 && arguments[1] !== void 0
      ? arguments[1]
      : { focus: !0 };
  const { componentCls: n } = t,
    r = `${n}-compact`;
  return { [r]: Object.assign(Object.assign({}, Jee(t, r, e)), ete(n, r, e)) };
}
function tte(t, e) {
  return {
    [`&-item:not(${e}-last-item)`]: {
      marginBottom: t.calc(t.lineWidth).mul(-1).equal(),
    },
    "&-item": {
      "&:hover,&:focus,&:active": { zIndex: 2 },
      "&[disabled]": { zIndex: 0 },
    },
  };
}
function nte(t, e) {
  return {
    [`&-item:not(${e}-first-item):not(${e}-last-item)`]: { borderRadius: 0 },
    [`&-item${e}-first-item:not(${e}-last-item)`]: {
      [`&, &${t}-sm, &${t}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0,
      },
    },
    [`&-item${e}-last-item:not(${e}-first-item)`]: {
      [`&, &${t}-sm, &${t}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0,
      },
    },
  };
}
function rte(t) {
  const e = `${t.componentCls}-compact-vertical`;
  return {
    [e]: Object.assign(Object.assign({}, tte(t, e)), nte(t.componentCls, e)),
  };
}
const ite = (t) => {
    const { componentCls: e, calc: n } = t;
    return {
      [e]: {
        [`&-compact-item${e}-primary`]: {
          [`&:not([disabled]) + ${e}-compact-item${e}-primary:not([disabled])`]:
            {
              position: "relative",
              "&:before": {
                position: "absolute",
                top: n(t.lineWidth).mul(-1).equal(),
                insetInlineStart: n(t.lineWidth).mul(-1).equal(),
                display: "inline-block",
                width: t.lineWidth,
                height: `calc(100% + ${Ze(t.lineWidth)} * 2)`,
                backgroundColor: t.colorPrimaryHover,
                content: '""',
              },
            },
        },
        "&-compact-vertical-item": {
          [`&${e}-primary`]: {
            [`&:not([disabled]) + ${e}-compact-vertical-item${e}-primary:not([disabled])`]:
              {
                position: "relative",
                "&:before": {
                  position: "absolute",
                  top: n(t.lineWidth).mul(-1).equal(),
                  insetInlineStart: n(t.lineWidth).mul(-1).equal(),
                  display: "inline-block",
                  width: `calc(100% + ${Ze(t.lineWidth)} * 2)`,
                  height: t.lineWidth,
                  backgroundColor: t.colorPrimaryHover,
                  content: '""',
                },
              },
          },
        },
      },
    };
  },
  ote = WQ(
    ["Button", "compact"],
    (t) => {
      const e = kk(t);
      return [Vk(e), rte(e), ite(e)];
    },
    Bk
  );
var ate = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
function ste(t) {
  if (typeof t == "object" && t) {
    let e = t == null ? void 0 : t.delay;
    return (
      (e = !Number.isNaN(e) && typeof e == "number" ? e : 0),
      { loading: e <= 0, delay: e }
    );
  }
  return { loading: !!t, delay: 0 };
}
const lte = (t, e) => {
    var n, r;
    const {
        loading: i = !1,
        prefixCls: o,
        type: a = "default",
        danger: s,
        shape: l = "default",
        size: c,
        styles: u,
        disabled: d,
        className: p,
        rootClassName: m,
        children: v,
        icon: S,
        ghost: x = !1,
        block: g = !1,
        htmlType: _ = "button",
        classNames: y,
        style: w = {},
      } = t,
      A = ate(t, [
        "loading",
        "prefixCls",
        "type",
        "danger",
        "shape",
        "size",
        "styles",
        "disabled",
        "className",
        "rootClassName",
        "children",
        "icon",
        "ghost",
        "block",
        "htmlType",
        "classNames",
        "style",
      ]),
      {
        getPrefixCls: M,
        autoInsertSpaceInButton: T,
        direction: I,
        button: R,
      } = E.useContext(Rn),
      P = M("btn", o),
      [F, D, j] = Qee(P),
      N = E.useContext(Cm),
      V = d ?? N,
      W = E.useContext(zk),
      Q = E.useMemo(() => ste(i), [i]),
      [B, $] = E.useState(Q.loading),
      [G, k] = E.useState(!1),
      X = ls(e, E.createRef()),
      ee = E.Children.count(v) === 1 && !S && !V_(a);
    E.useEffect(() => {
      let Z = null;
      Q.delay > 0
        ? (Z = setTimeout(() => {
            (Z = null), $(!0);
          }, Q.delay))
        : $(Q.loading);
      function ge() {
        Z && (clearTimeout(Z), (Z = null));
      }
      return ge;
    }, [Q]),
      E.useEffect(() => {
        if (!X || !X.current || T === !1) return;
        const Z = X.current.textContent;
        ee && PE(Z) ? G || k(!0) : G && k(!1);
      }, [X]);
    const J = (Z) => {
        const { onClick: ge } = t;
        if (B || V) {
          Z.preventDefault();
          return;
        }
        ge == null || ge(Z);
      },
      oe = T !== !1,
      { compactSize: ae, compactItemClassnames: le } = g2(P, I),
      _e = { large: "lg", small: "sm", middle: void 0 },
      me = Tu((Z) => {
        var ge, ce;
        return (ce = (ge = c ?? ae) !== null && ge !== void 0 ? ge : W) !==
          null && ce !== void 0
          ? ce
          : Z;
      }),
      se = (me && _e[me]) || "",
      Y = B ? "loading" : S,
      ve = Ys(A, ["navigate"]),
      de = nt(
        P,
        D,
        j,
        {
          [`${P}-${l}`]: l !== "default" && l,
          [`${P}-${a}`]: a,
          [`${P}-${se}`]: se,
          [`${P}-icon-only`]: !v && v !== 0 && !!Y,
          [`${P}-background-ghost`]: x && !V_(a),
          [`${P}-loading`]: B,
          [`${P}-two-chinese-chars`]: G && oe && !B,
          [`${P}-block`]: g,
          [`${P}-dangerous`]: !!s,
          [`${P}-rtl`]: I === "rtl",
        },
        le,
        p,
        m,
        R == null ? void 0 : R.className
      ),
      ue = Object.assign(Object.assign({}, R == null ? void 0 : R.style), w),
      fe = nt(
        y == null ? void 0 : y.icon,
        (n = R == null ? void 0 : R.classNames) === null || n === void 0
          ? void 0
          : n.icon
      ),
      Te = Object.assign(
        Object.assign({}, (u == null ? void 0 : u.icon) || {}),
        ((r = R == null ? void 0 : R.styles) === null || r === void 0
          ? void 0
          : r.icon) || {}
      ),
      pe =
        S && !B
          ? at.createElement(Uk, { prefixCls: P, className: fe, style: Te }, S)
          : at.createElement(Dee, {
              existIcon: !!S,
              prefixCls: P,
              loading: !!B,
            }),
      H = v || v === 0 ? Oee(v, ee && oe) : null;
    if (ve.href !== void 0)
      return F(
        at.createElement(
          "a",
          Object.assign({}, ve, {
            className: nt(de, { [`${P}-disabled`]: V }),
            href: V ? void 0 : ve.href,
            style: ue,
            onClick: J,
            ref: X,
            tabIndex: V ? -1 : 0,
          }),
          pe,
          H
        )
      );
    let z = at.createElement(
      "button",
      Object.assign({}, A, {
        type: _,
        className: de,
        style: ue,
        onClick: J,
        disabled: V,
        ref: X,
      }),
      pe,
      H,
      !!le && at.createElement(ote, { key: "compact", prefixCls: P })
    );
    return (
      V_(a) ||
        (z = at.createElement(Fk, { component: "Button", disabled: !!B }, z)),
      F(z)
    );
  },
  x2 = E.forwardRef(lte);
x2.Group = Iee;
x2.__ANT_BUTTON = !0;
const Xo = x2;
var $k = E.createContext(null),
  PI = [];
function cte(t, e) {
  var n = E.useState(function () {
      if (!to()) return null;
      var v = document.createElement("div");
      return v;
    }),
    r = Ve(n, 1),
    i = r[0],
    o = E.useRef(!1),
    a = E.useContext($k),
    s = E.useState(PI),
    l = Ve(s, 2),
    c = l[0],
    u = l[1],
    d =
      a ||
      (o.current
        ? void 0
        : function (v) {
            u(function (S) {
              var x = [v].concat(It(S));
              return x;
            });
          });
  function p() {
    i.parentElement || document.body.appendChild(i), (o.current = !0);
  }
  function m() {
    var v;
    (v = i.parentElement) === null || v === void 0 || v.removeChild(i),
      (o.current = !1);
  }
  return (
    Hr(
      function () {
        return t ? (a ? a(p) : p()) : m(), m;
      },
      [t]
    ),
    Hr(
      function () {
        c.length &&
          (c.forEach(function (v) {
            return v();
          }),
          u(PI));
      },
      [c]
    ),
    [i, d]
  );
}
var W_;
function ute(t) {
  if (typeof document > "u") return 0;
  if (t || W_ === void 0) {
    var e = document.createElement("div");
    (e.style.width = "100%"), (e.style.height = "200px");
    var n = document.createElement("div"),
      r = n.style;
    (r.position = "absolute"),
      (r.top = "0"),
      (r.left = "0"),
      (r.pointerEvents = "none"),
      (r.visibility = "hidden"),
      (r.width = "200px"),
      (r.height = "150px"),
      (r.overflow = "hidden"),
      n.appendChild(e),
      document.body.appendChild(n);
    var i = e.offsetWidth;
    n.style.overflow = "scroll";
    var o = e.offsetWidth;
    i === o && (o = n.clientWidth), document.body.removeChild(n), (W_ = i - o);
  }
  return W_;
}
function II(t) {
  var e = t.match(/^(.*)px$/),
    n = Number(e == null ? void 0 : e[1]);
  return Number.isNaN(n) ? ute() : n;
}
function dte(t) {
  if (typeof document > "u" || !t || !(t instanceof Element))
    return { width: 0, height: 0 };
  var e = getComputedStyle(t, "::-webkit-scrollbar"),
    n = e.width,
    r = e.height;
  return { width: II(n), height: II(r) };
}
function fte() {
  return (
    document.body.scrollHeight >
      (window.innerHeight || document.documentElement.clientHeight) &&
    window.innerWidth > document.body.offsetWidth
  );
}
var hte = "rc-util-locker-".concat(Date.now()),
  LI = 0;
function pte(t) {
  var e = !!t,
    n = E.useState(function () {
      return (LI += 1), "".concat(hte, "_").concat(LI);
    }),
    r = Ve(n, 1),
    i = r[0];
  Hr(
    function () {
      if (e) {
        var o = dte(document.body).width,
          a = fte();
        Wl(
          `
html body {
  overflow-y: hidden;
  `.concat(
            a ? "width: calc(100% - ".concat(o, "px);") : "",
            `
}`
          ),
          i
        );
      } else Yp(i);
      return function () {
        Yp(i);
      };
    },
    [e, i]
  );
}
var OI = !1;
function mte(t) {
  return typeof t == "boolean" && (OI = t), OI;
}
var NI = function (e) {
    return e === !1
      ? !1
      : !to() || !e
      ? null
      : typeof e == "string"
      ? document.querySelector(e)
      : typeof e == "function"
      ? e()
      : e;
  },
  Gk = E.forwardRef(function (t, e) {
    var n = t.open,
      r = t.autoLock,
      i = t.getContainer;
    t.debug;
    var o = t.autoDestroy,
      a = o === void 0 ? !0 : o,
      s = t.children,
      l = E.useState(n),
      c = Ve(l, 2),
      u = c[0],
      d = c[1],
      p = u || n;
    E.useEffect(
      function () {
        (a || n) && d(n);
      },
      [n, a]
    );
    var m = E.useState(function () {
        return NI(i);
      }),
      v = Ve(m, 2),
      S = v[0],
      x = v[1];
    E.useEffect(function () {
      var F = NI(i);
      x(F ?? null);
    });
    var g = cte(p && !S),
      _ = Ve(g, 2),
      y = _[0],
      w = _[1],
      A = S ?? y;
    pte(r && n && to() && (A === y || A === document.body));
    var M = null;
    if (s && wu(s) && e) {
      var T = s;
      M = T.ref;
    }
    var I = Em(M, e);
    if (!p || !to() || S === void 0) return null;
    var R = A === !1 || mte(),
      P = s;
    return (
      e && (P = E.cloneElement(s, { ref: I })),
      E.createElement($k.Provider, { value: w }, R ? P : Cf.createPortal(P, A))
    );
  });
function gte() {
  var t = De({}, ru);
  return t.useId;
}
var FI = 0,
  DI = gte();
const vte = DI
  ? function (e) {
      var n = DI();
      return e || n;
    }
  : function (e) {
      var n = E.useState("ssr-id"),
        r = Ve(n, 2),
        i = r[0],
        o = r[1];
      return (
        E.useEffect(function () {
          var a = FI;
          (FI += 1), o("rc_unique_".concat(a));
        }, []),
        e || i
      );
    };
var $c = "RC_FORM_INTERNAL_HOOKS",
  Pn = function () {
    Ni(
      !1,
      "Can not find FormContext. Please make sure you wrap Field under Form."
    );
  },
  bf = E.createContext({
    getFieldValue: Pn,
    getFieldsValue: Pn,
    getFieldError: Pn,
    getFieldWarning: Pn,
    getFieldsError: Pn,
    isFieldsTouched: Pn,
    isFieldTouched: Pn,
    isFieldValidating: Pn,
    isFieldsValidating: Pn,
    resetFields: Pn,
    setFields: Pn,
    setFieldValue: Pn,
    setFieldsValue: Pn,
    validateFields: Pn,
    submit: Pn,
    getInternalHooks: function () {
      return (
        Pn(),
        {
          dispatch: Pn,
          initEntityValue: Pn,
          registerField: Pn,
          useSubscribe: Pn,
          setInitialValues: Pn,
          destroyForm: Pn,
          setCallbacks: Pn,
          registerWatch: Pn,
          getFields: Pn,
          setValidateMessages: Pn,
          setPreserve: Pn,
          getInitialValue: Pn,
        }
      );
    },
  }),
  Ry = E.createContext(null);
function IE(t) {
  return t == null ? [] : Array.isArray(t) ? t : [t];
}
function yte(t) {
  return t && !!t._init;
}
function Gc() {
  return (
    (Gc = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Gc.apply(this, arguments)
  );
}
function xte(t, e) {
  (t.prototype = Object.create(e.prototype)),
    (t.prototype.constructor = t),
    nm(t, e);
}
function LE(t) {
  return (
    (LE = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (n) {
          return n.__proto__ || Object.getPrototypeOf(n);
        }),
    LE(t)
  );
}
function nm(t, e) {
  return (
    (nm = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, i) {
          return (r.__proto__ = i), r;
        }),
    nm(t, e)
  );
}
function Ste() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    );
  } catch {
    return !1;
  }
}
function O0(t, e, n) {
  return (
    Ste()
      ? (O0 = Reflect.construct.bind())
      : (O0 = function (i, o, a) {
          var s = [null];
          s.push.apply(s, o);
          var l = Function.bind.apply(i, s),
            c = new l();
          return a && nm(c, a.prototype), c;
        }),
    O0.apply(null, arguments)
  );
}
function _te(t) {
  return Function.toString.call(t).indexOf("[native code]") !== -1;
}
function OE(t) {
  var e = typeof Map == "function" ? new Map() : void 0;
  return (
    (OE = function (r) {
      if (r === null || !_te(r)) return r;
      if (typeof r != "function")
        throw new TypeError(
          "Super expression must either be null or a function"
        );
      if (typeof e < "u") {
        if (e.has(r)) return e.get(r);
        e.set(r, i);
      }
      function i() {
        return O0(r, arguments, LE(this).constructor);
      }
      return (
        (i.prototype = Object.create(r.prototype, {
          constructor: {
            value: i,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })),
        nm(i, r)
      );
    }),
    OE(t)
  );
}
var bte = /%[sdj%]/g,
  wte = function () {};
function NE(t) {
  if (!t || !t.length) return null;
  var e = {};
  return (
    t.forEach(function (n) {
      var r = n.field;
      (e[r] = e[r] || []), e[r].push(n);
    }),
    e
  );
}
function Co(t) {
  for (
    var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1;
    r < e;
    r++
  )
    n[r - 1] = arguments[r];
  var i = 0,
    o = n.length;
  if (typeof t == "function") return t.apply(null, n);
  if (typeof t == "string") {
    var a = t.replace(bte, function (s) {
      if (s === "%%") return "%";
      if (i >= o) return s;
      switch (s) {
        case "%s":
          return String(n[i++]);
        case "%d":
          return Number(n[i++]);
        case "%j":
          try {
            return JSON.stringify(n[i++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return s;
      }
    });
    return a;
  }
  return t;
}
function Ete(t) {
  return (
    t === "string" ||
    t === "url" ||
    t === "hex" ||
    t === "email" ||
    t === "date" ||
    t === "pattern"
  );
}
function Lr(t, e) {
  return !!(
    t == null ||
    (e === "array" && Array.isArray(t) && !t.length) ||
    (Ete(e) && typeof t == "string" && !t)
  );
}
function Mte(t, e, n) {
  var r = [],
    i = 0,
    o = t.length;
  function a(s) {
    r.push.apply(r, s || []), i++, i === o && n(r);
  }
  t.forEach(function (s) {
    e(s, a);
  });
}
function zI(t, e, n) {
  var r = 0,
    i = t.length;
  function o(a) {
    if (a && a.length) {
      n(a);
      return;
    }
    var s = r;
    (r = r + 1), s < i ? e(t[s], o) : n([]);
  }
  o([]);
}
function Cte(t) {
  var e = [];
  return (
    Object.keys(t).forEach(function (n) {
      e.push.apply(e, t[n] || []);
    }),
    e
  );
}
var UI = (function (t) {
  xte(e, t);
  function e(n, r) {
    var i;
    return (
      (i = t.call(this, "Async Validation Error") || this),
      (i.errors = n),
      (i.fields = r),
      i
    );
  }
  return e;
})(OE(Error));
function Tte(t, e, n, r, i) {
  if (e.first) {
    var o = new Promise(function (p, m) {
      var v = function (g) {
          return r(g), g.length ? m(new UI(g, NE(g))) : p(i);
        },
        S = Cte(t);
      zI(S, n, v);
    });
    return (
      o.catch(function (p) {
        return p;
      }),
      o
    );
  }
  var a = e.firstFields === !0 ? Object.keys(t) : e.firstFields || [],
    s = Object.keys(t),
    l = s.length,
    c = 0,
    u = [],
    d = new Promise(function (p, m) {
      var v = function (x) {
        if ((u.push.apply(u, x), c++, c === l))
          return r(u), u.length ? m(new UI(u, NE(u))) : p(i);
      };
      s.length || (r(u), p(i)),
        s.forEach(function (S) {
          var x = t[S];
          a.indexOf(S) !== -1 ? zI(x, n, v) : Mte(x, n, v);
        });
    });
  return (
    d.catch(function (p) {
      return p;
    }),
    d
  );
}
function Ate(t) {
  return !!(t && t.message !== void 0);
}
function Rte(t, e) {
  for (var n = t, r = 0; r < e.length; r++) {
    if (n == null) return n;
    n = n[e[r]];
  }
  return n;
}
function kI(t, e) {
  return function (n) {
    var r;
    return (
      t.fullFields
        ? (r = Rte(e, t.fullFields))
        : (r = e[n.field || t.fullField]),
      Ate(n)
        ? ((n.field = n.field || t.fullField), (n.fieldValue = r), n)
        : {
            message: typeof n == "function" ? n() : n,
            fieldValue: r,
            field: n.field || t.fullField,
          }
    );
  };
}
function BI(t, e) {
  if (e) {
    for (var n in e)
      if (e.hasOwnProperty(n)) {
        var r = e[n];
        typeof r == "object" && typeof t[n] == "object"
          ? (t[n] = Gc({}, t[n], r))
          : (t[n] = r);
      }
  }
  return t;
}
var Wk = function (e, n, r, i, o, a) {
    e.required &&
      (!r.hasOwnProperty(e.field) || Lr(n, a || e.type)) &&
      i.push(Co(o.messages.required, e.fullField));
  },
  Pte = function (e, n, r, i, o) {
    (/^\s+$/.test(n) || n === "") &&
      i.push(Co(o.messages.whitespace, e.fullField));
  },
  e0,
  Ite = function () {
    if (e0) return e0;
    var t = "[a-fA-F\\d:]",
      e = function (w) {
        return w && w.includeBoundaries
          ? "(?:(?<=\\s|^)(?=" + t + ")|(?<=" + t + ")(?=\\s|$))"
          : "";
      },
      n =
        "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",
      r = "[a-fA-F\\d]{1,4}",
      i = (
        `
(?:
(?:` +
        r +
        ":){7}(?:" +
        r +
        `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` +
        r +
        ":){6}(?:" +
        n +
        "|:" +
        r +
        `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` +
        r +
        ":){5}(?::" +
        n +
        "|(?::" +
        r +
        `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` +
        r +
        ":){4}(?:(?::" +
        r +
        "){0,1}:" +
        n +
        "|(?::" +
        r +
        `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` +
        r +
        ":){3}(?:(?::" +
        r +
        "){0,2}:" +
        n +
        "|(?::" +
        r +
        `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` +
        r +
        ":){2}(?:(?::" +
        r +
        "){0,3}:" +
        n +
        "|(?::" +
        r +
        `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` +
        r +
        ":){1}(?:(?::" +
        r +
        "){0,4}:" +
        n +
        "|(?::" +
        r +
        `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` +
        r +
        "){0,5}:" +
        n +
        "|(?::" +
        r +
        `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`
      )
        .replace(/\s*\/\/.*$/gm, "")
        .replace(/\n/g, "")
        .trim(),
      o = new RegExp("(?:^" + n + "$)|(?:^" + i + "$)"),
      a = new RegExp("^" + n + "$"),
      s = new RegExp("^" + i + "$"),
      l = function (w) {
        return w && w.exact
          ? o
          : new RegExp(
              "(?:" + e(w) + n + e(w) + ")|(?:" + e(w) + i + e(w) + ")",
              "g"
            );
      };
    (l.v4 = function (y) {
      return y && y.exact ? a : new RegExp("" + e(y) + n + e(y), "g");
    }),
      (l.v6 = function (y) {
        return y && y.exact ? s : new RegExp("" + e(y) + i + e(y), "g");
      });
    var c = "(?:(?:[a-z]+:)?//)",
      u = "(?:\\S+(?::\\S*)?@)?",
      d = l.v4().source,
      p = l.v6().source,
      m = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)",
      v = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*",
      S = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))",
      x = "(?::\\d{2,5})?",
      g = '(?:[/?#][^\\s"]*)?',
      _ =
        "(?:" +
        c +
        "|www\\.)" +
        u +
        "(?:localhost|" +
        d +
        "|" +
        p +
        "|" +
        m +
        v +
        S +
        ")" +
        x +
        g;
    return (e0 = new RegExp("(?:^" + _ + "$)", "i")), e0;
  },
  HI = {
    email:
      /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,
  },
  Uh = {
    integer: function (e) {
      return Uh.number(e) && parseInt(e, 10) === e;
    },
    float: function (e) {
      return Uh.number(e) && !Uh.integer(e);
    },
    array: function (e) {
      return Array.isArray(e);
    },
    regexp: function (e) {
      if (e instanceof RegExp) return !0;
      try {
        return !!new RegExp(e);
      } catch {
        return !1;
      }
    },
    date: function (e) {
      return (
        typeof e.getTime == "function" &&
        typeof e.getMonth == "function" &&
        typeof e.getYear == "function" &&
        !isNaN(e.getTime())
      );
    },
    number: function (e) {
      return isNaN(e) ? !1 : typeof e == "number";
    },
    object: function (e) {
      return typeof e == "object" && !Uh.array(e);
    },
    method: function (e) {
      return typeof e == "function";
    },
    email: function (e) {
      return typeof e == "string" && e.length <= 320 && !!e.match(HI.email);
    },
    url: function (e) {
      return typeof e == "string" && e.length <= 2048 && !!e.match(Ite());
    },
    hex: function (e) {
      return typeof e == "string" && !!e.match(HI.hex);
    },
  },
  Lte = function (e, n, r, i, o) {
    if (e.required && n === void 0) {
      Wk(e, n, r, i, o);
      return;
    }
    var a = [
        "integer",
        "float",
        "array",
        "regexp",
        "object",
        "method",
        "email",
        "number",
        "date",
        "url",
        "hex",
      ],
      s = e.type;
    a.indexOf(s) > -1
      ? Uh[s](n) || i.push(Co(o.messages.types[s], e.fullField, e.type))
      : s &&
        typeof n !== e.type &&
        i.push(Co(o.messages.types[s], e.fullField, e.type));
  },
  Ote = function (e, n, r, i, o) {
    var a = typeof e.len == "number",
      s = typeof e.min == "number",
      l = typeof e.max == "number",
      c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
      u = n,
      d = null,
      p = typeof n == "number",
      m = typeof n == "string",
      v = Array.isArray(n);
    if ((p ? (d = "number") : m ? (d = "string") : v && (d = "array"), !d))
      return !1;
    v && (u = n.length),
      m && (u = n.replace(c, "_").length),
      a
        ? u !== e.len && i.push(Co(o.messages[d].len, e.fullField, e.len))
        : s && !l && u < e.min
        ? i.push(Co(o.messages[d].min, e.fullField, e.min))
        : l && !s && u > e.max
        ? i.push(Co(o.messages[d].max, e.fullField, e.max))
        : s &&
          l &&
          (u < e.min || u > e.max) &&
          i.push(Co(o.messages[d].range, e.fullField, e.min, e.max));
  },
  fd = "enum",
  Nte = function (e, n, r, i, o) {
    (e[fd] = Array.isArray(e[fd]) ? e[fd] : []),
      e[fd].indexOf(n) === -1 &&
        i.push(Co(o.messages[fd], e.fullField, e[fd].join(", ")));
  },
  Fte = function (e, n, r, i, o) {
    if (e.pattern) {
      if (e.pattern instanceof RegExp)
        (e.pattern.lastIndex = 0),
          e.pattern.test(n) ||
            i.push(Co(o.messages.pattern.mismatch, e.fullField, n, e.pattern));
      else if (typeof e.pattern == "string") {
        var a = new RegExp(e.pattern);
        a.test(n) ||
          i.push(Co(o.messages.pattern.mismatch, e.fullField, n, e.pattern));
      }
    }
  },
  an = {
    required: Wk,
    whitespace: Pte,
    type: Lte,
    range: Ote,
    enum: Nte,
    pattern: Fte,
  },
  Dte = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if (Lr(n, "string") && !e.required) return r();
      an.required(e, n, i, a, o, "string"),
        Lr(n, "string") ||
          (an.type(e, n, i, a, o),
          an.range(e, n, i, a, o),
          an.pattern(e, n, i, a, o),
          e.whitespace === !0 && an.whitespace(e, n, i, a, o));
    }
    r(a);
  },
  zte = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if (Lr(n) && !e.required) return r();
      an.required(e, n, i, a, o), n !== void 0 && an.type(e, n, i, a, o);
    }
    r(a);
  },
  Ute = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if ((n === "" && (n = void 0), Lr(n) && !e.required)) return r();
      an.required(e, n, i, a, o),
        n !== void 0 && (an.type(e, n, i, a, o), an.range(e, n, i, a, o));
    }
    r(a);
  },
  kte = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if (Lr(n) && !e.required) return r();
      an.required(e, n, i, a, o), n !== void 0 && an.type(e, n, i, a, o);
    }
    r(a);
  },
  Bte = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if (Lr(n) && !e.required) return r();
      an.required(e, n, i, a, o), Lr(n) || an.type(e, n, i, a, o);
    }
    r(a);
  },
  Hte = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if (Lr(n) && !e.required) return r();
      an.required(e, n, i, a, o),
        n !== void 0 && (an.type(e, n, i, a, o), an.range(e, n, i, a, o));
    }
    r(a);
  },
  jte = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if (Lr(n) && !e.required) return r();
      an.required(e, n, i, a, o),
        n !== void 0 && (an.type(e, n, i, a, o), an.range(e, n, i, a, o));
    }
    r(a);
  },
  Vte = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if (n == null && !e.required) return r();
      an.required(e, n, i, a, o, "array"),
        n != null && (an.type(e, n, i, a, o), an.range(e, n, i, a, o));
    }
    r(a);
  },
  $te = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if (Lr(n) && !e.required) return r();
      an.required(e, n, i, a, o), n !== void 0 && an.type(e, n, i, a, o);
    }
    r(a);
  },
  Gte = "enum",
  Wte = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if (Lr(n) && !e.required) return r();
      an.required(e, n, i, a, o), n !== void 0 && an[Gte](e, n, i, a, o);
    }
    r(a);
  },
  Xte = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if (Lr(n, "string") && !e.required) return r();
      an.required(e, n, i, a, o), Lr(n, "string") || an.pattern(e, n, i, a, o);
    }
    r(a);
  },
  qte = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if (Lr(n, "date") && !e.required) return r();
      if ((an.required(e, n, i, a, o), !Lr(n, "date"))) {
        var l;
        n instanceof Date ? (l = n) : (l = new Date(n)),
          an.type(e, l, i, a, o),
          l && an.range(e, l.getTime(), i, a, o);
      }
    }
    r(a);
  },
  Kte = function (e, n, r, i, o) {
    var a = [],
      s = Array.isArray(n) ? "array" : typeof n;
    an.required(e, n, i, a, o, s), r(a);
  },
  X_ = function (e, n, r, i, o) {
    var a = e.type,
      s = [],
      l = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (l) {
      if (Lr(n, a) && !e.required) return r();
      an.required(e, n, i, s, o, a), Lr(n, a) || an.type(e, n, i, s, o);
    }
    r(s);
  },
  Yte = function (e, n, r, i, o) {
    var a = [],
      s = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (s) {
      if (Lr(n) && !e.required) return r();
      an.required(e, n, i, a, o);
    }
    r(a);
  },
  ap = {
    string: Dte,
    method: zte,
    number: Ute,
    boolean: kte,
    regexp: Bte,
    integer: Hte,
    float: jte,
    array: Vte,
    object: $te,
    enum: Wte,
    pattern: Xte,
    date: qte,
    url: X_,
    hex: X_,
    email: X_,
    required: Kte,
    any: Yte,
  };
function FE() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid",
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s",
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters",
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s",
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length",
    },
    pattern: { mismatch: "%s value %s does not match pattern %s" },
    clone: function () {
      var e = JSON.parse(JSON.stringify(this));
      return (e.clone = this.clone), e;
    },
  };
}
var DE = FE(),
  Im = (function () {
    function t(n) {
      (this.rules = null), (this._messages = DE), this.define(n);
    }
    var e = t.prototype;
    return (
      (e.define = function (r) {
        var i = this;
        if (!r) throw new Error("Cannot configure a schema with no rules");
        if (typeof r != "object" || Array.isArray(r))
          throw new Error("Rules must be an object");
        (this.rules = {}),
          Object.keys(r).forEach(function (o) {
            var a = r[o];
            i.rules[o] = Array.isArray(a) ? a : [a];
          });
      }),
      (e.messages = function (r) {
        return r && (this._messages = BI(FE(), r)), this._messages;
      }),
      (e.validate = function (r, i, o) {
        var a = this;
        i === void 0 && (i = {}), o === void 0 && (o = function () {});
        var s = r,
          l = i,
          c = o;
        if (
          (typeof l == "function" && ((c = l), (l = {})),
          !this.rules || Object.keys(this.rules).length === 0)
        )
          return c && c(null, s), Promise.resolve(s);
        function u(S) {
          var x = [],
            g = {};
          function _(w) {
            if (Array.isArray(w)) {
              var A;
              x = (A = x).concat.apply(A, w);
            } else x.push(w);
          }
          for (var y = 0; y < S.length; y++) _(S[y]);
          x.length ? ((g = NE(x)), c(x, g)) : c(null, s);
        }
        if (l.messages) {
          var d = this.messages();
          d === DE && (d = FE()), BI(d, l.messages), (l.messages = d);
        } else l.messages = this.messages();
        var p = {},
          m = l.keys || Object.keys(this.rules);
        m.forEach(function (S) {
          var x = a.rules[S],
            g = s[S];
          x.forEach(function (_) {
            var y = _;
            typeof y.transform == "function" &&
              (s === r && (s = Gc({}, s)), (g = s[S] = y.transform(g))),
              typeof y == "function" ? (y = { validator: y }) : (y = Gc({}, y)),
              (y.validator = a.getValidationMethod(y)),
              y.validator &&
                ((y.field = S),
                (y.fullField = y.fullField || S),
                (y.type = a.getType(y)),
                (p[S] = p[S] || []),
                p[S].push({ rule: y, value: g, source: s, field: S }));
          });
        });
        var v = {};
        return Tte(
          p,
          l,
          function (S, x) {
            var g = S.rule,
              _ =
                (g.type === "object" || g.type === "array") &&
                (typeof g.fields == "object" ||
                  typeof g.defaultField == "object");
            (_ = _ && (g.required || (!g.required && S.value))),
              (g.field = S.field);
            function y(M, T) {
              return Gc({}, T, {
                fullField: g.fullField + "." + M,
                fullFields: g.fullFields ? [].concat(g.fullFields, [M]) : [M],
              });
            }
            function w(M) {
              M === void 0 && (M = []);
              var T = Array.isArray(M) ? M : [M];
              !l.suppressWarning &&
                T.length &&
                t.warning("async-validator:", T),
                T.length && g.message !== void 0 && (T = [].concat(g.message));
              var I = T.map(kI(g, s));
              if (l.first && I.length) return (v[g.field] = 1), x(I);
              if (!_) x(I);
              else {
                if (g.required && !S.value)
                  return (
                    g.message !== void 0
                      ? (I = [].concat(g.message).map(kI(g, s)))
                      : l.error &&
                        (I = [l.error(g, Co(l.messages.required, g.field))]),
                    x(I)
                  );
                var R = {};
                g.defaultField &&
                  Object.keys(S.value).map(function (D) {
                    R[D] = g.defaultField;
                  }),
                  (R = Gc({}, R, S.rule.fields));
                var P = {};
                Object.keys(R).forEach(function (D) {
                  var j = R[D],
                    N = Array.isArray(j) ? j : [j];
                  P[D] = N.map(y.bind(null, D));
                });
                var F = new t(P);
                F.messages(l.messages),
                  S.rule.options &&
                    ((S.rule.options.messages = l.messages),
                    (S.rule.options.error = l.error)),
                  F.validate(S.value, S.rule.options || l, function (D) {
                    var j = [];
                    I && I.length && j.push.apply(j, I),
                      D && D.length && j.push.apply(j, D),
                      x(j.length ? j : null);
                  });
              }
            }
            var A;
            if (g.asyncValidator)
              A = g.asyncValidator(g, S.value, w, S.source, l);
            else if (g.validator) {
              try {
                A = g.validator(g, S.value, w, S.source, l);
              } catch (M) {
                console.error == null || console.error(M),
                  l.suppressValidatorError ||
                    setTimeout(function () {
                      throw M;
                    }, 0),
                  w(M.message);
              }
              A === !0
                ? w()
                : A === !1
                ? w(
                    typeof g.message == "function"
                      ? g.message(g.fullField || g.field)
                      : g.message || (g.fullField || g.field) + " fails"
                  )
                : A instanceof Array
                ? w(A)
                : A instanceof Error && w(A.message);
            }
            A &&
              A.then &&
              A.then(
                function () {
                  return w();
                },
                function (M) {
                  return w(M);
                }
              );
          },
          function (S) {
            u(S);
          },
          s
        );
      }),
      (e.getType = function (r) {
        if (
          (r.type === void 0 &&
            r.pattern instanceof RegExp &&
            (r.type = "pattern"),
          typeof r.validator != "function" &&
            r.type &&
            !ap.hasOwnProperty(r.type))
        )
          throw new Error(Co("Unknown rule type %s", r.type));
        return r.type || "string";
      }),
      (e.getValidationMethod = function (r) {
        if (typeof r.validator == "function") return r.validator;
        var i = Object.keys(r),
          o = i.indexOf("message");
        return (
          o !== -1 && i.splice(o, 1),
          i.length === 1 && i[0] === "required"
            ? ap.required
            : ap[this.getType(r)] || void 0
        );
      }),
      t
    );
  })();
Im.register = function (e, n) {
  if (typeof n != "function")
    throw new Error(
      "Cannot register a validator by type, validator is not a function"
    );
  ap[e] = n;
};
Im.warning = wte;
Im.messages = DE;
Im.validators = ap;
var yo = "'${name}' is not a valid ${type}",
  Xk = {
    default: "Validation error on field '${name}'",
    required: "'${name}' is required",
    enum: "'${name}' must be one of [${enum}]",
    whitespace: "'${name}' cannot be empty",
    date: {
      format: "'${name}' is invalid for format date",
      parse: "'${name}' could not be parsed as date",
      invalid: "'${name}' is invalid date",
    },
    types: {
      string: yo,
      method: yo,
      array: yo,
      object: yo,
      number: yo,
      date: yo,
      boolean: yo,
      integer: yo,
      float: yo,
      regexp: yo,
      email: yo,
      url: yo,
      hex: yo,
    },
    string: {
      len: "'${name}' must be exactly ${len} characters",
      min: "'${name}' must be at least ${min} characters",
      max: "'${name}' cannot be longer than ${max} characters",
      range: "'${name}' must be between ${min} and ${max} characters",
    },
    number: {
      len: "'${name}' must equal ${len}",
      min: "'${name}' cannot be less than ${min}",
      max: "'${name}' cannot be greater than ${max}",
      range: "'${name}' must be between ${min} and ${max}",
    },
    array: {
      len: "'${name}' must be exactly ${len} in length",
      min: "'${name}' cannot be less than ${min} in length",
      max: "'${name}' cannot be greater than ${max} in length",
      range: "'${name}' must be between ${min} and ${max} in length",
    },
    pattern: { mismatch: "'${name}' does not match pattern ${pattern}" },
  },
  jI = Im;
function Zte(t, e) {
  return t.replace(/\$\{\w+\}/g, function (n) {
    var r = n.slice(2, -1);
    return e[r];
  });
}
var VI = "CODE_LOGIC_ERROR";
function zE(t, e, n, r, i) {
  return UE.apply(this, arguments);
}
function UE() {
  return (
    (UE = Cu(
      vi().mark(function t(e, n, r, i, o) {
        var a, s, l, c, u, d, p, m, v;
        return vi().wrap(
          function (x) {
            for (;;)
              switch ((x.prev = x.next)) {
                case 0:
                  return (
                    (a = De({}, r)),
                    delete a.ruleIndex,
                    (jI.warning = function () {}),
                    a.validator &&
                      ((s = a.validator),
                      (a.validator = function () {
                        try {
                          return s.apply(void 0, arguments);
                        } catch (g) {
                          return console.error(g), Promise.reject(VI);
                        }
                      })),
                    (l = null),
                    a &&
                      a.type === "array" &&
                      a.defaultField &&
                      ((l = a.defaultField), delete a.defaultField),
                    (c = new jI(be({}, e, [a]))),
                    (u = $d(Xk, i.validateMessages)),
                    c.messages(u),
                    (d = []),
                    (x.prev = 10),
                    (x.next = 13),
                    Promise.resolve(c.validate(be({}, e, n), De({}, i)))
                  );
                case 13:
                  x.next = 18;
                  break;
                case 15:
                  (x.prev = 15),
                    (x.t0 = x.catch(10)),
                    x.t0.errors &&
                      (d = x.t0.errors.map(function (g, _) {
                        var y = g.message,
                          w = y === VI ? u.default : y;
                        return E.isValidElement(w)
                          ? E.cloneElement(w, { key: "error_".concat(_) })
                          : w;
                      }));
                case 18:
                  if (!(!d.length && l)) {
                    x.next = 23;
                    break;
                  }
                  return (
                    (x.next = 21),
                    Promise.all(
                      n.map(function (g, _) {
                        return zE("".concat(e, ".").concat(_), g, l, i, o);
                      })
                    )
                  );
                case 21:
                  return (
                    (p = x.sent),
                    x.abrupt(
                      "return",
                      p.reduce(function (g, _) {
                        return [].concat(It(g), It(_));
                      }, [])
                    )
                  );
                case 23:
                  return (
                    (m = De(
                      De({}, r),
                      {},
                      { name: e, enum: (r.enum || []).join(", ") },
                      o
                    )),
                    (v = d.map(function (g) {
                      return typeof g == "string" ? Zte(g, m) : g;
                    })),
                    x.abrupt("return", v)
                  );
                case 26:
                case "end":
                  return x.stop();
              }
          },
          t,
          null,
          [[10, 15]]
        );
      })
    )),
    UE.apply(this, arguments)
  );
}
function Qte(t, e, n, r, i, o) {
  var a = t.join("."),
    s = n
      .map(function (u, d) {
        var p = u.validator,
          m = De(De({}, u), {}, { ruleIndex: d });
        return (
          p &&
            (m.validator = function (v, S, x) {
              var g = !1,
                _ = function () {
                  for (
                    var A = arguments.length, M = new Array(A), T = 0;
                    T < A;
                    T++
                  )
                    M[T] = arguments[T];
                  Promise.resolve().then(function () {
                    Ni(
                      !g,
                      "Your validator function has already return a promise. `callback` will be ignored."
                    ),
                      g || x.apply(void 0, M);
                  });
                },
                y = p(v, S, _);
              (g =
                y &&
                typeof y.then == "function" &&
                typeof y.catch == "function"),
                Ni(
                  g,
                  "`callback` is deprecated. Please return a promise instead."
                ),
                g &&
                  y
                    .then(function () {
                      x();
                    })
                    .catch(function (w) {
                      x(w || " ");
                    });
            }),
          m
        );
      })
      .sort(function (u, d) {
        var p = u.warningOnly,
          m = u.ruleIndex,
          v = d.warningOnly,
          S = d.ruleIndex;
        return !!p == !!v ? m - S : p ? 1 : -1;
      }),
    l;
  if (i === !0)
    l = new Promise(
      (function () {
        var u = Cu(
          vi().mark(function d(p, m) {
            var v, S, x;
            return vi().wrap(function (_) {
              for (;;)
                switch ((_.prev = _.next)) {
                  case 0:
                    v = 0;
                  case 1:
                    if (!(v < s.length)) {
                      _.next = 12;
                      break;
                    }
                    return (S = s[v]), (_.next = 5), zE(a, e, S, r, o);
                  case 5:
                    if (((x = _.sent), !x.length)) {
                      _.next = 9;
                      break;
                    }
                    return m([{ errors: x, rule: S }]), _.abrupt("return");
                  case 9:
                    (v += 1), (_.next = 1);
                    break;
                  case 12:
                    p([]);
                  case 13:
                  case "end":
                    return _.stop();
                }
            }, d);
          })
        );
        return function (d, p) {
          return u.apply(this, arguments);
        };
      })()
    );
  else {
    var c = s.map(function (u) {
      return zE(a, e, u, r, o).then(function (d) {
        return { errors: d, rule: u };
      });
    });
    l = (i ? ene(c) : Jte(c)).then(function (u) {
      return Promise.reject(u);
    });
  }
  return (
    l.catch(function (u) {
      return u;
    }),
    l
  );
}
function Jte(t) {
  return kE.apply(this, arguments);
}
function kE() {
  return (
    (kE = Cu(
      vi().mark(function t(e) {
        return vi().wrap(function (r) {
          for (;;)
            switch ((r.prev = r.next)) {
              case 0:
                return r.abrupt(
                  "return",
                  Promise.all(e).then(function (i) {
                    var o,
                      a = (o = []).concat.apply(o, It(i));
                    return a;
                  })
                );
              case 1:
              case "end":
                return r.stop();
            }
        }, t);
      })
    )),
    kE.apply(this, arguments)
  );
}
function ene(t) {
  return BE.apply(this, arguments);
}
function BE() {
  return (
    (BE = Cu(
      vi().mark(function t(e) {
        var n;
        return vi().wrap(function (i) {
          for (;;)
            switch ((i.prev = i.next)) {
              case 0:
                return (
                  (n = 0),
                  i.abrupt(
                    "return",
                    new Promise(function (o) {
                      e.forEach(function (a) {
                        a.then(function (s) {
                          s.errors.length && o([s]),
                            (n += 1),
                            n === e.length && o([]);
                        });
                      });
                    })
                  )
                );
              case 2:
              case "end":
                return i.stop();
            }
        }, t);
      })
    )),
    BE.apply(this, arguments)
  );
}
function hr(t) {
  return IE(t);
}
function $I(t, e) {
  var n = {};
  return (
    e.forEach(function (r) {
      var i = Ya(t, r);
      n = ya(n, r, i);
    }),
    n
  );
}
function tf(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return (
    t &&
    t.some(function (r) {
      return qk(e, r, n);
    })
  );
}
function qk(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return !t || !e || (!n && t.length !== e.length)
    ? !1
    : e.every(function (r, i) {
        return t[i] === r;
      });
}
function tne(t, e) {
  if (t === e) return !0;
  if (
    (!t && e) ||
    (t && !e) ||
    !t ||
    !e ||
    un(t) !== "object" ||
    un(e) !== "object"
  )
    return !1;
  var n = Object.keys(t),
    r = Object.keys(e),
    i = new Set([].concat(n, r));
  return It(i).every(function (o) {
    var a = t[o],
      s = e[o];
    return typeof a == "function" && typeof s == "function" ? !0 : a === s;
  });
}
function nne(t) {
  var e = arguments.length <= 1 ? void 0 : arguments[1];
  return e && e.target && un(e.target) === "object" && t in e.target
    ? e.target[t]
    : e;
}
function GI(t, e, n) {
  var r = t.length;
  if (e < 0 || e >= r || n < 0 || n >= r) return t;
  var i = t[e],
    o = e - n;
  return o > 0
    ? [].concat(
        It(t.slice(0, n)),
        [i],
        It(t.slice(n, e)),
        It(t.slice(e + 1, r))
      )
    : o < 0
    ? [].concat(
        It(t.slice(0, e)),
        It(t.slice(e + 1, n + 1)),
        [i],
        It(t.slice(n + 1, r))
      )
    : t;
}
var rne = ["name"],
  $o = [];
function WI(t, e, n, r, i, o) {
  return typeof t == "function"
    ? t(e, n, "source" in o ? { source: o.source } : {})
    : r !== i;
}
var S2 = (function (t) {
  Eu(n, t);
  var e = Mm(n);
  function n(r) {
    var i;
    if (
      (ro(this, n),
      (i = e.call(this, r)),
      be(hn(i), "state", { resetCount: 0 }),
      be(hn(i), "cancelRegisterFunc", null),
      be(hn(i), "mounted", !1),
      be(hn(i), "touched", !1),
      be(hn(i), "dirty", !1),
      be(hn(i), "validatePromise", void 0),
      be(hn(i), "prevValidating", void 0),
      be(hn(i), "errors", $o),
      be(hn(i), "warnings", $o),
      be(hn(i), "cancelRegister", function () {
        var l = i.props,
          c = l.preserve,
          u = l.isListField,
          d = l.name;
        i.cancelRegisterFunc && i.cancelRegisterFunc(u, c, hr(d)),
          (i.cancelRegisterFunc = null);
      }),
      be(hn(i), "getNamePath", function () {
        var l = i.props,
          c = l.name,
          u = l.fieldContext,
          d = u.prefixName,
          p = d === void 0 ? [] : d;
        return c !== void 0 ? [].concat(It(p), It(c)) : [];
      }),
      be(hn(i), "getRules", function () {
        var l = i.props,
          c = l.rules,
          u = c === void 0 ? [] : c,
          d = l.fieldContext;
        return u.map(function (p) {
          return typeof p == "function" ? p(d) : p;
        });
      }),
      be(hn(i), "refresh", function () {
        i.mounted &&
          i.setState(function (l) {
            var c = l.resetCount;
            return { resetCount: c + 1 };
          });
      }),
      be(hn(i), "metaCache", null),
      be(hn(i), "triggerMetaEvent", function (l) {
        var c = i.props.onMetaChange;
        if (c) {
          var u = De(De({}, i.getMeta()), {}, { destroy: l });
          G1(i.metaCache, u) || c(u), (i.metaCache = u);
        } else i.metaCache = null;
      }),
      be(hn(i), "onStoreChange", function (l, c, u) {
        var d = i.props,
          p = d.shouldUpdate,
          m = d.dependencies,
          v = m === void 0 ? [] : m,
          S = d.onReset,
          x = u.store,
          g = i.getNamePath(),
          _ = i.getValue(l),
          y = i.getValue(x),
          w = c && tf(c, g);
        switch (
          (u.type === "valueUpdate" &&
            u.source === "external" &&
            _ !== y &&
            ((i.touched = !0),
            (i.dirty = !0),
            (i.validatePromise = null),
            (i.errors = $o),
            (i.warnings = $o),
            i.triggerMetaEvent()),
          u.type)
        ) {
          case "reset":
            if (!c || w) {
              (i.touched = !1),
                (i.dirty = !1),
                (i.validatePromise = void 0),
                (i.errors = $o),
                (i.warnings = $o),
                i.triggerMetaEvent(),
                S == null || S(),
                i.refresh();
              return;
            }
            break;
          case "remove": {
            if (p) {
              i.reRender();
              return;
            }
            break;
          }
          case "setField": {
            var A = u.data;
            if (w) {
              "touched" in A && (i.touched = A.touched),
                "validating" in A &&
                  !("originRCField" in A) &&
                  (i.validatePromise = A.validating
                    ? Promise.resolve([])
                    : null),
                "errors" in A && (i.errors = A.errors || $o),
                "warnings" in A && (i.warnings = A.warnings || $o),
                (i.dirty = !0),
                i.triggerMetaEvent(),
                i.reRender();
              return;
            } else if ("value" in A && tf(c, g, !0)) {
              i.reRender();
              return;
            }
            if (p && !g.length && WI(p, l, x, _, y, u)) {
              i.reRender();
              return;
            }
            break;
          }
          case "dependenciesUpdate": {
            var M = v.map(hr);
            if (
              M.some(function (T) {
                return tf(u.relatedFields, T);
              })
            ) {
              i.reRender();
              return;
            }
            break;
          }
          default:
            if (w || ((!v.length || g.length || p) && WI(p, l, x, _, y, u))) {
              i.reRender();
              return;
            }
            break;
        }
        p === !0 && i.reRender();
      }),
      be(hn(i), "validateRules", function (l) {
        var c = i.getNamePath(),
          u = i.getValue(),
          d = l || {},
          p = d.triggerName,
          m = d.validateOnly,
          v = m === void 0 ? !1 : m,
          S = Promise.resolve().then(
            Cu(
              vi().mark(function x() {
                var g, _, y, w, A, M, T;
                return vi().wrap(function (R) {
                  for (;;)
                    switch ((R.prev = R.next)) {
                      case 0:
                        if (i.mounted) {
                          R.next = 2;
                          break;
                        }
                        return R.abrupt("return", []);
                      case 2:
                        if (
                          ((g = i.props),
                          (_ = g.validateFirst),
                          (y = _ === void 0 ? !1 : _),
                          (w = g.messageVariables),
                          (A = g.validateDebounce),
                          (M = i.getRules()),
                          p &&
                            (M = M.filter(function (P) {
                              return P;
                            }).filter(function (P) {
                              var F = P.validateTrigger;
                              if (!F) return !0;
                              var D = IE(F);
                              return D.includes(p);
                            })),
                          !(A && p))
                        ) {
                          R.next = 10;
                          break;
                        }
                        return (
                          (R.next = 8),
                          new Promise(function (P) {
                            setTimeout(P, A);
                          })
                        );
                      case 8:
                        if (i.validatePromise === S) {
                          R.next = 10;
                          break;
                        }
                        return R.abrupt("return", []);
                      case 10:
                        return (
                          (T = Qte(c, u, M, l, y, w)),
                          T.catch(function (P) {
                            return P;
                          }).then(function () {
                            var P =
                              arguments.length > 0 && arguments[0] !== void 0
                                ? arguments[0]
                                : $o;
                            if (i.validatePromise === S) {
                              var F;
                              i.validatePromise = null;
                              var D = [],
                                j = [];
                              (F = P.forEach) === null ||
                                F === void 0 ||
                                F.call(P, function (N) {
                                  var V = N.rule.warningOnly,
                                    W = N.errors,
                                    Q = W === void 0 ? $o : W;
                                  V
                                    ? j.push.apply(j, It(Q))
                                    : D.push.apply(D, It(Q));
                                }),
                                (i.errors = D),
                                (i.warnings = j),
                                i.triggerMetaEvent(),
                                i.reRender();
                            }
                          }),
                          R.abrupt("return", T)
                        );
                      case 13:
                      case "end":
                        return R.stop();
                    }
                }, x);
              })
            )
          );
        return (
          v ||
            ((i.validatePromise = S),
            (i.dirty = !0),
            (i.errors = $o),
            (i.warnings = $o),
            i.triggerMetaEvent(),
            i.reRender()),
          S
        );
      }),
      be(hn(i), "isFieldValidating", function () {
        return !!i.validatePromise;
      }),
      be(hn(i), "isFieldTouched", function () {
        return i.touched;
      }),
      be(hn(i), "isFieldDirty", function () {
        if (i.dirty || i.props.initialValue !== void 0) return !0;
        var l = i.props.fieldContext,
          c = l.getInternalHooks($c),
          u = c.getInitialValue;
        return u(i.getNamePath()) !== void 0;
      }),
      be(hn(i), "getErrors", function () {
        return i.errors;
      }),
      be(hn(i), "getWarnings", function () {
        return i.warnings;
      }),
      be(hn(i), "isListField", function () {
        return i.props.isListField;
      }),
      be(hn(i), "isList", function () {
        return i.props.isList;
      }),
      be(hn(i), "isPreserve", function () {
        return i.props.preserve;
      }),
      be(hn(i), "getMeta", function () {
        i.prevValidating = i.isFieldValidating();
        var l = {
          touched: i.isFieldTouched(),
          validating: i.prevValidating,
          errors: i.errors,
          warnings: i.warnings,
          name: i.getNamePath(),
          validated: i.validatePromise === null,
        };
        return l;
      }),
      be(hn(i), "getOnlyChild", function (l) {
        if (typeof l == "function") {
          var c = i.getMeta();
          return De(
            De(
              {},
              i.getOnlyChild(l(i.getControlled(), c, i.props.fieldContext))
            ),
            {},
            { isFunction: !0 }
          );
        }
        var u = yf(l);
        return u.length !== 1 || !E.isValidElement(u[0])
          ? { child: u, isFunction: !1 }
          : { child: u[0], isFunction: !1 };
      }),
      be(hn(i), "getValue", function (l) {
        var c = i.props.fieldContext.getFieldsValue,
          u = i.getNamePath();
        return Ya(l || c(!0), u);
      }),
      be(hn(i), "getControlled", function () {
        var l =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
          c = i.props,
          u = c.trigger,
          d = c.validateTrigger,
          p = c.getValueFromEvent,
          m = c.normalize,
          v = c.valuePropName,
          S = c.getValueProps,
          x = c.fieldContext,
          g = d !== void 0 ? d : x.validateTrigger,
          _ = i.getNamePath(),
          y = x.getInternalHooks,
          w = x.getFieldsValue,
          A = y($c),
          M = A.dispatch,
          T = i.getValue(),
          I =
            S ||
            function (D) {
              return be({}, v, D);
            },
          R = l[u],
          P = De(De({}, l), I(T));
        P[u] = function () {
          (i.touched = !0), (i.dirty = !0), i.triggerMetaEvent();
          for (var D, j = arguments.length, N = new Array(j), V = 0; V < j; V++)
            N[V] = arguments[V];
          p ? (D = p.apply(void 0, N)) : (D = nne.apply(void 0, [v].concat(N))),
            m && (D = m(D, T, w(!0))),
            M({ type: "updateValue", namePath: _, value: D }),
            R && R.apply(void 0, N);
        };
        var F = IE(g || []);
        return (
          F.forEach(function (D) {
            var j = P[D];
            P[D] = function () {
              j && j.apply(void 0, arguments);
              var N = i.props.rules;
              N &&
                N.length &&
                M({ type: "validateField", namePath: _, triggerName: D });
            };
          }),
          P
        );
      }),
      r.fieldContext)
    ) {
      var o = r.fieldContext.getInternalHooks,
        a = o($c),
        s = a.initEntityValue;
      s(hn(i));
    }
    return i;
  }
  return (
    io(n, [
      {
        key: "componentDidMount",
        value: function () {
          var i = this.props,
            o = i.shouldUpdate,
            a = i.fieldContext;
          if (((this.mounted = !0), a)) {
            var s = a.getInternalHooks,
              l = s($c),
              c = l.registerField;
            this.cancelRegisterFunc = c(this);
          }
          o === !0 && this.reRender();
        },
      },
      {
        key: "componentWillUnmount",
        value: function () {
          this.cancelRegister(), this.triggerMetaEvent(!0), (this.mounted = !1);
        },
      },
      {
        key: "reRender",
        value: function () {
          this.mounted && this.forceUpdate();
        },
      },
      {
        key: "render",
        value: function () {
          var i = this.state.resetCount,
            o = this.props.children,
            a = this.getOnlyChild(o),
            s = a.child,
            l = a.isFunction,
            c;
          return (
            l
              ? (c = s)
              : E.isValidElement(s)
              ? (c = E.cloneElement(s, this.getControlled(s.props)))
              : (Ni(!s, "`children` of Field is not validate ReactElement."),
                (c = s)),
            E.createElement(E.Fragment, { key: i }, c)
          );
        },
      },
    ]),
    n
  );
})(E.Component);
be(S2, "contextType", bf);
be(S2, "defaultProps", { trigger: "onChange", valuePropName: "value" });
function Kk(t) {
  var e = t.name,
    n = on(t, rne),
    r = E.useContext(bf),
    i = E.useContext(Ry),
    o = e !== void 0 ? hr(e) : void 0,
    a = "keep";
  return (
    n.isListField || (a = "_".concat((o || []).join("_"))),
    E.createElement(
      S2,
      Et({ key: a, name: o, isListField: !!i }, n, { fieldContext: r })
    )
  );
}
function ine(t) {
  var e = t.name,
    n = t.initialValue,
    r = t.children,
    i = t.rules,
    o = t.validateTrigger,
    a = t.isListField,
    s = E.useContext(bf),
    l = E.useContext(Ry),
    c = E.useRef({ keys: [], id: 0 }),
    u = c.current,
    d = E.useMemo(
      function () {
        var S = hr(s.prefixName) || [];
        return [].concat(It(S), It(hr(e)));
      },
      [s.prefixName, e]
    ),
    p = E.useMemo(
      function () {
        return De(De({}, s), {}, { prefixName: d });
      },
      [s, d]
    ),
    m = E.useMemo(
      function () {
        return {
          getKey: function (x) {
            var g = d.length,
              _ = x[g];
            return [u.keys[_], x.slice(g + 1)];
          },
        };
      },
      [d]
    );
  if (typeof r != "function")
    return Ni(!1, "Form.List only accepts function as children."), null;
  var v = function (x, g, _) {
    var y = _.source;
    return y === "internal" ? !1 : x !== g;
  };
  return E.createElement(
    Ry.Provider,
    { value: m },
    E.createElement(
      bf.Provider,
      { value: p },
      E.createElement(
        Kk,
        {
          name: [],
          shouldUpdate: v,
          rules: i,
          validateTrigger: o,
          initialValue: n,
          isList: !0,
          isListField: a ?? !!l,
        },
        function (S, x) {
          var g = S.value,
            _ = g === void 0 ? [] : g,
            y = S.onChange,
            w = s.getFieldValue,
            A = function () {
              var R = w(d || []);
              return R || [];
            },
            M = {
              add: function (R, P) {
                var F = A();
                P >= 0 && P <= F.length
                  ? ((u.keys = [].concat(
                      It(u.keys.slice(0, P)),
                      [u.id],
                      It(u.keys.slice(P))
                    )),
                    y([].concat(It(F.slice(0, P)), [R], It(F.slice(P)))))
                  : ((u.keys = [].concat(It(u.keys), [u.id])),
                    y([].concat(It(F), [R]))),
                  (u.id += 1);
              },
              remove: function (R) {
                var P = A(),
                  F = new Set(Array.isArray(R) ? R : [R]);
                F.size <= 0 ||
                  ((u.keys = u.keys.filter(function (D, j) {
                    return !F.has(j);
                  })),
                  y(
                    P.filter(function (D, j) {
                      return !F.has(j);
                    })
                  ));
              },
              move: function (R, P) {
                if (R !== P) {
                  var F = A();
                  R < 0 ||
                    R >= F.length ||
                    P < 0 ||
                    P >= F.length ||
                    ((u.keys = GI(u.keys, R, P)), y(GI(F, R, P)));
                }
              },
            },
            T = _ || [];
          return (
            Array.isArray(T) || (T = []),
            r(
              T.map(function (I, R) {
                var P = u.keys[R];
                return (
                  P === void 0 &&
                    ((u.keys[R] = u.id), (P = u.keys[R]), (u.id += 1)),
                  { name: R, key: P, isListField: !0 }
                );
              }),
              M,
              x
            )
          );
        }
      )
    )
  );
}
function one(t) {
  var e = !1,
    n = t.length,
    r = [];
  return t.length
    ? new Promise(function (i, o) {
        t.forEach(function (a, s) {
          a.catch(function (l) {
            return (e = !0), l;
          }).then(function (l) {
            (n -= 1), (r[s] = l), !(n > 0) && (e && o(r), i(r));
          });
        });
      })
    : Promise.resolve([]);
}
var Yk = "__@field_split__";
function q_(t) {
  return t
    .map(function (e) {
      return "".concat(un(e), ":").concat(e);
    })
    .join(Yk);
}
var hd = (function () {
    function t() {
      ro(this, t), be(this, "kvs", new Map());
    }
    return (
      io(t, [
        {
          key: "set",
          value: function (n, r) {
            this.kvs.set(q_(n), r);
          },
        },
        {
          key: "get",
          value: function (n) {
            return this.kvs.get(q_(n));
          },
        },
        {
          key: "update",
          value: function (n, r) {
            var i = this.get(n),
              o = r(i);
            o ? this.set(n, o) : this.delete(n);
          },
        },
        {
          key: "delete",
          value: function (n) {
            this.kvs.delete(q_(n));
          },
        },
        {
          key: "map",
          value: function (n) {
            return It(this.kvs.entries()).map(function (r) {
              var i = Ve(r, 2),
                o = i[0],
                a = i[1],
                s = o.split(Yk);
              return n({
                key: s.map(function (l) {
                  var c = l.match(/^([^:]*):(.*)$/),
                    u = Ve(c, 3),
                    d = u[1],
                    p = u[2];
                  return d === "number" ? Number(p) : p;
                }),
                value: a,
              });
            });
          },
        },
        {
          key: "toJSON",
          value: function () {
            var n = {};
            return (
              this.map(function (r) {
                var i = r.key,
                  o = r.value;
                return (n[i.join(".")] = o), null;
              }),
              n
            );
          },
        },
      ]),
      t
    );
  })(),
  ane = ["name"],
  sne = io(function t(e) {
    var n = this;
    ro(this, t),
      be(this, "formHooked", !1),
      be(this, "forceRootUpdate", void 0),
      be(this, "subscribable", !0),
      be(this, "store", {}),
      be(this, "fieldEntities", []),
      be(this, "initialValues", {}),
      be(this, "callbacks", {}),
      be(this, "validateMessages", null),
      be(this, "preserve", null),
      be(this, "lastValidatePromise", null),
      be(this, "getForm", function () {
        return {
          getFieldValue: n.getFieldValue,
          getFieldsValue: n.getFieldsValue,
          getFieldError: n.getFieldError,
          getFieldWarning: n.getFieldWarning,
          getFieldsError: n.getFieldsError,
          isFieldsTouched: n.isFieldsTouched,
          isFieldTouched: n.isFieldTouched,
          isFieldValidating: n.isFieldValidating,
          isFieldsValidating: n.isFieldsValidating,
          resetFields: n.resetFields,
          setFields: n.setFields,
          setFieldValue: n.setFieldValue,
          setFieldsValue: n.setFieldsValue,
          validateFields: n.validateFields,
          submit: n.submit,
          _init: !0,
          getInternalHooks: n.getInternalHooks,
        };
      }),
      be(this, "getInternalHooks", function (r) {
        return r === $c
          ? ((n.formHooked = !0),
            {
              dispatch: n.dispatch,
              initEntityValue: n.initEntityValue,
              registerField: n.registerField,
              useSubscribe: n.useSubscribe,
              setInitialValues: n.setInitialValues,
              destroyForm: n.destroyForm,
              setCallbacks: n.setCallbacks,
              setValidateMessages: n.setValidateMessages,
              getFields: n.getFields,
              setPreserve: n.setPreserve,
              getInitialValue: n.getInitialValue,
              registerWatch: n.registerWatch,
            })
          : (Ni(
              !1,
              "`getInternalHooks` is internal usage. Should not call directly."
            ),
            null);
      }),
      be(this, "useSubscribe", function (r) {
        n.subscribable = r;
      }),
      be(this, "prevWithoutPreserves", null),
      be(this, "setInitialValues", function (r, i) {
        if (((n.initialValues = r || {}), i)) {
          var o,
            a = $d(r, n.store);
          (o = n.prevWithoutPreserves) === null ||
            o === void 0 ||
            o.map(function (s) {
              var l = s.key;
              a = ya(a, l, Ya(r, l));
            }),
            (n.prevWithoutPreserves = null),
            n.updateStore(a);
        }
      }),
      be(this, "destroyForm", function () {
        var r = new hd();
        n.getFieldEntities(!0).forEach(function (i) {
          n.isMergedPreserve(i.isPreserve()) || r.set(i.getNamePath(), !0);
        }),
          (n.prevWithoutPreserves = r);
      }),
      be(this, "getInitialValue", function (r) {
        var i = Ya(n.initialValues, r);
        return r.length ? $d(i) : i;
      }),
      be(this, "setCallbacks", function (r) {
        n.callbacks = r;
      }),
      be(this, "setValidateMessages", function (r) {
        n.validateMessages = r;
      }),
      be(this, "setPreserve", function (r) {
        n.preserve = r;
      }),
      be(this, "watchList", []),
      be(this, "registerWatch", function (r) {
        return (
          n.watchList.push(r),
          function () {
            n.watchList = n.watchList.filter(function (i) {
              return i !== r;
            });
          }
        );
      }),
      be(this, "notifyWatch", function () {
        var r =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (n.watchList.length) {
          var i = n.getFieldsValue(),
            o = n.getFieldsValue(!0);
          n.watchList.forEach(function (a) {
            a(i, o, r);
          });
        }
      }),
      be(this, "timeoutId", null),
      be(this, "warningUnhooked", function () {}),
      be(this, "updateStore", function (r) {
        n.store = r;
      }),
      be(this, "getFieldEntities", function () {
        var r =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
        return r
          ? n.fieldEntities.filter(function (i) {
              return i.getNamePath().length;
            })
          : n.fieldEntities;
      }),
      be(this, "getFieldsMap", function () {
        var r =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1,
          i = new hd();
        return (
          n.getFieldEntities(r).forEach(function (o) {
            var a = o.getNamePath();
            i.set(a, o);
          }),
          i
        );
      }),
      be(this, "getFieldEntitiesForNamePathList", function (r) {
        if (!r) return n.getFieldEntities(!0);
        var i = n.getFieldsMap(!0);
        return r.map(function (o) {
          var a = hr(o);
          return i.get(a) || { INVALIDATE_NAME_PATH: hr(o) };
        });
      }),
      be(this, "getFieldsValue", function (r, i) {
        n.warningUnhooked();
        var o, a, s;
        if (
          (r === !0 || Array.isArray(r)
            ? ((o = r), (a = i))
            : r && un(r) === "object" && ((s = r.strict), (a = r.filter)),
          o === !0 && !a)
        )
          return n.store;
        var l = n.getFieldEntitiesForNamePathList(Array.isArray(o) ? o : null),
          c = [];
        return (
          l.forEach(function (u) {
            var d,
              p,
              m =
                "INVALIDATE_NAME_PATH" in u
                  ? u.INVALIDATE_NAME_PATH
                  : u.getNamePath();
            if (s) {
              var v, S;
              if ((v = (S = u).isList) !== null && v !== void 0 && v.call(S))
                return;
            } else if (!o && (d = (p = u).isListField) !== null && d !== void 0 && d.call(p)) return;
            if (!a) c.push(m);
            else {
              var x = "getMeta" in u ? u.getMeta() : null;
              a(x) && c.push(m);
            }
          }),
          $I(n.store, c.map(hr))
        );
      }),
      be(this, "getFieldValue", function (r) {
        n.warningUnhooked();
        var i = hr(r);
        return Ya(n.store, i);
      }),
      be(this, "getFieldsError", function (r) {
        n.warningUnhooked();
        var i = n.getFieldEntitiesForNamePathList(r);
        return i.map(function (o, a) {
          return o && !("INVALIDATE_NAME_PATH" in o)
            ? {
                name: o.getNamePath(),
                errors: o.getErrors(),
                warnings: o.getWarnings(),
              }
            : { name: hr(r[a]), errors: [], warnings: [] };
        });
      }),
      be(this, "getFieldError", function (r) {
        n.warningUnhooked();
        var i = hr(r),
          o = n.getFieldsError([i])[0];
        return o.errors;
      }),
      be(this, "getFieldWarning", function (r) {
        n.warningUnhooked();
        var i = hr(r),
          o = n.getFieldsError([i])[0];
        return o.warnings;
      }),
      be(this, "isFieldsTouched", function () {
        n.warningUnhooked();
        for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)
          i[o] = arguments[o];
        var a = i[0],
          s = i[1],
          l,
          c = !1;
        i.length === 0
          ? (l = null)
          : i.length === 1
          ? Array.isArray(a)
            ? ((l = a.map(hr)), (c = !1))
            : ((l = null), (c = a))
          : ((l = a.map(hr)), (c = s));
        var u = n.getFieldEntities(!0),
          d = function (x) {
            return x.isFieldTouched();
          };
        if (!l) return c ? u.every(d) : u.some(d);
        var p = new hd();
        l.forEach(function (S) {
          p.set(S, []);
        }),
          u.forEach(function (S) {
            var x = S.getNamePath();
            l.forEach(function (g) {
              g.every(function (_, y) {
                return x[y] === _;
              }) &&
                p.update(g, function (_) {
                  return [].concat(It(_), [S]);
                });
            });
          });
        var m = function (x) {
            return x.some(d);
          },
          v = p.map(function (S) {
            var x = S.value;
            return x;
          });
        return c ? v.every(m) : v.some(m);
      }),
      be(this, "isFieldTouched", function (r) {
        return n.warningUnhooked(), n.isFieldsTouched([r]);
      }),
      be(this, "isFieldsValidating", function (r) {
        n.warningUnhooked();
        var i = n.getFieldEntities();
        if (!r)
          return i.some(function (a) {
            return a.isFieldValidating();
          });
        var o = r.map(hr);
        return i.some(function (a) {
          var s = a.getNamePath();
          return tf(o, s) && a.isFieldValidating();
        });
      }),
      be(this, "isFieldValidating", function (r) {
        return n.warningUnhooked(), n.isFieldsValidating([r]);
      }),
      be(this, "resetWithFieldInitialValue", function () {
        var r =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
          i = new hd(),
          o = n.getFieldEntities(!0);
        o.forEach(function (l) {
          var c = l.props.initialValue,
            u = l.getNamePath();
          if (c !== void 0) {
            var d = i.get(u) || new Set();
            d.add({ entity: l, value: c }), i.set(u, d);
          }
        });
        var a = function (c) {
            c.forEach(function (u) {
              var d = u.props.initialValue;
              if (d !== void 0) {
                var p = u.getNamePath(),
                  m = n.getInitialValue(p);
                if (m !== void 0)
                  Ni(
                    !1,
                    "Form already set 'initialValues' with path '".concat(
                      p.join("."),
                      "'. Field can not overwrite it."
                    )
                  );
                else {
                  var v = i.get(p);
                  if (v && v.size > 1)
                    Ni(
                      !1,
                      "Multiple Field with path '".concat(
                        p.join("."),
                        "' set 'initialValue'. Can not decide which one to pick."
                      )
                    );
                  else if (v) {
                    var S = n.getFieldValue(p),
                      x = u.isListField();
                    !x &&
                      (!r.skipExist || S === void 0) &&
                      n.updateStore(ya(n.store, p, It(v)[0].value));
                  }
                }
              }
            });
          },
          s;
        r.entities
          ? (s = r.entities)
          : r.namePathList
          ? ((s = []),
            r.namePathList.forEach(function (l) {
              var c = i.get(l);
              if (c) {
                var u;
                (u = s).push.apply(
                  u,
                  It(
                    It(c).map(function (d) {
                      return d.entity;
                    })
                  )
                );
              }
            }))
          : (s = o),
          a(s);
      }),
      be(this, "resetFields", function (r) {
        n.warningUnhooked();
        var i = n.store;
        if (!r) {
          n.updateStore($d(n.initialValues)),
            n.resetWithFieldInitialValue(),
            n.notifyObservers(i, null, { type: "reset" }),
            n.notifyWatch();
          return;
        }
        var o = r.map(hr);
        o.forEach(function (a) {
          var s = n.getInitialValue(a);
          n.updateStore(ya(n.store, a, s));
        }),
          n.resetWithFieldInitialValue({ namePathList: o }),
          n.notifyObservers(i, o, { type: "reset" }),
          n.notifyWatch(o);
      }),
      be(this, "setFields", function (r) {
        n.warningUnhooked();
        var i = n.store,
          o = [];
        r.forEach(function (a) {
          var s = a.name,
            l = on(a, ane),
            c = hr(s);
          o.push(c),
            "value" in l && n.updateStore(ya(n.store, c, l.value)),
            n.notifyObservers(i, [c], { type: "setField", data: a });
        }),
          n.notifyWatch(o);
      }),
      be(this, "getFields", function () {
        var r = n.getFieldEntities(!0),
          i = r.map(function (o) {
            var a = o.getNamePath(),
              s = o.getMeta(),
              l = De(De({}, s), {}, { name: a, value: n.getFieldValue(a) });
            return Object.defineProperty(l, "originRCField", { value: !0 }), l;
          });
        return i;
      }),
      be(this, "initEntityValue", function (r) {
        var i = r.props.initialValue;
        if (i !== void 0) {
          var o = r.getNamePath(),
            a = Ya(n.store, o);
          a === void 0 && n.updateStore(ya(n.store, o, i));
        }
      }),
      be(this, "isMergedPreserve", function (r) {
        var i = r !== void 0 ? r : n.preserve;
        return i ?? !0;
      }),
      be(this, "registerField", function (r) {
        n.fieldEntities.push(r);
        var i = r.getNamePath();
        if ((n.notifyWatch([i]), r.props.initialValue !== void 0)) {
          var o = n.store;
          n.resetWithFieldInitialValue({ entities: [r], skipExist: !0 }),
            n.notifyObservers(o, [r.getNamePath()], {
              type: "valueUpdate",
              source: "internal",
            });
        }
        return function (a, s) {
          var l =
            arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          if (
            ((n.fieldEntities = n.fieldEntities.filter(function (d) {
              return d !== r;
            })),
            !n.isMergedPreserve(s) && (!a || l.length > 1))
          ) {
            var c = a ? void 0 : n.getInitialValue(i);
            if (
              i.length &&
              n.getFieldValue(i) !== c &&
              n.fieldEntities.every(function (d) {
                return !qk(d.getNamePath(), i);
              })
            ) {
              var u = n.store;
              n.updateStore(ya(u, i, c, !0)),
                n.notifyObservers(u, [i], { type: "remove" }),
                n.triggerDependenciesUpdate(u, i);
            }
          }
          n.notifyWatch([i]);
        };
      }),
      be(this, "dispatch", function (r) {
        switch (r.type) {
          case "updateValue": {
            var i = r.namePath,
              o = r.value;
            n.updateValue(i, o);
            break;
          }
          case "validateField": {
            var a = r.namePath,
              s = r.triggerName;
            n.validateFields([a], { triggerName: s });
            break;
          }
        }
      }),
      be(this, "notifyObservers", function (r, i, o) {
        if (n.subscribable) {
          var a = De(De({}, o), {}, { store: n.getFieldsValue(!0) });
          n.getFieldEntities().forEach(function (s) {
            var l = s.onStoreChange;
            l(r, i, a);
          });
        } else n.forceRootUpdate();
      }),
      be(this, "triggerDependenciesUpdate", function (r, i) {
        var o = n.getDependencyChildrenFields(i);
        return (
          o.length && n.validateFields(o),
          n.notifyObservers(r, o, {
            type: "dependenciesUpdate",
            relatedFields: [i].concat(It(o)),
          }),
          o
        );
      }),
      be(this, "updateValue", function (r, i) {
        var o = hr(r),
          a = n.store;
        n.updateStore(ya(n.store, o, i)),
          n.notifyObservers(a, [o], {
            type: "valueUpdate",
            source: "internal",
          }),
          n.notifyWatch([o]);
        var s = n.triggerDependenciesUpdate(a, o),
          l = n.callbacks.onValuesChange;
        if (l) {
          var c = $I(n.store, [o]);
          l(c, n.getFieldsValue());
        }
        n.triggerOnFieldsChange([o].concat(It(s)));
      }),
      be(this, "setFieldsValue", function (r) {
        n.warningUnhooked();
        var i = n.store;
        if (r) {
          var o = $d(n.store, r);
          n.updateStore(o);
        }
        n.notifyObservers(i, null, { type: "valueUpdate", source: "external" }),
          n.notifyWatch();
      }),
      be(this, "setFieldValue", function (r, i) {
        n.setFields([{ name: r, value: i }]);
      }),
      be(this, "getDependencyChildrenFields", function (r) {
        var i = new Set(),
          o = [],
          a = new hd();
        n.getFieldEntities().forEach(function (l) {
          var c = l.props.dependencies;
          (c || []).forEach(function (u) {
            var d = hr(u);
            a.update(d, function () {
              var p =
                arguments.length > 0 && arguments[0] !== void 0
                  ? arguments[0]
                  : new Set();
              return p.add(l), p;
            });
          });
        });
        var s = function l(c) {
          var u = a.get(c) || new Set();
          u.forEach(function (d) {
            if (!i.has(d)) {
              i.add(d);
              var p = d.getNamePath();
              d.isFieldDirty() && p.length && (o.push(p), l(p));
            }
          });
        };
        return s(r), o;
      }),
      be(this, "triggerOnFieldsChange", function (r, i) {
        var o = n.callbacks.onFieldsChange;
        if (o) {
          var a = n.getFields();
          if (i) {
            var s = new hd();
            i.forEach(function (c) {
              var u = c.name,
                d = c.errors;
              s.set(u, d);
            }),
              a.forEach(function (c) {
                c.errors = s.get(c.name) || c.errors;
              });
          }
          var l = a.filter(function (c) {
            var u = c.name;
            return tf(r, u);
          });
          l.length && o(l, a);
        }
      }),
      be(this, "validateFields", function (r, i) {
        n.warningUnhooked();
        var o, a;
        Array.isArray(r) || typeof r == "string" || typeof i == "string"
          ? ((o = r), (a = i))
          : (a = r);
        var s = !!o,
          l = s ? o.map(hr) : [],
          c = [],
          u = String(Date.now()),
          d = new Set(),
          p = a || {},
          m = p.recursive,
          v = p.dirty;
        n.getFieldEntities(!0).forEach(function (_) {
          if (
            (s || l.push(_.getNamePath()),
            !(!_.props.rules || !_.props.rules.length) &&
              !(v && !_.isFieldDirty()))
          ) {
            var y = _.getNamePath();
            if ((d.add(y.join(u)), !s || tf(l, y, m))) {
              var w = _.validateRules(
                De({ validateMessages: De(De({}, Xk), n.validateMessages) }, a)
              );
              c.push(
                w
                  .then(function () {
                    return { name: y, errors: [], warnings: [] };
                  })
                  .catch(function (A) {
                    var M,
                      T = [],
                      I = [];
                    return (
                      (M = A.forEach) === null ||
                        M === void 0 ||
                        M.call(A, function (R) {
                          var P = R.rule.warningOnly,
                            F = R.errors;
                          P ? I.push.apply(I, It(F)) : T.push.apply(T, It(F));
                        }),
                      T.length
                        ? Promise.reject({ name: y, errors: T, warnings: I })
                        : { name: y, errors: T, warnings: I }
                    );
                  })
              );
            }
          }
        });
        var S = one(c);
        (n.lastValidatePromise = S),
          S.catch(function (_) {
            return _;
          }).then(function (_) {
            var y = _.map(function (w) {
              var A = w.name;
              return A;
            });
            n.notifyObservers(n.store, y, { type: "validateFinish" }),
              n.triggerOnFieldsChange(y, _);
          });
        var x = S.then(function () {
          return n.lastValidatePromise === S
            ? Promise.resolve(n.getFieldsValue(l))
            : Promise.reject([]);
        }).catch(function (_) {
          var y = _.filter(function (w) {
            return w && w.errors.length;
          });
          return Promise.reject({
            values: n.getFieldsValue(l),
            errorFields: y,
            outOfDate: n.lastValidatePromise !== S,
          });
        });
        x.catch(function (_) {
          return _;
        });
        var g = l.filter(function (_) {
          return d.has(_.join(u));
        });
        return n.triggerOnFieldsChange(g), x;
      }),
      be(this, "submit", function () {
        n.warningUnhooked(),
          n
            .validateFields()
            .then(function (r) {
              var i = n.callbacks.onFinish;
              if (i)
                try {
                  i(r);
                } catch (o) {
                  console.error(o);
                }
            })
            .catch(function (r) {
              var i = n.callbacks.onFinishFailed;
              i && i(r);
            });
      }),
      (this.forceRootUpdate = e);
  });
function Zk(t) {
  var e = E.useRef(),
    n = E.useState({}),
    r = Ve(n, 2),
    i = r[1];
  if (!e.current)
    if (t) e.current = t;
    else {
      var o = function () {
          i({});
        },
        a = new sne(o);
      e.current = a.getForm();
    }
  return [e.current];
}
var HE = E.createContext({
    triggerFormChange: function () {},
    triggerFormFinish: function () {},
    registerForm: function () {},
    unregisterForm: function () {},
  }),
  lne = function (e) {
    var n = e.validateMessages,
      r = e.onFormChange,
      i = e.onFormFinish,
      o = e.children,
      a = E.useContext(HE),
      s = E.useRef({});
    return E.createElement(
      HE.Provider,
      {
        value: De(
          De({}, a),
          {},
          {
            validateMessages: De(De({}, a.validateMessages), n),
            triggerFormChange: function (c, u) {
              r && r(c, { changedFields: u, forms: s.current }),
                a.triggerFormChange(c, u);
            },
            triggerFormFinish: function (c, u) {
              i && i(c, { values: u, forms: s.current }),
                a.triggerFormFinish(c, u);
            },
            registerForm: function (c, u) {
              c && (s.current = De(De({}, s.current), {}, be({}, c, u))),
                a.registerForm(c, u);
            },
            unregisterForm: function (c) {
              var u = De({}, s.current);
              delete u[c], (s.current = u), a.unregisterForm(c);
            },
          }
        ),
      },
      o
    );
  },
  cne = [
    "name",
    "initialValues",
    "fields",
    "form",
    "preserve",
    "children",
    "component",
    "validateMessages",
    "validateTrigger",
    "onValuesChange",
    "onFieldsChange",
    "onFinish",
    "onFinishFailed",
  ],
  une = function (e, n) {
    var r = e.name,
      i = e.initialValues,
      o = e.fields,
      a = e.form,
      s = e.preserve,
      l = e.children,
      c = e.component,
      u = c === void 0 ? "form" : c,
      d = e.validateMessages,
      p = e.validateTrigger,
      m = p === void 0 ? "onChange" : p,
      v = e.onValuesChange,
      S = e.onFieldsChange,
      x = e.onFinish,
      g = e.onFinishFailed,
      _ = on(e, cne),
      y = E.useContext(HE),
      w = Zk(a),
      A = Ve(w, 1),
      M = A[0],
      T = M.getInternalHooks($c),
      I = T.useSubscribe,
      R = T.setInitialValues,
      P = T.setCallbacks,
      F = T.setValidateMessages,
      D = T.setPreserve,
      j = T.destroyForm;
    E.useImperativeHandle(n, function () {
      return M;
    }),
      E.useEffect(
        function () {
          return (
            y.registerForm(r, M),
            function () {
              y.unregisterForm(r);
            }
          );
        },
        [y, M, r]
      ),
      F(De(De({}, y.validateMessages), d)),
      P({
        onValuesChange: v,
        onFieldsChange: function (q) {
          if ((y.triggerFormChange(r, q), S)) {
            for (
              var X = arguments.length,
                ee = new Array(X > 1 ? X - 1 : 0),
                J = 1;
              J < X;
              J++
            )
              ee[J - 1] = arguments[J];
            S.apply(void 0, [q].concat(ee));
          }
        },
        onFinish: function (q) {
          y.triggerFormFinish(r, q), x && x(q);
        },
        onFinishFailed: g,
      }),
      D(s);
    var N = E.useRef(null);
    R(i, !N.current),
      N.current || (N.current = !0),
      E.useEffect(function () {
        return j;
      }, []);
    var V,
      W = typeof l == "function";
    if (W) {
      var Q = M.getFieldsValue(!0);
      V = l(Q, M);
    } else V = l;
    I(!W);
    var B = E.useRef();
    E.useEffect(
      function () {
        tne(B.current || [], o || []) || M.setFields(o || []), (B.current = o);
      },
      [o, M]
    );
    var $ = E.useMemo(
        function () {
          return De(De({}, M), {}, { validateTrigger: m });
        },
        [M, m]
      ),
      G = E.createElement(
        Ry.Provider,
        { value: null },
        E.createElement(bf.Provider, { value: $ }, V)
      );
    return u === !1
      ? G
      : E.createElement(
          u,
          Et({}, _, {
            onSubmit: function (q) {
              q.preventDefault(), q.stopPropagation(), M.submit();
            },
            onReset: function (q) {
              var X;
              q.preventDefault(),
                M.resetFields(),
                (X = _.onReset) === null || X === void 0 || X.call(_, q);
            },
          }),
          G
        );
  };
function XI(t) {
  try {
    return JSON.stringify(t);
  } catch {
    return Math.random();
  }
}
function dne() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  var r = e[0],
    i = e[1],
    o = i === void 0 ? {} : i,
    a = yte(o) ? { form: o } : o,
    s = a.form,
    l = E.useState(),
    c = Ve(l, 2),
    u = c[0],
    d = c[1],
    p = E.useMemo(
      function () {
        return XI(u);
      },
      [u]
    ),
    m = E.useRef(p);
  m.current = p;
  var v = E.useContext(bf),
    S = s || v,
    x = S && S._init,
    g = hr(r),
    _ = E.useRef(g);
  return (
    (_.current = g),
    E.useEffect(
      function () {
        if (x) {
          var y = S.getFieldsValue,
            w = S.getInternalHooks,
            A = w($c),
            M = A.registerWatch,
            T = function (F, D) {
              var j = a.preserve ? D : F;
              return typeof r == "function" ? r(j) : Ya(j, _.current);
            },
            I = M(function (P, F) {
              var D = T(P, F),
                j = XI(D);
              m.current !== j && ((m.current = j), d(D));
            }),
            R = T(y(), y(!0));
          return u !== R && d(R), I;
        }
      },
      [x]
    ),
    u
  );
}
var fne = E.forwardRef(une),
  Lm = fne;
Lm.FormProvider = lne;
Lm.Field = Kk;
Lm.List = ine;
Lm.useForm = Zk;
Lm.useWatch = dne;
const mu = E.createContext({}),
  qI = (t) => {
    let { children: e, status: n, override: r } = t;
    const i = E.useContext(mu),
      o = E.useMemo(() => {
        const a = Object.assign({}, i);
        return (
          r && delete a.isFormItemInput,
          n && (delete a.status, delete a.hasFeedback, delete a.feedbackIcon),
          a
        );
      }, [n, r, i]);
    return E.createElement(mu.Provider, { value: o }, e);
  },
  hne = E.createContext(void 0),
  pne = (t) => ({ animationDuration: t, animationFillMode: "both" }),
  mne = (t) => ({ animationDuration: t, animationFillMode: "both" }),
  Qk = function (t, e, n, r) {
    const o = (
      arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1
    )
      ? "&"
      : "";
    return {
      [`
      ${o}${t}-enter,
      ${o}${t}-appear
    `]: Object.assign(Object.assign({}, pne(r)), {
        animationPlayState: "paused",
      }),
      [`${o}${t}-leave`]: Object.assign(Object.assign({}, mne(r)), {
        animationPlayState: "paused",
      }),
      [`
      ${o}${t}-enter${t}-enter-active,
      ${o}${t}-appear${t}-appear-active
    `]: { animationName: e, animationPlayState: "running" },
      [`${o}${t}-leave${t}-leave-active`]: {
        animationName: n,
        animationPlayState: "running",
        pointerEvents: "none",
      },
    };
  },
  gne = new gr("antSlideUpIn", {
    "0%": { transform: "scaleY(0.8)", transformOrigin: "0% 0%", opacity: 0 },
    "100%": { transform: "scaleY(1)", transformOrigin: "0% 0%", opacity: 1 },
  }),
  vne = new gr("antSlideUpOut", {
    "0%": { transform: "scaleY(1)", transformOrigin: "0% 0%", opacity: 1 },
    "100%": { transform: "scaleY(0.8)", transformOrigin: "0% 0%", opacity: 0 },
  }),
  yne = new gr("antSlideDownIn", {
    "0%": {
      transform: "scaleY(0.8)",
      transformOrigin: "100% 100%",
      opacity: 0,
    },
    "100%": {
      transform: "scaleY(1)",
      transformOrigin: "100% 100%",
      opacity: 1,
    },
  }),
  xne = new gr("antSlideDownOut", {
    "0%": { transform: "scaleY(1)", transformOrigin: "100% 100%", opacity: 1 },
    "100%": {
      transform: "scaleY(0.8)",
      transformOrigin: "100% 100%",
      opacity: 0,
    },
  }),
  Sne = new gr("antSlideLeftIn", {
    "0%": { transform: "scaleX(0.8)", transformOrigin: "0% 0%", opacity: 0 },
    "100%": { transform: "scaleX(1)", transformOrigin: "0% 0%", opacity: 1 },
  }),
  _ne = new gr("antSlideLeftOut", {
    "0%": { transform: "scaleX(1)", transformOrigin: "0% 0%", opacity: 1 },
    "100%": { transform: "scaleX(0.8)", transformOrigin: "0% 0%", opacity: 0 },
  }),
  bne = new gr("antSlideRightIn", {
    "0%": { transform: "scaleX(0.8)", transformOrigin: "100% 0%", opacity: 0 },
    "100%": { transform: "scaleX(1)", transformOrigin: "100% 0%", opacity: 1 },
  }),
  wne = new gr("antSlideRightOut", {
    "0%": { transform: "scaleX(1)", transformOrigin: "100% 0%", opacity: 1 },
    "100%": {
      transform: "scaleX(0.8)",
      transformOrigin: "100% 0%",
      opacity: 0,
    },
  }),
  Ene = {
    "slide-up": { inKeyframes: gne, outKeyframes: vne },
    "slide-down": { inKeyframes: yne, outKeyframes: xne },
    "slide-left": { inKeyframes: Sne, outKeyframes: _ne },
    "slide-right": { inKeyframes: bne, outKeyframes: wne },
  },
  KI = (t, e) => {
    const { antCls: n } = t,
      r = `${n}-${e}`,
      { inKeyframes: i, outKeyframes: o } = Ene[e];
    return [
      Qk(r, i, o, t.motionDurationMid),
      {
        [`
      ${r}-enter,
      ${r}-appear
    `]: {
          transform: "scale(0)",
          transformOrigin: "0% 0%",
          opacity: 0,
          animationTimingFunction: t.motionEaseOutQuint,
          "&-prepare": { transform: "scale(1)" },
        },
        [`${r}-leave`]: { animationTimingFunction: t.motionEaseInQuint },
      },
    ];
  },
  Mne = new gr("antZoomIn", {
    "0%": { transform: "scale(0.2)", opacity: 0 },
    "100%": { transform: "scale(1)", opacity: 1 },
  }),
  Cne = new gr("antZoomOut", {
    "0%": { transform: "scale(1)" },
    "100%": { transform: "scale(0.2)", opacity: 0 },
  }),
  YI = new gr("antZoomBigIn", {
    "0%": { transform: "scale(0.8)", opacity: 0 },
    "100%": { transform: "scale(1)", opacity: 1 },
  }),
  ZI = new gr("antZoomBigOut", {
    "0%": { transform: "scale(1)" },
    "100%": { transform: "scale(0.8)", opacity: 0 },
  }),
  Tne = new gr("antZoomUpIn", {
    "0%": { transform: "scale(0.8)", transformOrigin: "50% 0%", opacity: 0 },
    "100%": { transform: "scale(1)", transformOrigin: "50% 0%" },
  }),
  Ane = new gr("antZoomUpOut", {
    "0%": { transform: "scale(1)", transformOrigin: "50% 0%" },
    "100%": { transform: "scale(0.8)", transformOrigin: "50% 0%", opacity: 0 },
  }),
  Rne = new gr("antZoomLeftIn", {
    "0%": { transform: "scale(0.8)", transformOrigin: "0% 50%", opacity: 0 },
    "100%": { transform: "scale(1)", transformOrigin: "0% 50%" },
  }),
  Pne = new gr("antZoomLeftOut", {
    "0%": { transform: "scale(1)", transformOrigin: "0% 50%" },
    "100%": { transform: "scale(0.8)", transformOrigin: "0% 50%", opacity: 0 },
  }),
  Ine = new gr("antZoomRightIn", {
    "0%": { transform: "scale(0.8)", transformOrigin: "100% 50%", opacity: 0 },
    "100%": { transform: "scale(1)", transformOrigin: "100% 50%" },
  }),
  Lne = new gr("antZoomRightOut", {
    "0%": { transform: "scale(1)", transformOrigin: "100% 50%" },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0,
    },
  }),
  One = new gr("antZoomDownIn", {
    "0%": { transform: "scale(0.8)", transformOrigin: "50% 100%", opacity: 0 },
    "100%": { transform: "scale(1)", transformOrigin: "50% 100%" },
  }),
  Nne = new gr("antZoomDownOut", {
    "0%": { transform: "scale(1)", transformOrigin: "50% 100%" },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0,
    },
  }),
  Fne = {
    zoom: { inKeyframes: Mne, outKeyframes: Cne },
    "zoom-big": { inKeyframes: YI, outKeyframes: ZI },
    "zoom-big-fast": { inKeyframes: YI, outKeyframes: ZI },
    "zoom-left": { inKeyframes: Rne, outKeyframes: Pne },
    "zoom-right": { inKeyframes: Ine, outKeyframes: Lne },
    "zoom-up": { inKeyframes: Tne, outKeyframes: Ane },
    "zoom-down": { inKeyframes: One, outKeyframes: Nne },
  },
  Dne = (t, e) => {
    const { antCls: n } = t,
      r = `${n}-${e}`,
      { inKeyframes: i, outKeyframes: o } = Fne[e];
    return [
      Qk(
        r,
        i,
        o,
        e === "zoom-big-fast" ? t.motionDurationFast : t.motionDurationMid
      ),
      {
        [`
        ${r}-enter,
        ${r}-appear
      `]: {
          transform: "scale(0)",
          opacity: 0,
          animationTimingFunction: t.motionEaseOutCirc,
          "&-prepare": { transform: "none" },
        },
        [`${r}-leave`]: { animationTimingFunction: t.motionEaseInOutCirc },
      },
    ];
  },
  Jk = function () {
    if (typeof navigator > "u" || typeof window > "u") return !1;
    var t = navigator.userAgent || navigator.vendor || window.opera;
    return (
      /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(
        t
      ) ||
      /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(
        t == null ? void 0 : t.substr(0, 4)
      )
    );
  };
var zne = [
    "prefixCls",
    "invalidate",
    "item",
    "renderItem",
    "responsive",
    "responsiveDisabled",
    "registerSize",
    "itemKey",
    "className",
    "style",
    "children",
    "display",
    "order",
    "component",
  ],
  pd = void 0;
function Une(t, e) {
  var n = t.prefixCls,
    r = t.invalidate,
    i = t.item,
    o = t.renderItem,
    a = t.responsive,
    s = t.responsiveDisabled,
    l = t.registerSize,
    c = t.itemKey,
    u = t.className,
    d = t.style,
    p = t.children,
    m = t.display,
    v = t.order,
    S = t.component,
    x = S === void 0 ? "div" : S,
    g = on(t, zne),
    _ = a && !m;
  function y(I) {
    l(c, I);
  }
  E.useEffect(function () {
    return function () {
      y(null);
    };
  }, []);
  var w = o && i !== pd ? o(i) : p,
    A;
  r ||
    (A = {
      opacity: _ ? 0 : 1,
      height: _ ? 0 : pd,
      overflowY: _ ? "hidden" : pd,
      order: a ? v : pd,
      pointerEvents: _ ? "none" : pd,
      position: _ ? "absolute" : pd,
    });
  var M = {};
  _ && (M["aria-hidden"] = !0);
  var T = E.createElement(
    x,
    Et({ className: nt(!r && n, u), style: De(De({}, A), d) }, M, g, {
      ref: e,
    }),
    w
  );
  return (
    a &&
      (T = E.createElement(
        Ds,
        {
          onResize: function (R) {
            var P = R.offsetWidth;
            y(P);
          },
          disabled: s,
        },
        T
      )),
    T
  );
}
var sp = E.forwardRef(Une);
sp.displayName = "Item";
function kne(t) {
  if (typeof MessageChannel > "u") Er(t);
  else {
    var e = new MessageChannel();
    (e.port1.onmessage = function () {
      return t();
    }),
      e.port2.postMessage(void 0);
  }
}
function Bne() {
  var t = E.useRef(null),
    e = function (r) {
      t.current ||
        ((t.current = []),
        kne(function () {
          Cf.unstable_batchedUpdates(function () {
            t.current.forEach(function (i) {
              i();
            }),
              (t.current = null);
          });
        })),
        t.current.push(r);
    };
  return e;
}
function Th(t, e) {
  var n = E.useState(e),
    r = Ve(n, 2),
    i = r[0],
    o = r[1],
    a = Yo(function (s) {
      t(function () {
        o(s);
      });
    });
  return [i, a];
}
var Py = at.createContext(null),
  Hne = ["component"],
  jne = ["className"],
  Vne = ["className"],
  $ne = function (e, n) {
    var r = E.useContext(Py);
    if (!r) {
      var i = e.component,
        o = i === void 0 ? "div" : i,
        a = on(e, Hne);
      return E.createElement(o, Et({}, a, { ref: n }));
    }
    var s = r.className,
      l = on(r, jne),
      c = e.className,
      u = on(e, Vne);
    return E.createElement(
      Py.Provider,
      { value: null },
      E.createElement(sp, Et({ ref: n, className: nt(s, c) }, l, u))
    );
  },
  e4 = E.forwardRef($ne);
e4.displayName = "RawItem";
var Gne = [
    "prefixCls",
    "data",
    "renderItem",
    "renderRawItem",
    "itemKey",
    "itemWidth",
    "ssr",
    "style",
    "className",
    "maxCount",
    "renderRest",
    "renderRawRest",
    "suffix",
    "component",
    "itemComponent",
    "onVisibleChange",
  ],
  t4 = "responsive",
  n4 = "invalidate";
function Wne(t) {
  return "+ ".concat(t.length, " ...");
}
function Xne(t, e) {
  var n = t.prefixCls,
    r = n === void 0 ? "rc-overflow" : n,
    i = t.data,
    o = i === void 0 ? [] : i,
    a = t.renderItem,
    s = t.renderRawItem,
    l = t.itemKey,
    c = t.itemWidth,
    u = c === void 0 ? 10 : c,
    d = t.ssr,
    p = t.style,
    m = t.className,
    v = t.maxCount,
    S = t.renderRest,
    x = t.renderRawRest,
    g = t.suffix,
    _ = t.component,
    y = _ === void 0 ? "div" : _,
    w = t.itemComponent,
    A = t.onVisibleChange,
    M = on(t, Gne),
    T = d === "full",
    I = Bne(),
    R = Th(I, null),
    P = Ve(R, 2),
    F = P[0],
    D = P[1],
    j = F || 0,
    N = Th(I, new Map()),
    V = Ve(N, 2),
    W = V[0],
    Q = V[1],
    B = Th(I, 0),
    $ = Ve(B, 2),
    G = $[0],
    k = $[1],
    q = Th(I, 0),
    X = Ve(q, 2),
    ee = X[0],
    J = X[1],
    oe = Th(I, 0),
    ae = Ve(oe, 2),
    le = ae[0],
    _e = ae[1],
    me = E.useState(null),
    se = Ve(me, 2),
    Y = se[0],
    ve = se[1],
    de = E.useState(null),
    ue = Ve(de, 2),
    fe = ue[0],
    Te = ue[1],
    pe = E.useMemo(
      function () {
        return fe === null && T ? Number.MAX_SAFE_INTEGER : fe || 0;
      },
      [fe, F]
    ),
    H = E.useState(!1),
    z = Ve(H, 2),
    Z = z[0],
    ge = z[1],
    ce = "".concat(r, "-item"),
    he = Math.max(G, ee),
    Me = v === t4,
    Re = o.length && Me,
    Le = v === n4,
    Oe = Re || (typeof v == "number" && o.length > v),
    Pe = E.useMemo(
      function () {
        var ke = o;
        return (
          Re
            ? F === null && T
              ? (ke = o)
              : (ke = o.slice(0, Math.min(o.length, j / u)))
            : typeof v == "number" && (ke = o.slice(0, v)),
          ke
        );
      },
      [o, u, F, v, Re]
    ),
    Se = E.useMemo(
      function () {
        return Re ? o.slice(pe + 1) : o.slice(Pe.length);
      },
      [o, Pe, Re, pe]
    ),
    Je = E.useCallback(
      function (ke, tt) {
        var ut;
        return typeof l == "function"
          ? l(ke)
          : (ut = l && (ke == null ? void 0 : ke[l])) !== null && ut !== void 0
          ? ut
          : tt;
      },
      [l]
    ),
    st = E.useCallback(
      a ||
        function (ke) {
          return ke;
        },
      [a]
    );
  function Qe(ke, tt, ut) {
    (fe === ke && (tt === void 0 || tt === Y)) ||
      (Te(ke),
      ut || (ge(ke < o.length - 1), A == null || A(ke)),
      tt !== void 0 && ve(tt));
  }
  function Ke(ke, tt) {
    D(tt.clientWidth);
  }
  function Ne(ke, tt) {
    Q(function (ut) {
      var dt = new Map(ut);
      return tt === null ? dt.delete(ke) : dt.set(ke, tt), dt;
    });
  }
  function ne(ke, tt) {
    J(tt), k(ee);
  }
  function Ie(ke, tt) {
    _e(tt);
  }
  function et(ke) {
    return W.get(Je(Pe[ke], ke));
  }
  Hr(
    function () {
      if (j && typeof he == "number" && Pe) {
        var ke = le,
          tt = Pe.length,
          ut = tt - 1;
        if (!tt) {
          Qe(0, null);
          return;
        }
        for (var dt = 0; dt < tt; dt += 1) {
          var Rt = et(dt);
          if ((T && (Rt = Rt || 0), Rt === void 0)) {
            Qe(dt - 1, void 0, !0);
            break;
          }
          if (
            ((ke += Rt),
            (ut === 0 && ke <= j) || (dt === ut - 1 && ke + et(ut) <= j))
          ) {
            Qe(ut, null);
            break;
          } else if (ke + he > j) {
            Qe(dt - 1, ke - Rt - le + ee);
            break;
          }
        }
        g && et(0) + le > j && ve(null);
      }
    },
    [j, W, ee, le, Je, Pe]
  );
  var We = Z && !!Se.length,
    Ee = {};
  Y !== null && Re && (Ee = { position: "absolute", left: Y, top: 0 });
  var ie = { prefixCls: ce, responsive: Re, component: w, invalidate: Le },
    $e = s
      ? function (ke, tt) {
          var ut = Je(ke, tt);
          return E.createElement(
            Py.Provider,
            {
              key: ut,
              value: De(
                De({}, ie),
                {},
                {
                  order: tt,
                  item: ke,
                  itemKey: ut,
                  registerSize: Ne,
                  display: tt <= pe,
                }
              ),
            },
            s(ke, tt)
          );
        }
      : function (ke, tt) {
          var ut = Je(ke, tt);
          return E.createElement(
            sp,
            Et({}, ie, {
              order: tt,
              key: ut,
              item: ke,
              renderItem: st,
              itemKey: ut,
              registerSize: Ne,
              display: tt <= pe,
            })
          );
        },
    He,
    Xe = {
      order: We ? pe : Number.MAX_SAFE_INTEGER,
      className: "".concat(ce, "-rest"),
      registerSize: ne,
      display: We,
    };
  if (x)
    x &&
      (He = E.createElement(Py.Provider, { value: De(De({}, ie), Xe) }, x(Se)));
  else {
    var Ue = S || Wne;
    He = E.createElement(
      sp,
      Et({}, ie, Xe),
      typeof Ue == "function" ? Ue(Se) : Ue
    );
  }
  var Ye = E.createElement(
    y,
    Et({ className: nt(!Le && r, m), style: p, ref: e }, M),
    Pe.map($e),
    Oe ? He : null,
    g &&
      E.createElement(
        sp,
        Et({}, ie, {
          responsive: Me,
          responsiveDisabled: !Re,
          order: pe,
          className: "".concat(ce, "-suffix"),
          registerSize: Ie,
          display: !0,
          style: Ee,
        }),
        g
      )
  );
  return (
    Me && (Ye = E.createElement(Ds, { onResize: Ke, disabled: !Re }, Ye)), Ye
  );
}
var zs = E.forwardRef(Xne);
zs.displayName = "Overflow";
zs.Item = e4;
zs.RESPONSIVE = t4;
zs.INVALIDATE = n4;
function qne(t) {
  var e = t.prefixCls,
    n = t.align,
    r = t.arrow,
    i = t.arrowPos,
    o = r || {},
    a = o.className,
    s = o.content,
    l = i.x,
    c = l === void 0 ? 0 : l,
    u = i.y,
    d = u === void 0 ? 0 : u,
    p = E.useRef();
  if (!n || !n.points) return null;
  var m = { position: "absolute" };
  if (n.autoArrow !== !1) {
    var v = n.points[0],
      S = n.points[1],
      x = v[0],
      g = v[1],
      _ = S[0],
      y = S[1];
    x === _ || !["t", "b"].includes(x)
      ? (m.top = d)
      : x === "t"
      ? (m.top = 0)
      : (m.bottom = 0),
      g === y || !["l", "r"].includes(g)
        ? (m.left = c)
        : g === "l"
        ? (m.left = 0)
        : (m.right = 0);
  }
  return E.createElement(
    "div",
    { ref: p, className: nt("".concat(e, "-arrow"), a), style: m },
    s
  );
}
function Kne(t) {
  var e = t.prefixCls,
    n = t.open,
    r = t.zIndex,
    i = t.mask,
    o = t.motion;
  return i
    ? E.createElement(
        Mu,
        Et({}, o, { motionAppear: !0, visible: n, removeOnLeave: !0 }),
        function (a) {
          var s = a.className;
          return E.createElement("div", {
            style: { zIndex: r },
            className: nt("".concat(e, "-mask"), s),
          });
        }
      )
    : null;
}
var Yne = E.memo(
    function (t) {
      var e = t.children;
      return e;
    },
    function (t, e) {
      return e.cache;
    }
  ),
  Zne = E.forwardRef(function (t, e) {
    var n = t.popup,
      r = t.className,
      i = t.prefixCls,
      o = t.style,
      a = t.target,
      s = t.onVisibleChanged,
      l = t.open,
      c = t.keepDom,
      u = t.fresh,
      d = t.onClick,
      p = t.mask,
      m = t.arrow,
      v = t.arrowPos,
      S = t.align,
      x = t.motion,
      g = t.maskMotion,
      _ = t.forceRender,
      y = t.getPopupContainer,
      w = t.autoDestroy,
      A = t.portal,
      M = t.zIndex,
      T = t.onMouseEnter,
      I = t.onMouseLeave,
      R = t.onPointerEnter,
      P = t.ready,
      F = t.offsetX,
      D = t.offsetY,
      j = t.offsetR,
      N = t.offsetB,
      V = t.onAlign,
      W = t.onPrepare,
      Q = t.stretch,
      B = t.targetWidth,
      $ = t.targetHeight,
      G = typeof n == "function" ? n() : n,
      k = l || c,
      q = (y == null ? void 0 : y.length) > 0,
      X = E.useState(!y || !q),
      ee = Ve(X, 2),
      J = ee[0],
      oe = ee[1];
    if (
      (Hr(
        function () {
          !J && q && a && oe(!0);
        },
        [J, q, a]
      ),
      !J)
    )
      return null;
    var ae = "auto",
      le = { left: "-1000vw", top: "-1000vh", right: ae, bottom: ae };
    if (P || !l) {
      var _e,
        me = S.points,
        se =
          S.dynamicInset ||
          ((_e = S._experimental) === null || _e === void 0
            ? void 0
            : _e.dynamicInset),
        Y = se && me[0][1] === "r",
        ve = se && me[0][0] === "b";
      Y ? ((le.right = j), (le.left = ae)) : ((le.left = F), (le.right = ae)),
        ve
          ? ((le.bottom = N), (le.top = ae))
          : ((le.top = D), (le.bottom = ae));
    }
    var de = {};
    return (
      Q &&
        (Q.includes("height") && $
          ? (de.height = $)
          : Q.includes("minHeight") && $ && (de.minHeight = $),
        Q.includes("width") && B
          ? (de.width = B)
          : Q.includes("minWidth") && B && (de.minWidth = B)),
      l || (de.pointerEvents = "none"),
      E.createElement(
        A,
        {
          open: _ || k,
          getContainer:
            y &&
            function () {
              return y(a);
            },
          autoDestroy: w,
        },
        E.createElement(Kne, {
          prefixCls: i,
          open: l,
          zIndex: M,
          mask: p,
          motion: g,
        }),
        E.createElement(Ds, { onResize: V, disabled: !l }, function (ue) {
          return E.createElement(
            Mu,
            Et(
              {
                motionAppear: !0,
                motionEnter: !0,
                motionLeave: !0,
                removeOnLeave: !1,
                forceRender: _,
                leavedClassName: "".concat(i, "-hidden"),
              },
              x,
              {
                onAppearPrepare: W,
                onEnterPrepare: W,
                visible: l,
                onVisibleChanged: function (Te) {
                  var pe;
                  x == null ||
                    (pe = x.onVisibleChanged) === null ||
                    pe === void 0 ||
                    pe.call(x, Te),
                    s(Te);
                },
              }
            ),
            function (fe, Te) {
              var pe = fe.className,
                H = fe.style,
                z = nt(i, pe, r);
              return E.createElement(
                "div",
                {
                  ref: ls(ue, e, Te),
                  className: z,
                  style: De(
                    De(
                      De(
                        De(
                          {
                            "--arrow-x": "".concat(v.x || 0, "px"),
                            "--arrow-y": "".concat(v.y || 0, "px"),
                          },
                          le
                        ),
                        de
                      ),
                      H
                    ),
                    {},
                    { boxSizing: "border-box", zIndex: M },
                    o
                  ),
                  onMouseEnter: T,
                  onMouseLeave: I,
                  onPointerEnter: R,
                  onClick: d,
                },
                m &&
                  E.createElement(qne, {
                    prefixCls: i,
                    arrow: m,
                    arrowPos: v,
                    align: S,
                  }),
                E.createElement(Yne, { cache: !l && !u }, G)
              );
            }
          );
        })
      )
    );
  }),
  Qne = E.forwardRef(function (t, e) {
    var n = t.children,
      r = t.getTriggerDOMNode,
      i = wu(n),
      o = E.useCallback(
        function (s) {
          YC(e, r ? r(s) : s);
        },
        [r]
      ),
      a = Em(o, n.ref);
    return i ? E.cloneElement(n, { ref: a }) : n;
  }),
  QI = E.createContext(null);
function JI(t) {
  return t ? (Array.isArray(t) ? t : [t]) : [];
}
function Jne(t, e, n, r) {
  return E.useMemo(
    function () {
      var i = JI(n ?? e),
        o = JI(r ?? e),
        a = new Set(i),
        s = new Set(o);
      return (
        t &&
          (a.has("hover") && (a.delete("hover"), a.add("click")),
          s.has("hover") && (s.delete("hover"), s.add("click"))),
        [a, s]
      );
    },
    [t, e, n, r]
  );
}
function ere() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
    e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
    n = arguments.length > 2 ? arguments[2] : void 0;
  return n ? t[0] === e[0] : t[0] === e[0] && t[1] === e[1];
}
function tre(t, e, n, r) {
  for (var i = n.points, o = Object.keys(t), a = 0; a < o.length; a += 1) {
    var s,
      l = o[a];
    if (ere((s = t[l]) === null || s === void 0 ? void 0 : s.points, i, r))
      return "".concat(e, "-placement-").concat(l);
  }
  return "";
}
function eL(t, e, n, r) {
  return (
    e ||
    (n
      ? { motionName: "".concat(t, "-").concat(n) }
      : r
      ? { motionName: r }
      : null)
  );
}
function Om(t) {
  return t.ownerDocument.defaultView;
}
function jE(t) {
  for (
    var e = [],
      n = t == null ? void 0 : t.parentElement,
      r = ["hidden", "scroll", "clip", "auto"];
    n;

  ) {
    var i = Om(n).getComputedStyle(n),
      o = i.overflowX,
      a = i.overflowY,
      s = i.overflow;
    [o, a, s].some(function (l) {
      return r.includes(l);
    }) && e.push(n),
      (n = n.parentElement);
  }
  return e;
}
function rm(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  return Number.isNaN(t) ? e : t;
}
function Ah(t) {
  return rm(parseFloat(t), 0);
}
function tL(t, e) {
  var n = De({}, t);
  return (
    (e || []).forEach(function (r) {
      if (!(r instanceof HTMLBodyElement || r instanceof HTMLHtmlElement)) {
        var i = Om(r).getComputedStyle(r),
          o = i.overflow,
          a = i.overflowClipMargin,
          s = i.borderTopWidth,
          l = i.borderBottomWidth,
          c = i.borderLeftWidth,
          u = i.borderRightWidth,
          d = r.getBoundingClientRect(),
          p = r.offsetHeight,
          m = r.clientHeight,
          v = r.offsetWidth,
          S = r.clientWidth,
          x = Ah(s),
          g = Ah(l),
          _ = Ah(c),
          y = Ah(u),
          w = rm(Math.round((d.width / v) * 1e3) / 1e3),
          A = rm(Math.round((d.height / p) * 1e3) / 1e3),
          M = (v - S - _ - y) * w,
          T = (p - m - x - g) * A,
          I = x * A,
          R = g * A,
          P = _ * w,
          F = y * w,
          D = 0,
          j = 0;
        if (o === "clip") {
          var N = Ah(a);
          (D = N * w), (j = N * A);
        }
        var V = d.x + P - D,
          W = d.y + I - j,
          Q = V + d.width + 2 * D - P - F - M,
          B = W + d.height + 2 * j - I - R - T;
        (n.left = Math.max(n.left, V)),
          (n.top = Math.max(n.top, W)),
          (n.right = Math.min(n.right, Q)),
          (n.bottom = Math.min(n.bottom, B));
      }
    }),
    n
  );
}
function nL(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
    n = "".concat(e),
    r = n.match(/^(.*)\%$/);
  return r ? t * (parseFloat(r[1]) / 100) : parseFloat(n);
}
function rL(t, e) {
  var n = e || [],
    r = Ve(n, 2),
    i = r[0],
    o = r[1];
  return [nL(t.width, i), nL(t.height, o)];
}
function iL() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  return [t[0], t[1]];
}
function md(t, e) {
  var n = e[0],
    r = e[1],
    i,
    o;
  return (
    n === "t"
      ? (o = t.y)
      : n === "b"
      ? (o = t.y + t.height)
      : (o = t.y + t.height / 2),
    r === "l"
      ? (i = t.x)
      : r === "r"
      ? (i = t.x + t.width)
      : (i = t.x + t.width / 2),
    { x: i, y: o }
  );
}
function pl(t, e) {
  var n = { t: "b", b: "t", l: "r", r: "l" };
  return t
    .map(function (r, i) {
      return i === e ? n[r] || "c" : r;
    })
    .join("");
}
function nre(t, e, n, r, i, o, a) {
  var s = E.useState({
      ready: !1,
      offsetX: 0,
      offsetY: 0,
      offsetR: 0,
      offsetB: 0,
      arrowX: 0,
      arrowY: 0,
      scaleX: 1,
      scaleY: 1,
      align: i[r] || {},
    }),
    l = Ve(s, 2),
    c = l[0],
    u = l[1],
    d = E.useRef(0),
    p = E.useMemo(
      function () {
        return e ? jE(e) : [];
      },
      [e]
    ),
    m = E.useRef({}),
    v = function () {
      m.current = {};
    };
  t || v();
  var S = Yo(function () {
      if (e && n && t) {
        let nr = function (Bi, oo) {
            var ei =
                arguments.length > 2 && arguments[2] !== void 0
                  ? arguments[2]
                  : z,
              ao = G.x + Bi,
              ti = G.y + oo,
              Hi = ao + _e,
              _i = ti + le,
              Wt = Math.max(ao, ei.left),
              us = Math.max(ti, ei.top),
              so = Math.min(Hi, ei.right),
              za = Math.min(_i, ei.bottom);
            return Math.max(0, (so - Wt) * (za - us));
          },
          No = function () {
            (ln = G.y + Ue), (Ht = ln + le), (Dt = G.x + Xe), (nn = Dt + _e);
          };
        var _,
          y,
          w = e,
          A = w.ownerDocument,
          M = Om(w),
          T = M.getComputedStyle(w),
          I = T.width,
          R = T.height,
          P = T.position,
          F = w.style.left,
          D = w.style.top,
          j = w.style.right,
          N = w.style.bottom,
          V = w.style.overflow,
          W = De(De({}, i[r]), o),
          Q = A.createElement("div");
        (_ = w.parentElement) === null || _ === void 0 || _.appendChild(Q),
          (Q.style.left = "".concat(w.offsetLeft, "px")),
          (Q.style.top = "".concat(w.offsetTop, "px")),
          (Q.style.position = P),
          (Q.style.height = "".concat(w.offsetHeight, "px")),
          (Q.style.width = "".concat(w.offsetWidth, "px")),
          (w.style.left = "0"),
          (w.style.top = "0"),
          (w.style.right = "auto"),
          (w.style.bottom = "auto"),
          (w.style.overflow = "hidden");
        var B;
        if (Array.isArray(n)) B = { x: n[0], y: n[1], width: 0, height: 0 };
        else {
          var $ = n.getBoundingClientRect();
          B = { x: $.x, y: $.y, width: $.width, height: $.height };
        }
        var G = w.getBoundingClientRect(),
          k = A.documentElement,
          q = k.clientWidth,
          X = k.clientHeight,
          ee = k.scrollWidth,
          J = k.scrollHeight,
          oe = k.scrollTop,
          ae = k.scrollLeft,
          le = G.height,
          _e = G.width,
          me = B.height,
          se = B.width,
          Y = { left: 0, top: 0, right: q, bottom: X },
          ve = { left: -ae, top: -oe, right: ee - ae, bottom: J - oe },
          de = W.htmlRegion,
          ue = "visible",
          fe = "visibleFirst";
        de !== "scroll" && de !== fe && (de = ue);
        var Te = de === fe,
          pe = tL(ve, p),
          H = tL(Y, p),
          z = de === ue ? H : pe,
          Z = Te ? H : z;
        (w.style.left = "auto"),
          (w.style.top = "auto"),
          (w.style.right = "0"),
          (w.style.bottom = "0");
        var ge = w.getBoundingClientRect();
        (w.style.left = F),
          (w.style.top = D),
          (w.style.right = j),
          (w.style.bottom = N),
          (w.style.overflow = V),
          (y = w.parentElement) === null || y === void 0 || y.removeChild(Q);
        var ce = rm(Math.round((_e / parseFloat(I)) * 1e3) / 1e3),
          he = rm(Math.round((le / parseFloat(R)) * 1e3) / 1e3);
        if (ce === 0 || he === 0 || (xy(n) && !p2(n))) return;
        var Me = W.offset,
          Re = W.targetOffset,
          Le = rL(G, Me),
          Oe = Ve(Le, 2),
          Pe = Oe[0],
          Se = Oe[1],
          Je = rL(B, Re),
          st = Ve(Je, 2),
          Qe = st[0],
          Ke = st[1];
        (B.x -= Qe), (B.y -= Ke);
        var Ne = W.points || [],
          ne = Ve(Ne, 2),
          Ie = ne[0],
          et = ne[1],
          We = iL(et),
          Ee = iL(Ie),
          ie = md(B, We),
          $e = md(G, Ee),
          He = De({}, W),
          Xe = ie.x - $e.x + Pe,
          Ue = ie.y - $e.y + Se,
          Ye = nr(Xe, Ue),
          ke = nr(Xe, Ue, H),
          tt = md(B, ["t", "l"]),
          ut = md(G, ["t", "l"]),
          dt = md(B, ["b", "r"]),
          Rt = md(G, ["b", "r"]),
          Bt = W.overflow || {},
          In = Bt.adjustX,
          dn = Bt.adjustY,
          _n = Bt.shiftX,
          gn = Bt.shiftY,
          Gt = function (oo) {
            return typeof oo == "boolean" ? oo : oo >= 0;
          },
          ln,
          Ht,
          Dt,
          nn;
        No();
        var Ln = Gt(dn),
          te = Ee[0] === We[0];
        if (Ln && Ee[0] === "t" && (Ht > Z.bottom || m.current.bt)) {
          var ye = Ue;
          te ? (ye -= le - me) : (ye = tt.y - Rt.y - Se);
          var Ae = nr(Xe, ye),
            ze = nr(Xe, ye, H);
          Ae > Ye || (Ae === Ye && (!Te || ze >= ke))
            ? ((m.current.bt = !0),
              (Ue = ye),
              (Se = -Se),
              (He.points = [pl(Ee, 0), pl(We, 0)]))
            : (m.current.bt = !1);
        }
        if (Ln && Ee[0] === "b" && (ln < Z.top || m.current.tb)) {
          var Ce = Ue;
          te ? (Ce += le - me) : (Ce = dt.y - ut.y - Se);
          var ot = nr(Xe, Ce),
            ht = nr(Xe, Ce, H);
          ot > Ye || (ot === Ye && (!Te || ht >= ke))
            ? ((m.current.tb = !0),
              (Ue = Ce),
              (Se = -Se),
              (He.points = [pl(Ee, 0), pl(We, 0)]))
            : (m.current.tb = !1);
        }
        var xt = Gt(In),
          qe = Ee[1] === We[1];
        if (xt && Ee[1] === "l" && (nn > Z.right || m.current.rl)) {
          var bt = Xe;
          qe ? (bt -= _e - se) : (bt = tt.x - Rt.x - Pe);
          var Lt = nr(bt, Ue),
            Mt = nr(bt, Ue, H);
          Lt > Ye || (Lt === Ye && (!Te || Mt >= ke))
            ? ((m.current.rl = !0),
              (Xe = bt),
              (Pe = -Pe),
              (He.points = [pl(Ee, 1), pl(We, 1)]))
            : (m.current.rl = !1);
        }
        if (xt && Ee[1] === "r" && (Dt < Z.left || m.current.lr)) {
          var qt = Xe;
          qe ? (qt += _e - se) : (qt = dt.x - ut.x - Pe);
          var On = nr(qt, Ue),
            tn = nr(qt, Ue, H);
          On > Ye || (On === Ye && (!Te || tn >= ke))
            ? ((m.current.lr = !0),
              (Xe = qt),
              (Pe = -Pe),
              (He.points = [pl(Ee, 1), pl(We, 1)]))
            : (m.current.lr = !1);
        }
        No();
        var cn = _n === !0 ? 0 : _n;
        typeof cn == "number" &&
          (Dt < H.left &&
            ((Xe -= Dt - H.left - Pe),
            B.x + se < H.left + cn && (Xe += B.x - H.left + se - cn)),
          nn > H.right &&
            ((Xe -= nn - H.right - Pe),
            B.x > H.right - cn && (Xe += B.x - H.right + cn)));
        var St = gn === !0 ? 0 : gn;
        typeof St == "number" &&
          (ln < H.top &&
            ((Ue -= ln - H.top - Se),
            B.y + me < H.top + St && (Ue += B.y - H.top + me - St)),
          Ht > H.bottom &&
            ((Ue -= Ht - H.bottom - Se),
            B.y > H.bottom - St && (Ue += B.y - H.bottom + St)));
        var ct = G.x + Xe,
          zn = ct + _e,
          Ot = G.y + Ue,
          fn = Ot + le,
          Xn = B.x,
          Ut = Xn + se,
          Pt = B.y,
          Tt = Pt + me,
          vn = Math.max(ct, Xn),
          En = Math.min(zn, Ut),
          bn = (vn + En) / 2,
          Bn = bn - ct,
          lr = Math.max(Ot, Pt),
          Vr = Math.min(fn, Tt),
          Ui = (lr + Vr) / 2,
          ki = Ui - Ot;
        a == null || a(e, He);
        var Or = ge.right - G.x - (Xe + G.width),
          Si = ge.bottom - G.y - (Ue + G.height);
        u({
          ready: !0,
          offsetX: Xe / ce,
          offsetY: Ue / he,
          offsetR: Or / ce,
          offsetB: Si / he,
          arrowX: Bn / ce,
          arrowY: ki / he,
          scaleX: ce,
          scaleY: he,
          align: He,
        });
      }
    }),
    x = function () {
      d.current += 1;
      var y = d.current;
      Promise.resolve().then(function () {
        d.current === y && S();
      });
    },
    g = function () {
      u(function (y) {
        return De(De({}, y), {}, { ready: !1 });
      });
    };
  return (
    Hr(g, [r]),
    Hr(
      function () {
        t || g();
      },
      [t]
    ),
    [
      c.ready,
      c.offsetX,
      c.offsetY,
      c.offsetR,
      c.offsetB,
      c.arrowX,
      c.arrowY,
      c.scaleX,
      c.scaleY,
      c.align,
      x,
    ]
  );
}
function rre(t, e, n, r, i) {
  Hr(
    function () {
      if (t && e && n) {
        let d = function () {
          r(), i();
        };
        var o = e,
          a = n,
          s = jE(o),
          l = jE(a),
          c = Om(a),
          u = new Set([c].concat(It(s), It(l)));
        return (
          u.forEach(function (p) {
            p.addEventListener("scroll", d, { passive: !0 });
          }),
          c.addEventListener("resize", d, { passive: !0 }),
          r(),
          function () {
            u.forEach(function (p) {
              p.removeEventListener("scroll", d),
                c.removeEventListener("resize", d);
            });
          }
        );
      }
    },
    [t, e, n]
  );
}
function ire(t, e, n, r, i, o, a, s) {
  var l = E.useRef(t),
    c = E.useRef(!1);
  l.current !== t && ((c.current = !0), (l.current = t)),
    E.useEffect(
      function () {
        var u = Er(function () {
          c.current = !1;
        });
        return function () {
          Er.cancel(u);
        };
      },
      [t]
    ),
    E.useEffect(
      function () {
        if (e && r && (!i || o)) {
          var u = function () {
              var M = !1,
                T = function (P) {
                  var F = P.target;
                  M = a(F);
                },
                I = function (P) {
                  var F = P.target;
                  !c.current && l.current && !M && !a(F) && s(!1);
                };
              return [T, I];
            },
            d = u(),
            p = Ve(d, 2),
            m = p[0],
            v = p[1],
            S = u(),
            x = Ve(S, 2),
            g = x[0],
            _ = x[1],
            y = Om(r);
          y.addEventListener("mousedown", m, !0),
            y.addEventListener("click", v, !0),
            y.addEventListener("contextmenu", v, !0);
          var w = My(n);
          return (
            w &&
              (w.addEventListener("mousedown", g, !0),
              w.addEventListener("click", _, !0),
              w.addEventListener("contextmenu", _, !0)),
            function () {
              y.removeEventListener("mousedown", m, !0),
                y.removeEventListener("click", v, !0),
                y.removeEventListener("contextmenu", v, !0),
                w &&
                  (w.removeEventListener("mousedown", g, !0),
                  w.removeEventListener("click", _, !0),
                  w.removeEventListener("contextmenu", _, !0));
            }
          );
        }
      },
      [e, n, r, i, o]
    );
}
var ore = [
  "prefixCls",
  "children",
  "action",
  "showAction",
  "hideAction",
  "popupVisible",
  "defaultPopupVisible",
  "onPopupVisibleChange",
  "afterPopupVisibleChange",
  "mouseEnterDelay",
  "mouseLeaveDelay",
  "focusDelay",
  "blurDelay",
  "mask",
  "maskClosable",
  "getPopupContainer",
  "forceRender",
  "autoDestroy",
  "destroyPopupOnHide",
  "popup",
  "popupClassName",
  "popupStyle",
  "popupPlacement",
  "builtinPlacements",
  "popupAlign",
  "zIndex",
  "stretch",
  "getPopupClassNameFromAlign",
  "fresh",
  "alignPoint",
  "onPopupClick",
  "onPopupAlign",
  "arrow",
  "popupMotion",
  "maskMotion",
  "popupTransitionName",
  "popupAnimation",
  "maskTransitionName",
  "maskAnimation",
  "className",
  "getTriggerDOMNode",
];
function are() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Gk,
    e = E.forwardRef(function (n, r) {
      var i = n.prefixCls,
        o = i === void 0 ? "rc-trigger-popup" : i,
        a = n.children,
        s = n.action,
        l = s === void 0 ? "hover" : s,
        c = n.showAction,
        u = n.hideAction,
        d = n.popupVisible,
        p = n.defaultPopupVisible,
        m = n.onPopupVisibleChange,
        v = n.afterPopupVisibleChange,
        S = n.mouseEnterDelay,
        x = n.mouseLeaveDelay,
        g = x === void 0 ? 0.1 : x,
        _ = n.focusDelay,
        y = n.blurDelay,
        w = n.mask,
        A = n.maskClosable,
        M = A === void 0 ? !0 : A,
        T = n.getPopupContainer,
        I = n.forceRender,
        R = n.autoDestroy,
        P = n.destroyPopupOnHide,
        F = n.popup,
        D = n.popupClassName,
        j = n.popupStyle,
        N = n.popupPlacement,
        V = n.builtinPlacements,
        W = V === void 0 ? {} : V,
        Q = n.popupAlign,
        B = n.zIndex,
        $ = n.stretch,
        G = n.getPopupClassNameFromAlign,
        k = n.fresh,
        q = n.alignPoint,
        X = n.onPopupClick,
        ee = n.onPopupAlign,
        J = n.arrow,
        oe = n.popupMotion,
        ae = n.maskMotion,
        le = n.popupTransitionName,
        _e = n.popupAnimation,
        me = n.maskTransitionName,
        se = n.maskAnimation,
        Y = n.className,
        ve = n.getTriggerDOMNode,
        de = on(n, ore),
        ue = R || P || !1,
        fe = E.useState(!1),
        Te = Ve(fe, 2),
        pe = Te[0],
        H = Te[1];
      Hr(function () {
        H(Jk());
      }, []);
      var z = E.useRef({}),
        Z = E.useContext(QI),
        ge = E.useMemo(
          function () {
            return {
              registerSubPopup: function (zt, jt) {
                (z.current[zt] = jt), Z == null || Z.registerSubPopup(zt, jt);
              },
            };
          },
          [Z]
        ),
        ce = vte(),
        he = E.useState(null),
        Me = Ve(he, 2),
        Re = Me[0],
        Le = Me[1],
        Oe = Yo(function (vt) {
          xy(vt) && Re !== vt && Le(vt),
            Z == null || Z.registerSubPopup(ce, vt);
        }),
        Pe = E.useState(null),
        Se = Ve(Pe, 2),
        Je = Se[0],
        st = Se[1],
        Qe = E.useRef(null),
        Ke = Yo(function (vt) {
          xy(vt) && Je !== vt && (st(vt), (Qe.current = vt));
        }),
        Ne = E.Children.only(a),
        ne = (Ne == null ? void 0 : Ne.props) || {},
        Ie = {},
        et = Yo(function (vt) {
          var zt,
            jt,
            Nn = Je;
          return (
            (Nn == null ? void 0 : Nn.contains(vt)) ||
            ((zt = My(Nn)) === null || zt === void 0 ? void 0 : zt.host) ===
              vt ||
            vt === Nn ||
            (Re == null ? void 0 : Re.contains(vt)) ||
            ((jt = My(Re)) === null || jt === void 0 ? void 0 : jt.host) ===
              vt ||
            vt === Re ||
            Object.values(z.current).some(function (Fn) {
              return (Fn == null ? void 0 : Fn.contains(vt)) || vt === Fn;
            })
          );
        }),
        We = eL(o, oe, _e, le),
        Ee = eL(o, ae, se, me),
        ie = E.useState(p || !1),
        $e = Ve(ie, 2),
        He = $e[0],
        Xe = $e[1],
        Ue = d ?? He,
        Ye = Yo(function (vt) {
          d === void 0 && Xe(vt);
        });
      Hr(
        function () {
          Xe(d || !1);
        },
        [d]
      );
      var ke = E.useRef(Ue);
      ke.current = Ue;
      var tt = E.useRef([]);
      tt.current = [];
      var ut = Yo(function (vt) {
          var zt;
          Ye(vt),
            ((zt = tt.current[tt.current.length - 1]) !== null && zt !== void 0
              ? zt
              : Ue) !== vt && (tt.current.push(vt), m == null || m(vt));
        }),
        dt = E.useRef(),
        Rt = function () {
          clearTimeout(dt.current);
        },
        Bt = function (zt) {
          var jt =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          Rt(),
            jt === 0
              ? ut(zt)
              : (dt.current = setTimeout(function () {
                  ut(zt);
                }, jt * 1e3));
        };
      E.useEffect(function () {
        return Rt;
      }, []);
      var In = E.useState(!1),
        dn = Ve(In, 2),
        _n = dn[0],
        gn = dn[1];
      Hr(
        function (vt) {
          (!vt || Ue) && gn(!0);
        },
        [Ue]
      );
      var Gt = E.useState(null),
        ln = Ve(Gt, 2),
        Ht = ln[0],
        Dt = ln[1],
        nn = E.useState([0, 0]),
        Ln = Ve(nn, 2),
        te = Ln[0],
        ye = Ln[1],
        Ae = function (zt) {
          ye([zt.clientX, zt.clientY]);
        },
        ze = nre(Ue, Re, q ? te : Je, N, W, Q, ee),
        Ce = Ve(ze, 11),
        ot = Ce[0],
        ht = Ce[1],
        xt = Ce[2],
        qe = Ce[3],
        bt = Ce[4],
        Lt = Ce[5],
        Mt = Ce[6],
        qt = Ce[7],
        On = Ce[8],
        tn = Ce[9],
        cn = Ce[10],
        St = Jne(pe, l, c, u),
        ct = Ve(St, 2),
        zn = ct[0],
        Ot = ct[1],
        fn = zn.has("click"),
        Xn = Ot.has("click") || Ot.has("contextMenu"),
        Ut = Yo(function () {
          _n || cn();
        }),
        Pt = function () {
          ke.current && q && Xn && Bt(!1);
        };
      rre(Ue, Je, Re, Ut, Pt),
        Hr(
          function () {
            Ut();
          },
          [te, N]
        ),
        Hr(
          function () {
            Ue && !(W != null && W[N]) && Ut();
          },
          [JSON.stringify(Q)]
        );
      var Tt = E.useMemo(
        function () {
          var vt = tre(W, o, tn, q);
          return nt(vt, G == null ? void 0 : G(tn));
        },
        [tn, G, W, o, q]
      );
      E.useImperativeHandle(r, function () {
        return { nativeElement: Qe.current, forceAlign: Ut };
      });
      var vn = E.useState(0),
        En = Ve(vn, 2),
        bn = En[0],
        Bn = En[1],
        lr = E.useState(0),
        Vr = Ve(lr, 2),
        Ui = Vr[0],
        ki = Vr[1],
        Or = function () {
          if ($ && Je) {
            var zt = Je.getBoundingClientRect();
            Bn(zt.width), ki(zt.height);
          }
        },
        Si = function () {
          Or(), Ut();
        },
        nr = function (zt) {
          gn(!1), cn(), v == null || v(zt);
        },
        No = function () {
          return new Promise(function (zt) {
            Or(),
              Dt(function () {
                return zt;
              });
          });
        };
      Hr(
        function () {
          Ht && (cn(), Ht(), Dt(null));
        },
        [Ht]
      );
      function Bi(vt, zt, jt, Nn) {
        Ie[vt] = function (Fn) {
          var vr;
          Nn == null || Nn(Fn), Bt(zt, jt);
          for (
            var ds = arguments.length,
              Ua = new Array(ds > 1 ? ds - 1 : 0),
              Nr = 1;
            Nr < ds;
            Nr++
          )
            Ua[Nr - 1] = arguments[Nr];
          (vr = ne[vt]) === null ||
            vr === void 0 ||
            vr.call.apply(vr, [ne, Fn].concat(Ua));
        };
      }
      (fn || Xn) &&
        (Ie.onClick = function (vt) {
          var zt;
          ke.current && Xn ? Bt(!1) : !ke.current && fn && (Ae(vt), Bt(!0));
          for (
            var jt = arguments.length,
              Nn = new Array(jt > 1 ? jt - 1 : 0),
              Fn = 1;
            Fn < jt;
            Fn++
          )
            Nn[Fn - 1] = arguments[Fn];
          (zt = ne.onClick) === null ||
            zt === void 0 ||
            zt.call.apply(zt, [ne, vt].concat(Nn));
        }),
        ire(Ue, Xn, Je, Re, w, M, et, Bt);
      var oo = zn.has("hover"),
        ei = Ot.has("hover"),
        ao,
        ti;
      oo &&
        (Bi("onMouseEnter", !0, S, function (vt) {
          Ae(vt);
        }),
        Bi("onPointerEnter", !0, S, function (vt) {
          Ae(vt);
        }),
        (ao = function (zt) {
          (Ue || _n) &&
            Re !== null &&
            Re !== void 0 &&
            Re.contains(zt.target) &&
            Bt(!0, S);
        }),
        q &&
          (Ie.onMouseMove = function (vt) {
            var zt;
            (zt = ne.onMouseMove) === null || zt === void 0 || zt.call(ne, vt);
          })),
        ei &&
          (Bi("onMouseLeave", !1, g),
          Bi("onPointerLeave", !1, g),
          (ti = function () {
            Bt(!1, g);
          })),
        zn.has("focus") && Bi("onFocus", !0, _),
        Ot.has("focus") && Bi("onBlur", !1, y),
        zn.has("contextMenu") &&
          (Ie.onContextMenu = function (vt) {
            var zt;
            ke.current && Ot.has("contextMenu") ? Bt(!1) : (Ae(vt), Bt(!0)),
              vt.preventDefault();
            for (
              var jt = arguments.length,
                Nn = new Array(jt > 1 ? jt - 1 : 0),
                Fn = 1;
              Fn < jt;
              Fn++
            )
              Nn[Fn - 1] = arguments[Fn];
            (zt = ne.onContextMenu) === null ||
              zt === void 0 ||
              zt.call.apply(zt, [ne, vt].concat(Nn));
          }),
        Y && (Ie.className = nt(ne.className, Y));
      var Hi = De(De({}, ne), Ie),
        _i = {},
        Wt = [
          "onContextMenu",
          "onClick",
          "onMouseDown",
          "onTouchStart",
          "onMouseEnter",
          "onMouseLeave",
          "onFocus",
          "onBlur",
        ];
      Wt.forEach(function (vt) {
        de[vt] &&
          (_i[vt] = function () {
            for (
              var zt, jt = arguments.length, Nn = new Array(jt), Fn = 0;
              Fn < jt;
              Fn++
            )
              Nn[Fn] = arguments[Fn];
            (zt = Hi[vt]) === null ||
              zt === void 0 ||
              zt.call.apply(zt, [Hi].concat(Nn)),
              de[vt].apply(de, Nn);
          });
      });
      var us = E.cloneElement(Ne, De(De({}, Hi), _i)),
        so = { x: Lt, y: Mt },
        za = J ? De({}, J !== !0 ? J : {}) : null;
      return E.createElement(
        E.Fragment,
        null,
        E.createElement(
          Ds,
          { disabled: !Ue, ref: Ke, onResize: Si },
          E.createElement(Qne, { getTriggerDOMNode: ve }, us)
        ),
        E.createElement(
          QI.Provider,
          { value: ge },
          E.createElement(Zne, {
            portal: t,
            ref: Oe,
            prefixCls: o,
            popup: F,
            className: nt(D, Tt),
            style: j,
            target: Je,
            onMouseEnter: ao,
            onMouseLeave: ti,
            onPointerEnter: ao,
            zIndex: B,
            open: Ue,
            keepDom: _n,
            fresh: k,
            onClick: X,
            mask: w,
            motion: We,
            maskMotion: Ee,
            onVisibleChanged: nr,
            onPrepare: No,
            forceRender: I,
            autoDestroy: ue,
            getPopupContainer: T,
            align: tn,
            arrow: za,
            arrowPos: so,
            ready: ot,
            offsetX: ht,
            offsetY: xt,
            offsetR: qe,
            offsetB: bt,
            onAlign: Ut,
            stretch: $,
            targetWidth: bn / qt,
            targetHeight: Ui / On,
          })
        )
      );
    });
  return e;
}
const _2 = are(Gk);
function VE(t, e, n) {
  return nt({
    [`${t}-status-success`]: e === "success",
    [`${t}-status-warning`]: e === "warning",
    [`${t}-status-error`]: e === "error",
    [`${t}-status-validating`]: e === "validating",
    [`${t}-has-feedback`]: n,
  });
}
const r4 = (t, e) => e || t,
  sre = ["outlined", "borderless", "filled"],
  i4 = function (t) {
    let e =
      arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    const n = E.useContext(hne);
    let r;
    typeof t < "u"
      ? (r = t)
      : e === !1
      ? (r = "borderless")
      : (r = n ?? "outlined");
    const i = sre.includes(r);
    return [r, i];
  };
var lre = {
  icon: {
    tag: "svg",
    attrs: { viewBox: "64 64 896 896", focusable: "false" },
    children: [
      {
        tag: "path",
        attrs: {
          d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z",
        },
      },
    ],
  },
  name: "search",
  theme: "outlined",
};
const cre = lre;
var ure = function (e, n) {
  return E.createElement(cs, Et({}, e, { ref: n, icon: cre }));
};
const dre = E.forwardRef(ure);
function o4(t) {
  var e = t.children,
    n = t.prefixCls,
    r = t.id,
    i = t.overlayInnerStyle,
    o = t.className,
    a = t.style;
  return E.createElement(
    "div",
    { className: nt("".concat(n, "-content"), o), style: a },
    E.createElement(
      "div",
      { className: "".concat(n, "-inner"), id: r, role: "tooltip", style: i },
      typeof e == "function" ? e() : e
    )
  );
}
var gd = { shiftX: 64, adjustY: 1 },
  vd = { adjustX: 1, shiftY: !0 },
  Go = [0, 0],
  fre = {
    left: {
      points: ["cr", "cl"],
      overflow: vd,
      offset: [-4, 0],
      targetOffset: Go,
    },
    right: {
      points: ["cl", "cr"],
      overflow: vd,
      offset: [4, 0],
      targetOffset: Go,
    },
    top: {
      points: ["bc", "tc"],
      overflow: gd,
      offset: [0, -4],
      targetOffset: Go,
    },
    bottom: {
      points: ["tc", "bc"],
      overflow: gd,
      offset: [0, 4],
      targetOffset: Go,
    },
    topLeft: {
      points: ["bl", "tl"],
      overflow: gd,
      offset: [0, -4],
      targetOffset: Go,
    },
    leftTop: {
      points: ["tr", "tl"],
      overflow: vd,
      offset: [-4, 0],
      targetOffset: Go,
    },
    topRight: {
      points: ["br", "tr"],
      overflow: gd,
      offset: [0, -4],
      targetOffset: Go,
    },
    rightTop: {
      points: ["tl", "tr"],
      overflow: vd,
      offset: [4, 0],
      targetOffset: Go,
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: gd,
      offset: [0, 4],
      targetOffset: Go,
    },
    rightBottom: {
      points: ["bl", "br"],
      overflow: vd,
      offset: [4, 0],
      targetOffset: Go,
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: gd,
      offset: [0, 4],
      targetOffset: Go,
    },
    leftBottom: {
      points: ["br", "bl"],
      overflow: vd,
      offset: [-4, 0],
      targetOffset: Go,
    },
  },
  hre = [
    "overlayClassName",
    "trigger",
    "mouseEnterDelay",
    "mouseLeaveDelay",
    "overlayStyle",
    "prefixCls",
    "children",
    "onVisibleChange",
    "afterVisibleChange",
    "transitionName",
    "animation",
    "motion",
    "placement",
    "align",
    "destroyTooltipOnHide",
    "defaultVisible",
    "getTooltipContainer",
    "overlayInnerStyle",
    "arrowContent",
    "overlay",
    "id",
    "showArrow",
  ],
  pre = function (e, n) {
    var r = e.overlayClassName,
      i = e.trigger,
      o = i === void 0 ? ["hover"] : i,
      a = e.mouseEnterDelay,
      s = a === void 0 ? 0 : a,
      l = e.mouseLeaveDelay,
      c = l === void 0 ? 0.1 : l,
      u = e.overlayStyle,
      d = e.prefixCls,
      p = d === void 0 ? "rc-tooltip" : d,
      m = e.children,
      v = e.onVisibleChange,
      S = e.afterVisibleChange,
      x = e.transitionName,
      g = e.animation,
      _ = e.motion,
      y = e.placement,
      w = y === void 0 ? "right" : y,
      A = e.align,
      M = A === void 0 ? {} : A,
      T = e.destroyTooltipOnHide,
      I = T === void 0 ? !1 : T,
      R = e.defaultVisible,
      P = e.getTooltipContainer,
      F = e.overlayInnerStyle;
    e.arrowContent;
    var D = e.overlay,
      j = e.id,
      N = e.showArrow,
      V = N === void 0 ? !0 : N,
      W = on(e, hre),
      Q = E.useRef(null);
    E.useImperativeHandle(n, function () {
      return Q.current;
    });
    var B = De({}, W);
    "visible" in e && (B.popupVisible = e.visible);
    var $ = function () {
      return E.createElement(
        o4,
        { key: "content", prefixCls: p, id: j, overlayInnerStyle: F },
        D
      );
    };
    return E.createElement(
      _2,
      Et(
        {
          popupClassName: r,
          prefixCls: p,
          popup: $,
          action: o,
          builtinPlacements: fre,
          popupPlacement: w,
          ref: Q,
          popupAlign: M,
          getPopupContainer: P,
          onPopupVisibleChange: v,
          afterPopupVisibleChange: S,
          popupTransitionName: x,
          popupAnimation: g,
          popupMotion: _,
          defaultPopupVisible: R,
          autoDestroy: I,
          mouseLeaveDelay: c,
          popupStyle: u,
          mouseEnterDelay: s,
          arrow: V,
        },
        B
      ),
      m
    );
  };
const mre = E.forwardRef(pre);
function gre(t) {
  const { sizePopupArrow: e, borderRadiusXS: n, borderRadiusOuter: r } = t,
    i = e / 2,
    o = 0,
    a = i,
    s = (r * 1) / Math.sqrt(2),
    l = i - r * (1 - 1 / Math.sqrt(2)),
    c = i - n * (1 / Math.sqrt(2)),
    u = r * (Math.sqrt(2) - 1) + n * (1 / Math.sqrt(2)),
    d = 2 * i - c,
    p = u,
    m = 2 * i - s,
    v = l,
    S = 2 * i - o,
    x = a,
    g = i * Math.sqrt(2) + r * (Math.sqrt(2) - 2),
    _ = r * (Math.sqrt(2) - 1),
    y = `polygon(${_}px 100%, 50% ${_}px, ${2 * i - _}px 100%, ${_}px 100%)`,
    w = `path('M ${o} ${a} A ${r} ${r} 0 0 0 ${s} ${l} L ${c} ${u} A ${n} ${n} 0 0 1 ${d} ${p} L ${m} ${v} A ${r} ${r} 0 0 0 ${S} ${x} Z')`;
  return { arrowShadowWidth: g, arrowPath: w, arrowPolygon: y };
}
const vre = (t, e, n) => {
    const {
      sizePopupArrow: r,
      arrowPolygon: i,
      arrowPath: o,
      arrowShadowWidth: a,
      borderRadiusXS: s,
      calc: l,
    } = t;
    return {
      pointerEvents: "none",
      width: r,
      height: r,
      overflow: "hidden",
      "&::before": {
        position: "absolute",
        bottom: 0,
        insetInlineStart: 0,
        width: r,
        height: l(r).div(2).equal(),
        background: e,
        clipPath: { _multi_value_: !0, value: [i, o] },
        content: '""',
      },
      "&::after": {
        content: '""',
        position: "absolute",
        width: a,
        height: a,
        bottom: 0,
        insetInline: 0,
        margin: "auto",
        borderRadius: { _skip_check_: !0, value: `0 0 ${Ze(s)} 0` },
        transform: "translateY(50%) rotate(-135deg)",
        boxShadow: n,
        zIndex: 0,
        background: "transparent",
      },
    };
  },
  a4 = 8;
function s4(t) {
  const { contentRadius: e, limitVerticalRadius: n } = t,
    r = e > 12 ? e + 2 : 12;
  return { arrowOffsetHorizontal: r, arrowOffsetVertical: n ? a4 : r };
}
function t0(t, e) {
  return t ? e : {};
}
function yre(t, e, n) {
  const {
      componentCls: r,
      boxShadowPopoverArrow: i,
      arrowOffsetVertical: o,
      arrowOffsetHorizontal: a,
    } = t,
    {
      arrowDistance: s = 0,
      arrowPlacement: l = { left: !0, right: !0, top: !0, bottom: !0 },
    } = n || {};
  return {
    [r]: Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            {
              [`${r}-arrow`]: [
                Object.assign(
                  Object.assign(
                    { position: "absolute", zIndex: 1, display: "block" },
                    vre(t, e, i)
                  ),
                  { "&:before": { background: e } }
                ),
              ],
            },
            t0(!!l.top, {
              [[
                `&-placement-top > ${r}-arrow`,
                `&-placement-topLeft > ${r}-arrow`,
                `&-placement-topRight > ${r}-arrow`,
              ].join(",")]: {
                bottom: s,
                transform: "translateY(100%) rotate(180deg)",
              },
              [`&-placement-top > ${r}-arrow`]: {
                left: { _skip_check_: !0, value: "50%" },
                transform: "translateX(-50%) translateY(100%) rotate(180deg)",
              },
              [`&-placement-topLeft > ${r}-arrow`]: {
                left: { _skip_check_: !0, value: a },
              },
              [`&-placement-topRight > ${r}-arrow`]: {
                right: { _skip_check_: !0, value: a },
              },
            })
          ),
          t0(!!l.bottom, {
            [[
              `&-placement-bottom > ${r}-arrow`,
              `&-placement-bottomLeft > ${r}-arrow`,
              `&-placement-bottomRight > ${r}-arrow`,
            ].join(",")]: { top: s, transform: "translateY(-100%)" },
            [`&-placement-bottom > ${r}-arrow`]: {
              left: { _skip_check_: !0, value: "50%" },
              transform: "translateX(-50%) translateY(-100%)",
            },
            [`&-placement-bottomLeft > ${r}-arrow`]: {
              left: { _skip_check_: !0, value: a },
            },
            [`&-placement-bottomRight > ${r}-arrow`]: {
              right: { _skip_check_: !0, value: a },
            },
          })
        ),
        t0(!!l.left, {
          [[
            `&-placement-left > ${r}-arrow`,
            `&-placement-leftTop > ${r}-arrow`,
            `&-placement-leftBottom > ${r}-arrow`,
          ].join(",")]: {
            right: { _skip_check_: !0, value: s },
            transform: "translateX(100%) rotate(90deg)",
          },
          [`&-placement-left > ${r}-arrow`]: {
            top: { _skip_check_: !0, value: "50%" },
            transform: "translateY(-50%) translateX(100%) rotate(90deg)",
          },
          [`&-placement-leftTop > ${r}-arrow`]: { top: o },
          [`&-placement-leftBottom > ${r}-arrow`]: { bottom: o },
        })
      ),
      t0(!!l.right, {
        [[
          `&-placement-right > ${r}-arrow`,
          `&-placement-rightTop > ${r}-arrow`,
          `&-placement-rightBottom > ${r}-arrow`,
        ].join(",")]: {
          left: { _skip_check_: !0, value: s },
          transform: "translateX(-100%) rotate(-90deg)",
        },
        [`&-placement-right > ${r}-arrow`]: {
          top: { _skip_check_: !0, value: "50%" },
          transform: "translateY(-50%) translateX(-100%) rotate(-90deg)",
        },
        [`&-placement-rightTop > ${r}-arrow`]: { top: o },
        [`&-placement-rightBottom > ${r}-arrow`]: { bottom: o },
      })
    ),
  };
}
function xre(t, e, n, r) {
  if (r === !1) return { adjustX: !1, adjustY: !1 };
  const i = r && typeof r == "object" ? r : {},
    o = {};
  switch (t) {
    case "top":
    case "bottom":
      (o.shiftX = e.arrowOffsetHorizontal * 2 + n),
        (o.shiftY = !0),
        (o.adjustY = !0);
      break;
    case "left":
    case "right":
      (o.shiftY = e.arrowOffsetVertical * 2 + n),
        (o.shiftX = !0),
        (o.adjustX = !0);
      break;
  }
  const a = Object.assign(Object.assign({}, o), i);
  return a.shiftX || (a.adjustX = !0), a.shiftY || (a.adjustY = !0), a;
}
const oL = {
    left: { points: ["cr", "cl"] },
    right: { points: ["cl", "cr"] },
    top: { points: ["bc", "tc"] },
    bottom: { points: ["tc", "bc"] },
    topLeft: { points: ["bl", "tl"] },
    leftTop: { points: ["tr", "tl"] },
    topRight: { points: ["br", "tr"] },
    rightTop: { points: ["tl", "tr"] },
    bottomRight: { points: ["tr", "br"] },
    rightBottom: { points: ["bl", "br"] },
    bottomLeft: { points: ["tl", "bl"] },
    leftBottom: { points: ["br", "bl"] },
  },
  Sre = {
    topLeft: { points: ["bl", "tc"] },
    leftTop: { points: ["tr", "cl"] },
    topRight: { points: ["br", "tc"] },
    rightTop: { points: ["tl", "cr"] },
    bottomRight: { points: ["tr", "bc"] },
    rightBottom: { points: ["bl", "cr"] },
    bottomLeft: { points: ["tl", "bc"] },
    leftBottom: { points: ["br", "cl"] },
  },
  _re = new Set([
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight",
    "leftTop",
    "leftBottom",
    "rightTop",
    "rightBottom",
  ]);
function bre(t) {
  const {
      arrowWidth: e,
      autoAdjustOverflow: n,
      arrowPointAtCenter: r,
      offset: i,
      borderRadius: o,
      visibleFirst: a,
    } = t,
    s = e / 2,
    l = {};
  return (
    Object.keys(oL).forEach((c) => {
      const u = (r && Sre[c]) || oL[c],
        d = Object.assign(Object.assign({}, u), {
          offset: [0, 0],
          dynamicInset: !0,
        });
      switch (((l[c] = d), _re.has(c) && (d.autoArrow = !1), c)) {
        case "top":
        case "topLeft":
        case "topRight":
          d.offset[1] = -s - i;
          break;
        case "bottom":
        case "bottomLeft":
        case "bottomRight":
          d.offset[1] = s + i;
          break;
        case "left":
        case "leftTop":
        case "leftBottom":
          d.offset[0] = -s - i;
          break;
        case "right":
        case "rightTop":
        case "rightBottom":
          d.offset[0] = s + i;
          break;
      }
      const p = s4({ contentRadius: o, limitVerticalRadius: !0 });
      if (r)
        switch (c) {
          case "topLeft":
          case "bottomLeft":
            d.offset[0] = -p.arrowOffsetHorizontal - s;
            break;
          case "topRight":
          case "bottomRight":
            d.offset[0] = p.arrowOffsetHorizontal + s;
            break;
          case "leftTop":
          case "rightTop":
            d.offset[1] = -p.arrowOffsetHorizontal - s;
            break;
          case "leftBottom":
          case "rightBottom":
            d.offset[1] = p.arrowOffsetHorizontal + s;
            break;
        }
      (d.overflow = xre(c, p, e, n)), a && (d.htmlRegion = "visibleFirst");
    }),
    l
  );
}
const wre = (t) => {
    const {
      componentCls: e,
      tooltipMaxWidth: n,
      tooltipColor: r,
      tooltipBg: i,
      tooltipBorderRadius: o,
      zIndexPopup: a,
      controlHeight: s,
      boxShadowSecondary: l,
      paddingSM: c,
      paddingXS: u,
    } = t;
    return [
      {
        [e]: Object.assign(
          Object.assign(
            Object.assign(Object.assign({}, os(t)), {
              position: "absolute",
              zIndex: a,
              display: "block",
              width: "max-content",
              maxWidth: n,
              visibility: "visible",
              transformOrigin: "var(--arrow-x, 50%) var(--arrow-y, 50%)",
              "&-hidden": { display: "none" },
              "--antd-arrow-background-color": i,
              [`${e}-inner`]: {
                minWidth: s,
                minHeight: s,
                padding: `${Ze(t.calc(c).div(2).equal())} ${Ze(u)}`,
                color: r,
                textAlign: "start",
                textDecoration: "none",
                wordWrap: "break-word",
                backgroundColor: i,
                borderRadius: o,
                boxShadow: l,
                boxSizing: "border-box",
              },
              [[
                "&-placement-left",
                "&-placement-leftTop",
                "&-placement-leftBottom",
                "&-placement-right",
                "&-placement-rightTop",
                "&-placement-rightBottom",
              ].join(",")]: { [`${e}-inner`]: { borderRadius: t.min(o, a4) } },
              [`${e}-content`]: { position: "relative" },
            }),
            qQ(t, (d, p) => {
              let { darkColor: m } = p;
              return {
                [`&${e}-${d}`]: {
                  [`${e}-inner`]: { backgroundColor: m },
                  [`${e}-arrow`]: { "--antd-arrow-background-color": m },
                },
              };
            })
          ),
          { "&-rtl": { direction: "rtl" } }
        ),
      },
      yre(t, "var(--antd-arrow-background-color)"),
      {
        [`${e}-pure`]: {
          position: "relative",
          maxWidth: "none",
          margin: t.sizePopupArrow,
        },
      },
    ];
  },
  Ere = (t) =>
    Object.assign(
      Object.assign(
        { zIndexPopup: t.zIndexPopupBase + 70 },
        s4({ contentRadius: t.borderRadius, limitVerticalRadius: !0 })
      ),
      gre(xi(t, { borderRadiusOuter: Math.min(t.borderRadiusOuter, 4) }))
    ),
  l4 = function (t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return ec(
      "Tooltip",
      (r) => {
        const {
            borderRadius: i,
            colorTextLightSolid: o,
            colorBgSpotlight: a,
          } = r,
          s = xi(r, {
            tooltipMaxWidth: 250,
            tooltipColor: o,
            tooltipBorderRadius: i,
            tooltipBg: a,
          });
        return [wre(s), Dne(r, "zoom-big-fast")];
      },
      Ere,
      { resetStyle: !1, injectStyle: e }
    )(t);
  },
  Mre = Ey.map((t) => `${t}-inverse`);
function Cre(t) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0)
    ? [].concat(It(Mre), It(Ey)).includes(t)
    : Ey.includes(t);
}
function c4(t, e) {
  const n = Cre(e),
    r = nt({ [`${t}-${e}`]: e && n }),
    i = {},
    o = {};
  return (
    e && !n && ((i.background = e), (o["--antd-arrow-background-color"] = e)),
    { className: r, overlayStyle: i, arrowStyle: o }
  );
}
const Tre = (t) => {
    const {
        prefixCls: e,
        className: n,
        placement: r = "top",
        title: i,
        color: o,
        overlayInnerStyle: a,
      } = t,
      { getPrefixCls: s } = E.useContext(Rn),
      l = s("tooltip", e),
      [c, u, d] = l4(l),
      p = c4(l, o),
      m = p.arrowStyle,
      v = Object.assign(Object.assign({}, a), p.overlayStyle),
      S = nt(u, d, l, `${l}-pure`, `${l}-placement-${r}`, n, p.className);
    return c(
      E.createElement(
        "div",
        { className: S, style: m },
        E.createElement("div", { className: `${l}-arrow` }),
        E.createElement(
          o4,
          Object.assign({}, t, {
            className: u,
            prefixCls: l,
            overlayInnerStyle: v,
          }),
          i
        )
      )
    );
  },
  Are = Tre;
var Rre = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const u4 = E.forwardRef((t, e) => {
  var n, r;
  const {
      prefixCls: i,
      openClassName: o,
      getTooltipContainer: a,
      overlayClassName: s,
      color: l,
      overlayInnerStyle: c,
      children: u,
      afterOpenChange: d,
      afterVisibleChange: p,
      destroyTooltipOnHide: m,
      arrow: v = !0,
      title: S,
      overlay: x,
      builtinPlacements: g,
      arrowPointAtCenter: _ = !1,
      autoAdjustOverflow: y = !0,
    } = t,
    w = !!v,
    [, A] = is(),
    { getPopupContainer: M, getPrefixCls: T, direction: I } = E.useContext(Rn),
    R = XU(),
    P = E.useRef(null),
    F = () => {
      var ce;
      (ce = P.current) === null || ce === void 0 || ce.forceAlign();
    };
  E.useImperativeHandle(e, () => ({
    forceAlign: F,
    forcePopupAlign: () => {
      R.deprecated(!1, "forcePopupAlign", "forceAlign"), F();
    },
  }));
  const [D, j] = ta(!1, {
      value: (n = t.open) !== null && n !== void 0 ? n : t.visible,
      defaultValue:
        (r = t.defaultOpen) !== null && r !== void 0 ? r : t.defaultVisible,
    }),
    N = !S && !x && S !== 0,
    V = (ce) => {
      var he, Me;
      j(N ? !1 : ce),
        N ||
          ((he = t.onOpenChange) === null || he === void 0 || he.call(t, ce),
          (Me = t.onVisibleChange) === null || Me === void 0 || Me.call(t, ce));
    },
    W = E.useMemo(() => {
      var ce, he;
      let Me = _;
      return (
        typeof v == "object" &&
          (Me =
            (he =
              (ce = v.pointAtCenter) !== null && ce !== void 0
                ? ce
                : v.arrowPointAtCenter) !== null && he !== void 0
              ? he
              : _),
        g ||
          bre({
            arrowPointAtCenter: Me,
            autoAdjustOverflow: y,
            arrowWidth: w ? A.sizePopupArrow : 0,
            borderRadius: A.borderRadius,
            offset: A.marginXXS,
            visibleFirst: !0,
          })
      );
    }, [_, v, g, A]),
    Q = E.useMemo(() => (S === 0 ? S : x || S || ""), [x, S]),
    B = E.createElement(RE, null, typeof Q == "function" ? Q() : Q),
    {
      getPopupContainer: $,
      placement: G = "top",
      mouseEnterDelay: k = 0.1,
      mouseLeaveDelay: q = 0.1,
      overlayStyle: X,
      rootClassName: ee,
    } = t,
    J = Rre(t, [
      "getPopupContainer",
      "placement",
      "mouseEnterDelay",
      "mouseLeaveDelay",
      "overlayStyle",
      "rootClassName",
    ]),
    oe = T("tooltip", i),
    ae = T(),
    le = t["data-popover-inject"];
  let _e = D;
  !("open" in t) && !("visible" in t) && N && (_e = !1);
  const me = f2(u) && !Rk(u) ? u : E.createElement("span", null, u),
    se = me.props,
    Y =
      !se.className || typeof se.className == "string"
        ? nt(se.className, o || `${oe}-open`)
        : se.className,
    [ve, de, ue] = l4(oe, !le),
    fe = c4(oe, l),
    Te = fe.arrowStyle,
    pe = Object.assign(Object.assign({}, c), fe.overlayStyle),
    H = nt(s, { [`${oe}-rtl`]: I === "rtl" }, fe.className, ee, de, ue),
    [z, Z] = see("Tooltip", J.zIndex),
    ge = E.createElement(
      mre,
      Object.assign({}, J, {
        zIndex: z,
        showArrow: w,
        placement: G,
        mouseEnterDelay: k,
        mouseLeaveDelay: q,
        prefixCls: oe,
        overlayClassName: H,
        overlayStyle: Object.assign(Object.assign({}, Te), X),
        getTooltipContainer: $ || a || M,
        ref: P,
        builtinPlacements: W,
        overlay: B,
        visible: _e,
        onVisibleChange: V,
        afterVisibleChange: d ?? p,
        overlayInnerStyle: pe,
        arrowContent: E.createElement("span", {
          className: `${oe}-arrow-content`,
        }),
        motion: {
          motionName: Nk(ae, "zoom-big-fast", t.transitionName),
          motionDeadline: 1e3,
        },
        destroyTooltipOnHide: !!m,
      }),
      _e ? em(me, { className: Y }) : me
    );
  return ve(E.createElement(Pk.Provider, { value: Z }, ge));
});
u4._InternalPanelDoNotUseOrYouWillBeFired = Are;
const aL = u4;
var Pre = gt.ESC,
  Ire = gt.TAB;
function Lre(t) {
  var e = t.visible,
    n = t.triggerRef,
    r = t.onVisibleChange,
    i = t.autoFocus,
    o = t.overlayRef,
    a = E.useRef(!1),
    s = function () {
      if (e) {
        var d, p;
        (d = n.current) === null ||
          d === void 0 ||
          (p = d.focus) === null ||
          p === void 0 ||
          p.call(d),
          r == null || r(!1);
      }
    },
    l = function () {
      var d;
      return (d = o.current) !== null && d !== void 0 && d.focus
        ? (o.current.focus(), (a.current = !0), !0)
        : !1;
    },
    c = function (d) {
      switch (d.keyCode) {
        case Pre:
          s();
          break;
        case Ire: {
          var p = !1;
          a.current || (p = l()), p ? d.preventDefault() : s();
          break;
        }
      }
    };
  E.useEffect(
    function () {
      return e
        ? (window.addEventListener("keydown", c),
          i && Er(l, 3),
          function () {
            window.removeEventListener("keydown", c), (a.current = !1);
          })
        : function () {
            a.current = !1;
          };
    },
    [e]
  );
}
var Ore = E.forwardRef(function (t, e) {
    var n = t.overlay,
      r = t.arrow,
      i = t.prefixCls,
      o = E.useMemo(
        function () {
          var s;
          return typeof n == "function" ? (s = n()) : (s = n), s;
        },
        [n]
      ),
      a = ls(e, o == null ? void 0 : o.ref);
    return at.createElement(
      at.Fragment,
      null,
      r && at.createElement("div", { className: "".concat(i, "-arrow") }),
      at.cloneElement(o, { ref: wu(o) ? a : void 0 })
    );
  }),
  yd = { adjustX: 1, adjustY: 1 },
  xd = [0, 0],
  Nre = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: yd,
      offset: [0, -4],
      targetOffset: xd,
    },
    top: {
      points: ["bc", "tc"],
      overflow: yd,
      offset: [0, -4],
      targetOffset: xd,
    },
    topRight: {
      points: ["br", "tr"],
      overflow: yd,
      offset: [0, -4],
      targetOffset: xd,
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: yd,
      offset: [0, 4],
      targetOffset: xd,
    },
    bottom: {
      points: ["tc", "bc"],
      overflow: yd,
      offset: [0, 4],
      targetOffset: xd,
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: yd,
      offset: [0, 4],
      targetOffset: xd,
    },
  },
  Fre = [
    "arrow",
    "prefixCls",
    "transitionName",
    "animation",
    "align",
    "placement",
    "placements",
    "getPopupContainer",
    "showAction",
    "hideAction",
    "overlayClassName",
    "overlayStyle",
    "visible",
    "trigger",
    "autoFocus",
    "overlay",
    "children",
    "onVisibleChange",
  ];
function Dre(t, e) {
  var n,
    r = t.arrow,
    i = r === void 0 ? !1 : r,
    o = t.prefixCls,
    a = o === void 0 ? "rc-dropdown" : o,
    s = t.transitionName,
    l = t.animation,
    c = t.align,
    u = t.placement,
    d = u === void 0 ? "bottomLeft" : u,
    p = t.placements,
    m = p === void 0 ? Nre : p,
    v = t.getPopupContainer,
    S = t.showAction,
    x = t.hideAction,
    g = t.overlayClassName,
    _ = t.overlayStyle,
    y = t.visible,
    w = t.trigger,
    A = w === void 0 ? ["hover"] : w,
    M = t.autoFocus,
    T = t.overlay,
    I = t.children,
    R = t.onVisibleChange,
    P = on(t, Fre),
    F = at.useState(),
    D = Ve(F, 2),
    j = D[0],
    N = D[1],
    V = "visible" in t ? y : j,
    W = at.useRef(null),
    Q = at.useRef(null),
    B = at.useRef(null);
  at.useImperativeHandle(e, function () {
    return W.current;
  });
  var $ = function (le) {
    N(le), R == null || R(le);
  };
  Lre({
    visible: V,
    triggerRef: B,
    onVisibleChange: $,
    autoFocus: M,
    overlayRef: Q,
  });
  var G = function (le) {
      var _e = t.onOverlayClick;
      N(!1), _e && _e(le);
    },
    k = function () {
      return at.createElement(Ore, {
        ref: Q,
        overlay: T,
        prefixCls: a,
        arrow: i,
      });
    },
    q = function () {
      return typeof T == "function" ? k : k();
    },
    X = function () {
      var le = t.minOverlayWidthMatchTrigger,
        _e = t.alignPoint;
      return "minOverlayWidthMatchTrigger" in t ? le : !_e;
    },
    ee = function () {
      var le = t.openClassName;
      return le !== void 0 ? le : "".concat(a, "-open");
    },
    J = at.cloneElement(I, {
      className: nt(
        (n = I.props) === null || n === void 0 ? void 0 : n.className,
        V && ee()
      ),
      ref: wu(I) ? ls(B, I.ref) : void 0,
    }),
    oe = x;
  return (
    !oe && A.indexOf("contextMenu") !== -1 && (oe = ["click"]),
    at.createElement(
      _2,
      Et({ builtinPlacements: m }, P, {
        prefixCls: a,
        ref: W,
        popupClassName: nt(g, be({}, "".concat(a, "-show-arrow"), i)),
        popupStyle: _,
        action: A,
        showAction: S,
        hideAction: oe,
        popupPlacement: d,
        popupAlign: c,
        popupTransitionName: s,
        popupAnimation: l,
        popupVisible: V,
        stretch: X() ? "minWidth" : "",
        popup: q(),
        onPopupVisibleChange: $,
        onPopupClick: G,
        getPopupContainer: v,
      }),
      J
    )
  );
}
const zre = at.forwardRef(Dre);
var d4 = E.createContext(null);
function f4(t, e) {
  return t === void 0 ? null : "".concat(t, "-").concat(e);
}
function h4(t) {
  var e = E.useContext(d4);
  return f4(e, t);
}
var Ure = ["children", "locked"],
  La = E.createContext(null);
function kre(t, e) {
  var n = De({}, t);
  return (
    Object.keys(e).forEach(function (r) {
      var i = e[r];
      i !== void 0 && (n[r] = i);
    }),
    n
  );
}
function im(t) {
  var e = t.children,
    n = t.locked,
    r = on(t, Ure),
    i = E.useContext(La),
    o = H1(
      function () {
        return kre(i, r);
      },
      [i, r],
      function (a, s) {
        return !n && (a[0] !== s[0] || !G1(a[1], s[1], !0));
      }
    );
  return E.createElement(La.Provider, { value: o }, e);
}
var Bre = [],
  p4 = E.createContext(null);
function ex() {
  return E.useContext(p4);
}
var m4 = E.createContext(Bre);
function Nm(t) {
  var e = E.useContext(m4);
  return E.useMemo(
    function () {
      return t !== void 0 ? [].concat(It(e), [t]) : e;
    },
    [e, t]
  );
}
var g4 = E.createContext(null),
  b2 = E.createContext({});
function sL(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (p2(t)) {
    var n = t.nodeName.toLowerCase(),
      r =
        ["input", "select", "textarea", "button"].includes(n) ||
        t.isContentEditable ||
        (n === "a" && !!t.getAttribute("href")),
      i = t.getAttribute("tabindex"),
      o = Number(i),
      a = null;
    return (
      i && !Number.isNaN(o) ? (a = o) : r && a === null && (a = 0),
      r && t.disabled && (a = null),
      a !== null && (a >= 0 || (e && a < 0))
    );
  }
  return !1;
}
function Hre(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    n = It(t.querySelectorAll("*")).filter(function (r) {
      return sL(r, e);
    });
  return sL(t, e) && n.unshift(t), n;
}
var $E = gt.LEFT,
  GE = gt.RIGHT,
  WE = gt.UP,
  N0 = gt.DOWN,
  F0 = gt.ENTER,
  v4 = gt.ESC,
  Rh = gt.HOME,
  Ph = gt.END,
  lL = [WE, N0, $E, GE];
function jre(t, e, n, r) {
  var i,
    o,
    a,
    s,
    l = "prev",
    c = "next",
    u = "children",
    d = "parent";
  if (t === "inline" && r === F0) return { inlineTrigger: !0 };
  var p = ((i = {}), be(i, WE, l), be(i, N0, c), i),
    m =
      ((o = {}),
      be(o, $E, n ? c : l),
      be(o, GE, n ? l : c),
      be(o, N0, u),
      be(o, F0, u),
      o),
    v =
      ((a = {}),
      be(a, WE, l),
      be(a, N0, c),
      be(a, F0, u),
      be(a, v4, d),
      be(a, $E, n ? u : d),
      be(a, GE, n ? d : u),
      a),
    S = {
      inline: p,
      horizontal: m,
      vertical: v,
      inlineSub: p,
      horizontalSub: v,
      verticalSub: v,
    },
    x =
      (s = S["".concat(t).concat(e ? "" : "Sub")]) === null || s === void 0
        ? void 0
        : s[r];
  switch (x) {
    case l:
      return { offset: -1, sibling: !0 };
    case c:
      return { offset: 1, sibling: !0 };
    case d:
      return { offset: -1, sibling: !1 };
    case u:
      return { offset: 1, sibling: !1 };
    default:
      return null;
  }
}
function Vre(t) {
  for (var e = t; e; ) {
    if (e.getAttribute("data-menu-list")) return e;
    e = e.parentElement;
  }
  return null;
}
function $re(t, e) {
  for (var n = t || document.activeElement; n; ) {
    if (e.has(n)) return n;
    n = n.parentElement;
  }
  return null;
}
function w2(t, e) {
  var n = Hre(t, !0);
  return n.filter(function (r) {
    return e.has(r);
  });
}
function cL(t, e, n) {
  var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  if (!t) return null;
  var i = w2(t, e),
    o = i.length,
    a = i.findIndex(function (s) {
      return n === s;
    });
  return (
    r < 0 ? (a === -1 ? (a = o - 1) : (a -= 1)) : r > 0 && (a += 1),
    (a = (a + o) % o),
    i[a]
  );
}
var XE = function (e, n) {
  var r = new Set(),
    i = new Map(),
    o = new Map();
  return (
    e.forEach(function (a) {
      var s = document.querySelector("[data-menu-id='".concat(f4(n, a), "']"));
      s && (r.add(s), o.set(s, a), i.set(a, s));
    }),
    { elements: r, key2element: i, element2key: o }
  );
};
function Gre(t, e, n, r, i, o, a, s, l, c) {
  var u = E.useRef(),
    d = E.useRef();
  d.current = e;
  var p = function () {
    Er.cancel(u.current);
  };
  return (
    E.useEffect(function () {
      return function () {
        p();
      };
    }, []),
    function (m) {
      var v = m.which;
      if ([].concat(lL, [F0, v4, Rh, Ph]).includes(v)) {
        var S = o(),
          x = XE(S, r),
          g = x,
          _ = g.elements,
          y = g.key2element,
          w = g.element2key,
          A = y.get(e),
          M = $re(A, _),
          T = w.get(M),
          I = jre(t, a(T, !0).length === 1, n, v);
        if (!I && v !== Rh && v !== Ph) return;
        (lL.includes(v) || [Rh, Ph].includes(v)) && m.preventDefault();
        var R = function (Q) {
          if (Q) {
            var B = Q,
              $ = Q.querySelector("a");
            $ != null && $.getAttribute("href") && (B = $);
            var G = w.get(Q);
            s(G),
              p(),
              (u.current = Er(function () {
                d.current === G && B.focus();
              }));
          }
        };
        if ([Rh, Ph].includes(v) || I.sibling || !M) {
          var P;
          !M || t === "inline" ? (P = i.current) : (P = Vre(M));
          var F,
            D = w2(P, _);
          v === Rh
            ? (F = D[0])
            : v === Ph
            ? (F = D[D.length - 1])
            : (F = cL(P, _, M, I.offset)),
            R(F);
        } else if (I.inlineTrigger) l(T);
        else if (I.offset > 0)
          l(T, !0),
            p(),
            (u.current = Er(function () {
              x = XE(S, r);
              var W = M.getAttribute("aria-controls"),
                Q = document.getElementById(W),
                B = cL(Q, x.elements);
              R(B);
            }, 5));
        else if (I.offset < 0) {
          var j = a(T, !0),
            N = j[j.length - 2],
            V = y.get(N);
          l(N, !1), R(V);
        }
      }
      c == null || c(m);
    }
  );
}
function Wre(t) {
  Promise.resolve().then(t);
}
var E2 = "__RC_UTIL_PATH_SPLIT__",
  uL = function (e) {
    return e.join(E2);
  },
  Xre = function (e) {
    return e.split(E2);
  },
  qE = "rc-menu-more";
function qre() {
  var t = E.useState({}),
    e = Ve(t, 2),
    n = e[1],
    r = E.useRef(new Map()),
    i = E.useRef(new Map()),
    o = E.useState([]),
    a = Ve(o, 2),
    s = a[0],
    l = a[1],
    c = E.useRef(0),
    u = E.useRef(!1),
    d = function () {
      u.current || n({});
    },
    p = E.useCallback(function (y, w) {
      var A = uL(w);
      i.current.set(A, y), r.current.set(y, A), (c.current += 1);
      var M = c.current;
      Wre(function () {
        M === c.current && d();
      });
    }, []),
    m = E.useCallback(function (y, w) {
      var A = uL(w);
      i.current.delete(A), r.current.delete(y);
    }, []),
    v = E.useCallback(function (y) {
      l(y);
    }, []),
    S = E.useCallback(
      function (y, w) {
        var A = r.current.get(y) || "",
          M = Xre(A);
        return w && s.includes(M[0]) && M.unshift(qE), M;
      },
      [s]
    ),
    x = E.useCallback(
      function (y, w) {
        return y.some(function (A) {
          var M = S(A, !0);
          return M.includes(w);
        });
      },
      [S]
    ),
    g = function () {
      var w = It(r.current.keys());
      return s.length && w.push(qE), w;
    },
    _ = E.useCallback(function (y) {
      var w = "".concat(r.current.get(y)).concat(E2),
        A = new Set();
      return (
        It(i.current.keys()).forEach(function (M) {
          M.startsWith(w) && A.add(i.current.get(M));
        }),
        A
      );
    }, []);
  return (
    E.useEffect(function () {
      return function () {
        u.current = !0;
      };
    }, []),
    {
      registerPath: p,
      unregisterPath: m,
      refreshOverflowKeys: v,
      isSubPathKey: x,
      getKeyPath: S,
      getKeys: g,
      getSubPathKeys: _,
    }
  );
}
function kh(t) {
  var e = E.useRef(t);
  e.current = t;
  var n = E.useCallback(function () {
    for (var r, i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    return (r = e.current) === null || r === void 0
      ? void 0
      : r.call.apply(r, [e].concat(o));
  }, []);
  return t ? n : void 0;
}
var Kre = Math.random().toFixed(5).toString().slice(2),
  dL = 0;
function Yre(t) {
  var e = ta(t, { value: t }),
    n = Ve(e, 2),
    r = n[0],
    i = n[1];
  return (
    E.useEffect(function () {
      dL += 1;
      var o = "".concat(Kre, "-").concat(dL);
      i("rc-menu-uuid-".concat(o));
    }, []),
    r
  );
}
function y4(t, e, n, r) {
  var i = E.useContext(La),
    o = i.activeKey,
    a = i.onActive,
    s = i.onInactive,
    l = { active: o === t };
  return (
    e ||
      ((l.onMouseEnter = function (c) {
        n == null || n({ key: t, domEvent: c }), a(t);
      }),
      (l.onMouseLeave = function (c) {
        r == null || r({ key: t, domEvent: c }), s(t);
      })),
    l
  );
}
function x4(t) {
  var e = E.useContext(La),
    n = e.mode,
    r = e.rtl,
    i = e.inlineIndent;
  if (n !== "inline") return null;
  var o = t;
  return r ? { paddingRight: o * i } : { paddingLeft: o * i };
}
function S4(t) {
  var e = t.icon,
    n = t.props,
    r = t.children,
    i;
  return e === null || e === !1
    ? null
    : (typeof e == "function"
        ? (i = E.createElement(e, De({}, n)))
        : typeof e != "boolean" && (i = e),
      i || r || null);
}
var Zre = ["item"];
function Iy(t) {
  var e = t.item,
    n = on(t, Zre);
  return (
    Object.defineProperty(n, "item", {
      get: function () {
        return (
          Ni(
            !1,
            "`info.item` is deprecated since we will move to function component that not provides React Node instance in future."
          ),
          e
        );
      },
    }),
    n
  );
}
var Qre = ["title", "attribute", "elementRef"],
  Jre = [
    "style",
    "className",
    "eventKey",
    "warnKey",
    "disabled",
    "itemIcon",
    "children",
    "role",
    "onMouseEnter",
    "onMouseLeave",
    "onClick",
    "onKeyDown",
    "onFocus",
  ],
  eie = ["active"],
  tie = (function (t) {
    Eu(n, t);
    var e = Mm(n);
    function n() {
      return ro(this, n), e.apply(this, arguments);
    }
    return (
      io(n, [
        {
          key: "render",
          value: function () {
            var i = this.props,
              o = i.title,
              a = i.attribute,
              s = i.elementRef,
              l = on(i, Qre),
              c = Ys(l, [
                "eventKey",
                "popupClassName",
                "popupOffset",
                "onTitleClick",
              ]);
            return (
              Ni(
                !a,
                "`attribute` of Menu.Item is deprecated. Please pass attribute directly."
              ),
              E.createElement(
                zs.Item,
                Et({}, a, { title: typeof o == "string" ? o : void 0 }, c, {
                  ref: s,
                })
              )
            );
          },
        },
      ]),
      n
    );
  })(E.Component),
  nie = E.forwardRef(function (t, e) {
    var n,
      r = t.style,
      i = t.className,
      o = t.eventKey;
    t.warnKey;
    var a = t.disabled,
      s = t.itemIcon,
      l = t.children,
      c = t.role,
      u = t.onMouseEnter,
      d = t.onMouseLeave,
      p = t.onClick,
      m = t.onKeyDown,
      v = t.onFocus,
      S = on(t, Jre),
      x = h4(o),
      g = E.useContext(La),
      _ = g.prefixCls,
      y = g.onItemClick,
      w = g.disabled,
      A = g.overflowDisabled,
      M = g.itemIcon,
      T = g.selectedKeys,
      I = g.onActive,
      R = E.useContext(b2),
      P = R._internalRenderMenuItem,
      F = "".concat(_, "-item"),
      D = E.useRef(),
      j = E.useRef(),
      N = w || a,
      V = Em(e, j),
      W = Nm(o),
      Q = function (me) {
        return {
          key: o,
          keyPath: It(W).reverse(),
          item: D.current,
          domEvent: me,
        };
      },
      B = s || M,
      $ = y4(o, N, u, d),
      G = $.active,
      k = on($, eie),
      q = T.includes(o),
      X = x4(W.length),
      ee = function (me) {
        if (!N) {
          var se = Q(me);
          p == null || p(Iy(se)), y(se);
        }
      },
      J = function (me) {
        if ((m == null || m(me), me.which === gt.ENTER)) {
          var se = Q(me);
          p == null || p(Iy(se)), y(se);
        }
      },
      oe = function (me) {
        I(o), v == null || v(me);
      },
      ae = {};
    t.role === "option" && (ae["aria-selected"] = q);
    var le = E.createElement(
      tie,
      Et(
        {
          ref: D,
          elementRef: V,
          role: c === null ? "none" : c || "menuitem",
          tabIndex: a ? null : -1,
          "data-menu-id": A && x ? null : x,
        },
        S,
        k,
        ae,
        {
          component: "li",
          "aria-disabled": a,
          style: De(De({}, X), r),
          className: nt(
            F,
            ((n = {}),
            be(n, "".concat(F, "-active"), G),
            be(n, "".concat(F, "-selected"), q),
            be(n, "".concat(F, "-disabled"), N),
            n),
            i
          ),
          onClick: ee,
          onKeyDown: J,
          onFocus: oe,
        }
      ),
      l,
      E.createElement(S4, {
        props: De(De({}, t), {}, { isSelected: q }),
        icon: B,
      })
    );
    return P && (le = P(le, t, { selected: q })), le;
  });
function rie(t, e) {
  var n = t.eventKey,
    r = ex(),
    i = Nm(n);
  return (
    E.useEffect(
      function () {
        if (r)
          return (
            r.registerPath(n, i),
            function () {
              r.unregisterPath(n, i);
            }
          );
      },
      [i]
    ),
    r ? null : E.createElement(nie, Et({}, t, { ref: e }))
  );
}
const tx = E.forwardRef(rie);
var iie = ["className", "children"],
  oie = function (e, n) {
    var r = e.className,
      i = e.children,
      o = on(e, iie),
      a = E.useContext(La),
      s = a.prefixCls,
      l = a.mode,
      c = a.rtl;
    return E.createElement(
      "ul",
      Et(
        {
          className: nt(
            s,
            c && "".concat(s, "-rtl"),
            "".concat(s, "-sub"),
            "".concat(s, "-").concat(l === "inline" ? "inline" : "vertical"),
            r
          ),
          role: "menu",
        },
        o,
        { "data-menu-list": !0, ref: n }
      ),
      i
    );
  },
  M2 = E.forwardRef(oie);
M2.displayName = "SubMenuList";
function C2(t, e) {
  return yf(t).map(function (n, r) {
    if (E.isValidElement(n)) {
      var i,
        o,
        a = n.key,
        s =
          (i = (o = n.props) === null || o === void 0 ? void 0 : o.eventKey) !==
            null && i !== void 0
            ? i
            : a,
        l = s == null;
      l && (s = "tmp_key-".concat([].concat(It(e), [r]).join("-")));
      var c = { key: s, eventKey: s };
      return E.cloneElement(n, c);
    }
    return n;
  });
}
var fi = { adjustX: 1, adjustY: 1 },
  aie = {
    topLeft: { points: ["bl", "tl"], overflow: fi },
    topRight: { points: ["br", "tr"], overflow: fi },
    bottomLeft: { points: ["tl", "bl"], overflow: fi },
    bottomRight: { points: ["tr", "br"], overflow: fi },
    leftTop: { points: ["tr", "tl"], overflow: fi },
    leftBottom: { points: ["br", "bl"], overflow: fi },
    rightTop: { points: ["tl", "tr"], overflow: fi },
    rightBottom: { points: ["bl", "br"], overflow: fi },
  },
  sie = {
    topLeft: { points: ["bl", "tl"], overflow: fi },
    topRight: { points: ["br", "tr"], overflow: fi },
    bottomLeft: { points: ["tl", "bl"], overflow: fi },
    bottomRight: { points: ["tr", "br"], overflow: fi },
    rightTop: { points: ["tr", "tl"], overflow: fi },
    rightBottom: { points: ["br", "bl"], overflow: fi },
    leftTop: { points: ["tl", "tr"], overflow: fi },
    leftBottom: { points: ["bl", "br"], overflow: fi },
  };
function _4(t, e, n) {
  if (e) return e;
  if (n) return n[t] || n.other;
}
var lie = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop",
};
function cie(t) {
  var e = t.prefixCls,
    n = t.visible,
    r = t.children,
    i = t.popup,
    o = t.popupStyle,
    a = t.popupClassName,
    s = t.popupOffset,
    l = t.disabled,
    c = t.mode,
    u = t.onVisibleChange,
    d = E.useContext(La),
    p = d.getPopupContainer,
    m = d.rtl,
    v = d.subMenuOpenDelay,
    S = d.subMenuCloseDelay,
    x = d.builtinPlacements,
    g = d.triggerSubMenuAction,
    _ = d.forceSubMenuRender,
    y = d.rootClassName,
    w = d.motion,
    A = d.defaultMotions,
    M = E.useState(!1),
    T = Ve(M, 2),
    I = T[0],
    R = T[1],
    P = De(m ? De({}, sie) : De({}, aie), x),
    F = lie[c],
    D = _4(c, w, A),
    j = E.useRef(D);
  c !== "inline" && (j.current = D);
  var N = De(
      De({}, j.current),
      {},
      {
        leavedClassName: "".concat(e, "-hidden"),
        removeOnLeave: !1,
        motionAppear: !0,
      }
    ),
    V = E.useRef();
  return (
    E.useEffect(
      function () {
        return (
          (V.current = Er(function () {
            R(n);
          })),
          function () {
            Er.cancel(V.current);
          }
        );
      },
      [n]
    ),
    E.createElement(
      _2,
      {
        prefixCls: e,
        popupClassName: nt(
          "".concat(e, "-popup"),
          be({}, "".concat(e, "-rtl"), m),
          a,
          y
        ),
        stretch: c === "horizontal" ? "minWidth" : null,
        getPopupContainer: p,
        builtinPlacements: P,
        popupPlacement: F,
        popupVisible: I,
        popup: i,
        popupStyle: o,
        popupAlign: s && { offset: s },
        action: l ? [] : [g],
        mouseEnterDelay: v,
        mouseLeaveDelay: S,
        onPopupVisibleChange: u,
        forceRender: _,
        popupMotion: N,
        fresh: !0,
      },
      r
    )
  );
}
function uie(t) {
  var e = t.id,
    n = t.open,
    r = t.keyPath,
    i = t.children,
    o = "inline",
    a = E.useContext(La),
    s = a.prefixCls,
    l = a.forceSubMenuRender,
    c = a.motion,
    u = a.defaultMotions,
    d = a.mode,
    p = E.useRef(!1);
  p.current = d === o;
  var m = E.useState(!p.current),
    v = Ve(m, 2),
    S = v[0],
    x = v[1],
    g = p.current ? n : !1;
  E.useEffect(
    function () {
      p.current && x(!1);
    },
    [d]
  );
  var _ = De({}, _4(o, c, u));
  r.length > 1 && (_.motionAppear = !1);
  var y = _.onVisibleChanged;
  return (
    (_.onVisibleChanged = function (w) {
      return !p.current && !w && x(!0), y == null ? void 0 : y(w);
    }),
    S
      ? null
      : E.createElement(
          im,
          { mode: o, locked: !p.current },
          E.createElement(
            Mu,
            Et({ visible: g }, _, {
              forceRender: l,
              removeOnLeave: !1,
              leavedClassName: "".concat(s, "-hidden"),
            }),
            function (w) {
              var A = w.className,
                M = w.style;
              return E.createElement(M2, { id: e, className: A, style: M }, i);
            }
          )
        )
  );
}
var die = [
    "style",
    "className",
    "title",
    "eventKey",
    "warnKey",
    "disabled",
    "internalPopupClose",
    "children",
    "itemIcon",
    "expandIcon",
    "popupClassName",
    "popupOffset",
    "popupStyle",
    "onClick",
    "onMouseEnter",
    "onMouseLeave",
    "onTitleClick",
    "onTitleMouseEnter",
    "onTitleMouseLeave",
  ],
  fie = ["active"],
  hie = function (e) {
    var n,
      r = e.style,
      i = e.className,
      o = e.title,
      a = e.eventKey;
    e.warnKey;
    var s = e.disabled,
      l = e.internalPopupClose,
      c = e.children,
      u = e.itemIcon,
      d = e.expandIcon,
      p = e.popupClassName,
      m = e.popupOffset,
      v = e.popupStyle,
      S = e.onClick,
      x = e.onMouseEnter,
      g = e.onMouseLeave,
      _ = e.onTitleClick,
      y = e.onTitleMouseEnter,
      w = e.onTitleMouseLeave,
      A = on(e, die),
      M = h4(a),
      T = E.useContext(La),
      I = T.prefixCls,
      R = T.mode,
      P = T.openKeys,
      F = T.disabled,
      D = T.overflowDisabled,
      j = T.activeKey,
      N = T.selectedKeys,
      V = T.itemIcon,
      W = T.expandIcon,
      Q = T.onItemClick,
      B = T.onOpenChange,
      $ = T.onActive,
      G = E.useContext(b2),
      k = G._internalRenderSubMenuItem,
      q = E.useContext(g4),
      X = q.isSubPathKey,
      ee = Nm(),
      J = "".concat(I, "-submenu"),
      oe = F || s,
      ae = E.useRef(),
      le = E.useRef(),
      _e = u ?? V,
      me = d ?? W,
      se = P.includes(a),
      Y = !D && se,
      ve = X(N, a),
      de = y4(a, oe, y, w),
      ue = de.active,
      fe = on(de, fie),
      Te = E.useState(!1),
      pe = Ve(Te, 2),
      H = pe[0],
      z = pe[1],
      Z = function (ne) {
        oe || z(ne);
      },
      ge = function (ne) {
        Z(!0), x == null || x({ key: a, domEvent: ne });
      },
      ce = function (ne) {
        Z(!1), g == null || g({ key: a, domEvent: ne });
      },
      he = E.useMemo(
        function () {
          return ue || (R !== "inline" ? H || X([j], a) : !1);
        },
        [R, ue, j, H, a, X]
      ),
      Me = x4(ee.length),
      Re = function (ne) {
        oe ||
          (_ == null || _({ key: a, domEvent: ne }),
          R === "inline" && B(a, !se));
      },
      Le = kh(function (Ne) {
        S == null || S(Iy(Ne)), Q(Ne);
      }),
      Oe = function (ne) {
        R !== "inline" && B(a, ne);
      },
      Pe = function () {
        $(a);
      },
      Se = M && "".concat(M, "-popup"),
      Je = E.createElement(
        "div",
        Et(
          {
            role: "menuitem",
            style: Me,
            className: "".concat(J, "-title"),
            tabIndex: oe ? null : -1,
            ref: ae,
            title: typeof o == "string" ? o : null,
            "data-menu-id": D && M ? null : M,
            "aria-expanded": Y,
            "aria-haspopup": !0,
            "aria-controls": Se,
            "aria-disabled": oe,
            onClick: Re,
            onFocus: Pe,
          },
          fe
        ),
        o,
        E.createElement(
          S4,
          {
            icon: R !== "horizontal" ? me : void 0,
            props: De(De({}, e), {}, { isOpen: Y, isSubMenu: !0 }),
          },
          E.createElement("i", { className: "".concat(J, "-arrow") })
        )
      ),
      st = E.useRef(R);
    if (
      (R !== "inline" && ee.length > 1
        ? (st.current = "vertical")
        : (st.current = R),
      !D)
    ) {
      var Qe = st.current;
      Je = E.createElement(
        cie,
        {
          mode: Qe,
          prefixCls: J,
          visible: !l && Y && R !== "inline",
          popupClassName: p,
          popupOffset: m,
          popupStyle: v,
          popup: E.createElement(
            im,
            { mode: Qe === "horizontal" ? "vertical" : Qe },
            E.createElement(M2, { id: Se, ref: le }, c)
          ),
          disabled: oe,
          onVisibleChange: Oe,
        },
        Je
      );
    }
    var Ke = E.createElement(
      zs.Item,
      Et({ role: "none" }, A, {
        component: "li",
        style: r,
        className: nt(
          J,
          "".concat(J, "-").concat(R),
          i,
          ((n = {}),
          be(n, "".concat(J, "-open"), Y),
          be(n, "".concat(J, "-active"), he),
          be(n, "".concat(J, "-selected"), ve),
          be(n, "".concat(J, "-disabled"), oe),
          n)
        ),
        onMouseEnter: ge,
        onMouseLeave: ce,
      }),
      Je,
      !D && E.createElement(uie, { id: Se, open: Y, keyPath: ee }, c)
    );
    return (
      k && (Ke = k(Ke, e, { selected: ve, active: he, open: Y, disabled: oe })),
      E.createElement(
        im,
        {
          onItemClick: Le,
          mode: R === "horizontal" ? "vertical" : R,
          itemIcon: _e,
          expandIcon: me,
        },
        Ke
      )
    );
  };
function T2(t) {
  var e = t.eventKey,
    n = t.children,
    r = Nm(e),
    i = C2(n, r),
    o = ex();
  E.useEffect(
    function () {
      if (o)
        return (
          o.registerPath(e, r),
          function () {
            o.unregisterPath(e, r);
          }
        );
    },
    [r]
  );
  var a;
  return (
    o ? (a = i) : (a = E.createElement(hie, t, i)),
    E.createElement(m4.Provider, { value: r }, a)
  );
}
var pie = ["className", "title", "eventKey", "children"],
  mie = ["children"],
  gie = function (e) {
    var n = e.className,
      r = e.title;
    e.eventKey;
    var i = e.children,
      o = on(e, pie),
      a = E.useContext(La),
      s = a.prefixCls,
      l = "".concat(s, "-item-group");
    return E.createElement(
      "li",
      Et({ role: "presentation" }, o, {
        onClick: function (u) {
          return u.stopPropagation();
        },
        className: nt(l, n),
      }),
      E.createElement(
        "div",
        {
          role: "presentation",
          className: "".concat(l, "-title"),
          title: typeof r == "string" ? r : void 0,
        },
        r
      ),
      E.createElement(
        "ul",
        { role: "group", className: "".concat(l, "-list") },
        i
      )
    );
  };
function b4(t) {
  var e = t.children,
    n = on(t, mie),
    r = Nm(n.eventKey),
    i = C2(e, r),
    o = ex();
  return o ? i : E.createElement(gie, Ys(n, ["warnKey"]), i);
}
function w4(t) {
  var e = t.className,
    n = t.style,
    r = E.useContext(La),
    i = r.prefixCls,
    o = ex();
  return o
    ? null
    : E.createElement("li", {
        role: "separator",
        className: nt("".concat(i, "-item-divider"), e),
        style: n,
      });
}
var vie = ["label", "children", "key", "type"];
function KE(t) {
  return (t || [])
    .map(function (e, n) {
      if (e && un(e) === "object") {
        var r = e,
          i = r.label,
          o = r.children,
          a = r.key,
          s = r.type,
          l = on(r, vie),
          c = a ?? "tmp-".concat(n);
        return o || s === "group"
          ? s === "group"
            ? E.createElement(b4, Et({ key: c }, l, { title: i }), KE(o))
            : E.createElement(T2, Et({ key: c }, l, { title: i }), KE(o))
          : s === "divider"
          ? E.createElement(w4, Et({ key: c }, l))
          : E.createElement(tx, Et({ key: c }, l), i);
      }
      return null;
    })
    .filter(function (e) {
      return e;
    });
}
function yie(t, e, n) {
  var r = t;
  return e && (r = KE(e)), C2(r, n);
}
var xie = [
    "prefixCls",
    "rootClassName",
    "style",
    "className",
    "tabIndex",
    "items",
    "children",
    "direction",
    "id",
    "mode",
    "inlineCollapsed",
    "disabled",
    "disabledOverflow",
    "subMenuOpenDelay",
    "subMenuCloseDelay",
    "forceSubMenuRender",
    "defaultOpenKeys",
    "openKeys",
    "activeKey",
    "defaultActiveFirst",
    "selectable",
    "multiple",
    "defaultSelectedKeys",
    "selectedKeys",
    "onSelect",
    "onDeselect",
    "inlineIndent",
    "motion",
    "defaultMotions",
    "triggerSubMenuAction",
    "builtinPlacements",
    "itemIcon",
    "expandIcon",
    "overflowedIndicator",
    "overflowedIndicatorPopupClassName",
    "getPopupContainer",
    "onClick",
    "onOpenChange",
    "onKeyDown",
    "openAnimation",
    "openTransitionName",
    "_internalRenderMenuItem",
    "_internalRenderSubMenuItem",
  ],
  Sd = [],
  Sie = E.forwardRef(function (t, e) {
    var n,
      r,
      i = t,
      o = i.prefixCls,
      a = o === void 0 ? "rc-menu" : o,
      s = i.rootClassName,
      l = i.style,
      c = i.className,
      u = i.tabIndex,
      d = u === void 0 ? 0 : u,
      p = i.items,
      m = i.children,
      v = i.direction,
      S = i.id,
      x = i.mode,
      g = x === void 0 ? "vertical" : x,
      _ = i.inlineCollapsed,
      y = i.disabled,
      w = i.disabledOverflow,
      A = i.subMenuOpenDelay,
      M = A === void 0 ? 0.1 : A,
      T = i.subMenuCloseDelay,
      I = T === void 0 ? 0.1 : T,
      R = i.forceSubMenuRender,
      P = i.defaultOpenKeys,
      F = i.openKeys,
      D = i.activeKey,
      j = i.defaultActiveFirst,
      N = i.selectable,
      V = N === void 0 ? !0 : N,
      W = i.multiple,
      Q = W === void 0 ? !1 : W,
      B = i.defaultSelectedKeys,
      $ = i.selectedKeys,
      G = i.onSelect,
      k = i.onDeselect,
      q = i.inlineIndent,
      X = q === void 0 ? 24 : q,
      ee = i.motion,
      J = i.defaultMotions,
      oe = i.triggerSubMenuAction,
      ae = oe === void 0 ? "hover" : oe,
      le = i.builtinPlacements,
      _e = i.itemIcon,
      me = i.expandIcon,
      se = i.overflowedIndicator,
      Y = se === void 0 ? "..." : se,
      ve = i.overflowedIndicatorPopupClassName,
      de = i.getPopupContainer,
      ue = i.onClick,
      fe = i.onOpenChange,
      Te = i.onKeyDown;
    i.openAnimation, i.openTransitionName;
    var pe = i._internalRenderMenuItem,
      H = i._internalRenderSubMenuItem,
      z = on(i, xie),
      Z = E.useMemo(
        function () {
          return yie(m, p, Sd);
        },
        [m, p]
      ),
      ge = E.useState(!1),
      ce = Ve(ge, 2),
      he = ce[0],
      Me = ce[1],
      Re = E.useRef(),
      Le = Yre(S),
      Oe = v === "rtl",
      Pe = ta(P, {
        value: F,
        postState: function (Pt) {
          return Pt || Sd;
        },
      }),
      Se = Ve(Pe, 2),
      Je = Se[0],
      st = Se[1],
      Qe = function (Pt) {
        var Tt =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        function vn() {
          st(Pt), fe == null || fe(Pt);
        }
        Tt ? Cf.flushSync(vn) : vn();
      },
      Ke = E.useState(Je),
      Ne = Ve(Ke, 2),
      ne = Ne[0],
      Ie = Ne[1],
      et = E.useRef(!1),
      We = E.useMemo(
        function () {
          return (g === "inline" || g === "vertical") && _
            ? ["vertical", _]
            : [g, !1];
        },
        [g, _]
      ),
      Ee = Ve(We, 2),
      ie = Ee[0],
      $e = Ee[1],
      He = ie === "inline",
      Xe = E.useState(ie),
      Ue = Ve(Xe, 2),
      Ye = Ue[0],
      ke = Ue[1],
      tt = E.useState($e),
      ut = Ve(tt, 2),
      dt = ut[0],
      Rt = ut[1];
    E.useEffect(
      function () {
        ke(ie), Rt($e), et.current && (He ? st(ne) : Qe(Sd));
      },
      [ie, $e]
    );
    var Bt = E.useState(0),
      In = Ve(Bt, 2),
      dn = In[0],
      _n = In[1],
      gn = dn >= Z.length - 1 || Ye !== "horizontal" || w;
    E.useEffect(
      function () {
        He && Ie(Je);
      },
      [Je]
    ),
      E.useEffect(function () {
        return (
          (et.current = !0),
          function () {
            et.current = !1;
          }
        );
      }, []);
    var Gt = qre(),
      ln = Gt.registerPath,
      Ht = Gt.unregisterPath,
      Dt = Gt.refreshOverflowKeys,
      nn = Gt.isSubPathKey,
      Ln = Gt.getKeyPath,
      te = Gt.getKeys,
      ye = Gt.getSubPathKeys,
      Ae = E.useMemo(
        function () {
          return { registerPath: ln, unregisterPath: Ht };
        },
        [ln, Ht]
      ),
      ze = E.useMemo(
        function () {
          return { isSubPathKey: nn };
        },
        [nn]
      );
    E.useEffect(
      function () {
        Dt(
          gn
            ? Sd
            : Z.slice(dn + 1).map(function (Ut) {
                return Ut.key;
              })
        );
      },
      [dn, gn]
    );
    var Ce = ta(
        D || (j && ((n = Z[0]) === null || n === void 0 ? void 0 : n.key)),
        { value: D }
      ),
      ot = Ve(Ce, 2),
      ht = ot[0],
      xt = ot[1],
      qe = kh(function (Ut) {
        xt(Ut);
      }),
      bt = kh(function () {
        xt(void 0);
      });
    E.useImperativeHandle(e, function () {
      return {
        list: Re.current,
        focus: function (Pt) {
          var Tt,
            vn = te(),
            En = XE(vn, Le),
            bn = En.elements,
            Bn = En.key2element,
            lr = En.element2key,
            Vr = w2(Re.current, bn),
            Ui =
              ht ??
              (Vr[0]
                ? lr.get(Vr[0])
                : (Tt = Z.find(function (Si) {
                    return !Si.props.disabled;
                  })) === null || Tt === void 0
                ? void 0
                : Tt.key),
            ki = Bn.get(Ui);
          if (Ui && ki) {
            var Or;
            ki == null ||
              (Or = ki.focus) === null ||
              Or === void 0 ||
              Or.call(ki, Pt);
          }
        },
      };
    });
    var Lt = ta(B || [], {
        value: $,
        postState: function (Pt) {
          return Array.isArray(Pt) ? Pt : Pt == null ? Sd : [Pt];
        },
      }),
      Mt = Ve(Lt, 2),
      qt = Mt[0],
      On = Mt[1],
      tn = function (Pt) {
        if (V) {
          var Tt = Pt.key,
            vn = qt.includes(Tt),
            En;
          Q
            ? vn
              ? (En = qt.filter(function (Bn) {
                  return Bn !== Tt;
                }))
              : (En = [].concat(It(qt), [Tt]))
            : (En = [Tt]),
            On(En);
          var bn = De(De({}, Pt), {}, { selectedKeys: En });
          vn ? k == null || k(bn) : G == null || G(bn);
        }
        !Q && Je.length && Ye !== "inline" && Qe(Sd);
      },
      cn = kh(function (Ut) {
        ue == null || ue(Iy(Ut)), tn(Ut);
      }),
      St = kh(function (Ut, Pt) {
        var Tt = Je.filter(function (En) {
          return En !== Ut;
        });
        if (Pt) Tt.push(Ut);
        else if (Ye !== "inline") {
          var vn = ye(Ut);
          Tt = Tt.filter(function (En) {
            return !vn.has(En);
          });
        }
        G1(Je, Tt, !0) || Qe(Tt, !0);
      }),
      ct = function (Pt, Tt) {
        var vn = Tt ?? !Je.includes(Pt);
        St(Pt, vn);
      },
      zn = Gre(Ye, ht, Oe, Le, Re, te, Ln, xt, ct, Te);
    E.useEffect(function () {
      Me(!0);
    }, []);
    var Ot = E.useMemo(
        function () {
          return { _internalRenderMenuItem: pe, _internalRenderSubMenuItem: H };
        },
        [pe, H]
      ),
      fn =
        Ye !== "horizontal" || w
          ? Z
          : Z.map(function (Ut, Pt) {
              return E.createElement(
                im,
                { key: Ut.key, overflowDisabled: Pt > dn },
                Ut
              );
            }),
      Xn = E.createElement(
        zs,
        Et(
          {
            id: S,
            ref: Re,
            prefixCls: "".concat(a, "-overflow"),
            component: "ul",
            itemComponent: tx,
            className: nt(
              a,
              "".concat(a, "-root"),
              "".concat(a, "-").concat(Ye),
              c,
              ((r = {}),
              be(r, "".concat(a, "-inline-collapsed"), dt),
              be(r, "".concat(a, "-rtl"), Oe),
              r),
              s
            ),
            dir: v,
            style: l,
            role: "menu",
            tabIndex: d,
            data: fn,
            renderRawItem: function (Pt) {
              return Pt;
            },
            renderRawRest: function (Pt) {
              var Tt = Pt.length,
                vn = Tt ? Z.slice(-Tt) : null;
              return E.createElement(
                T2,
                {
                  eventKey: qE,
                  title: Y,
                  disabled: gn,
                  internalPopupClose: Tt === 0,
                  popupClassName: ve,
                },
                vn
              );
            },
            maxCount: Ye !== "horizontal" || w ? zs.INVALIDATE : zs.RESPONSIVE,
            ssr: "full",
            "data-menu-list": !0,
            onVisibleChange: function (Pt) {
              _n(Pt);
            },
            onKeyDown: zn,
          },
          z
        )
      );
    return E.createElement(
      b2.Provider,
      { value: Ot },
      E.createElement(
        d4.Provider,
        { value: Le },
        E.createElement(
          im,
          {
            prefixCls: a,
            rootClassName: s,
            mode: Ye,
            openKeys: Je,
            rtl: Oe,
            disabled: y,
            motion: he ? ee : null,
            defaultMotions: he ? J : null,
            activeKey: ht,
            onActive: qe,
            onInactive: bt,
            selectedKeys: qt,
            inlineIndent: X,
            subMenuOpenDelay: M,
            subMenuCloseDelay: I,
            forceSubMenuRender: R,
            builtinPlacements: le,
            triggerSubMenuAction: ae,
            getPopupContainer: de,
            itemIcon: _e,
            expandIcon: me,
            onItemClick: cn,
            onOpenChange: St,
          },
          E.createElement(g4.Provider, { value: ze }, Xn),
          E.createElement(
            "div",
            { style: { display: "none" }, "aria-hidden": !0 },
            E.createElement(p4.Provider, { value: Ae }, Z)
          )
        )
      )
    );
  }),
  Fm = Sie;
Fm.Item = tx;
Fm.SubMenu = T2;
Fm.ItemGroup = b4;
Fm.Divider = w4;
var _ie = {
  icon: {
    tag: "svg",
    attrs: { viewBox: "64 64 896 896", focusable: "false" },
    children: [
      {
        tag: "path",
        attrs: {
          d: "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z",
        },
      },
    ],
  },
  name: "ellipsis",
  theme: "outlined",
};
const bie = _ie;
var wie = function (e, n) {
  return E.createElement(cs, Et({}, e, { ref: n, icon: bie }));
};
const Eie = E.forwardRef(wie),
  E4 = E.createContext(null),
  Mie = E4.Provider,
  M4 = E.createContext(null),
  Cie = M4.Provider;
var Tie = [
    "prefixCls",
    "className",
    "style",
    "checked",
    "disabled",
    "defaultChecked",
    "type",
    "title",
    "onChange",
  ],
  Aie = E.forwardRef(function (t, e) {
    var n,
      r = t.prefixCls,
      i = r === void 0 ? "rc-checkbox" : r,
      o = t.className,
      a = t.style,
      s = t.checked,
      l = t.disabled,
      c = t.defaultChecked,
      u = c === void 0 ? !1 : c,
      d = t.type,
      p = d === void 0 ? "checkbox" : d,
      m = t.title,
      v = t.onChange,
      S = on(t, Tie),
      x = E.useRef(null),
      g = ta(u, { value: s }),
      _ = Ve(g, 2),
      y = _[0],
      w = _[1];
    E.useImperativeHandle(e, function () {
      return {
        focus: function () {
          var I;
          (I = x.current) === null || I === void 0 || I.focus();
        },
        blur: function () {
          var I;
          (I = x.current) === null || I === void 0 || I.blur();
        },
        input: x.current,
      };
    });
    var A = nt(
        i,
        o,
        ((n = {}),
        be(n, "".concat(i, "-checked"), y),
        be(n, "".concat(i, "-disabled"), l),
        n)
      ),
      M = function (I) {
        l ||
          ("checked" in t || w(I.target.checked),
          v == null ||
            v({
              target: De(De({}, t), {}, { type: p, checked: I.target.checked }),
              stopPropagation: function () {
                I.stopPropagation();
              },
              preventDefault: function () {
                I.preventDefault();
              },
              nativeEvent: I.nativeEvent,
            }));
      };
    return E.createElement(
      "span",
      { className: A, title: m, style: a },
      E.createElement(
        "input",
        Et({}, S, {
          className: "".concat(i, "-input"),
          ref: x,
          onChange: M,
          disabled: l,
          checked: !!y,
          type: p,
        })
      ),
      E.createElement("span", { className: "".concat(i, "-inner") })
    );
  });
const Rie = (t) => {
    const { componentCls: e, antCls: n } = t,
      r = `${e}-group`;
    return {
      [r]: Object.assign(Object.assign({}, os(t)), {
        display: "inline-block",
        fontSize: 0,
        [`&${r}-rtl`]: { direction: "rtl" },
        [`${n}-badge ${n}-badge-count`]: { zIndex: 1 },
        [`> ${n}-badge:not(:first-child) > ${n}-button-wrapper`]: {
          borderInlineStart: "none",
        },
      }),
    };
  },
  Pie = (t) => {
    const {
        componentCls: e,
        wrapperMarginInlineEnd: n,
        colorPrimary: r,
        radioSize: i,
        motionDurationSlow: o,
        motionDurationMid: a,
        motionEaseInOutCirc: s,
        colorBgContainer: l,
        colorBorder: c,
        lineWidth: u,
        colorBgContainerDisabled: d,
        colorTextDisabled: p,
        paddingXS: m,
        dotColorDisabled: v,
        lineType: S,
        radioColor: x,
        radioBgColor: g,
        calc: _,
      } = t,
      y = `${e}-inner`,
      A = _(i).sub(_(4).mul(2)),
      M = _(1).mul(i).equal();
    return {
      [`${e}-wrapper`]: Object.assign(Object.assign({}, os(t)), {
        display: "inline-flex",
        alignItems: "baseline",
        marginInlineStart: 0,
        marginInlineEnd: n,
        cursor: "pointer",
        [`&${e}-wrapper-rtl`]: { direction: "rtl" },
        "&-disabled": { cursor: "not-allowed", color: t.colorTextDisabled },
        "&::after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: '"\\a0"',
        },
        [`${e}-checked::after`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: "100%",
          height: "100%",
          border: `${Ze(u)} ${S} ${r}`,
          borderRadius: "50%",
          visibility: "hidden",
          content: '""',
        },
        [e]: Object.assign(Object.assign({}, os(t)), {
          position: "relative",
          display: "inline-block",
          outline: "none",
          cursor: "pointer",
          alignSelf: "center",
          borderRadius: "50%",
        }),
        [`${e}-wrapper:hover &,
        &:hover ${y}`]: { borderColor: r },
        [`${e}-input:focus-visible + ${y}`]: Object.assign({}, a2(t)),
        [`${e}:hover::after, ${e}-wrapper:hover &::after`]: {
          visibility: "visible",
        },
        [`${e}-inner`]: {
          "&::after": {
            boxSizing: "border-box",
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineStart: "50%",
            display: "block",
            width: M,
            height: M,
            marginBlockStart: _(1).mul(i).div(-2).equal(),
            marginInlineStart: _(1).mul(i).div(-2).equal(),
            backgroundColor: x,
            borderBlockStart: 0,
            borderInlineStart: 0,
            borderRadius: M,
            transform: "scale(0)",
            opacity: 0,
            transition: `all ${o} ${s}`,
            content: '""',
          },
          boxSizing: "border-box",
          position: "relative",
          insetBlockStart: 0,
          insetInlineStart: 0,
          display: "block",
          width: M,
          height: M,
          backgroundColor: l,
          borderColor: c,
          borderStyle: "solid",
          borderWidth: u,
          borderRadius: "50%",
          transition: `all ${a}`,
        },
        [`${e}-input`]: {
          position: "absolute",
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0,
        },
        [`${e}-checked`]: {
          [y]: {
            borderColor: r,
            backgroundColor: g,
            "&::after": {
              transform: `scale(${t.calc(t.dotSize).div(i).equal()})`,
              opacity: 1,
              transition: `all ${o} ${s}`,
            },
          },
        },
        [`${e}-disabled`]: {
          cursor: "not-allowed",
          [y]: {
            backgroundColor: d,
            borderColor: c,
            cursor: "not-allowed",
            "&::after": { backgroundColor: v },
          },
          [`${e}-input`]: { cursor: "not-allowed" },
          [`${e}-disabled + span`]: { color: p, cursor: "not-allowed" },
          [`&${e}-checked`]: {
            [y]: {
              "&::after": {
                transform: `scale(${_(A).div(i).equal({ unit: !1 })})`,
              },
            },
          },
        },
        [`span${e} + *`]: { paddingInlineStart: m, paddingInlineEnd: m },
      }),
    };
  },
  Iie = (t) => {
    const {
      buttonColor: e,
      controlHeight: n,
      componentCls: r,
      lineWidth: i,
      lineType: o,
      colorBorder: a,
      motionDurationSlow: s,
      motionDurationMid: l,
      buttonPaddingInline: c,
      fontSize: u,
      buttonBg: d,
      fontSizeLG: p,
      controlHeightLG: m,
      controlHeightSM: v,
      paddingXS: S,
      borderRadius: x,
      borderRadiusSM: g,
      borderRadiusLG: _,
      buttonCheckedBg: y,
      buttonSolidCheckedColor: w,
      colorTextDisabled: A,
      colorBgContainerDisabled: M,
      buttonCheckedBgDisabled: T,
      buttonCheckedColorDisabled: I,
      colorPrimary: R,
      colorPrimaryHover: P,
      colorPrimaryActive: F,
      buttonSolidCheckedBg: D,
      buttonSolidCheckedHoverBg: j,
      buttonSolidCheckedActiveBg: N,
      calc: V,
    } = t;
    return {
      [`${r}-button-wrapper`]: {
        position: "relative",
        display: "inline-block",
        height: n,
        margin: 0,
        paddingInline: c,
        paddingBlock: 0,
        color: e,
        fontSize: u,
        lineHeight: Ze(V(n).sub(V(i).mul(2)).equal()),
        background: d,
        border: `${Ze(i)} ${o} ${a}`,
        borderBlockStartWidth: V(i).add(0.02).equal(),
        borderInlineStartWidth: 0,
        borderInlineEndWidth: i,
        cursor: "pointer",
        transition: [`color ${l}`, `background ${l}`, `box-shadow ${l}`].join(
          ","
        ),
        a: { color: e },
        [`> ${r}-button`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          zIndex: -1,
          width: "100%",
          height: "100%",
        },
        "&:not(:first-child)": {
          "&::before": {
            position: "absolute",
            insetBlockStart: V(i).mul(-1).equal(),
            insetInlineStart: V(i).mul(-1).equal(),
            display: "block",
            boxSizing: "content-box",
            width: 1,
            height: "100%",
            paddingBlock: i,
            paddingInline: 0,
            backgroundColor: a,
            transition: `background-color ${s}`,
            content: '""',
          },
        },
        "&:first-child": {
          borderInlineStart: `${Ze(i)} ${o} ${a}`,
          borderStartStartRadius: x,
          borderEndStartRadius: x,
        },
        "&:last-child": { borderStartEndRadius: x, borderEndEndRadius: x },
        "&:first-child:last-child": { borderRadius: x },
        [`${r}-group-large &`]: {
          height: m,
          fontSize: p,
          lineHeight: Ze(V(m).sub(V(i).mul(2)).equal()),
          "&:first-child": {
            borderStartStartRadius: _,
            borderEndStartRadius: _,
          },
          "&:last-child": { borderStartEndRadius: _, borderEndEndRadius: _ },
        },
        [`${r}-group-small &`]: {
          height: v,
          paddingInline: V(S).sub(i).equal(),
          paddingBlock: 0,
          lineHeight: Ze(V(v).sub(V(i).mul(2)).equal()),
          "&:first-child": {
            borderStartStartRadius: g,
            borderEndStartRadius: g,
          },
          "&:last-child": { borderStartEndRadius: g, borderEndEndRadius: g },
        },
        "&:hover": { position: "relative", color: R },
        "&:has(:focus-visible)": Object.assign({}, a2(t)),
        [`${r}-inner, input[type='checkbox'], input[type='radio']`]: {
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none",
        },
        [`&-checked:not(${r}-button-wrapper-disabled)`]: {
          zIndex: 1,
          color: R,
          background: y,
          borderColor: R,
          "&::before": { backgroundColor: R },
          "&:first-child": { borderColor: R },
          "&:hover": {
            color: P,
            borderColor: P,
            "&::before": { backgroundColor: P },
          },
          "&:active": {
            color: F,
            borderColor: F,
            "&::before": { backgroundColor: F },
          },
        },
        [`${r}-group-solid &-checked:not(${r}-button-wrapper-disabled)`]: {
          color: w,
          background: D,
          borderColor: D,
          "&:hover": { color: w, background: j, borderColor: j },
          "&:active": { color: w, background: N, borderColor: N },
        },
        "&-disabled": {
          color: A,
          backgroundColor: M,
          borderColor: a,
          cursor: "not-allowed",
          "&:first-child, &:hover": {
            color: A,
            backgroundColor: M,
            borderColor: a,
          },
        },
        [`&-disabled${r}-button-wrapper-checked`]: {
          color: I,
          backgroundColor: T,
          borderColor: a,
          boxShadow: "none",
        },
      },
    };
  },
  Lie = (t) => {
    const {
        wireframe: e,
        padding: n,
        marginXS: r,
        lineWidth: i,
        fontSizeLG: o,
        colorText: a,
        colorBgContainer: s,
        colorTextDisabled: l,
        controlItemBgActiveDisabled: c,
        colorTextLightSolid: u,
        colorPrimary: d,
        colorPrimaryHover: p,
        colorPrimaryActive: m,
        colorWhite: v,
      } = t,
      S = 4,
      x = o,
      g = e ? x - S * 2 : x - (S + i) * 2;
    return {
      radioSize: x,
      dotSize: g,
      dotColorDisabled: l,
      buttonSolidCheckedColor: u,
      buttonSolidCheckedBg: d,
      buttonSolidCheckedHoverBg: p,
      buttonSolidCheckedActiveBg: m,
      buttonBg: s,
      buttonCheckedBg: s,
      buttonColor: a,
      buttonCheckedBgDisabled: c,
      buttonCheckedColorDisabled: l,
      buttonPaddingInline: n - i,
      wrapperMarginInlineEnd: r,
      radioColor: e ? d : v,
      radioBgColor: e ? s : d,
    };
  },
  C4 = ec(
    "Radio",
    (t) => {
      const { controlOutline: e, controlOutlineWidth: n } = t,
        r = `0 0 0 ${Ze(n)} ${e}`,
        o = xi(t, { radioFocusShadow: r, radioButtonFocusShadow: r });
      return [Rie(o), Pie(o), Iie(o)];
    },
    Lie,
    { unitless: { radioSize: !0, dotSize: !0 } }
  );
var Oie = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const Nie = (t, e) => {
    var n, r;
    const i = E.useContext(E4),
      o = E.useContext(M4),
      { getPrefixCls: a, direction: s, radio: l } = E.useContext(Rn),
      c = E.useRef(null),
      u = ls(e, c),
      { isFormItemInput: d } = E.useContext(mu),
      p = (N) => {
        var V, W;
        (V = t.onChange) === null || V === void 0 || V.call(t, N),
          (W = i == null ? void 0 : i.onChange) === null ||
            W === void 0 ||
            W.call(i, N);
      },
      {
        prefixCls: m,
        className: v,
        rootClassName: S,
        children: x,
        style: g,
        title: _,
      } = t,
      y = Oie(t, [
        "prefixCls",
        "className",
        "rootClassName",
        "children",
        "style",
        "title",
      ]),
      w = a("radio", m),
      A = ((i == null ? void 0 : i.optionType) || o) === "button",
      M = A ? `${w}-button` : w,
      T = Rm(w),
      [I, R, P] = C4(w, T),
      F = Object.assign({}, y),
      D = E.useContext(Cm);
    i &&
      ((F.name = i.name),
      (F.onChange = p),
      (F.checked = t.value === i.value),
      (F.disabled =
        (n = F.disabled) !== null && n !== void 0 ? n : i.disabled)),
      (F.disabled = (r = F.disabled) !== null && r !== void 0 ? r : D);
    const j = nt(
      `${M}-wrapper`,
      {
        [`${M}-wrapper-checked`]: F.checked,
        [`${M}-wrapper-disabled`]: F.disabled,
        [`${M}-wrapper-rtl`]: s === "rtl",
        [`${M}-wrapper-in-form-item`]: d,
      },
      l == null ? void 0 : l.className,
      v,
      S,
      R,
      P,
      T
    );
    return I(
      E.createElement(
        Fk,
        { component: "Radio", disabled: F.disabled },
        E.createElement(
          "label",
          {
            className: j,
            style: Object.assign(
              Object.assign({}, l == null ? void 0 : l.style),
              g
            ),
            onMouseEnter: t.onMouseEnter,
            onMouseLeave: t.onMouseLeave,
            title: _,
          },
          E.createElement(
            Aie,
            Object.assign({}, F, {
              className: nt(F.className, !A && m2),
              type: "radio",
              prefixCls: M,
              ref: u,
            })
          ),
          x !== void 0 ? E.createElement("span", null, x) : null
        )
      )
    );
  },
  Fie = E.forwardRef(Nie),
  Ly = Fie,
  Die = E.forwardRef((t, e) => {
    const { getPrefixCls: n, direction: r } = E.useContext(Rn),
      [i, o] = ta(t.defaultValue, { value: t.value }),
      a = (N) => {
        const V = i,
          W = N.target.value;
        "value" in t || o(W);
        const { onChange: Q } = t;
        Q && W !== V && Q(N);
      },
      {
        prefixCls: s,
        className: l,
        rootClassName: c,
        options: u,
        buttonStyle: d = "outline",
        disabled: p,
        children: m,
        size: v,
        style: S,
        id: x,
        onMouseEnter: g,
        onMouseLeave: _,
        onFocus: y,
        onBlur: w,
      } = t,
      A = n("radio", s),
      M = `${A}-group`,
      T = Rm(A),
      [I, R, P] = C4(A, T);
    let F = m;
    u &&
      u.length > 0 &&
      (F = u.map((N) =>
        typeof N == "string" || typeof N == "number"
          ? E.createElement(
              Ly,
              {
                key: N.toString(),
                prefixCls: A,
                disabled: p,
                value: N,
                checked: i === N,
              },
              N
            )
          : E.createElement(
              Ly,
              {
                key: `radio-group-value-options-${N.value}`,
                prefixCls: A,
                disabled: N.disabled || p,
                value: N.value,
                checked: i === N.value,
                title: N.title,
                style: N.style,
                id: N.id,
                required: N.required,
              },
              N.label
            )
      ));
    const D = Tu(v),
      j = nt(
        M,
        `${M}-${d}`,
        { [`${M}-${D}`]: D, [`${M}-rtl`]: r === "rtl" },
        l,
        c,
        R,
        P,
        T
      );
    return I(
      E.createElement(
        "div",
        Object.assign({}, YJ(t, { aria: !0, data: !0 }), {
          className: j,
          style: S,
          onMouseEnter: g,
          onMouseLeave: _,
          onFocus: y,
          onBlur: w,
          id: x,
          ref: e,
        }),
        E.createElement(
          Mie,
          {
            value: {
              onChange: a,
              value: i,
              disabled: t.disabled,
              name: t.name,
              optionType: t.optionType,
            },
          },
          F
        )
      )
    );
  }),
  zie = E.memo(Die);
var Uie = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const kie = (t, e) => {
    const { getPrefixCls: n } = E.useContext(Rn),
      { prefixCls: r } = t,
      i = Uie(t, ["prefixCls"]),
      o = n("radio", r);
    return E.createElement(
      Cie,
      { value: "button" },
      E.createElement(
        Ly,
        Object.assign({ prefixCls: o }, i, { type: "radio", ref: e })
      )
    );
  },
  Bie = E.forwardRef(kie),
  nx = Ly;
nx.Button = Bie;
nx.Group = zie;
nx.__ANT_RADIO = !0;
const Ih = nx;
function Hie(t) {
  return xi(t, { inputAffixPadding: t.paddingXXS });
}
const jie = (t) => {
    const {
      controlHeight: e,
      fontSize: n,
      lineHeight: r,
      lineWidth: i,
      controlHeightSM: o,
      controlHeightLG: a,
      fontSizeLG: s,
      lineHeightLG: l,
      paddingSM: c,
      controlPaddingHorizontalSM: u,
      controlPaddingHorizontal: d,
      colorFillAlter: p,
      colorPrimaryHover: m,
      colorPrimary: v,
      controlOutlineWidth: S,
      controlOutline: x,
      colorErrorOutline: g,
      colorWarningOutline: _,
      colorBgContainer: y,
    } = t;
    return {
      paddingBlock: Math.max(Math.round(((e - n * r) / 2) * 10) / 10 - i, 0),
      paddingBlockSM: Math.max(Math.round(((o - n * r) / 2) * 10) / 10 - i, 0),
      paddingBlockLG: Math.ceil(((a - s * l) / 2) * 10) / 10 - i,
      paddingInline: c - i,
      paddingInlineSM: u - i,
      paddingInlineLG: d - i,
      addonBg: p,
      activeBorderColor: v,
      hoverBorderColor: m,
      activeShadow: `0 0 0 ${S}px ${x}`,
      errorActiveShadow: `0 0 0 ${S}px ${g}`,
      warningActiveShadow: `0 0 0 ${S}px ${_}`,
      hoverBg: y,
      activeBg: y,
      inputFontSize: n,
      inputFontSizeLG: s,
      inputFontSizeSM: n,
    };
  },
  Vie = (t) => ({
    borderColor: t.hoverBorderColor,
    backgroundColor: t.hoverBg,
  }),
  A2 = (t) => ({
    color: t.colorTextDisabled,
    backgroundColor: t.colorBgContainerDisabled,
    borderColor: t.colorBorder,
    boxShadow: "none",
    cursor: "not-allowed",
    opacity: 1,
    "&:hover:not([disabled])": Object.assign(
      {},
      Vie(
        xi(t, {
          hoverBorderColor: t.colorBorder,
          hoverBg: t.colorBgContainerDisabled,
        })
      )
    ),
  }),
  T4 = (t, e) => ({
    background: t.colorBgContainer,
    borderWidth: t.lineWidth,
    borderStyle: t.lineType,
    borderColor: e.borderColor,
    "&:hover": { borderColor: e.hoverBorderColor, backgroundColor: t.hoverBg },
    "&:focus, &:focus-within": {
      borderColor: e.activeBorderColor,
      boxShadow: e.activeShadow,
      outline: 0,
      backgroundColor: t.activeBg,
    },
  }),
  fL = (t, e) => ({
    [`&${t.componentCls}-status-${e.status}:not(${t.componentCls}-disabled)`]:
      Object.assign(Object.assign({}, T4(t, e)), {
        [`${t.componentCls}-prefix, ${t.componentCls}-suffix`]: {
          color: e.affixColor,
        },
      }),
  }),
  $ie = (t, e) => ({
    "&-outlined": Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {},
              T4(t, {
                borderColor: t.colorBorder,
                hoverBorderColor: t.colorPrimaryHover,
                activeBorderColor: t.colorPrimary,
                activeShadow: t.activeShadow,
              })
            ),
            {
              [`&${t.componentCls}-disabled, &[disabled]`]: Object.assign(
                {},
                A2(t)
              ),
            }
          ),
          fL(t, {
            status: "error",
            borderColor: t.colorError,
            hoverBorderColor: t.colorErrorBorderHover,
            activeBorderColor: t.colorError,
            activeShadow: t.errorActiveShadow,
            affixColor: t.colorError,
          })
        ),
        fL(t, {
          status: "warning",
          borderColor: t.colorWarning,
          hoverBorderColor: t.colorWarningBorderHover,
          activeBorderColor: t.colorWarning,
          activeShadow: t.warningActiveShadow,
          affixColor: t.colorWarning,
        })
      ),
      e
    ),
  }),
  hL = (t, e) => ({
    [`&${t.componentCls}-group-wrapper-status-${e.status}`]: {
      [`${t.componentCls}-group-addon`]: {
        borderColor: e.addonBorderColor,
        color: e.addonColor,
      },
    },
  }),
  Gie = (t) => ({
    "&-outlined": Object.assign(
      Object.assign(
        Object.assign(
          {
            [`${t.componentCls}-group`]: {
              "&-addon": {
                background: t.addonBg,
                border: `${Ze(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
              },
              "&-addon:first-child": { borderInlineEnd: 0 },
              "&-addon:last-child": { borderInlineStart: 0 },
            },
          },
          hL(t, {
            status: "error",
            addonBorderColor: t.colorError,
            addonColor: t.colorErrorText,
          })
        ),
        hL(t, {
          status: "warning",
          addonBorderColor: t.colorWarning,
          addonColor: t.colorWarningText,
        })
      ),
      {
        [`&${t.componentCls}-group-wrapper-disabled`]: {
          [`${t.componentCls}-group-addon`]: Object.assign({}, A2(t)),
        },
      }
    ),
  }),
  Wie = (t, e) => ({
    "&-borderless": Object.assign(
      {
        background: "transparent",
        border: "none",
        "&:focus, &:focus-within": { outline: "none" },
        [`&${t.componentCls}-disabled, &[disabled]`]: {
          color: t.colorTextDisabled,
        },
      },
      e
    ),
  }),
  A4 = (t, e) => ({
    background: e.bg,
    borderWidth: t.lineWidth,
    borderStyle: t.lineType,
    borderColor: "transparent",
    "input&, & input, textarea&, & textarea": {
      color: e == null ? void 0 : e.inputColor,
    },
    "&:hover": { background: e.hoverBg },
    "&:focus, &:focus-within": {
      outline: 0,
      borderColor: e.activeBorderColor,
      backgroundColor: t.activeBg,
    },
  }),
  pL = (t, e) => ({
    [`&${t.componentCls}-status-${e.status}:not(${t.componentCls}-disabled)`]:
      Object.assign(Object.assign({}, A4(t, e)), {
        [`${t.componentCls}-prefix, ${t.componentCls}-suffix`]: {
          color: e.affixColor,
        },
      }),
  }),
  Xie = (t, e) => ({
    "&-filled": Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {},
              A4(t, {
                bg: t.colorFillTertiary,
                hoverBg: t.colorFillSecondary,
                activeBorderColor: t.colorPrimary,
              })
            ),
            {
              [`&${t.componentCls}-disabled, &[disabled]`]: Object.assign(
                {},
                A2(t)
              ),
            }
          ),
          pL(t, {
            status: "error",
            bg: t.colorErrorBg,
            hoverBg: t.colorErrorBgHover,
            activeBorderColor: t.colorError,
            inputColor: t.colorErrorText,
            affixColor: t.colorError,
          })
        ),
        pL(t, {
          status: "warning",
          bg: t.colorWarningBg,
          hoverBg: t.colorWarningBgHover,
          activeBorderColor: t.colorWarning,
          inputColor: t.colorWarningText,
          affixColor: t.colorWarning,
        })
      ),
      e
    ),
  }),
  mL = (t, e) => ({
    [`&${t.componentCls}-group-wrapper-status-${e.status}`]: {
      [`${t.componentCls}-group-addon`]: {
        background: e.addonBg,
        color: e.addonColor,
      },
    },
  }),
  qie = (t) => ({
    "&-filled": Object.assign(
      Object.assign(
        Object.assign(
          {
            [`${t.componentCls}-group`]: {
              "&-addon": { background: t.colorFillTertiary },
              [`${t.componentCls}-filled:not(:focus):not(:focus-within)`]: {
                "&:not(:first-child)": {
                  borderInlineStart: `${Ze(t.lineWidth)} ${t.lineType} ${
                    t.colorSplit
                  }`,
                },
                "&:not(:last-child)": {
                  borderInlineEnd: `${Ze(t.lineWidth)} ${t.lineType} ${
                    t.colorSplit
                  }`,
                },
              },
            },
          },
          mL(t, {
            status: "error",
            addonBg: t.colorErrorBg,
            addonColor: t.colorErrorText,
          })
        ),
        mL(t, {
          status: "warning",
          addonBg: t.colorWarningBg,
          addonColor: t.colorWarningText,
        })
      ),
      {
        [`&${t.componentCls}-group-wrapper-disabled`]: {
          [`${t.componentCls}-group`]: {
            "&-addon": {
              background: t.colorFillTertiary,
              color: t.colorTextDisabled,
            },
            "&-addon:first-child": {
              borderInlineStart: `${Ze(t.lineWidth)} ${t.lineType} ${
                t.colorBorder
              }`,
              borderTop: `${Ze(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
              borderBottom: `${Ze(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
            },
            "&-addon:last-child": {
              borderInlineEnd: `${Ze(t.lineWidth)} ${t.lineType} ${
                t.colorBorder
              }`,
              borderTop: `${Ze(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
              borderBottom: `${Ze(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
            },
          },
        },
      }
    ),
  }),
  Kie = (t) => ({
    "&::-moz-placeholder": { opacity: 1 },
    "&::placeholder": { color: t, userSelect: "none" },
    "&:placeholder-shown": { textOverflow: "ellipsis" },
  }),
  R4 = (t) => {
    const {
      paddingBlockLG: e,
      lineHeightLG: n,
      borderRadiusLG: r,
      paddingInlineLG: i,
    } = t;
    return {
      padding: `${Ze(e)} ${Ze(i)}`,
      fontSize: t.inputFontSizeLG,
      lineHeight: n,
      borderRadius: r,
    };
  },
  P4 = (t) => ({
    padding: `${Ze(t.paddingBlockSM)} ${Ze(t.paddingInlineSM)}`,
    fontSize: t.inputFontSizeSM,
    borderRadius: t.borderRadiusSM,
  }),
  I4 = (t) =>
    Object.assign(
      Object.assign(
        {
          position: "relative",
          display: "inline-block",
          width: "100%",
          minWidth: 0,
          padding: `${Ze(t.paddingBlock)} ${Ze(t.paddingInline)}`,
          color: t.colorText,
          fontSize: t.inputFontSize,
          lineHeight: t.lineHeight,
          borderRadius: t.borderRadius,
          transition: `all ${t.motionDurationMid}`,
        },
        Kie(t.colorTextPlaceholder)
      ),
      {
        "textarea&": {
          maxWidth: "100%",
          height: "auto",
          minHeight: t.controlHeight,
          lineHeight: t.lineHeight,
          verticalAlign: "bottom",
          transition: `all ${t.motionDurationSlow}, height 0s`,
          resize: "vertical",
        },
        "&-lg": Object.assign({}, R4(t)),
        "&-sm": Object.assign({}, P4(t)),
        "&-rtl": { direction: "rtl" },
        "&-textarea-rtl": { direction: "rtl" },
      }
    ),
  Yie = (t) => {
    const { componentCls: e, antCls: n } = t;
    return {
      position: "relative",
      display: "table",
      width: "100%",
      borderCollapse: "separate",
      borderSpacing: 0,
      "&[class*='col-']": {
        paddingInlineEnd: t.paddingXS,
        "&:last-child": { paddingInlineEnd: 0 },
      },
      [`&-lg ${e}, &-lg > ${e}-group-addon`]: Object.assign({}, R4(t)),
      [`&-sm ${e}, &-sm > ${e}-group-addon`]: Object.assign({}, P4(t)),
      [`&-lg ${n}-select-single ${n}-select-selector`]: {
        height: t.controlHeightLG,
      },
      [`&-sm ${n}-select-single ${n}-select-selector`]: {
        height: t.controlHeightSM,
      },
      [`> ${e}`]: {
        display: "table-cell",
        "&:not(:first-child):not(:last-child)": { borderRadius: 0 },
      },
      [`${e}-group`]: {
        "&-addon, &-wrap": {
          display: "table-cell",
          width: 1,
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          "&:not(:first-child):not(:last-child)": { borderRadius: 0 },
        },
        "&-wrap > *": { display: "block !important" },
        "&-addon": {
          position: "relative",
          padding: `0 ${Ze(t.paddingInline)}`,
          color: t.colorText,
          fontWeight: "normal",
          fontSize: t.inputFontSize,
          textAlign: "center",
          borderRadius: t.borderRadius,
          transition: `all ${t.motionDurationSlow}`,
          lineHeight: 1,
          [`${n}-select`]: {
            margin: `${Ze(t.calc(t.paddingBlock).add(1).mul(-1).equal())} ${Ze(
              t.calc(t.paddingInline).mul(-1).equal()
            )}`,
            [`&${n}-select-single:not(${n}-select-customize-input):not(${n}-pagination-size-changer)`]:
              {
                [`${n}-select-selector`]: {
                  backgroundColor: "inherit",
                  border: `${Ze(t.lineWidth)} ${t.lineType} transparent`,
                  boxShadow: "none",
                },
              },
            "&-open, &-focused": {
              [`${n}-select-selector`]: { color: t.colorPrimary },
            },
          },
          [`${n}-cascader-picker`]: {
            margin: `-9px ${Ze(t.calc(t.paddingInline).mul(-1).equal())}`,
            backgroundColor: "transparent",
            [`${n}-cascader-input`]: {
              textAlign: "start",
              border: 0,
              boxShadow: "none",
            },
          },
        },
      },
      [`${e}`]: {
        width: "100%",
        marginBottom: 0,
        textAlign: "inherit",
        "&:focus": { zIndex: 1, borderInlineEndWidth: 1 },
        "&:hover": {
          zIndex: 1,
          borderInlineEndWidth: 1,
          [`${e}-search-with-button &`]: { zIndex: 0 },
        },
      },
      [`> ${e}:first-child, ${e}-group-addon:first-child`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${n}-select ${n}-select-selector`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
        },
      },
      [`> ${e}-affix-wrapper`]: {
        [`&:not(:first-child) ${e}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
        },
        [`&:not(:last-child) ${e}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
        },
      },
      [`> ${e}:last-child, ${e}-group-addon:last-child`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
        [`${n}-select ${n}-select-selector`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
        },
      },
      [`${e}-affix-wrapper`]: {
        "&:not(:last-child)": {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          [`${e}-search &`]: {
            borderStartStartRadius: t.borderRadius,
            borderEndStartRadius: t.borderRadius,
          },
        },
        [`&:not(:first-child), ${e}-search &:not(:first-child)`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
        },
      },
      [`&${e}-group-compact`]: Object.assign(
        Object.assign({ display: "block" }, Tm()),
        {
          [`${e}-group-addon, ${e}-group-wrap, > ${e}`]: {
            "&:not(:first-child):not(:last-child)": {
              borderInlineEndWidth: t.lineWidth,
              "&:hover": { zIndex: 1 },
              "&:focus": { zIndex: 1 },
            },
          },
          "& > *": {
            display: "inline-block",
            float: "none",
            verticalAlign: "top",
            borderRadius: 0,
          },
          [`
        & > ${e}-affix-wrapper,
        & > ${e}-number-affix-wrapper,
        & > ${n}-picker-range
      `]: { display: "inline-flex" },
          "& > *:not(:last-child)": {
            marginInlineEnd: t.calc(t.lineWidth).mul(-1).equal(),
            borderInlineEndWidth: t.lineWidth,
          },
          [`${e}`]: { float: "none" },
          [`& > ${n}-select > ${n}-select-selector,
      & > ${n}-select-auto-complete ${e},
      & > ${n}-cascader-picker ${e},
      & > ${e}-group-wrapper ${e}`]: {
            borderInlineEndWidth: t.lineWidth,
            borderRadius: 0,
            "&:hover": { zIndex: 1 },
            "&:focus": { zIndex: 1 },
          },
          [`& > ${n}-select-focused`]: { zIndex: 1 },
          [`& > ${n}-select > ${n}-select-arrow`]: { zIndex: 1 },
          [`& > *:first-child,
      & > ${n}-select:first-child > ${n}-select-selector,
      & > ${n}-select-auto-complete:first-child ${e},
      & > ${n}-cascader-picker:first-child ${e}`]: {
            borderStartStartRadius: t.borderRadius,
            borderEndStartRadius: t.borderRadius,
          },
          [`& > *:last-child,
      & > ${n}-select:last-child > ${n}-select-selector,
      & > ${n}-cascader-picker:last-child ${e},
      & > ${n}-cascader-picker-focused:last-child ${e}`]: {
            borderInlineEndWidth: t.lineWidth,
            borderStartEndRadius: t.borderRadius,
            borderEndEndRadius: t.borderRadius,
          },
          [`& > ${n}-select-auto-complete ${e}`]: { verticalAlign: "top" },
          [`${e}-group-wrapper + ${e}-group-wrapper`]: {
            marginInlineStart: t.calc(t.lineWidth).mul(-1).equal(),
            [`${e}-affix-wrapper`]: { borderRadius: 0 },
          },
          [`${e}-group-wrapper:not(:last-child)`]: {
            [`&${e}-search > ${e}-group`]: {
              [`& > ${e}-group-addon > ${e}-search-button`]: {
                borderRadius: 0,
              },
              [`& > ${e}`]: {
                borderStartStartRadius: t.borderRadius,
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
                borderEndStartRadius: t.borderRadius,
              },
            },
          },
        }
      ),
    };
  },
  Zie = (t) => {
    const { componentCls: e, controlHeightSM: n, lineWidth: r, calc: i } = t,
      a = i(n).sub(i(r).mul(2)).sub(16).div(2).equal();
    return {
      [e]: Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(Object.assign({}, os(t)), I4(t)),
              $ie(t)
            ),
            Xie(t)
          ),
          Wie(t)
        ),
        {
          '&[type="color"]': {
            height: t.controlHeight,
            [`&${e}-lg`]: { height: t.controlHeightLG },
            [`&${e}-sm`]: { height: n, paddingTop: a, paddingBottom: a },
          },
          '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration':
            { "-webkit-appearance": "none" },
        }
      ),
    };
  },
  Qie = (t) => {
    const { componentCls: e } = t;
    return {
      [`${e}-clear-icon`]: {
        margin: 0,
        color: t.colorTextQuaternary,
        fontSize: t.fontSizeIcon,
        verticalAlign: -1,
        cursor: "pointer",
        transition: `color ${t.motionDurationSlow}`,
        "&:hover": { color: t.colorTextTertiary },
        "&:active": { color: t.colorText },
        "&-hidden": { visibility: "hidden" },
        "&-has-suffix": { margin: `0 ${Ze(t.inputAffixPadding)}` },
      },
    };
  },
  Jie = (t) => {
    const {
      componentCls: e,
      inputAffixPadding: n,
      colorTextDescription: r,
      motionDurationSlow: i,
      colorIcon: o,
      colorIconHover: a,
      iconCls: s,
    } = t;
    return {
      [`${e}-affix-wrapper`]: Object.assign(
        Object.assign(
          Object.assign(Object.assign({}, I4(t)), {
            display: "inline-flex",
            [`&:not(${e}-disabled):hover`]: {
              zIndex: 1,
              [`${e}-search-with-button &`]: { zIndex: 0 },
            },
            "&-focused, &:focus": { zIndex: 1 },
            [`> input${e}`]: {
              padding: 0,
              fontSize: "inherit",
              border: "none",
              borderRadius: 0,
              outline: "none",
              background: "transparent",
              color: "inherit",
              "&::-ms-reveal": { display: "none" },
              "&:focus": { boxShadow: "none !important" },
            },
            "&::before": {
              display: "inline-block",
              width: 0,
              visibility: "hidden",
              content: '"\\a0"',
            },
            [`${e}`]: {
              "&-prefix, &-suffix": {
                display: "flex",
                flex: "none",
                alignItems: "center",
                "> *:not(:last-child)": { marginInlineEnd: t.paddingXS },
              },
              "&-show-count-suffix": { color: r },
              "&-show-count-has-suffix": { marginInlineEnd: t.paddingXXS },
              "&-prefix": { marginInlineEnd: n },
              "&-suffix": { marginInlineStart: n },
            },
          }),
          Qie(t)
        ),
        {
          [`${s}${e}-password-icon`]: {
            color: o,
            cursor: "pointer",
            transition: `all ${i}`,
            "&:hover": { color: a },
          },
        }
      ),
    };
  },
  eoe = (t) => {
    const { componentCls: e, borderRadiusLG: n, borderRadiusSM: r } = t;
    return {
      [`${e}-group`]: Object.assign(
        Object.assign(Object.assign({}, os(t)), Yie(t)),
        {
          "&-rtl": { direction: "rtl" },
          "&-wrapper": Object.assign(
            Object.assign(
              Object.assign(
                {
                  display: "inline-block",
                  width: "100%",
                  textAlign: "start",
                  verticalAlign: "top",
                  "&-rtl": { direction: "rtl" },
                  "&-lg": {
                    [`${e}-group-addon`]: {
                      borderRadius: n,
                      fontSize: t.inputFontSizeLG,
                    },
                  },
                  "&-sm": { [`${e}-group-addon`]: { borderRadius: r } },
                },
                Gie(t)
              ),
              qie(t)
            ),
            {
              [`&:not(${e}-compact-first-item):not(${e}-compact-last-item)${e}-compact-item`]:
                { [`${e}, ${e}-group-addon`]: { borderRadius: 0 } },
              [`&:not(${e}-compact-last-item)${e}-compact-first-item`]: {
                [`${e}, ${e}-group-addon`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0,
                },
              },
              [`&:not(${e}-compact-first-item)${e}-compact-last-item`]: {
                [`${e}, ${e}-group-addon`]: {
                  borderStartStartRadius: 0,
                  borderEndStartRadius: 0,
                },
              },
              [`&:not(${e}-compact-last-item)${e}-compact-item`]: {
                [`${e}-affix-wrapper`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0,
                },
              },
            }
          ),
        }
      ),
    };
  },
  toe = (t) => {
    const { componentCls: e, antCls: n } = t,
      r = `${e}-search`;
    return {
      [r]: {
        [`${e}`]: {
          "&:hover, &:focus": {
            borderColor: t.colorPrimaryHover,
            [`+ ${e}-group-addon ${r}-button:not(${n}-btn-primary)`]: {
              borderInlineStartColor: t.colorPrimaryHover,
            },
          },
        },
        [`${e}-affix-wrapper`]: { borderRadius: 0 },
        [`${e}-lg`]: {
          lineHeight: t.calc(t.lineHeightLG).sub(2e-4).equal({ unit: !1 }),
        },
        [`> ${e}-group`]: {
          [`> ${e}-group-addon:last-child`]: {
            insetInlineStart: -1,
            padding: 0,
            border: 0,
            [`${r}-button`]: {
              marginInlineEnd: -1,
              paddingTop: 0,
              paddingBottom: 0,
              borderStartStartRadius: 0,
              borderStartEndRadius: t.borderRadius,
              borderEndEndRadius: t.borderRadius,
              borderEndStartRadius: 0,
              boxShadow: "none",
            },
            [`${r}-button:not(${n}-btn-primary)`]: {
              color: t.colorTextDescription,
              "&:hover": { color: t.colorPrimaryHover },
              "&:active": { color: t.colorPrimaryActive },
              [`&${n}-btn-loading::before`]: {
                insetInlineStart: 0,
                insetInlineEnd: 0,
                insetBlockStart: 0,
                insetBlockEnd: 0,
              },
            },
          },
        },
        [`${r}-button`]: {
          height: t.controlHeight,
          "&:hover, &:focus": { zIndex: 1 },
        },
        [`&-large ${r}-button`]: { height: t.controlHeightLG },
        [`&-small ${r}-button`]: { height: t.controlHeightSM },
        "&-rtl": { direction: "rtl" },
        [`&${e}-compact-item`]: {
          [`&:not(${e}-compact-last-item)`]: {
            [`${e}-group-addon`]: {
              [`${e}-search-button`]: {
                marginInlineEnd: t.calc(t.lineWidth).mul(-1).equal(),
                borderRadius: 0,
              },
            },
          },
          [`&:not(${e}-compact-first-item)`]: {
            [`${e},${e}-affix-wrapper`]: { borderRadius: 0 },
          },
          [`> ${e}-group-addon ${e}-search-button,
        > ${e},
        ${e}-affix-wrapper`]: { "&:hover,&:focus,&:active": { zIndex: 2 } },
          [`> ${e}-affix-wrapper-focused`]: { zIndex: 2 },
        },
      },
    };
  },
  noe = (t) => {
    const { componentCls: e, paddingLG: n } = t,
      r = `${e}-textarea`;
    return {
      [r]: {
        position: "relative",
        "&-show-count": {
          [`> ${e}`]: { height: "100%" },
          [`${e}-data-count`]: {
            position: "absolute",
            bottom: t.calc(t.fontSize).mul(t.lineHeight).mul(-1).equal(),
            insetInlineEnd: 0,
            color: t.colorTextDescription,
            whiteSpace: "nowrap",
            pointerEvents: "none",
          },
        },
        "&-allow-clear": { [`> ${e}`]: { paddingInlineEnd: n } },
        [`&-affix-wrapper${r}-has-feedback`]: {
          [`${e}`]: { paddingInlineEnd: n },
        },
        [`&-affix-wrapper${e}-affix-wrapper`]: {
          padding: 0,
          [`> textarea${e}`]: {
            fontSize: "inherit",
            border: "none",
            outline: "none",
            background: "transparent",
            "&:focus": { boxShadow: "none !important" },
          },
          [`${e}-suffix`]: {
            margin: 0,
            "> *:not(:last-child)": { marginInline: 0 },
            [`${e}-clear-icon`]: {
              position: "absolute",
              insetInlineEnd: t.paddingXS,
              insetBlockStart: t.paddingXS,
            },
            [`${r}-suffix`]: {
              position: "absolute",
              top: 0,
              insetInlineEnd: t.paddingInline,
              bottom: 0,
              zIndex: 1,
              display: "inline-flex",
              alignItems: "center",
              margin: "auto",
              pointerEvents: "none",
            },
          },
        },
      },
    };
  },
  roe = (t) => {
    const { componentCls: e } = t;
    return {
      [`${e}-out-of-range`]: {
        [`&, & input, & textarea, ${e}-show-count-suffix, ${e}-data-count`]: {
          color: t.colorError,
        },
      },
    };
  },
  R2 = ec(
    "Input",
    (t) => {
      const e = xi(t, Hie(t));
      return [Zie(e), noe(e), Jie(e), eoe(e), toe(e), roe(e), Vk(e)];
    },
    jie
  ),
  ioe = (t) => {
    const { prefixCls: e, className: n, style: r, size: i, shape: o } = t,
      a = nt({ [`${e}-lg`]: i === "large", [`${e}-sm`]: i === "small" }),
      s = nt({
        [`${e}-circle`]: o === "circle",
        [`${e}-square`]: o === "square",
        [`${e}-round`]: o === "round",
      }),
      l = E.useMemo(
        () =>
          typeof i == "number"
            ? { width: i, height: i, lineHeight: `${i}px` }
            : {},
        [i]
      );
    return E.createElement("span", {
      className: nt(e, a, s, n),
      style: Object.assign(Object.assign({}, l), r),
    });
  },
  rx = ioe,
  ooe = new gr("ant-skeleton-loading", {
    "0%": { backgroundPosition: "100% 50%" },
    "100%": { backgroundPosition: "0 50%" },
  }),
  ix = (t) => ({ height: t, lineHeight: Ze(t) }),
  nf = (t) => Object.assign({ width: t }, ix(t)),
  aoe = (t) => ({
    background: t.skeletonLoadingBackground,
    backgroundSize: "400% 100%",
    animationName: ooe,
    animationDuration: t.skeletonLoadingMotionDuration,
    animationTimingFunction: "ease",
    animationIterationCount: "infinite",
  }),
  K_ = (t, e) =>
    Object.assign(
      { width: e(t).mul(5).equal(), minWidth: e(t).mul(5).equal() },
      ix(t)
    ),
  soe = (t) => {
    const {
      skeletonAvatarCls: e,
      gradientFromColor: n,
      controlHeight: r,
      controlHeightLG: i,
      controlHeightSM: o,
    } = t;
    return {
      [`${e}`]: Object.assign(
        { display: "inline-block", verticalAlign: "top", background: n },
        nf(r)
      ),
      [`${e}${e}-circle`]: { borderRadius: "50%" },
      [`${e}${e}-lg`]: Object.assign({}, nf(i)),
      [`${e}${e}-sm`]: Object.assign({}, nf(o)),
    };
  },
  loe = (t) => {
    const {
      controlHeight: e,
      borderRadiusSM: n,
      skeletonInputCls: r,
      controlHeightLG: i,
      controlHeightSM: o,
      gradientFromColor: a,
      calc: s,
    } = t;
    return {
      [`${r}`]: Object.assign(
        {
          display: "inline-block",
          verticalAlign: "top",
          background: a,
          borderRadius: n,
        },
        K_(e, s)
      ),
      [`${r}-lg`]: Object.assign({}, K_(i, s)),
      [`${r}-sm`]: Object.assign({}, K_(o, s)),
    };
  },
  gL = (t) => Object.assign({ width: t }, ix(t)),
  coe = (t) => {
    const {
      skeletonImageCls: e,
      imageSizeBase: n,
      gradientFromColor: r,
      borderRadiusSM: i,
      calc: o,
    } = t;
    return {
      [`${e}`]: Object.assign(
        Object.assign(
          {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            verticalAlign: "top",
            background: r,
            borderRadius: i,
          },
          gL(o(n).mul(2).equal())
        ),
        {
          [`${e}-path`]: { fill: "#bfbfbf" },
          [`${e}-svg`]: Object.assign(Object.assign({}, gL(n)), {
            maxWidth: o(n).mul(4).equal(),
            maxHeight: o(n).mul(4).equal(),
          }),
          [`${e}-svg${e}-svg-circle`]: { borderRadius: "50%" },
        }
      ),
      [`${e}${e}-circle`]: { borderRadius: "50%" },
    };
  },
  Y_ = (t, e, n) => {
    const { skeletonButtonCls: r } = t;
    return {
      [`${n}${r}-circle`]: { width: e, minWidth: e, borderRadius: "50%" },
      [`${n}${r}-round`]: { borderRadius: e },
    };
  },
  Z_ = (t, e) =>
    Object.assign(
      { width: e(t).mul(2).equal(), minWidth: e(t).mul(2).equal() },
      ix(t)
    ),
  uoe = (t) => {
    const {
      borderRadiusSM: e,
      skeletonButtonCls: n,
      controlHeight: r,
      controlHeightLG: i,
      controlHeightSM: o,
      gradientFromColor: a,
      calc: s,
    } = t;
    return Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {
                [`${n}`]: Object.assign(
                  {
                    display: "inline-block",
                    verticalAlign: "top",
                    background: a,
                    borderRadius: e,
                    width: s(r).mul(2).equal(),
                    minWidth: s(r).mul(2).equal(),
                  },
                  Z_(r, s)
                ),
              },
              Y_(t, r, n)
            ),
            { [`${n}-lg`]: Object.assign({}, Z_(i, s)) }
          ),
          Y_(t, i, `${n}-lg`)
        ),
        { [`${n}-sm`]: Object.assign({}, Z_(o, s)) }
      ),
      Y_(t, o, `${n}-sm`)
    );
  },
  doe = (t) => {
    const {
      componentCls: e,
      skeletonAvatarCls: n,
      skeletonTitleCls: r,
      skeletonParagraphCls: i,
      skeletonButtonCls: o,
      skeletonInputCls: a,
      skeletonImageCls: s,
      controlHeight: l,
      controlHeightLG: c,
      controlHeightSM: u,
      gradientFromColor: d,
      padding: p,
      marginSM: m,
      borderRadius: v,
      titleHeight: S,
      blockRadius: x,
      paragraphLiHeight: g,
      controlHeightXS: _,
      paragraphMarginTop: y,
    } = t;
    return {
      [`${e}`]: {
        display: "table",
        width: "100%",
        [`${e}-header`]: {
          display: "table-cell",
          paddingInlineEnd: p,
          verticalAlign: "top",
          [`${n}`]: Object.assign(
            { display: "inline-block", verticalAlign: "top", background: d },
            nf(l)
          ),
          [`${n}-circle`]: { borderRadius: "50%" },
          [`${n}-lg`]: Object.assign({}, nf(c)),
          [`${n}-sm`]: Object.assign({}, nf(u)),
        },
        [`${e}-content`]: {
          display: "table-cell",
          width: "100%",
          verticalAlign: "top",
          [`${r}`]: {
            width: "100%",
            height: S,
            background: d,
            borderRadius: x,
            [`+ ${i}`]: { marginBlockStart: u },
          },
          [`${i}`]: {
            padding: 0,
            "> li": {
              width: "100%",
              height: g,
              listStyle: "none",
              background: d,
              borderRadius: x,
              "+ li": { marginBlockStart: _ },
            },
          },
          [`${i}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
            width: "61%",
          },
        },
        [`&-round ${e}-content`]: { [`${r}, ${i} > li`]: { borderRadius: v } },
      },
      [`${e}-with-avatar ${e}-content`]: {
        [`${r}`]: { marginBlockStart: m, [`+ ${i}`]: { marginBlockStart: y } },
      },
      [`${e}${e}-element`]: Object.assign(
        Object.assign(
          Object.assign(
            Object.assign({ display: "inline-block", width: "auto" }, uoe(t)),
            soe(t)
          ),
          loe(t)
        ),
        coe(t)
      ),
      [`${e}${e}-block`]: {
        width: "100%",
        [`${o}`]: { width: "100%" },
        [`${a}`]: { width: "100%" },
      },
      [`${e}${e}-active`]: {
        [`
        ${r},
        ${i} > li,
        ${n},
        ${o},
        ${a},
        ${s}
      `]: Object.assign({}, aoe(t)),
      },
    };
  },
  foe = (t) => {
    const { colorFillContent: e, colorFill: n } = t,
      r = e,
      i = n;
    return {
      color: r,
      colorGradientEnd: i,
      gradientFromColor: r,
      gradientToColor: i,
      titleHeight: t.controlHeight / 2,
      blockRadius: t.borderRadiusSM,
      paragraphMarginTop: t.marginLG + t.marginXXS,
      paragraphLiHeight: t.controlHeight / 2,
    };
  },
  Of = ec(
    "Skeleton",
    (t) => {
      const { componentCls: e, calc: n } = t,
        r = xi(t, {
          skeletonAvatarCls: `${e}-avatar`,
          skeletonTitleCls: `${e}-title`,
          skeletonParagraphCls: `${e}-paragraph`,
          skeletonButtonCls: `${e}-button`,
          skeletonInputCls: `${e}-input`,
          skeletonImageCls: `${e}-image`,
          imageSizeBase: n(t.controlHeight).mul(1.5).equal(),
          borderRadius: 100,
          skeletonLoadingBackground: `linear-gradient(90deg, ${t.gradientFromColor} 25%, ${t.gradientToColor} 37%, ${t.gradientFromColor} 63%)`,
          skeletonLoadingMotionDuration: "1.4s",
        });
      return [doe(r)];
    },
    foe,
    {
      deprecatedTokens: [
        ["color", "gradientFromColor"],
        ["colorGradientEnd", "gradientToColor"],
      ],
    }
  ),
  hoe = (t) => {
    const {
        prefixCls: e,
        className: n,
        rootClassName: r,
        active: i,
        shape: o = "circle",
        size: a = "default",
      } = t,
      { getPrefixCls: s } = E.useContext(Rn),
      l = s("skeleton", e),
      [c, u, d] = Of(l),
      p = Ys(t, ["prefixCls", "className"]),
      m = nt(l, `${l}-element`, { [`${l}-active`]: i }, n, r, u, d);
    return c(
      E.createElement(
        "div",
        { className: m },
        E.createElement(
          rx,
          Object.assign({ prefixCls: `${l}-avatar`, shape: o, size: a }, p)
        )
      )
    );
  },
  poe = hoe,
  moe = (t) => {
    const {
        prefixCls: e,
        className: n,
        rootClassName: r,
        active: i,
        block: o = !1,
        size: a = "default",
      } = t,
      { getPrefixCls: s } = E.useContext(Rn),
      l = s("skeleton", e),
      [c, u, d] = Of(l),
      p = Ys(t, ["prefixCls"]),
      m = nt(
        l,
        `${l}-element`,
        { [`${l}-active`]: i, [`${l}-block`]: o },
        n,
        r,
        u,
        d
      );
    return c(
      E.createElement(
        "div",
        { className: m },
        E.createElement(
          rx,
          Object.assign({ prefixCls: `${l}-button`, size: a }, p)
        )
      )
    );
  },
  goe = moe,
  voe =
    "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z",
  yoe = (t) => {
    const {
        prefixCls: e,
        className: n,
        rootClassName: r,
        style: i,
        active: o,
      } = t,
      { getPrefixCls: a } = E.useContext(Rn),
      s = a("skeleton", e),
      [l, c, u] = Of(s),
      d = nt(s, `${s}-element`, { [`${s}-active`]: o }, n, r, c, u);
    return l(
      E.createElement(
        "div",
        { className: d },
        E.createElement(
          "div",
          { className: nt(`${s}-image`, n), style: i },
          E.createElement(
            "svg",
            {
              viewBox: "0 0 1098 1024",
              xmlns: "http://www.w3.org/2000/svg",
              className: `${s}-image-svg`,
            },
            E.createElement("path", { d: voe, className: `${s}-image-path` })
          )
        )
      )
    );
  },
  xoe = yoe,
  Soe = (t) => {
    const {
        prefixCls: e,
        className: n,
        rootClassName: r,
        active: i,
        block: o,
        size: a = "default",
      } = t,
      { getPrefixCls: s } = E.useContext(Rn),
      l = s("skeleton", e),
      [c, u, d] = Of(l),
      p = Ys(t, ["prefixCls"]),
      m = nt(
        l,
        `${l}-element`,
        { [`${l}-active`]: i, [`${l}-block`]: o },
        n,
        r,
        u,
        d
      );
    return c(
      E.createElement(
        "div",
        { className: m },
        E.createElement(
          rx,
          Object.assign({ prefixCls: `${l}-input`, size: a }, p)
        )
      )
    );
  },
  _oe = Soe;
var boe = {
  icon: {
    tag: "svg",
    attrs: { viewBox: "64 64 896 896", focusable: "false" },
    children: [
      {
        tag: "path",
        attrs: {
          d: "M888 792H200V168c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h752c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM288 604a64 64 0 10128 0 64 64 0 10-128 0zm118-224a48 48 0 1096 0 48 48 0 10-96 0zm158 228a96 96 0 10192 0 96 96 0 10-192 0zm148-314a56 56 0 10112 0 56 56 0 10-112 0z",
        },
      },
    ],
  },
  name: "dot-chart",
  theme: "outlined",
};
const woe = boe;
var Eoe = function (e, n) {
  return E.createElement(cs, Et({}, e, { ref: n, icon: woe }));
};
const Moe = E.forwardRef(Eoe),
  Coe = (t) => {
    const {
        prefixCls: e,
        className: n,
        rootClassName: r,
        style: i,
        active: o,
        children: a,
      } = t,
      { getPrefixCls: s } = E.useContext(Rn),
      l = s("skeleton", e),
      [c, u, d] = Of(l),
      p = nt(l, `${l}-element`, { [`${l}-active`]: o }, u, n, r, d),
      m = a ?? E.createElement(Moe, null);
    return c(
      E.createElement(
        "div",
        { className: p },
        E.createElement("div", { className: nt(`${l}-image`, n), style: i }, m)
      )
    );
  },
  Toe = Coe,
  Aoe = (t) => {
    const e = (s) => {
        const { width: l, rows: c = 2 } = t;
        if (Array.isArray(l)) return l[s];
        if (c - 1 === s) return l;
      },
      { prefixCls: n, className: r, style: i, rows: o } = t,
      a = It(Array(o)).map((s, l) =>
        E.createElement("li", { key: l, style: { width: e(l) } })
      );
    return E.createElement("ul", { className: nt(n, r), style: i }, a);
  },
  Roe = Aoe,
  Poe = (t) => {
    let { prefixCls: e, className: n, width: r, style: i } = t;
    return E.createElement("h3", {
      className: nt(e, n),
      style: Object.assign({ width: r }, i),
    });
  },
  Ioe = Poe;
function Q_(t) {
  return t && typeof t == "object" ? t : {};
}
function Loe(t, e) {
  return t && !e
    ? { size: "large", shape: "square" }
    : { size: "large", shape: "circle" };
}
function Ooe(t, e) {
  return !t && e ? { width: "38%" } : t && e ? { width: "50%" } : {};
}
function Noe(t, e) {
  const n = {};
  return (
    (!t || !e) && (n.width = "61%"), !t && e ? (n.rows = 3) : (n.rows = 2), n
  );
}
const Nf = (t) => {
  const {
      prefixCls: e,
      loading: n,
      className: r,
      rootClassName: i,
      style: o,
      children: a,
      avatar: s = !1,
      title: l = !0,
      paragraph: c = !0,
      active: u,
      round: d,
    } = t,
    { getPrefixCls: p, direction: m, skeleton: v } = E.useContext(Rn),
    S = p("skeleton", e),
    [x, g, _] = Of(S);
  if (n || !("loading" in t)) {
    const y = !!s,
      w = !!l,
      A = !!c;
    let M;
    if (y) {
      const R = Object.assign(
        Object.assign({ prefixCls: `${S}-avatar` }, Loe(w, A)),
        Q_(s)
      );
      M = E.createElement(
        "div",
        { className: `${S}-header` },
        E.createElement(rx, Object.assign({}, R))
      );
    }
    let T;
    if (w || A) {
      let R;
      if (w) {
        const F = Object.assign(
          Object.assign({ prefixCls: `${S}-title` }, Ooe(y, A)),
          Q_(l)
        );
        R = E.createElement(Ioe, Object.assign({}, F));
      }
      let P;
      if (A) {
        const F = Object.assign(
          Object.assign({ prefixCls: `${S}-paragraph` }, Noe(y, w)),
          Q_(c)
        );
        P = E.createElement(Roe, Object.assign({}, F));
      }
      T = E.createElement("div", { className: `${S}-content` }, R, P);
    }
    const I = nt(
      S,
      {
        [`${S}-with-avatar`]: y,
        [`${S}-active`]: u,
        [`${S}-rtl`]: m === "rtl",
        [`${S}-round`]: d,
      },
      v == null ? void 0 : v.className,
      r,
      i,
      g,
      _
    );
    return x(
      E.createElement(
        "div",
        {
          className: I,
          style: Object.assign(
            Object.assign({}, v == null ? void 0 : v.style),
            o
          ),
        },
        M,
        T
      )
    );
  }
  return typeof a < "u" ? a : null;
};
Nf.Button = goe;
Nf.Avatar = poe;
Nf.Input = _oe;
Nf.Image = xoe;
Nf.Node = Toe;
const Foe = Nf;
var Doe = {
  icon: {
    tag: "svg",
    attrs: { viewBox: "64 64 896 896", focusable: "false" },
    children: [
      {
        tag: "path",
        attrs: {
          d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z",
        },
      },
      {
        tag: "path",
        attrs: {
          d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z",
        },
      },
    ],
  },
  name: "plus",
  theme: "outlined",
};
const zoe = Doe;
var Uoe = function (e, n) {
  return E.createElement(cs, Et({}, e, { ref: n, icon: zoe }));
};
const koe = E.forwardRef(Uoe),
  ox = E.createContext(null);
var Boe = function (e) {
    var n = e.activeTabOffset,
      r = e.horizontal,
      i = e.rtl,
      o = e.indicator,
      a = o === void 0 ? {} : o,
      s = a.size,
      l = a.align,
      c = l === void 0 ? "center" : l,
      u = E.useState(),
      d = Ve(u, 2),
      p = d[0],
      m = d[1],
      v = E.useRef(),
      S = at.useCallback(
        function (g) {
          return typeof s == "function" ? s(g) : typeof s == "number" ? s : g;
        },
        [s]
      );
    function x() {
      Er.cancel(v.current);
    }
    return (
      E.useEffect(
        function () {
          var g = {};
          if (n)
            if (r) {
              g.width = S(n.width);
              var _ = i ? "right" : "left";
              c === "start" && (g[_] = n[_]),
                c === "center" &&
                  ((g[_] = n[_] + n.width / 2),
                  (g.transform = i ? "translateX(50%)" : "translateX(-50%)")),
                c === "end" &&
                  ((g[_] = n[_] + n.width),
                  (g.transform = "translateX(-100%)"));
            } else
              (g.height = S(n.height)),
                c === "start" && (g.top = n.top),
                c === "center" &&
                  ((g.top = n.top + n.height / 2),
                  (g.transform = "translateY(-50%)")),
                c === "end" &&
                  ((g.top = n.top + n.height),
                  (g.transform = "translateY(-100%)"));
          return (
            x(),
            (v.current = Er(function () {
              m(g);
            })),
            x
          );
        },
        [n, r, i, c, S]
      ),
      { style: p }
    );
  },
  vL = { width: 0, height: 0, left: 0, top: 0 };
function Hoe(t, e, n) {
  return E.useMemo(
    function () {
      for (
        var r,
          i = new Map(),
          o = e.get((r = t[0]) === null || r === void 0 ? void 0 : r.key) || vL,
          a = o.left + o.width,
          s = 0;
        s < t.length;
        s += 1
      ) {
        var l = t[s].key,
          c = e.get(l);
        if (!c) {
          var u;
          c =
            e.get((u = t[s - 1]) === null || u === void 0 ? void 0 : u.key) ||
            vL;
        }
        var d = i.get(l) || De({}, c);
        (d.right = a - d.left - d.width), i.set(l, d);
      }
      return i;
    },
    [
      t
        .map(function (r) {
          return r.key;
        })
        .join("_"),
      e,
      n,
    ]
  );
}
function yL(t, e) {
  var n = E.useRef(t),
    r = E.useState({}),
    i = Ve(r, 2),
    o = i[1];
  function a(s) {
    var l = typeof s == "function" ? s(n.current) : s;
    l !== n.current && e(l, n.current), (n.current = l), o({});
  }
  return [n.current, a];
}
var joe = 0.1,
  xL = 0.01,
  D0 = 20,
  SL = Math.pow(0.995, D0);
function Voe(t, e) {
  var n = E.useState(),
    r = Ve(n, 2),
    i = r[0],
    o = r[1],
    a = E.useState(0),
    s = Ve(a, 2),
    l = s[0],
    c = s[1],
    u = E.useState(0),
    d = Ve(u, 2),
    p = d[0],
    m = d[1],
    v = E.useState(),
    S = Ve(v, 2),
    x = S[0],
    g = S[1],
    _ = E.useRef();
  function y(R) {
    var P = R.touches[0],
      F = P.screenX,
      D = P.screenY;
    o({ x: F, y: D }), window.clearInterval(_.current);
  }
  function w(R) {
    if (i) {
      R.preventDefault();
      var P = R.touches[0],
        F = P.screenX,
        D = P.screenY;
      o({ x: F, y: D });
      var j = F - i.x,
        N = D - i.y;
      e(j, N);
      var V = Date.now();
      c(V), m(V - l), g({ x: j, y: N });
    }
  }
  function A() {
    if (i && (o(null), g(null), x)) {
      var R = x.x / p,
        P = x.y / p,
        F = Math.abs(R),
        D = Math.abs(P);
      if (Math.max(F, D) < joe) return;
      var j = R,
        N = P;
      _.current = window.setInterval(function () {
        if (Math.abs(j) < xL && Math.abs(N) < xL) {
          window.clearInterval(_.current);
          return;
        }
        (j *= SL), (N *= SL), e(j * D0, N * D0);
      }, D0);
    }
  }
  var M = E.useRef();
  function T(R) {
    var P = R.deltaX,
      F = R.deltaY,
      D = 0,
      j = Math.abs(P),
      N = Math.abs(F);
    j === N
      ? (D = M.current === "x" ? P : F)
      : j > N
      ? ((D = P), (M.current = "x"))
      : ((D = F), (M.current = "y")),
      e(-D, -D) && R.preventDefault();
  }
  var I = E.useRef(null);
  (I.current = { onTouchStart: y, onTouchMove: w, onTouchEnd: A, onWheel: T }),
    E.useEffect(function () {
      function R(j) {
        I.current.onTouchStart(j);
      }
      function P(j) {
        I.current.onTouchMove(j);
      }
      function F(j) {
        I.current.onTouchEnd(j);
      }
      function D(j) {
        I.current.onWheel(j);
      }
      return (
        document.addEventListener("touchmove", P, { passive: !1 }),
        document.addEventListener("touchend", F, { passive: !1 }),
        t.current.addEventListener("touchstart", R, { passive: !1 }),
        t.current.addEventListener("wheel", D),
        function () {
          document.removeEventListener("touchmove", P),
            document.removeEventListener("touchend", F);
        }
      );
    }, []);
}
function L4(t) {
  var e = E.useState(0),
    n = Ve(e, 2),
    r = n[0],
    i = n[1],
    o = E.useRef(0),
    a = E.useRef();
  return (
    (a.current = t),
    uE(
      function () {
        var s;
        (s = a.current) === null || s === void 0 || s.call(a);
      },
      [r]
    ),
    function () {
      o.current === r && ((o.current += 1), i(o.current));
    }
  );
}
function $oe(t) {
  var e = E.useRef([]),
    n = E.useState({}),
    r = Ve(n, 2),
    i = r[1],
    o = E.useRef(typeof t == "function" ? t() : t),
    a = L4(function () {
      var l = o.current;
      e.current.forEach(function (c) {
        l = c(l);
      }),
        (e.current = []),
        (o.current = l),
        i({});
    });
  function s(l) {
    e.current.push(l), a();
  }
  return [o.current, s];
}
var _L = { width: 0, height: 0, left: 0, top: 0, right: 0 };
function Goe(t, e, n, r, i, o, a) {
  var s = a.tabs,
    l = a.tabPosition,
    c = a.rtl,
    u,
    d,
    p;
  return (
    ["top", "bottom"].includes(l)
      ? ((u = "width"), (d = c ? "right" : "left"), (p = Math.abs(n)))
      : ((u = "height"), (d = "top"), (p = -n)),
    E.useMemo(
      function () {
        if (!s.length) return [0, 0];
        for (var m = s.length, v = m, S = 0; S < m; S += 1) {
          var x = t.get(s[S].key) || _L;
          if (x[d] + x[u] > p + e) {
            v = S - 1;
            break;
          }
        }
        for (var g = 0, _ = m - 1; _ >= 0; _ -= 1) {
          var y = t.get(s[_].key) || _L;
          if (y[d] < p) {
            g = _ + 1;
            break;
          }
        }
        return g >= v ? [0, 0] : [g, v];
      },
      [
        t,
        e,
        r,
        i,
        o,
        p,
        l,
        s
          .map(function (m) {
            return m.key;
          })
          .join("_"),
        c,
      ]
    )
  );
}
function bL(t) {
  var e;
  return (
    t instanceof Map
      ? ((e = {}),
        t.forEach(function (n, r) {
          e[r] = n;
        }))
      : (e = t),
    JSON.stringify(e)
  );
}
var Woe = "TABS_DQ";
function O4(t) {
  return String(t).replace(/"/g, Woe);
}
function N4(t, e, n, r) {
  return !(!n || r || t === !1 || (t === void 0 && (e === !1 || e === null)));
}
var F4 = E.forwardRef(function (t, e) {
    var n = t.prefixCls,
      r = t.editable,
      i = t.locale,
      o = t.style;
    return !r || r.showAdd === !1
      ? null
      : E.createElement(
          "button",
          {
            ref: e,
            type: "button",
            className: "".concat(n, "-nav-add"),
            style: o,
            "aria-label": (i == null ? void 0 : i.addAriaLabel) || "Add tab",
            onClick: function (s) {
              r.onEdit("add", { event: s });
            },
          },
          r.addIcon || "+"
        );
  }),
  wL = E.forwardRef(function (t, e) {
    var n = t.position,
      r = t.prefixCls,
      i = t.extra;
    if (!i) return null;
    var o,
      a = {};
    return (
      un(i) === "object" && !E.isValidElement(i) ? (a = i) : (a.right = i),
      n === "right" && (o = a.right),
      n === "left" && (o = a.left),
      o
        ? E.createElement(
            "div",
            { className: "".concat(r, "-extra-content"), ref: e },
            o
          )
        : null
    );
  }),
  Xoe = E.forwardRef(function (t, e) {
    var n = t.prefixCls,
      r = t.id,
      i = t.tabs,
      o = t.locale,
      a = t.mobile,
      s = t.moreIcon,
      l = s === void 0 ? "More" : s,
      c = t.moreTransitionName,
      u = t.style,
      d = t.className,
      p = t.editable,
      m = t.tabBarGutter,
      v = t.rtl,
      S = t.removeAriaLabel,
      x = t.onTabClick,
      g = t.getPopupContainer,
      _ = t.popupClassName,
      y = E.useState(!1),
      w = Ve(y, 2),
      A = w[0],
      M = w[1],
      T = E.useState(null),
      I = Ve(T, 2),
      R = I[0],
      P = I[1],
      F = "".concat(r, "-more-popup"),
      D = "".concat(n, "-dropdown"),
      j = R !== null ? "".concat(F, "-").concat(R) : null,
      N = o == null ? void 0 : o.dropdownAriaLabel;
    function V(q, X) {
      q.preventDefault(),
        q.stopPropagation(),
        p.onEdit("remove", { key: X, event: q });
    }
    var W = E.createElement(
      Fm,
      {
        onClick: function (X) {
          var ee = X.key,
            J = X.domEvent;
          x(ee, J), M(!1);
        },
        prefixCls: "".concat(D, "-menu"),
        id: F,
        tabIndex: -1,
        role: "listbox",
        "aria-activedescendant": j,
        selectedKeys: [R],
        "aria-label": N !== void 0 ? N : "expanded dropdown",
      },
      i.map(function (q) {
        var X = q.closable,
          ee = q.disabled,
          J = q.closeIcon,
          oe = q.key,
          ae = q.label,
          le = N4(X, J, p, ee);
        return E.createElement(
          tx,
          {
            key: oe,
            id: "".concat(F, "-").concat(oe),
            role: "option",
            "aria-controls": r && "".concat(r, "-panel-").concat(oe),
            disabled: ee,
          },
          E.createElement("span", null, ae),
          le &&
            E.createElement(
              "button",
              {
                type: "button",
                "aria-label": S || "remove",
                tabIndex: 0,
                className: "".concat(D, "-menu-item-remove"),
                onClick: function (me) {
                  me.stopPropagation(), V(me, oe);
                },
              },
              J || p.removeIcon || ""
            )
        );
      })
    );
    function Q(q) {
      for (
        var X = i.filter(function (le) {
            return !le.disabled;
          }),
          ee =
            X.findIndex(function (le) {
              return le.key === R;
            }) || 0,
          J = X.length,
          oe = 0;
        oe < J;
        oe += 1
      ) {
        ee = (ee + q + J) % J;
        var ae = X[ee];
        if (!ae.disabled) {
          P(ae.key);
          return;
        }
      }
    }
    function B(q) {
      var X = q.which;
      if (!A) {
        [gt.DOWN, gt.SPACE, gt.ENTER].includes(X) &&
          (M(!0), q.preventDefault());
        return;
      }
      switch (X) {
        case gt.UP:
          Q(-1), q.preventDefault();
          break;
        case gt.DOWN:
          Q(1), q.preventDefault();
          break;
        case gt.ESC:
          M(!1);
          break;
        case gt.SPACE:
        case gt.ENTER:
          R !== null && x(R, q);
          break;
      }
    }
    E.useEffect(
      function () {
        var q = document.getElementById(j);
        q && q.scrollIntoView && q.scrollIntoView(!1);
      },
      [R]
    ),
      E.useEffect(
        function () {
          A || P(null);
        },
        [A]
      );
    var $ = be({}, v ? "marginRight" : "marginLeft", m);
    i.length || (($.visibility = "hidden"), ($.order = 1));
    var G = nt(be({}, "".concat(D, "-rtl"), v)),
      k = a
        ? null
        : E.createElement(
            zre,
            {
              prefixCls: D,
              overlay: W,
              trigger: ["hover"],
              visible: i.length ? A : !1,
              transitionName: c,
              onVisibleChange: M,
              overlayClassName: nt(G, _),
              mouseEnterDelay: 0.1,
              mouseLeaveDelay: 0.1,
              getPopupContainer: g,
            },
            E.createElement(
              "button",
              {
                type: "button",
                className: "".concat(n, "-nav-more"),
                style: $,
                tabIndex: -1,
                "aria-hidden": "true",
                "aria-haspopup": "listbox",
                "aria-controls": F,
                id: "".concat(r, "-more"),
                "aria-expanded": A,
                onKeyDown: B,
              },
              l
            )
          );
    return E.createElement(
      "div",
      { className: nt("".concat(n, "-nav-operations"), d), style: u, ref: e },
      k,
      E.createElement(F4, { prefixCls: n, locale: o, editable: p })
    );
  });
const qoe = E.memo(Xoe, function (t, e) {
  return e.tabMoving;
});
var Koe = function (e) {
    var n = e.prefixCls,
      r = e.id,
      i = e.active,
      o = e.tab,
      a = o.key,
      s = o.label,
      l = o.disabled,
      c = o.closeIcon,
      u = o.icon,
      d = e.closable,
      p = e.renderWrapper,
      m = e.removeAriaLabel,
      v = e.editable,
      S = e.onClick,
      x = e.onFocus,
      g = e.style,
      _ = "".concat(n, "-tab"),
      y = N4(d, c, v, l);
    function w(I) {
      l || S(I);
    }
    function A(I) {
      I.preventDefault(),
        I.stopPropagation(),
        v.onEdit("remove", { key: a, event: I });
    }
    var M = E.useMemo(
        function () {
          return u && typeof s == "string"
            ? E.createElement("span", null, s)
            : s;
        },
        [s, u]
      ),
      T = E.createElement(
        "div",
        {
          key: a,
          "data-node-key": O4(a),
          className: nt(
            _,
            be(
              be(
                be({}, "".concat(_, "-with-remove"), y),
                "".concat(_, "-active"),
                i
              ),
              "".concat(_, "-disabled"),
              l
            )
          ),
          style: g,
          onClick: w,
        },
        E.createElement(
          "div",
          {
            role: "tab",
            "aria-selected": i,
            id: r && "".concat(r, "-tab-").concat(a),
            className: "".concat(_, "-btn"),
            "aria-controls": r && "".concat(r, "-panel-").concat(a),
            "aria-disabled": l,
            tabIndex: l ? null : 0,
            onClick: function (R) {
              R.stopPropagation(), w(R);
            },
            onKeyDown: function (R) {
              [gt.SPACE, gt.ENTER].includes(R.which) &&
                (R.preventDefault(), w(R));
            },
            onFocus: x,
          },
          u && E.createElement("span", { className: "".concat(_, "-icon") }, u),
          s && M
        ),
        y &&
          E.createElement(
            "button",
            {
              type: "button",
              "aria-label": m || "remove",
              tabIndex: 0,
              className: "".concat(_, "-remove"),
              onClick: function (R) {
                R.stopPropagation(), A(R);
              },
            },
            c || v.removeIcon || ""
          )
      );
    return p ? p(T) : T;
  },
  Yoe = function (e, n) {
    var r = e.offsetWidth,
      i = e.offsetHeight,
      o = e.offsetTop,
      a = e.offsetLeft,
      s = e.getBoundingClientRect(),
      l = s.width,
      c = s.height,
      u = s.x,
      d = s.y;
    return Math.abs(l - r) < 1 ? [l, c, u - n.x, d - n.y] : [r, i, a, o];
  },
  _d = function (e) {
    var n = e.current || {},
      r = n.offsetWidth,
      i = r === void 0 ? 0 : r,
      o = n.offsetHeight,
      a = o === void 0 ? 0 : o;
    if (e.current) {
      var s = e.current.getBoundingClientRect(),
        l = s.width,
        c = s.height;
      if (Math.abs(l - i) < 1) return [l, c];
    }
    return [i, a];
  },
  n0 = function (e, n) {
    return e[n ? 0 : 1];
  },
  EL = E.forwardRef(function (t, e) {
    var n = t.className,
      r = t.style,
      i = t.id,
      o = t.animated,
      a = t.activeKey,
      s = t.rtl,
      l = t.extra,
      c = t.editable,
      u = t.locale,
      d = t.tabPosition,
      p = t.tabBarGutter,
      m = t.children,
      v = t.onTabClick,
      S = t.onTabScroll,
      x = t.indicator,
      g = E.useContext(ox),
      _ = g.prefixCls,
      y = g.tabs,
      w = E.useRef(null),
      A = E.useRef(null),
      M = E.useRef(null),
      T = E.useRef(null),
      I = E.useRef(null),
      R = E.useRef(null),
      P = E.useRef(null),
      F = d === "top" || d === "bottom",
      D = yL(0, function (Ht, Dt) {
        F && S && S({ direction: Ht > Dt ? "left" : "right" });
      }),
      j = Ve(D, 2),
      N = j[0],
      V = j[1],
      W = yL(0, function (Ht, Dt) {
        !F && S && S({ direction: Ht > Dt ? "top" : "bottom" });
      }),
      Q = Ve(W, 2),
      B = Q[0],
      $ = Q[1],
      G = E.useState([0, 0]),
      k = Ve(G, 2),
      q = k[0],
      X = k[1],
      ee = E.useState([0, 0]),
      J = Ve(ee, 2),
      oe = J[0],
      ae = J[1],
      le = E.useState([0, 0]),
      _e = Ve(le, 2),
      me = _e[0],
      se = _e[1],
      Y = E.useState([0, 0]),
      ve = Ve(Y, 2),
      de = ve[0],
      ue = ve[1],
      fe = $oe(new Map()),
      Te = Ve(fe, 2),
      pe = Te[0],
      H = Te[1],
      z = Hoe(y, pe, oe[0]),
      Z = n0(q, F),
      ge = n0(oe, F),
      ce = n0(me, F),
      he = n0(de, F),
      Me = Z < ge + ce,
      Re = Me ? Z - he : Z - ce,
      Le = "".concat(_, "-nav-operations-hidden"),
      Oe = 0,
      Pe = 0;
    F && s
      ? ((Oe = 0), (Pe = Math.max(0, ge - Re)))
      : ((Oe = Math.min(0, Re - ge)), (Pe = 0));
    function Se(Ht) {
      return Ht < Oe ? Oe : Ht > Pe ? Pe : Ht;
    }
    var Je = E.useRef(null),
      st = E.useState(),
      Qe = Ve(st, 2),
      Ke = Qe[0],
      Ne = Qe[1];
    function ne() {
      Ne(Date.now());
    }
    function Ie() {
      Je.current && clearTimeout(Je.current);
    }
    Voe(T, function (Ht, Dt) {
      function nn(Ln, te) {
        Ln(function (ye) {
          var Ae = Se(ye + te);
          return Ae;
        });
      }
      return Me ? (F ? nn(V, Ht) : nn($, Dt), Ie(), ne(), !0) : !1;
    }),
      E.useEffect(
        function () {
          return (
            Ie(),
            Ke &&
              (Je.current = setTimeout(function () {
                Ne(0);
              }, 100)),
            Ie
          );
        },
        [Ke]
      );
    var et = Goe(z, Re, F ? N : B, ge, ce, he, De(De({}, t), {}, { tabs: y })),
      We = Ve(et, 2),
      Ee = We[0],
      ie = We[1],
      $e = Yo(function () {
        var Ht =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : a,
          Dt = z.get(Ht) || { width: 0, height: 0, left: 0, right: 0, top: 0 };
        if (F) {
          var nn = N;
          s
            ? Dt.right < N
              ? (nn = Dt.right)
              : Dt.right + Dt.width > N + Re && (nn = Dt.right + Dt.width - Re)
            : Dt.left < -N
            ? (nn = -Dt.left)
            : Dt.left + Dt.width > -N + Re && (nn = -(Dt.left + Dt.width - Re)),
            $(0),
            V(Se(nn));
        } else {
          var Ln = B;
          Dt.top < -B
            ? (Ln = -Dt.top)
            : Dt.top + Dt.height > -B + Re && (Ln = -(Dt.top + Dt.height - Re)),
            V(0),
            $(Se(Ln));
        }
      }),
      He = {};
    d === "top" || d === "bottom"
      ? (He[s ? "marginRight" : "marginLeft"] = p)
      : (He.marginTop = p);
    var Xe = y.map(function (Ht, Dt) {
        var nn = Ht.key;
        return E.createElement(Koe, {
          id: i,
          prefixCls: _,
          key: nn,
          tab: Ht,
          style: Dt === 0 ? void 0 : He,
          closable: Ht.closable,
          editable: c,
          active: nn === a,
          renderWrapper: m,
          removeAriaLabel: u == null ? void 0 : u.removeAriaLabel,
          onClick: function (te) {
            v(nn, te);
          },
          onFocus: function () {
            $e(nn),
              ne(),
              T.current &&
                (s || (T.current.scrollLeft = 0), (T.current.scrollTop = 0));
          },
        });
      }),
      Ue = function () {
        return H(function () {
          var Dt,
            nn = new Map(),
            Ln =
              (Dt = I.current) === null || Dt === void 0
                ? void 0
                : Dt.getBoundingClientRect();
          return (
            y.forEach(function (te) {
              var ye,
                Ae = te.key,
                ze =
                  (ye = I.current) === null || ye === void 0
                    ? void 0
                    : ye.querySelector('[data-node-key="'.concat(O4(Ae), '"]'));
              if (ze) {
                var Ce = Yoe(ze, Ln),
                  ot = Ve(Ce, 4),
                  ht = ot[0],
                  xt = ot[1],
                  qe = ot[2],
                  bt = ot[3];
                nn.set(Ae, { width: ht, height: xt, left: qe, top: bt });
              }
            }),
            nn
          );
        });
      };
    E.useEffect(
      function () {
        Ue();
      },
      [
        y
          .map(function (Ht) {
            return Ht.key;
          })
          .join("_"),
      ]
    );
    var Ye = L4(function () {
        var Ht = _d(w),
          Dt = _d(A),
          nn = _d(M);
        X([Ht[0] - Dt[0] - nn[0], Ht[1] - Dt[1] - nn[1]]);
        var Ln = _d(P);
        se(Ln);
        var te = _d(R);
        ue(te);
        var ye = _d(I);
        ae([ye[0] - Ln[0], ye[1] - Ln[1]]), Ue();
      }),
      ke = y.slice(0, Ee),
      tt = y.slice(ie + 1),
      ut = [].concat(It(ke), It(tt)),
      dt = z.get(a),
      Rt = Boe({ activeTabOffset: dt, horizontal: F, indicator: x, rtl: s }),
      Bt = Rt.style;
    E.useEffect(
      function () {
        $e();
      },
      [a, Oe, Pe, bL(dt), bL(z), F]
    ),
      E.useEffect(
        function () {
          Ye();
        },
        [s]
      );
    var In = !!ut.length,
      dn = "".concat(_, "-nav-wrap"),
      _n,
      gn,
      Gt,
      ln;
    return (
      F
        ? s
          ? ((gn = N > 0), (_n = N !== Pe))
          : ((_n = N < 0), (gn = N !== Oe))
        : ((Gt = B < 0), (ln = B !== Oe)),
      E.createElement(
        Ds,
        { onResize: Ye },
        E.createElement(
          "div",
          {
            ref: Em(e, w),
            role: "tablist",
            className: nt("".concat(_, "-nav"), n),
            style: r,
            onKeyDown: function () {
              ne();
            },
          },
          E.createElement(wL, {
            ref: A,
            position: "left",
            extra: l,
            prefixCls: _,
          }),
          E.createElement(
            Ds,
            { onResize: Ye },
            E.createElement(
              "div",
              {
                className: nt(
                  dn,
                  be(
                    be(
                      be(
                        be({}, "".concat(dn, "-ping-left"), _n),
                        "".concat(dn, "-ping-right"),
                        gn
                      ),
                      "".concat(dn, "-ping-top"),
                      Gt
                    ),
                    "".concat(dn, "-ping-bottom"),
                    ln
                  )
                ),
                ref: T,
              },
              E.createElement(
                Ds,
                { onResize: Ye },
                E.createElement(
                  "div",
                  {
                    ref: I,
                    className: "".concat(_, "-nav-list"),
                    style: {
                      transform: "translate("
                        .concat(N, "px, ")
                        .concat(B, "px)"),
                      transition: Ke ? "none" : void 0,
                    },
                  },
                  Xe,
                  E.createElement(F4, {
                    ref: P,
                    prefixCls: _,
                    locale: u,
                    editable: c,
                    style: De(
                      De({}, Xe.length === 0 ? void 0 : He),
                      {},
                      { visibility: In ? "hidden" : null }
                    ),
                  }),
                  E.createElement("div", {
                    className: nt(
                      "".concat(_, "-ink-bar"),
                      be({}, "".concat(_, "-ink-bar-animated"), o.inkBar)
                    ),
                    style: Bt,
                  })
                )
              )
            )
          ),
          E.createElement(
            qoe,
            Et({}, t, {
              removeAriaLabel: u == null ? void 0 : u.removeAriaLabel,
              ref: R,
              prefixCls: _,
              tabs: ut,
              className: !In && Le,
              tabMoving: !!Ke,
            })
          ),
          E.createElement(wL, {
            ref: M,
            position: "right",
            extra: l,
            prefixCls: _,
          })
        )
      )
    );
  }),
  D4 = E.forwardRef(function (t, e) {
    var n = t.prefixCls,
      r = t.className,
      i = t.style,
      o = t.id,
      a = t.active,
      s = t.tabKey,
      l = t.children;
    return E.createElement(
      "div",
      {
        id: o && "".concat(o, "-panel-").concat(s),
        role: "tabpanel",
        tabIndex: a ? 0 : -1,
        "aria-labelledby": o && "".concat(o, "-tab-").concat(s),
        "aria-hidden": !a,
        style: i,
        className: nt(n, a && "".concat(n, "-active"), r),
        ref: e,
      },
      l
    );
  }),
  Zoe = ["renderTabBar"],
  Qoe = ["label", "key"],
  Joe = function (e) {
    var n = e.renderTabBar,
      r = on(e, Zoe),
      i = E.useContext(ox),
      o = i.tabs;
    if (n) {
      var a = De(
        De({}, r),
        {},
        {
          panes: o.map(function (s) {
            var l = s.label,
              c = s.key,
              u = on(s, Qoe);
            return E.createElement(D4, Et({ tab: l, key: c, tabKey: c }, u));
          }),
        }
      );
      return n(a, EL);
    }
    return E.createElement(EL, r);
  },
  eae = ["key", "forceRender", "style", "className", "destroyInactiveTabPane"],
  tae = function (e) {
    var n = e.id,
      r = e.activeKey,
      i = e.animated,
      o = e.tabPosition,
      a = e.destroyInactiveTabPane,
      s = E.useContext(ox),
      l = s.prefixCls,
      c = s.tabs,
      u = i.tabPane,
      d = "".concat(l, "-tabpane");
    return E.createElement(
      "div",
      { className: nt("".concat(l, "-content-holder")) },
      E.createElement(
        "div",
        {
          className: nt(
            "".concat(l, "-content"),
            "".concat(l, "-content-").concat(o),
            be({}, "".concat(l, "-content-animated"), u)
          ),
        },
        c.map(function (p) {
          var m = p.key,
            v = p.forceRender,
            S = p.style,
            x = p.className,
            g = p.destroyInactiveTabPane,
            _ = on(p, eae),
            y = m === r;
          return E.createElement(
            Mu,
            Et(
              {
                key: m,
                visible: y,
                forceRender: v,
                removeOnLeave: !!(a || g),
                leavedClassName: "".concat(d, "-hidden"),
              },
              i.tabPaneMotion
            ),
            function (w, A) {
              var M = w.style,
                T = w.className;
              return E.createElement(
                D4,
                Et({}, _, {
                  prefixCls: d,
                  id: n,
                  tabKey: m,
                  animated: u,
                  active: y,
                  style: De(De({}, S), M),
                  className: nt(x, T),
                  ref: A,
                })
              );
            }
          );
        })
      )
    );
  };
function nae() {
  var t =
      arguments.length > 0 && arguments[0] !== void 0
        ? arguments[0]
        : { inkBar: !0, tabPane: !1 },
    e;
  return (
    t === !1
      ? (e = { inkBar: !1, tabPane: !1 })
      : t === !0
      ? (e = { inkBar: !0, tabPane: !1 })
      : (e = De({ inkBar: !0 }, un(t) === "object" ? t : {})),
    e.tabPaneMotion && e.tabPane === void 0 && (e.tabPane = !0),
    !e.tabPaneMotion && e.tabPane && (e.tabPane = !1),
    e
  );
}
var rae = [
    "id",
    "prefixCls",
    "className",
    "items",
    "direction",
    "activeKey",
    "defaultActiveKey",
    "editable",
    "animated",
    "tabPosition",
    "tabBarGutter",
    "tabBarStyle",
    "tabBarExtraContent",
    "locale",
    "moreIcon",
    "moreTransitionName",
    "destroyInactiveTabPane",
    "renderTabBar",
    "onChange",
    "onTabClick",
    "onTabScroll",
    "getPopupContainer",
    "popupClassName",
    "indicator",
  ],
  ML = 0,
  iae = E.forwardRef(function (t, e) {
    var n = t.id,
      r = t.prefixCls,
      i = r === void 0 ? "rc-tabs" : r,
      o = t.className,
      a = t.items,
      s = t.direction,
      l = t.activeKey,
      c = t.defaultActiveKey,
      u = t.editable,
      d = t.animated,
      p = t.tabPosition,
      m = p === void 0 ? "top" : p,
      v = t.tabBarGutter,
      S = t.tabBarStyle,
      x = t.tabBarExtraContent,
      g = t.locale,
      _ = t.moreIcon,
      y = t.moreTransitionName,
      w = t.destroyInactiveTabPane,
      A = t.renderTabBar,
      M = t.onChange,
      T = t.onTabClick,
      I = t.onTabScroll,
      R = t.getPopupContainer,
      P = t.popupClassName,
      F = t.indicator,
      D = on(t, rae),
      j = E.useMemo(
        function () {
          return (a || []).filter(function (ue) {
            return ue && un(ue) === "object" && "key" in ue;
          });
        },
        [a]
      ),
      N = s === "rtl",
      V = nae(d),
      W = E.useState(!1),
      Q = Ve(W, 2),
      B = Q[0],
      $ = Q[1];
    E.useEffect(function () {
      $(Jk());
    }, []);
    var G = ta(
        function () {
          var ue;
          return (ue = j[0]) === null || ue === void 0 ? void 0 : ue.key;
        },
        { value: l, defaultValue: c }
      ),
      k = Ve(G, 2),
      q = k[0],
      X = k[1],
      ee = E.useState(function () {
        return j.findIndex(function (ue) {
          return ue.key === q;
        });
      }),
      J = Ve(ee, 2),
      oe = J[0],
      ae = J[1];
    E.useEffect(
      function () {
        var ue = j.findIndex(function (Te) {
          return Te.key === q;
        });
        if (ue === -1) {
          var fe;
          (ue = Math.max(0, Math.min(oe, j.length - 1))),
            X((fe = j[ue]) === null || fe === void 0 ? void 0 : fe.key);
        }
        ae(ue);
      },
      [
        j
          .map(function (ue) {
            return ue.key;
          })
          .join("_"),
        q,
        oe,
      ]
    );
    var le = ta(null, { value: n }),
      _e = Ve(le, 2),
      me = _e[0],
      se = _e[1];
    E.useEffect(function () {
      n || (se("rc-tabs-".concat(ML)), (ML += 1));
    }, []);
    function Y(ue, fe) {
      T == null || T(ue, fe);
      var Te = ue !== q;
      X(ue), Te && (M == null || M(ue));
    }
    var ve = {
        id: me,
        activeKey: q,
        animated: V,
        tabPosition: m,
        rtl: N,
        mobile: B,
      },
      de = De(
        De({}, ve),
        {},
        {
          editable: u,
          locale: g,
          moreIcon: _,
          moreTransitionName: y,
          tabBarGutter: v,
          onTabClick: Y,
          onTabScroll: I,
          extra: x,
          style: S,
          panes: null,
          getPopupContainer: R,
          popupClassName: P,
          indicator: F,
        }
      );
    return E.createElement(
      ox.Provider,
      { value: { tabs: j, prefixCls: i } },
      E.createElement(
        "div",
        Et(
          {
            ref: e,
            id: n,
            className: nt(
              i,
              "".concat(i, "-").concat(m),
              be(
                be(
                  be({}, "".concat(i, "-mobile"), B),
                  "".concat(i, "-editable"),
                  u
                ),
                "".concat(i, "-rtl"),
                N
              ),
              o
            ),
          },
          D
        ),
        E.createElement(Joe, Et({}, de, { renderTabBar: A })),
        E.createElement(
          tae,
          Et({ destroyInactiveTabPane: w }, ve, { animated: V })
        )
      )
    );
  });
const oae = { motionAppear: !1, motionEnter: !0, motionLeave: !0 };
function aae(t) {
  let e =
      arguments.length > 1 && arguments[1] !== void 0
        ? arguments[1]
        : { inkBar: !0, tabPane: !1 },
    n;
  return (
    e === !1
      ? (n = { inkBar: !1, tabPane: !1 })
      : e === !0
      ? (n = { inkBar: !0, tabPane: !0 })
      : (n = Object.assign({ inkBar: !0 }, typeof e == "object" ? e : {})),
    n.tabPane &&
      (n.tabPaneMotion = Object.assign(Object.assign({}, oae), {
        motionName: Nk(t, "switch"),
      })),
    n
  );
}
var sae = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
function lae(t) {
  return t.filter((e) => e);
}
function cae(t, e) {
  if (t) return t;
  const n = yf(e).map((r) => {
    if (E.isValidElement(r)) {
      const { key: i, props: o } = r,
        a = o || {},
        { tab: s } = a,
        l = sae(a, ["tab"]);
      return Object.assign(Object.assign({ key: String(i) }, l), { label: s });
    }
    return null;
  });
  return lae(n);
}
const uae = (t) => {
    const { componentCls: e, motionDurationSlow: n } = t;
    return [
      {
        [e]: {
          [`${e}-switch`]: {
            "&-appear, &-enter": {
              transition: "none",
              "&-start": { opacity: 0 },
              "&-active": { opacity: 1, transition: `opacity ${n}` },
            },
            "&-leave": {
              position: "absolute",
              transition: "none",
              inset: 0,
              "&-start": { opacity: 1 },
              "&-active": { opacity: 0, transition: `opacity ${n}` },
            },
          },
        },
      },
      [KI(t, "slide-up"), KI(t, "slide-down")],
    ];
  },
  dae = uae,
  fae = (t) => {
    const {
      componentCls: e,
      tabsCardPadding: n,
      cardBg: r,
      cardGutter: i,
      colorBorderSecondary: o,
      itemSelectedColor: a,
    } = t;
    return {
      [`${e}-card`]: {
        [`> ${e}-nav, > div > ${e}-nav`]: {
          [`${e}-tab`]: {
            margin: 0,
            padding: n,
            background: r,
            border: `${Ze(t.lineWidth)} ${t.lineType} ${o}`,
            transition: `all ${t.motionDurationSlow} ${t.motionEaseInOut}`,
          },
          [`${e}-tab-active`]: { color: a, background: t.colorBgContainer },
          [`${e}-ink-bar`]: { visibility: "hidden" },
        },
        [`&${e}-top, &${e}-bottom`]: {
          [`> ${e}-nav, > div > ${e}-nav`]: {
            [`${e}-tab + ${e}-tab`]: {
              marginLeft: { _skip_check_: !0, value: Ze(i) },
            },
          },
        },
        [`&${e}-top`]: {
          [`> ${e}-nav, > div > ${e}-nav`]: {
            [`${e}-tab`]: {
              borderRadius: `${Ze(t.borderRadiusLG)} ${Ze(
                t.borderRadiusLG
              )} 0 0`,
            },
            [`${e}-tab-active`]: { borderBottomColor: t.colorBgContainer },
          },
        },
        [`&${e}-bottom`]: {
          [`> ${e}-nav, > div > ${e}-nav`]: {
            [`${e}-tab`]: {
              borderRadius: `0 0 ${Ze(t.borderRadiusLG)} ${Ze(
                t.borderRadiusLG
              )}`,
            },
            [`${e}-tab-active`]: { borderTopColor: t.colorBgContainer },
          },
        },
        [`&${e}-left, &${e}-right`]: {
          [`> ${e}-nav, > div > ${e}-nav`]: {
            [`${e}-tab + ${e}-tab`]: { marginTop: Ze(i) },
          },
        },
        [`&${e}-left`]: {
          [`> ${e}-nav, > div > ${e}-nav`]: {
            [`${e}-tab`]: {
              borderRadius: {
                _skip_check_: !0,
                value: `${Ze(t.borderRadiusLG)} 0 0 ${Ze(t.borderRadiusLG)}`,
              },
            },
            [`${e}-tab-active`]: {
              borderRightColor: { _skip_check_: !0, value: t.colorBgContainer },
            },
          },
        },
        [`&${e}-right`]: {
          [`> ${e}-nav, > div > ${e}-nav`]: {
            [`${e}-tab`]: {
              borderRadius: {
                _skip_check_: !0,
                value: `0 ${Ze(t.borderRadiusLG)} ${Ze(t.borderRadiusLG)} 0`,
              },
            },
            [`${e}-tab-active`]: {
              borderLeftColor: { _skip_check_: !0, value: t.colorBgContainer },
            },
          },
        },
      },
    };
  },
  hae = (t) => {
    const {
      componentCls: e,
      itemHoverColor: n,
      dropdownEdgeChildVerticalPadding: r,
    } = t;
    return {
      [`${e}-dropdown`]: Object.assign(Object.assign({}, os(t)), {
        position: "absolute",
        top: -9999,
        left: { _skip_check_: !0, value: -9999 },
        zIndex: t.zIndexPopup,
        display: "block",
        "&-hidden": { display: "none" },
        [`${e}-dropdown-menu`]: {
          maxHeight: t.tabsDropdownHeight,
          margin: 0,
          padding: `${Ze(r)} 0`,
          overflowX: "hidden",
          overflowY: "auto",
          textAlign: { _skip_check_: !0, value: "left" },
          listStyleType: "none",
          backgroundColor: t.colorBgContainer,
          backgroundClip: "padding-box",
          borderRadius: t.borderRadiusLG,
          outline: "none",
          boxShadow: t.boxShadowSecondary,
          "&-item": Object.assign(Object.assign({}, o2), {
            display: "flex",
            alignItems: "center",
            minWidth: t.tabsDropdownWidth,
            margin: 0,
            padding: `${Ze(t.paddingXXS)} ${Ze(t.paddingSM)}`,
            color: t.colorText,
            fontWeight: "normal",
            fontSize: t.fontSize,
            lineHeight: t.lineHeight,
            cursor: "pointer",
            transition: `all ${t.motionDurationSlow}`,
            "> span": { flex: 1, whiteSpace: "nowrap" },
            "&-remove": {
              flex: "none",
              marginLeft: { _skip_check_: !0, value: t.marginSM },
              color: t.colorTextDescription,
              fontSize: t.fontSizeSM,
              background: "transparent",
              border: 0,
              cursor: "pointer",
              "&:hover": { color: n },
            },
            "&:hover": { background: t.controlItemBgHover },
            "&-disabled": {
              "&, &:hover": {
                color: t.colorTextDisabled,
                background: "transparent",
                cursor: "not-allowed",
              },
            },
          }),
        },
      }),
    };
  },
  pae = (t) => {
    const {
      componentCls: e,
      margin: n,
      colorBorderSecondary: r,
      horizontalMargin: i,
      verticalItemPadding: o,
      verticalItemMargin: a,
      calc: s,
    } = t;
    return {
      [`${e}-top, ${e}-bottom`]: {
        flexDirection: "column",
        [`> ${e}-nav, > div > ${e}-nav`]: {
          margin: i,
          "&::before": {
            position: "absolute",
            right: { _skip_check_: !0, value: 0 },
            left: { _skip_check_: !0, value: 0 },
            borderBottom: `${Ze(t.lineWidth)} ${t.lineType} ${r}`,
            content: "''",
          },
          [`${e}-ink-bar`]: {
            height: t.lineWidthBold,
            "&-animated": {
              transition: `width ${t.motionDurationSlow}, left ${t.motionDurationSlow},
            right ${t.motionDurationSlow}`,
            },
          },
          [`${e}-nav-wrap`]: {
            "&::before, &::after": {
              top: 0,
              bottom: 0,
              width: t.controlHeight,
            },
            "&::before": {
              left: { _skip_check_: !0, value: 0 },
              boxShadow: t.boxShadowTabsOverflowLeft,
            },
            "&::after": {
              right: { _skip_check_: !0, value: 0 },
              boxShadow: t.boxShadowTabsOverflowRight,
            },
            [`&${e}-nav-wrap-ping-left::before`]: { opacity: 1 },
            [`&${e}-nav-wrap-ping-right::after`]: { opacity: 1 },
          },
        },
      },
      [`${e}-top`]: {
        [`> ${e}-nav,
        > div > ${e}-nav`]: {
          "&::before": { bottom: 0 },
          [`${e}-ink-bar`]: { bottom: 0 },
        },
      },
      [`${e}-bottom`]: {
        [`> ${e}-nav, > div > ${e}-nav`]: {
          order: 1,
          marginTop: n,
          marginBottom: 0,
          "&::before": { top: 0 },
          [`${e}-ink-bar`]: { top: 0 },
        },
        [`> ${e}-content-holder, > div > ${e}-content-holder`]: { order: 0 },
      },
      [`${e}-left, ${e}-right`]: {
        [`> ${e}-nav, > div > ${e}-nav`]: {
          flexDirection: "column",
          minWidth: s(t.controlHeight).mul(1.25).equal(),
          [`${e}-tab`]: { padding: o, textAlign: "center" },
          [`${e}-tab + ${e}-tab`]: { margin: a },
          [`${e}-nav-wrap`]: {
            flexDirection: "column",
            "&::before, &::after": {
              right: { _skip_check_: !0, value: 0 },
              left: { _skip_check_: !0, value: 0 },
              height: t.controlHeight,
            },
            "&::before": { top: 0, boxShadow: t.boxShadowTabsOverflowTop },
            "&::after": { bottom: 0, boxShadow: t.boxShadowTabsOverflowBottom },
            [`&${e}-nav-wrap-ping-top::before`]: { opacity: 1 },
            [`&${e}-nav-wrap-ping-bottom::after`]: { opacity: 1 },
          },
          [`${e}-ink-bar`]: {
            width: t.lineWidthBold,
            "&-animated": {
              transition: `height ${t.motionDurationSlow}, top ${t.motionDurationSlow}`,
            },
          },
          [`${e}-nav-list, ${e}-nav-operations`]: {
            flex: "1 0 auto",
            flexDirection: "column",
          },
        },
      },
      [`${e}-left`]: {
        [`> ${e}-nav, > div > ${e}-nav`]: {
          [`${e}-ink-bar`]: { right: { _skip_check_: !0, value: 0 } },
        },
        [`> ${e}-content-holder, > div > ${e}-content-holder`]: {
          marginLeft: {
            _skip_check_: !0,
            value: Ze(s(t.lineWidth).mul(-1).equal()),
          },
          borderLeft: {
            _skip_check_: !0,
            value: `${Ze(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
          },
          [`> ${e}-content > ${e}-tabpane`]: {
            paddingLeft: { _skip_check_: !0, value: t.paddingLG },
          },
        },
      },
      [`${e}-right`]: {
        [`> ${e}-nav, > div > ${e}-nav`]: {
          order: 1,
          [`${e}-ink-bar`]: { left: { _skip_check_: !0, value: 0 } },
        },
        [`> ${e}-content-holder, > div > ${e}-content-holder`]: {
          order: 0,
          marginRight: {
            _skip_check_: !0,
            value: s(t.lineWidth).mul(-1).equal(),
          },
          borderRight: {
            _skip_check_: !0,
            value: `${Ze(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
          },
          [`> ${e}-content > ${e}-tabpane`]: {
            paddingRight: { _skip_check_: !0, value: t.paddingLG },
          },
        },
      },
    };
  },
  mae = (t) => {
    const {
      componentCls: e,
      cardPaddingSM: n,
      cardPaddingLG: r,
      horizontalItemPaddingSM: i,
      horizontalItemPaddingLG: o,
    } = t;
    return {
      [e]: {
        "&-small": {
          [`> ${e}-nav`]: {
            [`${e}-tab`]: { padding: i, fontSize: t.titleFontSizeSM },
          },
        },
        "&-large": {
          [`> ${e}-nav`]: {
            [`${e}-tab`]: { padding: o, fontSize: t.titleFontSizeLG },
          },
        },
      },
      [`${e}-card`]: {
        [`&${e}-small`]: {
          [`> ${e}-nav`]: { [`${e}-tab`]: { padding: n } },
          [`&${e}-bottom`]: {
            [`> ${e}-nav ${e}-tab`]: {
              borderRadius: `0 0 ${Ze(t.borderRadius)} ${Ze(t.borderRadius)}`,
            },
          },
          [`&${e}-top`]: {
            [`> ${e}-nav ${e}-tab`]: {
              borderRadius: `${Ze(t.borderRadius)} ${Ze(t.borderRadius)} 0 0`,
            },
          },
          [`&${e}-right`]: {
            [`> ${e}-nav ${e}-tab`]: {
              borderRadius: {
                _skip_check_: !0,
                value: `0 ${Ze(t.borderRadius)} ${Ze(t.borderRadius)} 0`,
              },
            },
          },
          [`&${e}-left`]: {
            [`> ${e}-nav ${e}-tab`]: {
              borderRadius: {
                _skip_check_: !0,
                value: `${Ze(t.borderRadius)} 0 0 ${Ze(t.borderRadius)}`,
              },
            },
          },
        },
        [`&${e}-large`]: { [`> ${e}-nav`]: { [`${e}-tab`]: { padding: r } } },
      },
    };
  },
  gae = (t) => {
    const {
        componentCls: e,
        itemActiveColor: n,
        itemHoverColor: r,
        iconCls: i,
        tabsHorizontalItemMargin: o,
        horizontalItemPadding: a,
        itemSelectedColor: s,
        itemColor: l,
      } = t,
      c = `${e}-tab`;
    return {
      [c]: {
        position: "relative",
        WebkitTouchCallout: "none",
        WebkitTapHighlightColor: "transparent",
        display: "inline-flex",
        alignItems: "center",
        padding: a,
        fontSize: t.titleFontSize,
        background: "transparent",
        border: 0,
        outline: "none",
        cursor: "pointer",
        color: l,
        "&-btn, &-remove": Object.assign(
          { "&:focus:not(:focus-visible), &:active": { color: n } },
          s2(t)
        ),
        "&-btn": {
          outline: "none",
          transition: "all 0.3s",
          [`${c}-icon:not(:last-child)`]: { marginInlineEnd: t.marginSM },
        },
        "&-remove": {
          flex: "none",
          marginRight: {
            _skip_check_: !0,
            value: t.calc(t.marginXXS).mul(-1).equal(),
          },
          marginLeft: { _skip_check_: !0, value: t.marginXS },
          color: t.colorTextDescription,
          fontSize: t.fontSizeSM,
          background: "transparent",
          border: "none",
          outline: "none",
          cursor: "pointer",
          transition: `all ${t.motionDurationSlow}`,
          "&:hover": { color: t.colorTextHeading },
        },
        "&:hover": { color: r },
        [`&${c}-active ${c}-btn`]: {
          color: s,
          textShadow: t.tabsActiveTextShadow,
        },
        [`&${c}-disabled`]: {
          color: t.colorTextDisabled,
          cursor: "not-allowed",
        },
        [`&${c}-disabled ${c}-btn, &${c}-disabled ${e}-remove`]: {
          "&:focus, &:active": { color: t.colorTextDisabled },
        },
        [`& ${c}-remove ${i}`]: { margin: 0 },
        [`${i}:not(:last-child)`]: {
          marginRight: { _skip_check_: !0, value: t.marginSM },
        },
      },
      [`${c} + ${c}`]: { margin: { _skip_check_: !0, value: o } },
    };
  },
  vae = (t) => {
    const {
      componentCls: e,
      tabsHorizontalItemMarginRTL: n,
      iconCls: r,
      cardGutter: i,
      calc: o,
    } = t;
    return {
      [`${e}-rtl`]: {
        direction: "rtl",
        [`${e}-nav`]: {
          [`${e}-tab`]: {
            margin: { _skip_check_: !0, value: n },
            [`${e}-tab:last-of-type`]: {
              marginLeft: { _skip_check_: !0, value: 0 },
            },
            [r]: {
              marginRight: { _skip_check_: !0, value: 0 },
              marginLeft: { _skip_check_: !0, value: Ze(t.marginSM) },
            },
            [`${e}-tab-remove`]: {
              marginRight: { _skip_check_: !0, value: Ze(t.marginXS) },
              marginLeft: {
                _skip_check_: !0,
                value: Ze(o(t.marginXXS).mul(-1).equal()),
              },
              [r]: { margin: 0 },
            },
          },
        },
        [`&${e}-left`]: {
          [`> ${e}-nav`]: { order: 1 },
          [`> ${e}-content-holder`]: { order: 0 },
        },
        [`&${e}-right`]: {
          [`> ${e}-nav`]: { order: 0 },
          [`> ${e}-content-holder`]: { order: 1 },
        },
        [`&${e}-card${e}-top, &${e}-card${e}-bottom`]: {
          [`> ${e}-nav, > div > ${e}-nav`]: {
            [`${e}-tab + ${e}-tab`]: {
              marginRight: { _skip_check_: !0, value: i },
              marginLeft: { _skip_check_: !0, value: 0 },
            },
          },
        },
      },
      [`${e}-dropdown-rtl`]: { direction: "rtl" },
      [`${e}-menu-item`]: {
        [`${e}-dropdown-rtl`]: {
          textAlign: { _skip_check_: !0, value: "right" },
        },
      },
    };
  },
  yae = (t) => {
    const {
      componentCls: e,
      tabsCardPadding: n,
      cardHeight: r,
      cardGutter: i,
      itemHoverColor: o,
      itemActiveColor: a,
      colorBorderSecondary: s,
    } = t;
    return {
      [e]: Object.assign(
        Object.assign(
          Object.assign(Object.assign({}, os(t)), {
            display: "flex",
            [`> ${e}-nav, > div > ${e}-nav`]: {
              position: "relative",
              display: "flex",
              flex: "none",
              alignItems: "center",
              [`${e}-nav-wrap`]: {
                position: "relative",
                display: "flex",
                flex: "auto",
                alignSelf: "stretch",
                overflow: "hidden",
                whiteSpace: "nowrap",
                transform: "translate(0)",
                "&::before, &::after": {
                  position: "absolute",
                  zIndex: 1,
                  opacity: 0,
                  transition: `opacity ${t.motionDurationSlow}`,
                  content: "''",
                  pointerEvents: "none",
                },
              },
              [`${e}-nav-list`]: {
                position: "relative",
                display: "flex",
                transition: `opacity ${t.motionDurationSlow}`,
              },
              [`${e}-nav-operations`]: {
                display: "flex",
                alignSelf: "stretch",
              },
              [`${e}-nav-operations-hidden`]: {
                position: "absolute",
                visibility: "hidden",
                pointerEvents: "none",
              },
              [`${e}-nav-more`]: {
                position: "relative",
                padding: n,
                background: "transparent",
                border: 0,
                color: t.colorText,
                "&::after": {
                  position: "absolute",
                  right: { _skip_check_: !0, value: 0 },
                  bottom: 0,
                  left: { _skip_check_: !0, value: 0 },
                  height: t.calc(t.controlHeightLG).div(8).equal(),
                  transform: "translateY(100%)",
                  content: "''",
                },
              },
              [`${e}-nav-add`]: Object.assign(
                {
                  minWidth: r,
                  minHeight: r,
                  marginLeft: { _skip_check_: !0, value: i },
                  padding: `0 ${Ze(t.paddingXS)}`,
                  background: "transparent",
                  border: `${Ze(t.lineWidth)} ${t.lineType} ${s}`,
                  borderRadius: `${Ze(t.borderRadiusLG)} ${Ze(
                    t.borderRadiusLG
                  )} 0 0`,
                  outline: "none",
                  cursor: "pointer",
                  color: t.colorText,
                  transition: `all ${t.motionDurationSlow} ${t.motionEaseInOut}`,
                  "&:hover": { color: o },
                  "&:active, &:focus:not(:focus-visible)": { color: a },
                },
                s2(t)
              ),
            },
            [`${e}-extra-content`]: { flex: "none" },
            [`${e}-ink-bar`]: {
              position: "absolute",
              background: t.inkBarColor,
              pointerEvents: "none",
            },
          }),
          gae(t)
        ),
        {
          [`${e}-content`]: { position: "relative", width: "100%" },
          [`${e}-content-holder`]: { flex: "auto", minWidth: 0, minHeight: 0 },
          [`${e}-tabpane`]: {
            outline: "none",
            "&-hidden": { display: "none" },
          },
        }
      ),
      [`${e}-centered`]: {
        [`> ${e}-nav, > div > ${e}-nav`]: {
          [`${e}-nav-wrap`]: {
            [`&:not([class*='${e}-nav-wrap-ping'])`]: {
              justifyContent: "center",
            },
          },
        },
      },
    };
  },
  xae = (t) => {
    const e = t.controlHeightLG;
    return {
      zIndexPopup: t.zIndexPopupBase + 50,
      cardBg: t.colorFillAlter,
      cardHeight: e,
      cardPadding: `${
        (e - Math.round(t.fontSize * t.lineHeight)) / 2 - t.lineWidth
      }px ${t.padding}px`,
      cardPaddingSM: `${t.paddingXXS * 1.5}px ${t.padding}px`,
      cardPaddingLG: `${t.paddingXS}px ${t.padding}px ${t.paddingXXS * 1.5}px`,
      titleFontSize: t.fontSize,
      titleFontSizeLG: t.fontSizeLG,
      titleFontSizeSM: t.fontSize,
      inkBarColor: t.colorPrimary,
      horizontalMargin: `0 0 ${t.margin}px 0`,
      horizontalItemGutter: 32,
      horizontalItemMargin: "",
      horizontalItemMarginRTL: "",
      horizontalItemPadding: `${t.paddingSM}px 0`,
      horizontalItemPaddingSM: `${t.paddingXS}px 0`,
      horizontalItemPaddingLG: `${t.padding}px 0`,
      verticalItemPadding: `${t.paddingXS}px ${t.paddingLG}px`,
      verticalItemMargin: `${t.margin}px 0 0 0`,
      itemColor: t.colorText,
      itemSelectedColor: t.colorPrimary,
      itemHoverColor: t.colorPrimaryHover,
      itemActiveColor: t.colorPrimaryActive,
      cardGutter: t.marginXXS / 2,
    };
  },
  Sae = ec(
    "Tabs",
    (t) => {
      const e = xi(t, {
        tabsCardPadding: t.cardPadding,
        dropdownEdgeChildVerticalPadding: t.paddingXXS,
        tabsActiveTextShadow: "0 0 0.25px currentcolor",
        tabsDropdownHeight: 200,
        tabsDropdownWidth: 120,
        tabsHorizontalItemMargin: `0 0 0 ${Ze(t.horizontalItemGutter)}`,
        tabsHorizontalItemMarginRTL: `0 0 0 ${Ze(t.horizontalItemGutter)}`,
      });
      return [mae(e), vae(e), pae(e), hae(e), fae(e), yae(e), dae(e)];
    },
    xae
  ),
  _ae = () => null,
  bae = _ae;
var wae = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const z4 = (t) => {
  var e, n, r, i, o, a;
  const {
      type: s,
      className: l,
      rootClassName: c,
      size: u,
      onEdit: d,
      hideAdd: p,
      centered: m,
      addIcon: v,
      popupClassName: S,
      children: x,
      items: g,
      animated: _,
      style: y,
      indicatorSize: w,
      indicator: A,
    } = t,
    M = wae(t, [
      "type",
      "className",
      "rootClassName",
      "size",
      "onEdit",
      "hideAdd",
      "centered",
      "addIcon",
      "popupClassName",
      "children",
      "items",
      "animated",
      "style",
      "indicatorSize",
      "indicator",
    ]),
    { prefixCls: T, moreIcon: I = E.createElement(Eie, null) } = M,
    {
      direction: R,
      tabs: P,
      getPrefixCls: F,
      getPopupContainer: D,
    } = E.useContext(Rn),
    j = F("tabs", T),
    N = Rm(j),
    [V, W, Q] = Sae(j, N);
  let B;
  s === "editable-card" &&
    (B = {
      onEdit: (J, oe) => {
        let { key: ae, event: le } = oe;
        d == null || d(J === "add" ? le : ae, J);
      },
      removeIcon: E.createElement($J, null),
      addIcon: v || E.createElement(koe, null),
      showAdd: p !== !0,
    });
  const $ = F(),
    G = Tu(u),
    k = cae(g, x),
    q = aae(j, _),
    X = Object.assign(Object.assign({}, P == null ? void 0 : P.style), y),
    ee = {
      align:
        (e = A == null ? void 0 : A.align) !== null && e !== void 0
          ? e
          : (n = P == null ? void 0 : P.indicator) === null || n === void 0
          ? void 0
          : n.align,
      size:
        (a =
          (i =
            (r = A == null ? void 0 : A.size) !== null && r !== void 0
              ? r
              : w) !== null && i !== void 0
            ? i
            : (o = P == null ? void 0 : P.indicator) === null || o === void 0
            ? void 0
            : o.size) !== null && a !== void 0
          ? a
          : P == null
          ? void 0
          : P.indicatorSize,
    };
  return V(
    E.createElement(
      iae,
      Object.assign(
        {
          direction: R,
          getPopupContainer: D,
          moreTransitionName: `${$}-slide-up`,
        },
        M,
        {
          items: k,
          className: nt(
            {
              [`${j}-${G}`]: G,
              [`${j}-card`]: ["card", "editable-card"].includes(s),
              [`${j}-editable-card`]: s === "editable-card",
              [`${j}-centered`]: m,
            },
            P == null ? void 0 : P.className,
            l,
            c,
            W,
            Q,
            N
          ),
          popupClassName: nt(S, W, Q, N),
          style: X,
          editable: B,
          moreIcon: I,
          prefixCls: j,
          animated: q,
          indicator: ee,
        }
      )
    )
  );
};
z4.TabPane = bae;
const Eae = z4;
var Mae = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const Cae = (t) => {
    var { prefixCls: e, className: n, hoverable: r = !0 } = t,
      i = Mae(t, ["prefixCls", "className", "hoverable"]);
    const { getPrefixCls: o } = E.useContext(Rn),
      a = o("card", e),
      s = nt(`${a}-grid`, n, { [`${a}-grid-hoverable`]: r });
    return E.createElement("div", Object.assign({}, i, { className: s }));
  },
  U4 = Cae,
  Tae = (t) => {
    const {
      antCls: e,
      componentCls: n,
      headerHeight: r,
      cardPaddingBase: i,
      tabsMarginBottom: o,
    } = t;
    return Object.assign(
      Object.assign(
        {
          display: "flex",
          justifyContent: "center",
          flexDirection: "column",
          minHeight: r,
          marginBottom: -1,
          padding: `0 ${Ze(i)}`,
          color: t.colorTextHeading,
          fontWeight: t.fontWeightStrong,
          fontSize: t.headerFontSize,
          background: t.headerBg,
          borderBottom: `${Ze(t.lineWidth)} ${t.lineType} ${
            t.colorBorderSecondary
          }`,
          borderRadius: `${Ze(t.borderRadiusLG)} ${Ze(t.borderRadiusLG)} 0 0`,
        },
        Tm()
      ),
      {
        "&-wrapper": { width: "100%", display: "flex", alignItems: "center" },
        "&-title": Object.assign(
          Object.assign({ display: "inline-block", flex: 1 }, o2),
          {
            [`
          > ${n}-typography,
          > ${n}-typography-edit-content
        `]: { insetInlineStart: 0, marginTop: 0, marginBottom: 0 },
          }
        ),
        [`${e}-tabs-top`]: {
          clear: "both",
          marginBottom: o,
          color: t.colorText,
          fontWeight: "normal",
          fontSize: t.fontSize,
          "&-bar": {
            borderBottom: `${Ze(t.lineWidth)} ${t.lineType} ${
              t.colorBorderSecondary
            }`,
          },
        },
      }
    );
  },
  Aae = (t) => {
    const {
      cardPaddingBase: e,
      colorBorderSecondary: n,
      cardShadow: r,
      lineWidth: i,
    } = t;
    return {
      width: "33.33%",
      padding: e,
      border: 0,
      borderRadius: 0,
      boxShadow: `
      ${Ze(i)} 0 0 0 ${n},
      0 ${Ze(i)} 0 0 ${n},
      ${Ze(i)} ${Ze(i)} 0 0 ${n},
      ${Ze(i)} 0 0 0 ${n} inset,
      0 ${Ze(i)} 0 0 ${n} inset;
    `,
      transition: `all ${t.motionDurationMid}`,
      "&-hoverable:hover": { position: "relative", zIndex: 1, boxShadow: r },
    };
  },
  Rae = (t) => {
    const {
      componentCls: e,
      iconCls: n,
      actionsLiMargin: r,
      cardActionsIconSize: i,
      colorBorderSecondary: o,
      actionsBg: a,
    } = t;
    return Object.assign(
      Object.assign(
        {
          margin: 0,
          padding: 0,
          listStyle: "none",
          background: a,
          borderTop: `${Ze(t.lineWidth)} ${t.lineType} ${o}`,
          display: "flex",
          borderRadius: `0 0 ${Ze(t.borderRadiusLG)} ${Ze(t.borderRadiusLG)}`,
        },
        Tm()
      ),
      {
        "& > li": {
          margin: r,
          color: t.colorTextDescription,
          textAlign: "center",
          "> span": {
            position: "relative",
            display: "block",
            minWidth: t.calc(t.cardActionsIconSize).mul(2).equal(),
            fontSize: t.fontSize,
            lineHeight: t.lineHeight,
            cursor: "pointer",
            "&:hover": {
              color: t.colorPrimary,
              transition: `color ${t.motionDurationMid}`,
            },
            [`a:not(${e}-btn), > ${n}`]: {
              display: "inline-block",
              width: "100%",
              color: t.colorTextDescription,
              lineHeight: Ze(t.fontHeight),
              transition: `color ${t.motionDurationMid}`,
              "&:hover": { color: t.colorPrimary },
            },
            [`> ${n}`]: {
              fontSize: i,
              lineHeight: Ze(t.calc(i).mul(t.lineHeight).equal()),
            },
          },
          "&:not(:last-child)": {
            borderInlineEnd: `${Ze(t.lineWidth)} ${t.lineType} ${o}`,
          },
        },
      }
    );
  },
  Pae = (t) =>
    Object.assign(
      Object.assign(
        {
          margin: `${Ze(t.calc(t.marginXXS).mul(-1).equal())} 0`,
          display: "flex",
        },
        Tm()
      ),
      {
        "&-avatar": { paddingInlineEnd: t.padding },
        "&-detail": {
          overflow: "hidden",
          flex: 1,
          "> div:not(:last-child)": { marginBottom: t.marginXS },
        },
        "&-title": Object.assign(
          {
            color: t.colorTextHeading,
            fontWeight: t.fontWeightStrong,
            fontSize: t.fontSizeLG,
          },
          o2
        ),
        "&-description": { color: t.colorTextDescription },
      }
    ),
  Iae = (t) => {
    const { componentCls: e, cardPaddingBase: n, colorFillAlter: r } = t;
    return {
      [`${e}-head`]: {
        padding: `0 ${Ze(n)}`,
        background: r,
        "&-title": { fontSize: t.fontSize },
      },
      [`${e}-body`]: { padding: `${Ze(t.padding)} ${Ze(n)}` },
    };
  },
  Lae = (t) => {
    const { componentCls: e } = t;
    return { overflow: "hidden", [`${e}-body`]: { userSelect: "none" } };
  },
  Oae = (t) => {
    const {
      antCls: e,
      componentCls: n,
      cardShadow: r,
      cardHeadPadding: i,
      colorBorderSecondary: o,
      boxShadowTertiary: a,
      cardPaddingBase: s,
      extraColor: l,
    } = t;
    return {
      [n]: Object.assign(Object.assign({}, os(t)), {
        position: "relative",
        background: t.colorBgContainer,
        borderRadius: t.borderRadiusLG,
        [`&:not(${n}-bordered)`]: { boxShadow: a },
        [`${n}-head`]: Tae(t),
        [`${n}-extra`]: {
          marginInlineStart: "auto",
          color: l,
          fontWeight: "normal",
          fontSize: t.fontSize,
        },
        [`${n}-body`]: Object.assign(
          {
            padding: s,
            borderRadius: ` 0 0 ${Ze(t.borderRadiusLG)} ${Ze(
              t.borderRadiusLG
            )}`,
          },
          Tm()
        ),
        [`${n}-grid`]: Aae(t),
        [`${n}-cover`]: {
          "> *": { display: "block", width: "100%" },
          [`img, img + ${e}-image-mask`]: {
            borderRadius: `${Ze(t.borderRadiusLG)} ${Ze(t.borderRadiusLG)} 0 0`,
          },
        },
        [`${n}-actions`]: Rae(t),
        [`${n}-meta`]: Pae(t),
      }),
      [`${n}-bordered`]: {
        border: `${Ze(t.lineWidth)} ${t.lineType} ${o}`,
        [`${n}-cover`]: {
          marginTop: -1,
          marginInlineStart: -1,
          marginInlineEnd: -1,
        },
      },
      [`${n}-hoverable`]: {
        cursor: "pointer",
        transition: `box-shadow ${t.motionDurationMid}, border-color ${t.motionDurationMid}`,
        "&:hover": { borderColor: "transparent", boxShadow: r },
      },
      [`${n}-contain-grid`]: {
        borderRadius: `${Ze(t.borderRadiusLG)} ${Ze(t.borderRadiusLG)} 0 0 `,
        [`${n}-body`]: { display: "flex", flexWrap: "wrap" },
        [`&:not(${n}-loading) ${n}-body`]: {
          marginBlockStart: t.calc(t.lineWidth).mul(-1).equal(),
          marginInlineStart: t.calc(t.lineWidth).mul(-1).equal(),
          padding: 0,
        },
      },
      [`${n}-contain-tabs`]: {
        [`> ${n}-head`]: {
          minHeight: 0,
          [`${n}-head-title, ${n}-extra`]: { paddingTop: i },
        },
      },
      [`${n}-type-inner`]: Iae(t),
      [`${n}-loading`]: Lae(t),
      [`${n}-rtl`]: { direction: "rtl" },
    };
  },
  Nae = (t) => {
    const {
      componentCls: e,
      cardPaddingSM: n,
      headerHeightSM: r,
      headerFontSizeSM: i,
    } = t;
    return {
      [`${e}-small`]: {
        [`> ${e}-head`]: {
          minHeight: r,
          padding: `0 ${Ze(n)}`,
          fontSize: i,
          [`> ${e}-head-wrapper`]: {
            [`> ${e}-extra`]: { fontSize: t.fontSize },
          },
        },
        [`> ${e}-body`]: { padding: n },
      },
      [`${e}-small${e}-contain-tabs`]: {
        [`> ${e}-head`]: {
          [`${e}-head-title, ${e}-extra`]: {
            paddingTop: 0,
            display: "flex",
            alignItems: "center",
          },
        },
      },
    };
  },
  Fae = (t) => ({
    headerBg: "transparent",
    headerFontSize: t.fontSizeLG,
    headerFontSizeSM: t.fontSize,
    headerHeight: t.fontSizeLG * t.lineHeightLG + t.padding * 2,
    headerHeightSM: t.fontSize * t.lineHeight + t.paddingXS * 2,
    actionsBg: t.colorBgContainer,
    actionsLiMargin: `${t.paddingSM}px 0`,
    tabsMarginBottom: -t.padding - t.lineWidth,
    extraColor: t.colorText,
  }),
  Dae = ec(
    "Card",
    (t) => {
      const e = xi(t, {
        cardShadow: t.boxShadowCard,
        cardHeadPadding: t.padding,
        cardPaddingBase: t.paddingLG,
        cardActionsIconSize: t.fontSize,
        cardPaddingSM: 12,
      });
      return [Oae(e), Nae(e)];
    },
    Fae
  );
var CL = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const zae = (t) => {
    const { prefixCls: e, actions: n = [] } = t;
    return E.createElement(
      "ul",
      { className: `${e}-actions` },
      n.map((r, i) => {
        const o = `action-${i}`;
        return E.createElement(
          "li",
          { style: { width: `${100 / n.length}%` }, key: o },
          E.createElement("span", null, r)
        );
      })
    );
  },
  Uae = E.forwardRef((t, e) => {
    const {
        prefixCls: n,
        className: r,
        rootClassName: i,
        style: o,
        extra: a,
        headStyle: s = {},
        bodyStyle: l = {},
        title: c,
        loading: u,
        bordered: d = !0,
        size: p,
        type: m,
        cover: v,
        actions: S,
        tabList: x,
        children: g,
        activeTabKey: _,
        defaultActiveTabKey: y,
        tabBarExtraContent: w,
        hoverable: A,
        tabProps: M = {},
      } = t,
      T = CL(t, [
        "prefixCls",
        "className",
        "rootClassName",
        "style",
        "extra",
        "headStyle",
        "bodyStyle",
        "title",
        "loading",
        "bordered",
        "size",
        "type",
        "cover",
        "actions",
        "tabList",
        "children",
        "activeTabKey",
        "defaultActiveTabKey",
        "tabBarExtraContent",
        "hoverable",
        "tabProps",
      ]),
      { getPrefixCls: I, direction: R, card: P } = E.useContext(Rn),
      F = (me) => {
        var se;
        (se = t.onTabChange) === null || se === void 0 || se.call(t, me);
      },
      D = E.useMemo(() => {
        let me = !1;
        return (
          E.Children.forEach(g, (se) => {
            se && se.type && se.type === U4 && (me = !0);
          }),
          me
        );
      }, [g]),
      j = I("card", n),
      [N, V, W] = Dae(j),
      Q = E.createElement(
        Foe,
        { loading: !0, active: !0, paragraph: { rows: 4 }, title: !1 },
        g
      ),
      B = _ !== void 0,
      $ = Object.assign(Object.assign({}, M), {
        [B ? "activeKey" : "defaultActiveKey"]: B ? _ : y,
        tabBarExtraContent: w,
      });
    let G;
    const k = Tu(p),
      q = !k || k === "default" ? "large" : k,
      X = x
        ? E.createElement(
            Eae,
            Object.assign({ size: q }, $, {
              className: `${j}-head-tabs`,
              onChange: F,
              items: x.map((me) => {
                var { tab: se } = me,
                  Y = CL(me, ["tab"]);
                return Object.assign({ label: se }, Y);
              }),
            })
          )
        : null;
    (c || a || X) &&
      (G = E.createElement(
        "div",
        { className: `${j}-head`, style: s },
        E.createElement(
          "div",
          { className: `${j}-head-wrapper` },
          c && E.createElement("div", { className: `${j}-head-title` }, c),
          a && E.createElement("div", { className: `${j}-extra` }, a)
        ),
        X
      ));
    const ee = v
        ? E.createElement("div", { className: `${j}-cover` }, v)
        : null,
      J = E.createElement(
        "div",
        { className: `${j}-body`, style: l },
        u ? Q : g
      ),
      oe =
        S && S.length
          ? E.createElement(zae, { prefixCls: j, actions: S })
          : null,
      ae = Ys(T, ["onTabChange"]),
      le = nt(
        j,
        P == null ? void 0 : P.className,
        {
          [`${j}-loading`]: u,
          [`${j}-bordered`]: d,
          [`${j}-hoverable`]: A,
          [`${j}-contain-grid`]: D,
          [`${j}-contain-tabs`]: x && x.length,
          [`${j}-${k}`]: k,
          [`${j}-type-${m}`]: !!m,
          [`${j}-rtl`]: R === "rtl",
        },
        r,
        i,
        V,
        W
      ),
      _e = Object.assign(Object.assign({}, P == null ? void 0 : P.style), o);
    return N(
      E.createElement(
        "div",
        Object.assign({ ref: e }, ae, { className: le, style: _e }),
        G,
        ee,
        J,
        oe
      )
    );
  }),
  kae = Uae;
var Bae = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const Hae = (t) => {
    const {
        prefixCls: e,
        className: n,
        avatar: r,
        title: i,
        description: o,
      } = t,
      a = Bae(t, ["prefixCls", "className", "avatar", "title", "description"]),
      { getPrefixCls: s } = E.useContext(Rn),
      l = s("card", e),
      c = nt(`${l}-meta`, n),
      u = r
        ? E.createElement("div", { className: `${l}-meta-avatar` }, r)
        : null,
      d = i
        ? E.createElement("div", { className: `${l}-meta-title` }, i)
        : null,
      p = o
        ? E.createElement("div", { className: `${l}-meta-description` }, o)
        : null,
      m =
        d || p
          ? E.createElement("div", { className: `${l}-meta-detail` }, d, p)
          : null;
    return E.createElement("div", Object.assign({}, a, { className: c }), u, m);
  },
  jae = Hae,
  P2 = kae;
P2.Grid = U4;
P2.Meta = jae;
const TL = P2,
  Vae = (t) => {
    const {
      componentCls: e,
      sizePaddingEdgeHorizontal: n,
      colorSplit: r,
      lineWidth: i,
      textPaddingInline: o,
      orientationMargin: a,
      verticalMarginInline: s,
    } = t;
    return {
      [e]: Object.assign(Object.assign({}, os(t)), {
        borderBlockStart: `${Ze(i)} solid ${r}`,
        "&-vertical": {
          position: "relative",
          top: "-0.06em",
          display: "inline-block",
          height: "0.9em",
          marginInline: s,
          marginBlock: 0,
          verticalAlign: "middle",
          borderTop: 0,
          borderInlineStart: `${Ze(i)} solid ${r}`,
        },
        "&-horizontal": {
          display: "flex",
          clear: "both",
          width: "100%",
          minWidth: "100%",
          margin: `${Ze(t.dividerHorizontalGutterMargin)} 0`,
        },
        [`&-horizontal${e}-with-text`]: {
          display: "flex",
          alignItems: "center",
          margin: `${Ze(t.dividerHorizontalWithTextGutterMargin)} 0`,
          color: t.colorTextHeading,
          fontWeight: 500,
          fontSize: t.fontSizeLG,
          whiteSpace: "nowrap",
          textAlign: "center",
          borderBlockStart: `0 ${r}`,
          "&::before, &::after": {
            position: "relative",
            width: "50%",
            borderBlockStart: `${Ze(i)} solid transparent`,
            borderBlockStartColor: "inherit",
            borderBlockEnd: 0,
            transform: "translateY(50%)",
            content: "''",
          },
        },
        [`&-horizontal${e}-with-text-left`]: {
          "&::before": { width: `calc(${a} * 100%)` },
          "&::after": { width: `calc(100% - ${a} * 100%)` },
        },
        [`&-horizontal${e}-with-text-right`]: {
          "&::before": { width: `calc(100% - ${a} * 100%)` },
          "&::after": { width: `calc(${a} * 100%)` },
        },
        [`${e}-inner-text`]: {
          display: "inline-block",
          paddingBlock: 0,
          paddingInline: o,
        },
        "&-dashed": {
          background: "none",
          borderColor: r,
          borderStyle: "dashed",
          borderWidth: `${Ze(i)} 0 0`,
        },
        [`&-horizontal${e}-with-text${e}-dashed`]: {
          "&::before, &::after": { borderStyle: "dashed none none" },
        },
        [`&-vertical${e}-dashed`]: {
          borderInlineStartWidth: i,
          borderInlineEnd: 0,
          borderBlockStart: 0,
          borderBlockEnd: 0,
        },
        [`&-plain${e}-with-text`]: {
          color: t.colorText,
          fontWeight: "normal",
          fontSize: t.fontSize,
        },
        [`&-horizontal${e}-with-text-left${e}-no-default-orientation-margin-left`]:
          {
            "&::before": { width: 0 },
            "&::after": { width: "100%" },
            [`${e}-inner-text`]: { paddingInlineStart: n },
          },
        [`&-horizontal${e}-with-text-right${e}-no-default-orientation-margin-right`]:
          {
            "&::before": { width: "100%" },
            "&::after": { width: 0 },
            [`${e}-inner-text`]: { paddingInlineEnd: n },
          },
      }),
    };
  },
  $ae = (t) => ({
    textPaddingInline: "1em",
    orientationMargin: 0.05,
    verticalMarginInline: t.marginXS,
  }),
  Gae = ec(
    "Divider",
    (t) => {
      const e = xi(t, {
        dividerHorizontalWithTextGutterMargin: t.margin,
        dividerHorizontalGutterMargin: t.marginLG,
        sizePaddingEdgeHorizontal: 0,
      });
      return [Vae(e)];
    },
    $ae,
    { unitless: { orientationMargin: !0 } }
  );
var Wae = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const Xae = (t) => {
    const { getPrefixCls: e, direction: n, divider: r } = E.useContext(Rn),
      {
        prefixCls: i,
        type: o = "horizontal",
        orientation: a = "center",
        orientationMargin: s,
        className: l,
        rootClassName: c,
        children: u,
        dashed: d,
        plain: p,
        style: m,
      } = t,
      v = Wae(t, [
        "prefixCls",
        "type",
        "orientation",
        "orientationMargin",
        "className",
        "rootClassName",
        "children",
        "dashed",
        "plain",
        "style",
      ]),
      S = e("divider", i),
      [x, g, _] = Gae(S),
      y = a.length > 0 ? `-${a}` : a,
      w = !!u,
      A = a === "left" && s != null,
      M = a === "right" && s != null,
      T = nt(
        S,
        r == null ? void 0 : r.className,
        g,
        _,
        `${S}-${o}`,
        {
          [`${S}-with-text`]: w,
          [`${S}-with-text${y}`]: w,
          [`${S}-dashed`]: !!d,
          [`${S}-plain`]: !!p,
          [`${S}-rtl`]: n === "rtl",
          [`${S}-no-default-orientation-margin-left`]: A,
          [`${S}-no-default-orientation-margin-right`]: M,
        },
        l,
        c
      ),
      I = E.useMemo(
        () => (typeof s == "number" ? s : /^\d+$/.test(s) ? Number(s) : s),
        [s]
      ),
      R = Object.assign(
        Object.assign({}, A && { marginLeft: I }),
        M && { marginRight: I }
      );
    return x(
      E.createElement(
        "div",
        Object.assign(
          {
            className: T,
            style: Object.assign(
              Object.assign({}, r == null ? void 0 : r.style),
              m
            ),
          },
          v,
          { role: "separator" }
        ),
        u &&
          o !== "vertical" &&
          E.createElement("span", { className: `${S}-inner-text`, style: R }, u)
      )
    );
  },
  r0 = Xae;
function qae(t) {
  return !!(t.addonBefore || t.addonAfter);
}
function Kae(t) {
  return !!(t.prefix || t.suffix || t.allowClear);
}
function Oy(t, e, n, r) {
  if (n) {
    var i = e;
    if (e.type === "click") {
      var o = t.cloneNode(!0);
      (i = Object.create(e, {
        target: { value: o },
        currentTarget: { value: o },
      })),
        (o.value = ""),
        n(i);
      return;
    }
    if (t.type !== "file" && r !== void 0) {
      var a = t.cloneNode(!0);
      (i = Object.create(e, {
        target: { value: a },
        currentTarget: { value: a },
      })),
        (a.value = r),
        n(i);
      return;
    }
    n(i);
  }
}
function Yae(t, e) {
  if (t) {
    t.focus(e);
    var n = e || {},
      r = n.cursor;
    if (r) {
      var i = t.value.length;
      switch (r) {
        case "start":
          t.setSelectionRange(0, 0);
          break;
        case "end":
          t.setSelectionRange(i, i);
          break;
        default:
          t.setSelectionRange(0, i);
      }
    }
  }
}
var k4 = function (e) {
    var n,
      r,
      i = e.inputElement,
      o = e.children,
      a = e.prefixCls,
      s = e.prefix,
      l = e.suffix,
      c = e.addonBefore,
      u = e.addonAfter,
      d = e.className,
      p = e.style,
      m = e.disabled,
      v = e.readOnly,
      S = e.focused,
      x = e.triggerFocus,
      g = e.allowClear,
      _ = e.value,
      y = e.handleReset,
      w = e.hidden,
      A = e.classes,
      M = e.classNames,
      T = e.dataAttrs,
      I = e.styles,
      R = e.components,
      P = o ?? i,
      F = (R == null ? void 0 : R.affixWrapper) || "span",
      D = (R == null ? void 0 : R.groupWrapper) || "span",
      j = (R == null ? void 0 : R.wrapper) || "span",
      N = (R == null ? void 0 : R.groupAddon) || "span",
      V = E.useRef(null),
      W = function (de) {
        var ue;
        (ue = V.current) !== null &&
          ue !== void 0 &&
          ue.contains(de.target) &&
          (x == null || x());
      },
      Q = Kae(e),
      B = E.cloneElement(P, {
        value: _,
        className:
          nt(P.props.className, !Q && (M == null ? void 0 : M.variant)) || null,
      });
    if (Q) {
      var $,
        G = null;
      if (g) {
        var k,
          q = !m && !v && _,
          X = "".concat(a, "-clear-icon"),
          ee =
            un(g) === "object" && g !== null && g !== void 0 && g.clearIcon
              ? g.clearIcon
              : "";
        G = at.createElement(
          "span",
          {
            onClick: y,
            onMouseDown: function (de) {
              return de.preventDefault();
            },
            className: nt(
              X,
              ((k = {}),
              be(k, "".concat(X, "-hidden"), !q),
              be(k, "".concat(X, "-has-suffix"), !!l),
              k)
            ),
            role: "button",
            tabIndex: -1,
          },
          ee
        );
      }
      var J = "".concat(a, "-affix-wrapper"),
        oe = nt(
          J,
          (($ = {}),
          be($, "".concat(a, "-disabled"), m),
          be($, "".concat(J, "-disabled"), m),
          be($, "".concat(J, "-focused"), S),
          be($, "".concat(J, "-readonly"), v),
          be($, "".concat(J, "-input-with-clear-btn"), l && g && _),
          $),
          A == null ? void 0 : A.affixWrapper,
          M == null ? void 0 : M.affixWrapper,
          M == null ? void 0 : M.variant
        ),
        ae =
          (l || g) &&
          at.createElement(
            "span",
            {
              className: nt(
                "".concat(a, "-suffix"),
                M == null ? void 0 : M.suffix
              ),
              style: I == null ? void 0 : I.suffix,
            },
            G,
            l
          );
      B = at.createElement(
        F,
        Et(
          {
            className: oe,
            style: I == null ? void 0 : I.affixWrapper,
            onClick: W,
          },
          T == null ? void 0 : T.affixWrapper,
          { ref: V }
        ),
        s &&
          at.createElement(
            "span",
            {
              className: nt(
                "".concat(a, "-prefix"),
                M == null ? void 0 : M.prefix
              ),
              style: I == null ? void 0 : I.prefix,
            },
            s
          ),
        B,
        ae
      );
    }
    if (qae(e)) {
      var le = "".concat(a, "-group"),
        _e = "".concat(le, "-addon"),
        me = "".concat(le, "-wrapper"),
        se = nt(
          "".concat(a, "-wrapper"),
          le,
          A == null ? void 0 : A.wrapper,
          M == null ? void 0 : M.wrapper
        ),
        Y = nt(
          me,
          be({}, "".concat(me, "-disabled"), m),
          A == null ? void 0 : A.group,
          M == null ? void 0 : M.groupWrapper
        );
      B = at.createElement(
        D,
        { className: Y },
        at.createElement(
          j,
          { className: se },
          c && at.createElement(N, { className: _e }, c),
          B,
          u && at.createElement(N, { className: _e }, u)
        )
      );
    }
    return at.cloneElement(B, {
      className:
        nt((n = B.props) === null || n === void 0 ? void 0 : n.className, d) ||
        null,
      style: De(
        De({}, (r = B.props) === null || r === void 0 ? void 0 : r.style),
        p
      ),
      hidden: w,
    });
  },
  Zae = ["show"];
function B4(t, e) {
  return E.useMemo(
    function () {
      var n = {};
      e && (n.show = un(e) === "object" && e.formatter ? e.formatter : !!e),
        (n = De(De({}, n), t));
      var r = n,
        i = r.show,
        o = on(r, Zae);
      return De(
        De({}, o),
        {},
        {
          show: !!i,
          showFormatter: typeof i == "function" ? i : void 0,
          strategy:
            o.strategy ||
            function (a) {
              return a.length;
            },
        }
      );
    },
    [t, e]
  );
}
var Qae = [
    "autoComplete",
    "onChange",
    "onFocus",
    "onBlur",
    "onPressEnter",
    "onKeyDown",
    "prefixCls",
    "disabled",
    "htmlSize",
    "className",
    "maxLength",
    "suffix",
    "showCount",
    "count",
    "type",
    "classes",
    "classNames",
    "styles",
    "onCompositionStart",
    "onCompositionEnd",
  ],
  Jae = E.forwardRef(function (t, e) {
    var n = t.autoComplete,
      r = t.onChange,
      i = t.onFocus,
      o = t.onBlur,
      a = t.onPressEnter,
      s = t.onKeyDown,
      l = t.prefixCls,
      c = l === void 0 ? "rc-input" : l,
      u = t.disabled,
      d = t.htmlSize,
      p = t.className,
      m = t.maxLength,
      v = t.suffix,
      S = t.showCount,
      x = t.count,
      g = t.type,
      _ = g === void 0 ? "text" : g,
      y = t.classes,
      w = t.classNames,
      A = t.styles,
      M = t.onCompositionStart,
      T = t.onCompositionEnd,
      I = on(t, Qae),
      R = E.useState(!1),
      P = Ve(R, 2),
      F = P[0],
      D = P[1],
      j = E.useRef(!1),
      N = E.useRef(null),
      V = function (z) {
        N.current && Yae(N.current, z);
      },
      W = ta(t.defaultValue, { value: t.value }),
      Q = Ve(W, 2),
      B = Q[0],
      $ = Q[1],
      G = B == null ? "" : String(B),
      k = E.useState(null),
      q = Ve(k, 2),
      X = q[0],
      ee = q[1],
      J = B4(x, S),
      oe = J.max || m,
      ae = J.strategy(G),
      le = !!oe && ae > oe;
    E.useImperativeHandle(e, function () {
      return {
        focus: V,
        blur: function () {
          var z;
          (z = N.current) === null || z === void 0 || z.blur();
        },
        setSelectionRange: function (z, Z, ge) {
          var ce;
          (ce = N.current) === null ||
            ce === void 0 ||
            ce.setSelectionRange(z, Z, ge);
        },
        select: function () {
          var z;
          (z = N.current) === null || z === void 0 || z.select();
        },
        input: N.current,
      };
    }),
      E.useEffect(
        function () {
          D(function (H) {
            return H && u ? !1 : H;
          });
        },
        [u]
      );
    var _e = function (z, Z, ge) {
      var ce = Z;
      if (!j.current && J.exceedFormatter && J.max && J.strategy(Z) > J.max) {
        if (((ce = J.exceedFormatter(Z, { max: J.max })), Z !== ce)) {
          var he, Me;
          ee([
            ((he = N.current) === null || he === void 0
              ? void 0
              : he.selectionStart) || 0,
            ((Me = N.current) === null || Me === void 0
              ? void 0
              : Me.selectionEnd) || 0,
          ]);
        }
      } else if (ge.source === "compositionEnd") return;
      $(ce), N.current && Oy(N.current, z, r, ce);
    };
    E.useEffect(
      function () {
        if (X) {
          var H;
          (H = N.current) === null ||
            H === void 0 ||
            H.setSelectionRange.apply(H, It(X));
        }
      },
      [X]
    );
    var me = function (z) {
        _e(z, z.target.value, { source: "change" });
      },
      se = function (z) {
        (j.current = !1),
          _e(z, z.currentTarget.value, { source: "compositionEnd" }),
          T == null || T(z);
      },
      Y = function (z) {
        a && z.key === "Enter" && a(z), s == null || s(z);
      },
      ve = function (z) {
        D(!0), i == null || i(z);
      },
      de = function (z) {
        D(!1), o == null || o(z);
      },
      ue = function (z) {
        $(""), V(), N.current && Oy(N.current, z, r);
      },
      fe = le && "".concat(c, "-out-of-range"),
      Te = function () {
        var z = Ys(t, [
          "prefixCls",
          "onPressEnter",
          "addonBefore",
          "addonAfter",
          "prefix",
          "suffix",
          "allowClear",
          "defaultValue",
          "showCount",
          "count",
          "classes",
          "htmlSize",
          "styles",
          "classNames",
        ]);
        return at.createElement(
          "input",
          Et({ autoComplete: n }, z, {
            onChange: me,
            onFocus: ve,
            onBlur: de,
            onKeyDown: Y,
            className: nt(
              c,
              be({}, "".concat(c, "-disabled"), u),
              w == null ? void 0 : w.input
            ),
            style: A == null ? void 0 : A.input,
            ref: N,
            size: d,
            type: _,
            onCompositionStart: function (ge) {
              (j.current = !0), M == null || M(ge);
            },
            onCompositionEnd: se,
          })
        );
      },
      pe = function () {
        var z = Number(oe) > 0;
        if (v || J.show) {
          var Z = J.showFormatter
            ? J.showFormatter({ value: G, count: ae, maxLength: oe })
            : "".concat(ae).concat(z ? " / ".concat(oe) : "");
          return at.createElement(
            at.Fragment,
            null,
            J.show &&
              at.createElement(
                "span",
                {
                  className: nt(
                    "".concat(c, "-show-count-suffix"),
                    be({}, "".concat(c, "-show-count-has-suffix"), !!v),
                    w == null ? void 0 : w.count
                  ),
                  style: De({}, A == null ? void 0 : A.count),
                },
                Z
              ),
            v
          );
        }
        return null;
      };
    return at.createElement(
      k4,
      Et({}, I, {
        prefixCls: c,
        className: nt(p, fe),
        handleReset: ue,
        value: G,
        focused: F,
        triggerFocus: V,
        suffix: pe(),
        disabled: u,
        classes: y,
        classNames: w,
        styles: A,
      }),
      Te()
    );
  });
const ese = (t) => {
    const { getPrefixCls: e, direction: n } = E.useContext(Rn),
      { prefixCls: r, className: i } = t,
      o = e("input-group", r),
      a = e("input"),
      [s, l] = R2(a),
      c = nt(
        o,
        {
          [`${o}-lg`]: t.size === "large",
          [`${o}-sm`]: t.size === "small",
          [`${o}-compact`]: t.compact,
          [`${o}-rtl`]: n === "rtl",
        },
        l,
        i
      ),
      u = E.useContext(mu),
      d = E.useMemo(
        () => Object.assign(Object.assign({}, u), { isFormItemInput: !1 }),
        [u]
      );
    return s(
      E.createElement(
        "span",
        {
          className: c,
          style: t.style,
          onMouseEnter: t.onMouseEnter,
          onMouseLeave: t.onMouseLeave,
          onFocus: t.onFocus,
          onBlur: t.onBlur,
        },
        E.createElement(mu.Provider, { value: d }, t.children)
      )
    );
  },
  tse = ese;
function H4(t, e) {
  const n = E.useRef([]),
    r = () => {
      n.current.push(
        setTimeout(() => {
          var i, o, a, s;
          !((i = t.current) === null || i === void 0) &&
            i.input &&
            ((o = t.current) === null || o === void 0
              ? void 0
              : o.input.getAttribute("type")) === "password" &&
            !((a = t.current) === null || a === void 0) &&
            a.input.hasAttribute("value") &&
            ((s = t.current) === null ||
              s === void 0 ||
              s.input.removeAttribute("value"));
        })
      );
    };
  return (
    E.useEffect(
      () => (
        e && r(),
        () =>
          n.current.forEach((i) => {
            i && clearTimeout(i);
          })
      ),
      []
    ),
    r
  );
}
function nse(t) {
  return !!(t.prefix || t.suffix || t.allowClear || t.showCount);
}
const rse = (t) => {
  let e;
  return (
    typeof t == "object" && t != null && t.clearIcon
      ? (e = t)
      : t && (e = { clearIcon: at.createElement(d2, null) }),
    e
  );
};
var ise = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
function ose(t, e) {
  if (!t) return;
  t.focus(e);
  const { cursor: n } = e || {};
  if (n) {
    const r = t.value.length;
    switch (n) {
      case "start":
        t.setSelectionRange(0, 0);
        break;
      case "end":
        t.setSelectionRange(r, r);
        break;
      default:
        t.setSelectionRange(0, r);
        break;
    }
  }
}
const ase = E.forwardRef((t, e) => {
    var n;
    const {
        prefixCls: r,
        bordered: i = !0,
        status: o,
        size: a,
        disabled: s,
        onBlur: l,
        onFocus: c,
        suffix: u,
        allowClear: d,
        addonAfter: p,
        addonBefore: m,
        className: v,
        style: S,
        styles: x,
        rootClassName: g,
        onChange: _,
        classNames: y,
        variant: w,
      } = t,
      A = ise(t, [
        "prefixCls",
        "bordered",
        "status",
        "size",
        "disabled",
        "onBlur",
        "onFocus",
        "suffix",
        "allowClear",
        "addonAfter",
        "addonBefore",
        "className",
        "style",
        "styles",
        "rootClassName",
        "onChange",
        "classNames",
        "variant",
      ]),
      { getPrefixCls: M, direction: T, input: I } = at.useContext(Rn),
      R = M("input", r),
      P = E.useRef(null),
      F = Rm(R),
      [D, j, N] = R2(R, F),
      { compactSize: V, compactItemClassnames: W } = g2(R, T),
      Q = Tu((ve) => {
        var de;
        return (de = a ?? V) !== null && de !== void 0 ? de : ve;
      }),
      B = at.useContext(Cm),
      $ = s ?? B,
      { status: G, hasFeedback: k, feedbackIcon: q } = E.useContext(mu),
      X = r4(G, o),
      ee = nse(t) || !!k;
    E.useRef(ee);
    const J = H4(P, !0),
      oe = (ve) => {
        J(), l == null || l(ve);
      },
      ae = (ve) => {
        J(), c == null || c(ve);
      },
      le = (ve) => {
        J(), _ == null || _(ve);
      },
      _e = (k || u) && at.createElement(at.Fragment, null, u, k && q),
      me = rse(d),
      [se, Y] = i4(w, i);
    return D(
      at.createElement(
        Jae,
        Object.assign(
          {
            ref: ls(e, P),
            prefixCls: R,
            autoComplete: I == null ? void 0 : I.autoComplete,
          },
          A,
          {
            disabled: $,
            onBlur: oe,
            onFocus: ae,
            style: Object.assign(
              Object.assign({}, I == null ? void 0 : I.style),
              S
            ),
            styles: Object.assign(
              Object.assign({}, I == null ? void 0 : I.styles),
              x
            ),
            suffix: _e,
            allowClear: me,
            className: nt(v, g, N, F, W, I == null ? void 0 : I.className),
            onChange: le,
            addonAfter:
              p &&
              at.createElement(
                RE,
                null,
                at.createElement(qI, { override: !0, status: !0 }, p)
              ),
            addonBefore:
              m &&
              at.createElement(
                RE,
                null,
                at.createElement(qI, { override: !0, status: !0 }, m)
              ),
            classNames: Object.assign(
              Object.assign(
                Object.assign({}, y),
                I == null ? void 0 : I.classNames
              ),
              {
                input: nt(
                  {
                    [`${R}-sm`]: Q === "small",
                    [`${R}-lg`]: Q === "large",
                    [`${R}-rtl`]: T === "rtl",
                  },
                  y == null ? void 0 : y.input,
                  (n = I == null ? void 0 : I.classNames) === null ||
                    n === void 0
                    ? void 0
                    : n.input,
                  j
                ),
                variant: nt({ [`${R}-${se}`]: Y }, VE(R, X)),
                affixWrapper: nt(
                  {
                    [`${R}-affix-wrapper-sm`]: Q === "small",
                    [`${R}-affix-wrapper-lg`]: Q === "large",
                    [`${R}-affix-wrapper-rtl`]: T === "rtl",
                  },
                  j
                ),
                wrapper: nt({ [`${R}-group-rtl`]: T === "rtl" }, j),
                groupWrapper: nt(
                  {
                    [`${R}-group-wrapper-sm`]: Q === "small",
                    [`${R}-group-wrapper-lg`]: Q === "large",
                    [`${R}-group-wrapper-rtl`]: T === "rtl",
                    [`${R}-group-wrapper-${se}`]: Y,
                  },
                  VE(`${R}-group-wrapper`, X, k),
                  j
                ),
              }
            ),
          }
        )
      )
    );
  }),
  I2 = ase;
var sse = {
  icon: {
    tag: "svg",
    attrs: { viewBox: "64 64 896 896", focusable: "false" },
    children: [
      {
        tag: "path",
        attrs: {
          d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z",
        },
      },
      {
        tag: "path",
        attrs: {
          d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z",
        },
      },
    ],
  },
  name: "eye-invisible",
  theme: "outlined",
};
const lse = sse;
var cse = function (e, n) {
  return E.createElement(cs, Et({}, e, { ref: n, icon: lse }));
};
const use = E.forwardRef(cse);
var dse = {
  icon: {
    tag: "svg",
    attrs: { viewBox: "64 64 896 896", focusable: "false" },
    children: [
      {
        tag: "path",
        attrs: {
          d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z",
        },
      },
    ],
  },
  name: "eye",
  theme: "outlined",
};
const fse = dse;
var hse = function (e, n) {
  return E.createElement(cs, Et({}, e, { ref: n, icon: fse }));
};
const pse = E.forwardRef(hse);
var mse = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const gse = (t) =>
    t ? E.createElement(pse, null) : E.createElement(use, null),
  vse = { click: "onClick", hover: "onMouseOver" },
  yse = E.forwardRef((t, e) => {
    const { visibilityToggle: n = !0 } = t,
      r = typeof n == "object" && n.visible !== void 0,
      [i, o] = E.useState(() => (r ? n.visible : !1)),
      a = E.useRef(null);
    E.useEffect(() => {
      r && o(n.visible);
    }, [r, n]);
    const s = H4(a),
      l = () => {
        const { disabled: A } = t;
        A ||
          (i && s(),
          o((M) => {
            var T;
            const I = !M;
            return (
              typeof n == "object" &&
                ((T = n.onVisibleChange) === null ||
                  T === void 0 ||
                  T.call(n, I)),
              I
            );
          }));
      },
      c = (A) => {
        const { action: M = "click", iconRender: T = gse } = t,
          I = vse[M] || "",
          R = T(i),
          P = {
            [I]: l,
            className: `${A}-icon`,
            key: "passwordIcon",
            onMouseDown: (F) => {
              F.preventDefault();
            },
            onMouseUp: (F) => {
              F.preventDefault();
            },
          };
        return E.cloneElement(
          E.isValidElement(R) ? R : E.createElement("span", null, R),
          P
        );
      },
      { className: u, prefixCls: d, inputPrefixCls: p, size: m } = t,
      v = mse(t, ["className", "prefixCls", "inputPrefixCls", "size"]),
      { getPrefixCls: S } = E.useContext(Rn),
      x = S("input", p),
      g = S("input-password", d),
      _ = n && c(g),
      y = nt(g, u, { [`${g}-${m}`]: !!m }),
      w = Object.assign(
        Object.assign({}, Ys(v, ["suffix", "iconRender", "visibilityToggle"])),
        { type: i ? "text" : "password", className: y, prefixCls: x, suffix: _ }
      );
    return (
      m && (w.size = m),
      E.createElement(I2, Object.assign({ ref: ls(e, a) }, w))
    );
  }),
  xse = yse;
var Sse = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const _se = E.forwardRef((t, e) => {
    const {
        prefixCls: n,
        inputPrefixCls: r,
        className: i,
        size: o,
        suffix: a,
        enterButton: s = !1,
        addonAfter: l,
        loading: c,
        disabled: u,
        onSearch: d,
        onChange: p,
        onCompositionStart: m,
        onCompositionEnd: v,
      } = t,
      S = Sse(t, [
        "prefixCls",
        "inputPrefixCls",
        "className",
        "size",
        "suffix",
        "enterButton",
        "addonAfter",
        "loading",
        "disabled",
        "onSearch",
        "onChange",
        "onCompositionStart",
        "onCompositionEnd",
      ]),
      { getPrefixCls: x, direction: g } = E.useContext(Rn),
      _ = E.useRef(!1),
      y = x("input-search", n),
      w = x("input", r),
      { compactSize: A } = g2(y, g),
      M = Tu((G) => {
        var k;
        return (k = o ?? A) !== null && k !== void 0 ? k : G;
      }),
      T = E.useRef(null),
      I = (G) => {
        G &&
          G.target &&
          G.type === "click" &&
          d &&
          d(G.target.value, G, { source: "clear" }),
          p && p(G);
      },
      R = (G) => {
        var k;
        document.activeElement ===
          ((k = T.current) === null || k === void 0 ? void 0 : k.input) &&
          G.preventDefault();
      },
      P = (G) => {
        var k, q;
        d &&
          d(
            (q =
              (k = T.current) === null || k === void 0 ? void 0 : k.input) ===
              null || q === void 0
              ? void 0
              : q.value,
            G,
            { source: "input" }
          );
      },
      F = (G) => {
        _.current || c || P(G);
      },
      D = typeof s == "boolean" ? E.createElement(dre, null) : null,
      j = `${y}-button`;
    let N;
    const V = s || {},
      W = V.type && V.type.__ANT_BUTTON === !0;
    W || V.type === "button"
      ? (N = em(
          V,
          Object.assign(
            {
              onMouseDown: R,
              onClick: (G) => {
                var k, q;
                (q =
                  (k = V == null ? void 0 : V.props) === null || k === void 0
                    ? void 0
                    : k.onClick) === null ||
                  q === void 0 ||
                  q.call(k, G),
                  P(G);
              },
              key: "enterButton",
            },
            W ? { className: j, size: M } : {}
          )
        ))
      : (N = E.createElement(
          Xo,
          {
            className: j,
            type: s ? "primary" : void 0,
            size: M,
            disabled: u,
            key: "enterButton",
            onMouseDown: R,
            onClick: P,
            loading: c,
            icon: D,
          },
          s
        )),
      l && (N = [N, em(l, { key: "addonAfter" })]);
    const Q = nt(
        y,
        {
          [`${y}-rtl`]: g === "rtl",
          [`${y}-${M}`]: !!M,
          [`${y}-with-button`]: !!s,
        },
        i
      ),
      B = (G) => {
        (_.current = !0), m == null || m(G);
      },
      $ = (G) => {
        (_.current = !1), v == null || v(G);
      };
    return E.createElement(
      I2,
      Object.assign({ ref: ls(T, e), onPressEnter: F }, S, {
        size: M,
        onCompositionStart: B,
        onCompositionEnd: $,
        prefixCls: w,
        addonAfter: N,
        suffix: a,
        onChange: I,
        className: Q,
        disabled: u,
      })
    );
  }),
  bse = _se;
var wse = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`,
  Ese = [
    "letter-spacing",
    "line-height",
    "padding-top",
    "padding-bottom",
    "font-family",
    "font-weight",
    "font-size",
    "font-variant",
    "text-rendering",
    "text-transform",
    "width",
    "text-indent",
    "padding-left",
    "padding-right",
    "border-width",
    "box-sizing",
    "word-break",
    "white-space",
  ],
  J_ = {},
  Wo;
function Mse(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    n =
      t.getAttribute("id") ||
      t.getAttribute("data-reactid") ||
      t.getAttribute("name");
  if (e && J_[n]) return J_[n];
  var r = window.getComputedStyle(t),
    i =
      r.getPropertyValue("box-sizing") ||
      r.getPropertyValue("-moz-box-sizing") ||
      r.getPropertyValue("-webkit-box-sizing"),
    o =
      parseFloat(r.getPropertyValue("padding-bottom")) +
      parseFloat(r.getPropertyValue("padding-top")),
    a =
      parseFloat(r.getPropertyValue("border-bottom-width")) +
      parseFloat(r.getPropertyValue("border-top-width")),
    s = Ese.map(function (c) {
      return "".concat(c, ":").concat(r.getPropertyValue(c));
    }).join(";"),
    l = { sizingStyle: s, paddingSize: o, borderSize: a, boxSizing: i };
  return e && n && (J_[n] = l), l;
}
function Cse(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
    r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  Wo ||
    ((Wo = document.createElement("textarea")),
    Wo.setAttribute("tab-index", "-1"),
    Wo.setAttribute("aria-hidden", "true"),
    document.body.appendChild(Wo)),
    t.getAttribute("wrap")
      ? Wo.setAttribute("wrap", t.getAttribute("wrap"))
      : Wo.removeAttribute("wrap");
  var i = Mse(t, e),
    o = i.paddingSize,
    a = i.borderSize,
    s = i.boxSizing,
    l = i.sizingStyle;
  Wo.setAttribute("style", "".concat(l, ";").concat(wse)),
    (Wo.value = t.value || t.placeholder || "");
  var c = void 0,
    u = void 0,
    d,
    p = Wo.scrollHeight;
  if (
    (s === "border-box" ? (p += a) : s === "content-box" && (p -= o),
    n !== null || r !== null)
  ) {
    Wo.value = " ";
    var m = Wo.scrollHeight - o;
    n !== null &&
      ((c = m * n),
      s === "border-box" && (c = c + o + a),
      (p = Math.max(c, p))),
      r !== null &&
        ((u = m * r),
        s === "border-box" && (u = u + o + a),
        (d = p > u ? "" : "hidden"),
        (p = Math.min(u, p)));
  }
  var v = { height: p, overflowY: d, resize: "none" };
  return c && (v.minHeight = c), u && (v.maxHeight = u), v;
}
var Tse = [
    "prefixCls",
    "onPressEnter",
    "defaultValue",
    "value",
    "autoSize",
    "onResize",
    "className",
    "style",
    "disabled",
    "onChange",
    "onInternalAutoSize",
  ],
  eb = 0,
  tb = 1,
  nb = 2,
  Ase = E.forwardRef(function (t, e) {
    var n = t,
      r = n.prefixCls;
    n.onPressEnter;
    var i = n.defaultValue,
      o = n.value,
      a = n.autoSize,
      s = n.onResize,
      l = n.className,
      c = n.style,
      u = n.disabled,
      d = n.onChange;
    n.onInternalAutoSize;
    var p = on(n, Tse),
      m = ta(i, {
        value: o,
        postState: function (ee) {
          return ee ?? "";
        },
      }),
      v = Ve(m, 2),
      S = v[0],
      x = v[1],
      g = function (ee) {
        x(ee.target.value), d == null || d(ee);
      },
      _ = E.useRef();
    E.useImperativeHandle(e, function () {
      return { textArea: _.current };
    });
    var y = E.useMemo(
        function () {
          return a && un(a) === "object" ? [a.minRows, a.maxRows] : [];
        },
        [a]
      ),
      w = Ve(y, 2),
      A = w[0],
      M = w[1],
      T = !!a,
      I = function () {
        try {
          if (document.activeElement === _.current) {
            var ee = _.current,
              J = ee.selectionStart,
              oe = ee.selectionEnd,
              ae = ee.scrollTop;
            _.current.setSelectionRange(J, oe), (_.current.scrollTop = ae);
          }
        } catch {}
      },
      R = E.useState(nb),
      P = Ve(R, 2),
      F = P[0],
      D = P[1],
      j = E.useState(),
      N = Ve(j, 2),
      V = N[0],
      W = N[1],
      Q = function () {
        D(eb);
      };
    Hr(
      function () {
        T && Q();
      },
      [o, A, M, T]
    ),
      Hr(
        function () {
          if (F === eb) D(tb);
          else if (F === tb) {
            var X = Cse(_.current, !1, A, M);
            D(nb), W(X);
          } else I();
        },
        [F]
      );
    var B = E.useRef(),
      $ = function () {
        Er.cancel(B.current);
      },
      G = function (ee) {
        F === nb &&
          (s == null || s(ee),
          a &&
            ($(),
            (B.current = Er(function () {
              Q();
            }))));
      };
    E.useEffect(function () {
      return $;
    }, []);
    var k = T ? V : null,
      q = De(De({}, c), k);
    return (
      (F === eb || F === tb) &&
        ((q.overflowY = "hidden"), (q.overflowX = "hidden")),
      E.createElement(
        Ds,
        { onResize: G, disabled: !(a || s) },
        E.createElement(
          "textarea",
          Et({}, p, {
            ref: _,
            style: q,
            className: nt(r, l, be({}, "".concat(r, "-disabled"), u)),
            disabled: u,
            value: S,
            onChange: g,
          })
        )
      )
    );
  }),
  Rse = [
    "defaultValue",
    "value",
    "onFocus",
    "onBlur",
    "onChange",
    "allowClear",
    "maxLength",
    "onCompositionStart",
    "onCompositionEnd",
    "suffix",
    "prefixCls",
    "showCount",
    "count",
    "className",
    "style",
    "disabled",
    "hidden",
    "classNames",
    "styles",
    "onResize",
  ],
  Pse = at.forwardRef(function (t, e) {
    var n,
      r,
      i = t.defaultValue,
      o = t.value,
      a = t.onFocus,
      s = t.onBlur,
      l = t.onChange,
      c = t.allowClear,
      u = t.maxLength,
      d = t.onCompositionStart,
      p = t.onCompositionEnd,
      m = t.suffix,
      v = t.prefixCls,
      S = v === void 0 ? "rc-textarea" : v,
      x = t.showCount,
      g = t.count,
      _ = t.className,
      y = t.style,
      w = t.disabled,
      A = t.hidden,
      M = t.classNames,
      T = t.styles,
      I = t.onResize,
      R = on(t, Rse),
      P = ta(i, { value: o, defaultValue: i }),
      F = Ve(P, 2),
      D = F[0],
      j = F[1],
      N = D == null ? "" : String(D),
      V = at.useState(!1),
      W = Ve(V, 2),
      Q = W[0],
      B = W[1],
      $ = at.useRef(!1),
      G = at.useState(null),
      k = Ve(G, 2),
      q = k[0],
      X = k[1],
      ee = E.useRef(null),
      J = function () {
        var Pe;
        return (Pe = ee.current) === null || Pe === void 0
          ? void 0
          : Pe.textArea;
      },
      oe = function () {
        J().focus();
      };
    E.useImperativeHandle(e, function () {
      return {
        resizableTextArea: ee.current,
        focus: oe,
        blur: function () {
          J().blur();
        },
      };
    }),
      E.useEffect(
        function () {
          B(function (Oe) {
            return !w && Oe;
          });
        },
        [w]
      );
    var ae = at.useState(null),
      le = Ve(ae, 2),
      _e = le[0],
      me = le[1];
    at.useEffect(
      function () {
        if (_e) {
          var Oe;
          (Oe = J()).setSelectionRange.apply(Oe, It(_e));
        }
      },
      [_e]
    );
    var se = B4(g, x),
      Y = (n = se.max) !== null && n !== void 0 ? n : u,
      ve = Number(Y) > 0,
      de = se.strategy(N),
      ue = !!Y && de > Y,
      fe = function (Pe, Se) {
        var Je = Se;
        !$.current &&
          se.exceedFormatter &&
          se.max &&
          se.strategy(Se) > se.max &&
          ((Je = se.exceedFormatter(Se, { max: se.max })),
          Se !== Je && me([J().selectionStart || 0, J().selectionEnd || 0])),
          j(Je),
          Oy(Pe.currentTarget, Pe, l, Je);
      },
      Te = function (Pe) {
        ($.current = !0), d == null || d(Pe);
      },
      pe = function (Pe) {
        ($.current = !1), fe(Pe, Pe.currentTarget.value), p == null || p(Pe);
      },
      H = function (Pe) {
        fe(Pe, Pe.target.value);
      },
      z = function (Pe) {
        var Se = R.onPressEnter,
          Je = R.onKeyDown;
        Pe.key === "Enter" && Se && Se(Pe), Je == null || Je(Pe);
      },
      Z = function (Pe) {
        B(!0), a == null || a(Pe);
      },
      ge = function (Pe) {
        B(!1), s == null || s(Pe);
      },
      ce = function (Pe) {
        j(""), oe(), Oy(J(), Pe, l);
      },
      he = m,
      Me;
    se.show &&
      (se.showFormatter
        ? (Me = se.showFormatter({ value: N, count: de, maxLength: Y }))
        : (Me = "".concat(de).concat(ve ? " / ".concat(Y) : "")),
      (he = at.createElement(
        at.Fragment,
        null,
        he,
        at.createElement(
          "span",
          {
            className: nt(
              "".concat(S, "-data-count"),
              M == null ? void 0 : M.count
            ),
            style: T == null ? void 0 : T.count,
          },
          Me
        )
      )));
    var Re = function (Pe) {
        var Se;
        I == null || I(Pe),
          (Se = J()) !== null && Se !== void 0 && Se.style.height && X(!0);
      },
      Le = !R.autoSize && !x && !c;
    return at.createElement(
      k4,
      {
        value: N,
        allowClear: c,
        handleReset: ce,
        suffix: he,
        prefixCls: S,
        classNames: De(
          De({}, M),
          {},
          {
            affixWrapper: nt(
              M == null ? void 0 : M.affixWrapper,
              ((r = {}),
              be(r, "".concat(S, "-show-count"), x),
              be(r, "".concat(S, "-textarea-allow-clear"), c),
              r)
            ),
          }
        ),
        disabled: w,
        focused: Q,
        className: nt(_, ue && "".concat(S, "-out-of-range")),
        style: De(De({}, y), q && !Le ? { height: "auto" } : {}),
        dataAttrs: {
          affixWrapper: { "data-count": typeof Me == "string" ? Me : void 0 },
        },
        hidden: A,
      },
      at.createElement(
        Ase,
        Et({}, R, {
          maxLength: u,
          onKeyDown: z,
          onChange: H,
          onFocus: Z,
          onBlur: ge,
          onCompositionStart: Te,
          onCompositionEnd: pe,
          className: nt(M == null ? void 0 : M.textarea),
          style: De(
            De({}, T == null ? void 0 : T.textarea),
            {},
            { resize: y == null ? void 0 : y.resize }
          ),
          disabled: w,
          prefixCls: S,
          onResize: Re,
          ref: ee,
        })
      )
    );
  }),
  Ise = function (t, e) {
    var n = {};
    for (var r in t)
      Object.prototype.hasOwnProperty.call(t, r) &&
        e.indexOf(r) < 0 &&
        (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]]);
    return n;
  };
const Lse = E.forwardRef((t, e) => {
    var n;
    const {
        prefixCls: r,
        bordered: i = !0,
        size: o,
        disabled: a,
        status: s,
        allowClear: l,
        classNames: c,
        rootClassName: u,
        className: d,
        variant: p,
      } = t,
      m = Ise(t, [
        "prefixCls",
        "bordered",
        "size",
        "disabled",
        "status",
        "allowClear",
        "classNames",
        "rootClassName",
        "className",
        "variant",
      ]),
      { getPrefixCls: v, direction: S } = E.useContext(Rn),
      x = Tu(o),
      g = E.useContext(Cm),
      _ = a ?? g,
      { status: y, hasFeedback: w, feedbackIcon: A } = E.useContext(mu),
      M = r4(y, s),
      T = E.useRef(null);
    E.useImperativeHandle(e, () => {
      var W;
      return {
        resizableTextArea:
          (W = T.current) === null || W === void 0
            ? void 0
            : W.resizableTextArea,
        focus: (Q) => {
          var B, $;
          ose(
            ($ =
              (B = T.current) === null || B === void 0
                ? void 0
                : B.resizableTextArea) === null || $ === void 0
              ? void 0
              : $.textArea,
            Q
          );
        },
        blur: () => {
          var Q;
          return (Q = T.current) === null || Q === void 0 ? void 0 : Q.blur();
        },
      };
    });
    const I = v("input", r);
    let R;
    typeof l == "object" && l != null && l.clearIcon
      ? (R = l)
      : l && (R = { clearIcon: E.createElement(d2, null) });
    const P = Rm(I),
      [F, D, j] = R2(I, P),
      [N, V] = i4(p, i);
    return F(
      E.createElement(
        Pse,
        Object.assign({}, m, {
          disabled: _,
          allowClear: R,
          className: nt(j, P, d, u),
          classNames: Object.assign(Object.assign({}, c), {
            textarea: nt(
              { [`${I}-sm`]: x === "small", [`${I}-lg`]: x === "large" },
              D,
              c == null ? void 0 : c.textarea
            ),
            variant: nt({ [`${I}-${N}`]: V }, VE(I, M)),
            affixWrapper: nt(
              `${I}-textarea-affix-wrapper`,
              {
                [`${I}-affix-wrapper-rtl`]: S === "rtl",
                [`${I}-affix-wrapper-sm`]: x === "small",
                [`${I}-affix-wrapper-lg`]: x === "large",
                [`${I}-textarea-show-count`]:
                  t.showCount ||
                  ((n = t.count) === null || n === void 0 ? void 0 : n.show),
              },
              D
            ),
          }),
          prefixCls: I,
          suffix:
            w &&
            E.createElement("span", { className: `${I}-textarea-suffix` }, A),
          ref: T,
        })
      )
    );
  }),
  Ose = Lse,
  Dm = I2;
Dm.Group = tse;
Dm.Search = bse;
Dm.TextArea = Ose;
Dm.Password = xse;
const Nse = Dm;
var Fse = {
  icon: function (e, n) {
    return {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z",
            fill: e,
          },
        },
        {
          tag: "path",
          attrs: {
            d: "M512 140c-205.4 0-372 166.6-372 372s166.6 372 372 372 372-166.6 372-372-166.6-372-372-372zm193.4 225.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.3 0 19.9 5 25.9 13.3l71.2 98.8 157.2-218c6-8.4 15.7-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.4 12.7z",
            fill: n,
          },
        },
        {
          tag: "path",
          attrs: {
            d: "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z",
            fill: e,
          },
        },
      ],
    };
  },
  name: "check-circle",
  theme: "twotone",
};
const Dse = Fse;
var zse = function (e, n) {
  return E.createElement(cs, Et({}, e, { ref: n, icon: Dse }));
};
const Use = E.forwardRef(zse),
  kse = "images/correct-LGGHlV9_.mp3",
  rb = {
    UNION: { value: "a|b", task: 4 },
    KLEENE_A_CONCAT_B: { value: "a*b", task: 5 },
    CONCAT: { value: "ab", task: 6 },
    KLEENE_AB_UNION: { value: "(a|b)*", task: 1 },
    KLEENE_AB_CONCAT: { value: "(ab)*", task: 2 },
    COMPLEX_1: { value: "(a|b)*abb", task: 3 },
    UNION_CONCAT_C: { value: "(a|b)c", task: 7 },
  },
  Ec = { UNION: "|", KLEENE: "*", CONCAT: "." },
  Bse = () => {
    const {
        isConverted: t,
        REvalue: e,
        clickedStep: n,
        firstRe: r,
        secondRe: i,
        task: o,
        thirdRe: a,
        fourthRe: s,
      } = oa((N) => N.NFA),
      l = Fa(),
      [c, u] = E.useState([]),
      [d, p] = E.useState(null),
      [m, v] = E.useState(!1),
      [S, x] = E.useState(!1),
      g =  new Audio(kse),
      _ = c.length === 2 && d !== null;
    E.useEffect(() => {
      if (_) {
        const N = d === Ec.CONCAT ? "ab" : `a${d}b`,
          V = Object.values(rb).find((W) => W.value === N) || { task: 0 };
        l(wh({ val: N, task: V.task })), l(Vv(!1));
      }
    }, [c, d, l, _]);
    const y = (N) => {
        c.includes(N) || u((V) => [...V, N]);
      },
      w = (N) => {
        p(N);
      },
      A = () => {
        u([]), p(null), v(!1), l(k3()), l(wh({ val: "", task: 0 })), l(Vv(!1));
      },
      M = (N) => {
        const { value: V } = N.target,
          W = Object.values(rb).find((Q) => Q.value === V) || { task: 0 };
        l(k3()), l(wh({ val: V, task: W.task })), l(Vv(!1));
      },
      T = () => {
        e
          ? l(Vv(!0))
          : alert("Please build or select a Regular Expression first.");
      },
      I = (N) => {
        const V = N.toLowerCase().replace(" ", ""),
          W = N === "Kleene star" ? "kleene" : V;
        l(B3({ ...n, [W]: !n[W] }));
      },
      R = (N, V) => {
        if (!e) {
          alert("Please build or select an expression first.");
          return;
        }
        g.play(), l(Da(!0)), l(ss(V));
        let W = "";
        const Q = ($) => $.a && $.b,
          B = ($) => {
            l(M_({ ...r, [$]: !0 })),
              l(C_({ ...i, [$]: !0 })),
              l(T_({ ...a, [$]: !0 })),
              (o === 7 || S) && l(Eh({ ...s, [$]: !0 }));
          };
        switch (N) {
          case "a":
          case "Add a":
            B("a"), (W = "State created for 'a'");
            break;
          case "b":
          case "Add b":
            B("b"), (W = "State created for 'b'");
            break;
          case "Add union":
            if (!Q(r) && !Q(a)) {
              alert("Please create states for 'a' and 'b' first.");
              return;
            }
            l(M_({ ...r, union: !0 })),
              l(T_({ ...a, union: !0 })),
              o === 7 && l(Eh({ ...s, union: !0 })),
              (W = "Union operation applied");
            break;
          case "Add Kleene star":
            l(M_({ ...r, kleene: !0 })),
              l(C_({ ...i, kleene: !0 })),
              l(T_({ ...a, kleene: !0 })),
              o === 3 && (x(!0), l(wh({ val: e, task: 4 }))),
              (W = "Kleene star operation applied");
            break;
          case "Add Concat":
          case "concat":
            if ((o === 2 || o === 6) && !Q(i)) {
              alert("Please create states for 'a' and 'b' first.");
              return;
            }
            if (o === 5 && !r.a) {
              alert("Please create the 'a' state first.");
              return;
            }
            if (o === 7) {
              if (!r.union) {
                alert("Please complete the union operation first.");
                return;
              }
              l(Eh({ ...s, concat: !0 }));
            } else l(C_({ ...i, concat: !0 }));
            S && l(Eh({ ...s, concat: !0 })),
              l(pK(!0)),
              (W = "Concatenation operation applied");
            break;
          case "Add c":
            if (o === 7) {
              if (!s.concat) {
                alert("Please complete the concatenation operation first.");
                return;
              }
              l(Eh({ ...s, c: !0 })),
                l(B3({ ...n, concatenation: !0 })),
                (W = "Transition 'c' added after concatenation");
            }
            break;
        }
        W && l(mK(W));
      },
      P = (N) => l(wh({ val: e, task: N === "1" ? 3 : 4 })),
      F = () => {
        switch (o) {
          case 1:
            return Pi[1];
          case 2:
            return Pi[2];
          case 3:
            return Pi[3];
          case 4:
            return e === "a|b" ? Pi[5] : Pi[4];
          case 5:
            return Pi[6];
          case 6:
            return Pi[7];
          case 7:
            return WC;
          default:
            return [];
        }
      },
      D = [{}, r, i, a, s, i, i, s],
      j = [
        {
          name: "Character",
          color: "white",
          re: Object.values(rb).map((N) => N.value),
        },
        {
          name: "Union",
          color: "#00DFFF",
          re: ["a|b", "(a|b)*", "(a|b)*abb", "(a|b)c"],
        },
        {
          name: "Concatenation",
          color: "#FF00D1",
          re: ["ab", "(ab)*", "(a|b)*abb", "(a|b)c"],
        },
        {
          name: "Kleene star",
          color: "#FFA305",
          re: ["a*b", "(a|b)*", "(ab)*", "(a|b)*abb"],
        },
      ];
    return L.jsxs("div", {
      style: Kt.container,
      children: [
        L.jsxs(TL, {
          title: "RE to NFA Converter: Setup",
          style: Kt.setupCard,
          children: [
            L.jsxs("div", {
              style: Kt.builderSection,
              children: [
                L.jsxs("div", {
                  style: Kt.headerContainer,
                  children: [
                    L.jsx("h4", {
                      style: Kt.subHeader,
                      children: "Build a Simple Expression",
                    }),
                    L.jsx(Xo, {
                      size: "small",
                      onClick: A,
                      children: "Clear Selection",
                    }),
                  ],
                }),
                L.jsxs("div", {
                  style: Kt.inlineStepContainer,
                  children: [
                    L.jsx("p", {
                      style: Kt.inlineStepText,
                      children: "1. Choose Variables:",
                    }),
                    L.jsxs("div", {
                      style: Kt.buttonGroup,
                      children: [
                        L.jsx(Xo, {
                          onClick: () => y("a"),
                          type: c.includes("a") ? "primary" : "default",
                          children: "a",
                        }),
                        L.jsx(Xo, {
                          onClick: () => y("b"),
                          type: c.includes("b") ? "primary" : "default",
                          children: "b",
                        }),
                      ],
                    }),
                  ],
                }),
                L.jsx(r0, { style: Kt.inlineDivider }),
                L.jsxs("div", {
                  children: [
                    L.jsx("p", {
                      style: Kt.operationLabel,
                      children: "2. Choose Operation:",
                    }),
                    L.jsx(aL, {
                      title:
                        c.length !== 2 ? "Please select 2 variables first" : "",
                      children: L.jsxs("div", {
                        style: Kt.buttonGroup,
                        children: [
                          L.jsx(Xo, {
                            onClick: () => w(Ec.UNION),
                            type: d === Ec.UNION ? "primary" : "default",
                            disabled: c.length !== 2,
                            children: "Union (|)",
                          }),
                          L.jsx(Xo, {
                            onClick: () => w(Ec.CONCAT),
                            type: d === Ec.CONCAT ? "primary" : "default",
                            disabled: c.length !== 2,
                            children: "Concat (.)",
                          }),
                          L.jsx(Xo, {
                            onClick: () => w(Ec.KLEENE),
                            type: d === Ec.KLEENE ? "primary" : "default",
                            disabled: c.length !== 2,
                            children: "Kleene (*)",
                          }),
                        ],
                      }),
                    }),
                  ],
                }),
              ],
            }),
            L.jsx(r0, { style: Kt.mainDivider, children: "OR" }),
            L.jsx(aL, {
              title: _
                ? ""
                : "Complete the simple builder above to enable advanced examples",
              children: L.jsx(Xo, {
                style: Kt.fullWidthButton,
                type: "dashed",
                onClick: () => v(!m),
                disabled: !_,
                children: m
                  ? "Hide Advanced Examples"
                  : "Select an Advanced Example",
              }),
            }),
            m &&
              _ &&
              L.jsx("div", {
                style: Kt.radioGroupContainer,
                children: L.jsxs(Ih.Group, {
                  optionType: "button",
                  buttonStyle: "solid",
                  style: Kt.radioGroup,
                  onChange: M,
                  value: e,
                  children: [
                    L.jsx(Ih.Button, { value: "(a|b)c", children: "(a|b)c" }),
                    L.jsx(Ih.Button, { value: "(a|b)*", children: "(a|b)*" }),
                    L.jsx(Ih.Button, { value: "(ab)*", children: "(ab)*" }),
                    L.jsx(Ih.Button, {
                      value: "(a|b)*abb",
                      children: "(a|b)*abb",
                    }),
                  ],
                }),
              }),
            L.jsx(r0, { style: Kt.mainDivider }),
            L.jsxs("div", {
              style: Kt.reInputContainer,
              children: [
                L.jsx("strong", { style: Kt.reLabel, children: "Current RE:" }),
                L.jsx(Nse, {
                  style: Kt.reInput,
                  placeholder: "Build or select an expression",
                  value: e,
                  disabled: !0,
                }),
                L.jsx(Xo, {
                  style: Kt.convertButton,
                  type: "primary",
                  onClick: T,
                  disabled: !e,
                  children: "Convert",
                }),
                o === 3 &&
                  L.jsxs("div", {
                    style: Kt.subTaskContainer,
                    children: [
                      L.jsx(Xo, {
                        style:
                          o === 3 ? Kt.activeSubTaskButton : Kt.subTaskButton,
                        onClick: () => P("1"),
                        children: "(a|b)*",
                      }),
                      S &&
                        L.jsx(Xo, {
                          style:
                            o === 4 ? Kt.activeSubTaskButton : Kt.subTaskButton,
                          onClick: () => P("2"),
                          children: "abb",
                        }),
                    ],
                  }),
              ],
            }),
          ],
        }),
        t &&
          L.jsxs("div", {
            style: Kt.stepsCard,
            children: [
              L.jsx("h5", {
                style: Kt.stepsTitle,
                children: "Construction Panel",
              }),
              L.jsx("div", {
                style: Kt.stepsList,
                children: F().map((N) => {
                  var W;
                  const V = ((W = D[o]) == null ? void 0 : W[N.name]) === !0;
                  return L.jsx(
                    TL,
                    {
                      style: V ? Kt.stepItemCompleted : Kt.stepItemReady,
                      bodyStyle: Kt.stepBody,
                      children: L.jsxs("div", {
                        style: Kt.stepContent,
                        children: [
                          V
                            ? L.jsx(Use, {
                                twoToneColor: "#52c41a",
                                style: Kt.stepIcon,
                              })
                            : L.jsx("div", {
                                style: Kt.stepNumberIcon,
                                children: N.id,
                              }),
                          L.jsx("span", {
                            style: V ? Kt.stepTextCompleted : Kt.stepTextActive,
                            children: N.flow,
                          }),
                          L.jsx(Xo, {
                            style: Kt.stepButton,
                            type: V ? "default" : "primary",
                            onClick: () => R(N.btn, N.info),
                            disabled: V,
                            children: N.btn,
                          }),
                        ],
                      }),
                    },
                    N.id
                  );
                }),
              }),
              L.jsx(r0, { style: Kt.mainDivider, children: "Diagram Legend" }),
              L.jsx("ul", {
                style: Kt.legendList,
                children: j.map((N) => {
                  const V = N.name.toLowerCase().replace(" ", ""),
                    W = N.name === "Kleene star" ? "kleene" : V;
                  return (
                    N.re.includes(e) &&
                    L.jsxs(
                      "li",
                      {
                        style: Kt.legendItem(n[W]),
                        onClick: () => I(N.name),
                        children: [
                          L.jsx("div", { style: Kt.legendColorBox(N.color) }),
                          N.name,
                        ],
                      },
                      N.name
                    )
                  );
                }),
              }),
            ],
          }),
      ],
    });
  },
  Kt = {
    container: {
      width: "100%",
      minHeight: "100vh",
      backgroundColor: "#f0f2f5",
      display: "flex",
      flexDirection: "column",
      padding: "2%",
      boxSizing: "border-box",
      overflowX: "hidden",
      "@media (min-width: 769px)": {
        borderTopLeftRadius: "50px",
        borderBottomLeftRadius: "50px",
      },
    },
    setupCard: {
      width: "100%",
      marginBottom: "2%",
      boxShadow: "0 2px 8px rgba(0,0,0,0.1)",
      maxHeight: { "@media (max-width: 768px)": "70vh" },
      overflowY: { "@media (max-width: 768px)": "auto" },
      "@media (min-width: 769px)": { maxHeight: "none", overflowY: "visible" },
    },
    builderSection: {
      border: "1px solid #e0e0ff",
      borderRadius: "8px",
      padding: "2%",
      backgroundColor: "#fafbff",
    },
    headerContainer: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      flexWrap: "wrap",
      gap: "1rem",
    },
    subHeader: {
      color: "#333",
      marginBottom: "1rem",
      fontWeight: "600",
      fontSize: "clamp(14px, 4vw, 16px)",
    },
    inlineStepContainer: {
      display: "flex",
      alignItems: "center",
      gap: "1rem",
      flexWrap: "wrap",
    },
    inlineStepText: {
      margin: 0,
      fontWeight: 600,
      color: "#333",
      whiteSpace: "nowrap",
      fontSize: "clamp(12px, 3.5vw, 14px)",
    },
    operationLabel: {
      margin: "0 0 0.5rem 0",
      fontWeight: 600,
      color: "#333",
      fontSize: "clamp(12px, 3.5vw, 14px)",
    },
    inlineDivider: { margin: "0.5rem 0" },
    mainDivider: { margin: "0.75rem 0" },
    buttonGroup: { display: "flex", flexWrap: "wrap", gap: "0.75rem" },
    radioGroupContainer: { marginTop: "0.75rem" },
    radioGroup: { display: "flex", flexWrap: "wrap", gap: "0.75rem" },
    reInputContainer: {
      display: "flex",
      flexDirection: {
        "@media (max-width: 576px)": "column",
        "@media (min-width: 577px)": "row",
      },
      alignItems: {
        "@media (max-width: 576px)": "stretch",
        "@media (min-width: 577px)": "center",
      },
      gap: "0.5rem",
    },
    reLabel: {
      marginRight: { "@media (min-width: 577px)": "0.5rem" },
      fontSize: "clamp(12px, 3.5vw, 14px)",
    },
    reInput: {
      flex: 1,
      color: "green",
      fontWeight: 800,
      textAlign: "center",
      fontSize: "clamp(0.9em, 3vw, 1.1em)",
    },
    convertButton: {
      marginLeft: { "@media (min-width: 577px)": "0.75rem" },
      width: {
        "@media (max-width: 576px)": "100%",
        "@media (min-width: 577px)": "auto",
      },
    },
    subTaskContainer: {
      display: "flex",
      gap: "0.5rem",
      marginLeft: { "@media (min-width: 577px)": "auto" },
      flexWrap: "wrap",
    },
    stepsCard: {
      backgroundColor: "white",
      borderRadius: "0.75rem",
      padding: "2%",
      maxHeight: "60vh",
      overflowY: "auto",
      boxShadow: "0 2px 8px rgba(0,0,0,0.1)",
    },
    stepsTitle: {
      color: "green",
      textDecoration: "underline",
      margin: 0,
      paddingBottom: "0.5rem",
      borderBottom: "1px solid #f0f0f0",
      marginBottom: "0.5rem",
      fontSize: "clamp(14px, 4vw, 16px)",
    },
    activeSubTaskButton: {
      background: "#1890ff",
      color: "white",
      borderColor: "#1890ff",
    },
    subTaskButton: {},
    stepsList: {
      display: "flex",
      flexDirection: "column",
      gap: "0.5rem",
      margin: "0.75rem 0",
    },
    stepItemReady: {
      border: "1px solid #d9d9d9",
      cursor: "pointer",
      transition: "all 0.3s",
    },
    stepItemCompleted: {
      opacity: 0.7,
      border: "1px solid #f0f0f0",
      backgroundColor: "#fafafa",
    },
    stepBody: { padding: "clamp(6px, 2vw, 8px) clamp(8px, 3vw, 12px)" },
    stepContent: {
      display: "flex",
      alignItems: "center",
      gap: "0.75rem",
      flexWrap: "wrap",
    },
    stepIcon: { fontSize: "clamp(18px, 5vw, 24px)" },
    stepNumberIcon: {
      backgroundColor: "#1890ff",
      color: "white",
      borderRadius: "50%",
      width: "clamp(20px, 5vw, 24px)",
      height: "clamp(20px, 5vw, 24px)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      fontWeight: "bold",
      flexShrink: 0,
    },
    stepTextActive: {
      flex: 1,
      margin: 0,
      color: "#333",
      fontSize: "clamp(12px, 3.5vw, 14px)",
    },
    stepTextCompleted: {
      flex: 1,
      margin: 0,
      textDecoration: "line-through",
      color: "#888",
      fontSize: "clamp(12px, 3.5vw, 14px)",
    },
    stepButton: {
      marginLeft: "auto",
      width: {
        "@media (max-width: 576px)": "100%",
        "@media (min-width: 577px)": "auto",
      },
    },
    legendList: { padding: 0, listStyle: "none", marginTop: "0.5rem" },
    legendItem: (t) => ({
      listStyle: "none",
      display: "flex",
      alignItems: "center",
      color: t ? "black" : "grey",
      fontSize: "clamp(10px, 3vw, 12px)",
      marginBlock: "0.25rem",
      cursor: "pointer",
      fontWeight: 700,
    }),
    legendColorBox: (t) => ({
      width: "clamp(20px, 5vw, 25px)",
      height: "5px",
      background: t === "white" ? "black" : t,
      marginRight: "0.5rem",
      border: "1px solid #ccc",
    }),
    fullWidthButton: { width: "100%" },
  },
  Hse = () => {
    const t = Fa(),
      { isInfo: e, infoCom: n } = oa((r) => r.NFA);
    return (
      e &&
      L.jsxs("div", {
        className: "info-wrap",
        children: [
          L.jsxs("div", {
            className: "info-header",
            children: [
              L.jsx("h4", {
                className: "info-title",
                children: "Operations :",
              }),
              L.jsx(d2, {
                onClick: () => t(Da(!1)),
                className: "info-close",
                "aria-label": "Close info panel",
              }),
            ],
          }),
          L.jsx("div", { className: "info-body", id: "style-1", children: n }),
        ],
      })
    );
  },
  jse = () => {
    const { isInfo: t } = oa((r) => r.NFA),
      [e, n] = E.useState(!1);
    return L.jsxs("div", {
      className: "mc-container",
      id: "style-1",
      children: [
        L.jsx("div", {
          className: `mc-left ${e ? "open" : ""}`,
          children: e
            ? L.jsx(L.Fragment, { children: t && L.jsx(Hse, {}) })
            : L.jsx("button", {
                onClick: () => n(!0),
                className: "mc-show-btn",
                children: "Show Operations",
              }),
        }),
        L.jsx("div", {
          className: `mc-center ${e ? "with-left" : ""}`,
          children: L.jsx(kK, {}),
        }),
        L.jsx("div", { className: "mc-right", children: L.jsx(Bse, {}) }),
      ],
    });
  },
  Vse = Xq({ reducer: { NFA: gK } });
function $se() {
  return L.jsx($9, {
    store: Vse,
    children: L.jsx("div", {
      style: { width: "100%", height: "100vh" },
      children: L.jsx(jse, {}),
    }),
  });
}
ib.createRoot(document.getElementById("root")).render(
  L.jsx(at.StrictMode, { children: L.jsx($se, {}) })
);
